<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>《代码大全》精粹摘要</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --background-color: #ffffff;
            --text-color: #333;
            --light-gray: #f4f4f4;
            --medium-gray: #e0e0e0;
            --border-radius: 8px;
            --shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.7;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            font-size: 16px;
        }

        #sidebar {
            width: 280px;
            background-color: var(--light-gray);
            height: 100vh;
            overflow-y: auto;
            position: fixed;
            padding: 20px;
            border-right: 1px solid var(--medium-gray);
            box-sizing: border-box;
        }

        #sidebar h2 {
            color: var(--primary-color);
            text-align: center;
            font-size: 1.5em;
            margin-bottom: 20px;
        }

        #sidebar ul {
            list-style: none;
            padding: 0;
        }

        #sidebar li {
            margin-bottom: 8px;
        }

        #sidebar a {
            text-decoration: none;
            color: var(--text-color);
            display: block;
            padding: 10px 15px;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
            font-weight: 500;
        }

        #sidebar a:hover, #sidebar a.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .part-title {
            font-weight: bold;
            color: #555;
            margin-top: 20px;
            padding-left: 15px;
            border-left: 3px solid var(--secondary-color);
        }

        #main-content {
            margin-left: 280px;
            padding: 40px;
            width: calc(100% - 280px);
            box-sizing: border-box;
        }

        header {
            text-align: center;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 20px;
            margin-bottom: 40px;
            animation: fadeIn 0.8s ease-out;
        }

        header h1 {
            font-size: 3em;
            color: var(--text-color);
            margin: 0;
        }

        header p {
            font-size: 1.2em;
            color: #777;
        }

        section {
            margin-bottom: 40px;
            padding-top: 40px; /* For scroll anchoring */
            margin-top: -40px; /* Counteract padding */
            animation: fadeIn 0.8s ease-out;
        }

        details {
            background-color: #f9f9f9;
            border: 1px solid var(--medium-gray);
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            transition: all 0.3s ease;
        }
        
        details[open] {
            background-color: white;
        }

        summary {
            font-size: 1.8em;
            font-weight: 600;
            padding: 20px;
            cursor: pointer;
            color: var(--primary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            outline: none;
        }
        
        summary::after {
            content: '＋';
            font-size: 1.5em;
            transition: transform 0.3s ease;
        }

        details[open] summary::after {
            transform: rotate(45deg);
        }

        .chapter-content {
            padding: 0 20px 20px 20px;
        }

        .chapter-content h3 {
            font-size: 1.4em;
            color: var(--secondary-color);
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 8px;
            margin-top: 25px;
        }

        .fact, .viewpoint {
            padding: 15px;
            margin: 15px 0;
            border-left: 5px solid;
            border-radius: 5px;
            position: relative;
            padding-left: 40px;
        }
        
        .fact::before, .viewpoint::before {
            font-family: 'Georgia', serif;
            font-size: 2em;
            position: absolute;
            left: 10px;
            top: 5px;
        }

        .fact {
            background-color: #e8f4fd;
            border-color: #3498db;
        }
        .fact::before {
            content: '📊';
            top: 12px;
            left: 8px;
            font-size: 1.5em;
        }

        .viewpoint {
            background-color: #eafaf1;
            border-color: #2ecc71;
        }
        .viewpoint::before {
            content: '💡';
            top: 12px;
            left: 8px;
            font-size: 1.5em;
        }
        
        ul {
            padding-left: 20px;
        }
        
        li {
            margin-bottom: 10px;
        }

        code {
            background-color: #eee;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 0.9em;
        }

        .dev-way {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 40px;
            border-radius: var(--border-radius);
            text-align: center;
            box-shadow: var(--shadow);
            border-top: 5px solid var(--primary-color);
        }

        .dev-way h2 {
            font-size: 2.5em;
            color: var(--text-color);
            margin-bottom: 20px;
        }

        .dev-way p {
            font-size: 1.2em;
            max-width: 800px;
            margin: 15px auto;
            color: #444;
            line-height: 1.8;
        }
    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>

    <nav id="sidebar">
        <h2>《代码大全》精粹</h2>
        <ul>
            <li class="part-title">I. 奠定基础</li>
            <li><a href="#ch1">1. 欢迎进入软件构建</a></li>
            <li><a href="#ch2">2. 用隐喻来更深刻地理解软件开发</a></li>
            <li><a href="#ch3">3. 前期准备：度量两次，切割一次</a></li>
            <li><a href="#ch4">4. 关键的构建决策</a></li>
            <li class="part-title">II. 创建高质量的代码</li>
            <li><a href="#ch5">5. 构建中的设计</a></li>
            <li><a href="#ch6">6. 可以工作的类</a></li>
            <li><a href="#ch7">7. 高质量的子程序</a></li>
            <li><a href="#ch8">8. 防御式编程</a></li>
            <li><a href="#ch9">9. 伪代码编程过程</a></li>
            <li class="part-title">III. 变量</li>
            <li><a href="#ch10">10. 使用变量的一般事项</a></li>
            <li><a href="#ch11">11. 变量名的力量</a></li>
            <li><a href="#ch12">12. 基本数据类型</a></li>
            <li><a href="#ch13">13. 不常见的数据类型</a></li>
            <li class="part-title">IV. 语句</li>
            <li><a href="#ch14">14. 组织直线型代码</a></li>
            <li><a href="#ch15">15. 使用条件语句</a></li>
            <li><a href="#ch16">16. 控制循环</a></li>
            <li><a href="#ch17">17. 不常见的控制结构</a></li>
            <li><a href="#ch18">18. 表驱动法</a></li>
            <li><a href="#ch19">19. 常规控制问题</a></li>
            <li class="part-title">V. 代码改善</li>
            <li><a href="#ch20">20. 软件质量概览</a></li>
            <li><a href="#ch21">21. 协同构建</a></li>
            <li><a href="#ch22">22. 开发者测试</a></li>
            <li><a href="#ch23">23. 调试</a></li>
            <li><a href="#ch24">24. 重构</a></li>
            <li><a href="#ch25">25. 代码调整策略</a></li>
            <li><a href="#ch26">26. 代码调整技术</a></li>
            <li class="part-title">VI. 系统级的考虑</li>
            <li><a href="#ch27">27. 程序规模对构建的影响</a></li>
            <li><a href="#ch28">28. 管理构建</a></li>
            <li><a href="#ch29">29. 集成</a></li>
            <li><a href="#ch30">30. 编程工具</a></li>
            <li class="part-title">VII. 软件工艺</li>
            <li><a href="#ch31">31. 布局与风格</a></li>
            <li><a href="#ch32">32. 自说明代码</a></li>
            <li><a href="#ch33">33. 个人性格</a></li>
            <li><a href="#ch34">34. 软件工艺的主题</a></li>
            <li><a href="#dev-way">开发者之道</a></li>
        </ul>
    </nav>

    <div id="main-content">
        <header>
            <h1>《代码大全》第二版 (Code Complete 2)</h1>
            <p>作者: Steve McConnell</p>
            <p>一本旨在缩小业界大师知识与普通商业实践之间差距的软件构建手册。</p>
        </header>

        <!-- PART I -->
        <section id="ch1">
            <details>
                <summary>第一章: 欢迎进入软件构建</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>软件构建是核心活动：</strong> 软件构建（也称为“编码”或“编程”）是软件开发的核心环节。它不仅包括编写代码，还涉及详细设计、单元测试、集成和调试。
                    </div>
                    <div class="fact">
                        <strong>构建的中心地位：</strong> 构建是唯一一个在任何软件项目中都保证会发生的活动。需求可以被假定，架构可以被忽略，测试可以被缩减，但代码必须被构建。
                    </div>
                    <div class="fact">
                        <strong>构建的重要性：</strong> 在小型项目中，构建通常占总工作量的65%；中型项目占50%。它也是大多数错误的来源，约占50-75%的错误。因此，改进构建实践能带来巨大回报。
                    </div>
                    <div class="viewpoint">
                        <strong>构建不只是机械翻译：</strong> 构建并非简单地将设计稿翻译成代码。它是一个充满创造力、判断力和解决问题挑战的过程。
                    </div>
                </div>
            </details>
        </section>
        
        <section id="ch2">
            <details>
                <summary>第二章: 用隐喻来更深刻地理解软件开发</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>隐喻是启发式工具，而非算法：</strong> 软件隐喻（Metaphor）帮助我们理解复杂的开发过程，它提供的是思考方向（如何寻找答案），而不是具体的步骤（答案本身）。
                    </div>
                    <ul>
                        <li><strong>写代码（Software Penmanship）：</strong> 这是最简单的隐喻，将编程比作写信。它适用于个人或小型项目，但忽略了软件开发的协作性、迭代性和长期维护的本质。Fred Brooks "Plan to throw one away" 的观点源于此，但对于大型系统来说成本过高。</li>
                        <li><strong>农耕（Software Farming）：</strong> 将开发比作种植庄稼，暗示逐步、增量地构建系统。但这个隐喻的弱点在于，它暗示了开发者对过程缺乏直接控制，仿佛只能等待代码“自然生长”。</li>
                        
                        <li><strong>增殖/堆积（System Accretion）：</strong> 将开发比作牡蛎造珍珠，逐步地、一点点地增加功能。这是对增量式开发（Incremental Development）更准确的描述，强调了先构建骨架，再逐步添加血肉的过程。这是现代敏捷开发方法的基础。</li>
                        <li><strong>软件构建（Software Construction）：</strong> 这是本书采用的核心隐喻。它将软件开发比作建造房屋或摩天大楼。
                            <ul>
                                <li>它强调了不同规模项目需要不同程度的规划、设计和质量保证（建狗窝 vs. 建摩天大楼）。</li>
                                <li>它突出了“前期准备”的重要性，如同建筑的地基。糟糕的基础无法支撑高质量的建筑。</li>
                                <li>它解释了“复用”的概念，如同购买预制门窗而不是自己从头打造。</li>
                            </ul>
                        </li>
                    </ul>
                    <div class="viewpoint">
                        <strong>智力工具箱（Intellectual Toolbox）：</strong> 优秀的程序员拥有一个装满各种技术、技巧和方法的“智力工具箱”。他们不会盲从于任何单一的方法论，而是根据具体问题选择最合适的工具。
                    </div>
                </div>
            </details>
        </section>
        
        <section id="ch3">
            <details>
                <summary>第三章: 前期准备：度量两次，切割一次</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>前期准备的目标是降低风险：</strong> 在正式开始编码之前进行充分的准备（如问题定义、需求分析、架构设计）是为了尽可能早地识别和消除项目中的主要风险，尤其是糟糕的需求和规划。
                    </div>
                    <div class="fact">
                        <strong>缺陷修复成本随时间指数级增长：</strong> 在需求阶段发现并修复一个缺陷的成本，是发布后修复成本的1/10到1/100。数据显示，缺陷在系统中停留的时间越长，修复它的代价就越大。
                        <p><strong>成本对比：</strong> 需求阶段修复成本为1，架构阶段为3，构建阶段为5-10，系统测试阶段为10，发布后为10-100。</p>
                    </div>
                    <div class="viewpoint">
                        <strong>区分迭代法和瀑布法：</strong>
                        <ul>
                            <li><strong>瀑布式/顺序式方法（Sequential）</strong> 适用于需求稳定、设计直接、团队熟悉应用领域的项目。</li>
                            <li><strong>迭代式方法（Iterative）</strong> 适用于需求不稳定、设计复杂、团队不熟悉应用领域或风险较高的项目。</li>
                        </ul>
                        <strong>迭代开发不等于没有前期准备：</strong> 即使是迭代开发，也需要在每次迭代开始前，对当前要构建的部分进行充分的需求和架构准备。忽略前期准备的迭代项目，其成本可能会高于精心准备的顺序式项目。
                    </div>
                    <h3>三大构建前提</h3>
                    <ol>
                        <li><strong>问题定义（Problem Definition）：</strong>
                            <ul>
                                <li>一个清晰的、一到两页纸的陈述，用用户的语言描述要解决的“问题”是什么，而不是“解决方案”是什么。</li>
                                <li>错误的问题定义会导致团队花费大量时间和金钱去解决一个错误的问题。</li>
                            </ul>
                        </li>
                        <li><strong>需求（Requirements）：</strong>
                            <ul>
                                <li>详细描述系统应该做什么。明确的需求有助于确保用户驱动功能、避免争论，并最大限度地减少后期变更。</li>
                                <div class="fact"><strong>需求变更的普遍性：</strong> 典型项目在开发过程中会经历约25%的需求变更，这占到了项目中70%到85%的返工工作量。因此，必须有系统的变更控制流程。</div>
                            </ul>
                        </li>
                        <li><strong>软件架构（Software Architecture）：</strong>
                            <ul>
                                <li>系统的高层设计，如同建筑的框架。它决定了系统的概念完整性，并为程序员提供指导。</li>
                                <li>糟糕的架构会使构建变得几乎不可能。架构变更的成本与需求变更同样高昂。</li>
                                <li>一个好的架构应该定义主要的构建模块（子系统）、关键类、数据设计、业务规则、用户界面、资源管理、安全、性能、可扩展性等。</li>
                            </ul>
                        </li>
                    </ol>
                </div>
            </details>
        </section>

        <section id="ch4">
            <details>
                <summary>第四章: 关键的构建决策</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>编程语言的选择影响深远：</strong> 语言的选择会影响生产率、代码质量和程序员的思维方式。
                    </div>
                    <div class="fact">
                        <strong>语言与生产率：</strong>
                        <ul>
                            <li>程序员使用熟悉的语言比不熟悉的语言生产率高约30% (Cocomo II)。</li>
                            <li>高级语言（如C++, Java, C#）的生产率比低级语言（如C，汇编）高5到15倍。</li>
                        </ul>
                    </div>
                    <div class="viewpoint">
                        <strong>编程“到”一种语言，而不是“在”一种语言中编程：</strong>
                        <ul>
                            <li><strong>编程“在”一种语言中（Programming IN a language）：</strong> 思想受限于语言直接支持的结构。</li>
                            <li><strong>编程“到”一种语言中（Programming INTO a language）：</strong> 先决定想表达的思想，然后利用语言提供的工具来实现它。这意味着你可以通过约定、标准、类库来弥补语言的不足。</li>
                        </ul>
                    </div>
                    <div class="viewpoint">
                        <strong>技术浪潮的位置：</strong> 你所处的“技术浪潮”的位置决定了你的开发体验。
                        <ul>
                            <li><strong>浪潮早期（Early Wave）：</strong> 语言和工具有很多bug，文档稀少，大量时间花在解决环境问题上。</li>
                            <li><strong>浪潮晚期（Late Wave）：</strong> 拥有丰富的开发基础设施，如强大的IDE、成熟的库、稳定的编译器和大量的文档。</li>
                        </ul>
                        在浪潮早期，“编程到语言中”的理念尤为重要。
                    </div>
                    <div class="viewpoint">
                        <strong>制定编程约定：</strong> 在构建开始前，团队应就变量命名、代码格式、注释风格等达成一致。这可以减少无谓的争论，提高代码的一致性和可读性。约定是管理复杂性的关键工具。
                    </div>
                </div>
            </details>
        </section>

        <!-- PART II -->
        <section id="ch5">
            <details>
                <summary>第五章: 构建中的设计</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>软件的首要技术使命：管理复杂度（Managing Complexity）：</strong> 这是软件开发中最重要的话题。几乎所有设计技巧和编码实践的最终目的都是为了分解和控制复杂性，使程序员在任何时候只需关注程序的一小部分。
                    </div>
                    <div class="viewpoint">
                        <strong>设计的挑战：</strong>
                        <ul>
                            <li><strong>设计是“邪恶问题”（Wicked Problem）：</strong> 问题的定义只有在解决（或部分解决）之后才能完全清晰。</li>
                            <li><strong>设计是一个凌乱的过程：</strong> 充满了错误的尝试和盲目的探索，但这是必要的，因为在设计阶段犯错比在编码后修复成本低得多。</li>
                            <li><strong>设计是关于权衡和优先级：</strong> 现实世界中没有完美的方案，好的设计是在相互冲突的目标（如速度、空间、开发时间、可维护性）之间做出明智的权衡。</li>
                            <li><strong>设计是启发式的（Heuristic）：</strong> 它依赖于经验法则和“有时奏效的技巧”，而不是确定性的算法。</li>
                            <li><strong>设计是涌现的（Emergent）：</strong> 好的设计不是一次成型的，而是通过评审、讨论和编码实践逐步演化和完善的。</li>
                        </ul>
                    </div>
                    <h3>关键设计概念</h3>
                    <ul>
                        <li><strong>理想的设计特征：</strong> 最小化复杂度、易于维护、松散耦合、可扩展性、可重用性、高扇入（Fan-in）、低到中等的扇出（Fan-out）、可移植性、精简、分层、标准化。</li>
                        <li><strong>设计的层次：</strong>
                            <ol>
                                <li>软件系统级</li>
                                <li>子系统/包级：将系统划分为大的功能块，并严格定义它们之间的通信规则。</li>
                                <li>类级：定义类的职责、接口和关系。</li>
                                <li>子程序级：设计类的内部实现，包括私有方法。</li>
                                <li>子程序内部设计：使用伪代码等方法规划子程序的具体逻辑。</li>
                            </ol>
                        </li>
                    </ul>
                    <h3>设计构造块：启发法</h3>
                    <div class="viewpoint">
                        <strong>信息隐藏（Information Hiding）：</strong> 这是结构化设计和面向对象设计的基石。每个模块（类、子程序）都应该隐藏一个“秘密”——一个设计或实现上的决策。这使得当这个决策改变时，影响被限制在模块内部。问自己“这个模块应该隐藏什么？”是解决许多设计难题的有力启发。
                    </div>
                    <ul>
                        <li><strong>寻找现实世界的对象：</strong> 面向对象设计的起点。</li>
                        <li><strong>形成一致的抽象：</strong> 让你可以在忽略不相关细节的情况下处理概念。</li>
                        <li><strong>封装实现细节：</strong> 强制隐藏细节，使得客户代码无法依赖于它们。</li>
                        <li><strong>识别最可能变化的地方：</strong> 将易变的部分隔离起来，以最小化变更带来的影响。</li>
                        <li><strong>保持松散耦合：</strong> 最小化模块之间的连接。</li>
                        <li><strong>寻找常见的设计模式：</strong> 使用经过验证的解决方案来解决常见问题，可以减少复杂性、减少错误，并改善沟通。</li>
                    </ul>
                </div>
            </details>
        </section>
        
        <section id="ch6">
            <details>
                <summary>第六章: 可以工作的类</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>类的基础是抽象数据类型（ADT）：</strong> 一个类不仅仅是数据和子程序的集合，它应该实现一个清晰的抽象数据类型（ADT），即一组数据以及操作这些数据的相关方法。理解ADT是创建高质量类的关键。
                    </div>
                    <h3>好的类接口</h3>
                    <ul>
                        <li><strong>提供一致的抽象层次：</strong> 一个类的所有公共方法应该服务于同一个抽象概念。不要在接口中暴露底层的实现细节（例如，一个<code>EmployeeList</code>类不应该暴露<code>GetNextItemInList()</code>这样的方法，而应该是<code>GetNextEmployee()</code>）。</li>
                        <li><strong>提供成对的服务：</strong> 如果有<code>Add()</code>，通常也需要<code>Remove()</code>；有<code>Enable()</code>，通常也需要<code>Disable()</code>。</li>
                        <li><strong>良好的封装：</strong>
                            <ul>
                                <li><strong>最小化可访问性：</strong> 默认将成员设为<code>private</code>，只有在必要时才放宽限制。</li>
                                <li><strong>不要暴露成员数据：</strong> 永远不要将成员变量声明为<code>public</code>。应该通过访问器方法（accessor methods）来提供对数据的访问。</li>
                                <li><strong>警惕语义上的封装破坏：</strong> 不要编写依赖于类内部实现细节的代码，即使这些细节是通过公共接口间接暴露的。</li>
                            </ul>
                        </li>
                    </ul>
                    <h3>设计与实现问题</h3>
                    <ul>
                        <li><strong>包含（“有一个”关系）：</strong> 这是面向对象编程中最常用的技术。当一个类“拥有”或“包含”另一个对象时，使用成员变量来实现。</li>
                        <li><strong>继承（“是一个”关系）：</strong>
                            <div class="viewpoint"><strong>继承是把双刃剑：</strong> 继承会增加复杂性，因为它打破了封装。只有在派生类确实是基类的一个特殊类型时（遵循里氏替换原则LSP）才使用公有继承。</div>
                            <ul>
                                <li><strong>里氏替换原则（LSP）：</strong> 子类的对象必须能够在不破坏程序正确性的前提下，替换掉基类的对象。</li>
                                <li><strong>继承树要浅：</strong> 深度超过2到3层的继承树就很难理解了。</li>
                                <li><strong>优先使用多态，而不是类型检查：</strong> 重复的<code>case</code>语句常常是使用继承和多态的信号。</li>
                                <li><strong>将所有数据成员设为private，而不是protected：</strong> 以保护封装性。</li>
                            </ul>
                        </li>
                    </ul>
                    <h3>为什么要创建一个类？</h3>
                    <p class="viewpoint">创建类的首要原因是降低程序的复杂性。其他原因包括：</p>
                    <ul>
                        <li>为现实世界或抽象的对象建模。</li>
                        <li>隔离复杂性，隐藏实现细节。</li>
                        <li>限制变更的影响。</li>
                        <li>隐藏全局数据。</li>
                        <li>简化参数传递。</li>
                        <li>创建集中的控制点。</li>
                        <li>促进代码复用。</li>
                    </ul>
                </div>
            </details>
        </section>
        
        <section id="ch7">
            <details>
                <summary>第七章: 高质量的子程序</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>创建子程序（Routine）的首要原因是降低复杂度：</strong> 将一段代码放入一个独立的子程序中，可以让你在其他地方调用它时忽略其内部细节，从而减轻智力负担。其他原因包括引入抽象、避免重复代码、隐藏序列或指针操作、提高可移植性等。
                    </div>
                    <div class="viewpoint">
                        <strong>即使是简单的操作也值得放入子程序：</strong> 即使一个操作只有一两行代码，将其放入一个命名良好的子程序中也能提高可读性，并且为未来的修改（例如增加错误检查）提供一个集中的修改点。
                    </div>
                    <h3>高质量子程序的设计</h3>
                    <ul>
                        <li><strong>强内聚（Strong Cohesion）：</strong> 这是子程序设计的核心。一个高质量的子程序应该只做一件事，并且把它做好。功能内聚（Functional Cohesion）是最好的，即子程序的所有操作都服务于一个单一、明确的功能。</li>
                        <li><strong>良好的命名：</strong>
                            <ul>
                                <li>准确描述子程序所做的<strong>所有</strong>事情。</li>
                                <li>避免使用模糊、无意义的动词，如<code>Handle...</code>, <code>Process...</code>。</li>
                                <li>对于函数（返回值的子程序），用其返回值来命名，如<code>printer.IsReady()</code>。</li>
                                <li>对于过程（不返回值的子程序），使用“动词 + 对象”的格式，如<code>PrintDocument()</code>。</li>
                                <li>精确使用反义词对，如<code>add/remove</code>, <code>start/stop</code>。</li>
                            </ul>
                        </li>
                        <li><strong>合适的长度：</strong> 大多数子程序可以保持在半屏到两屏代码（约25-100行）之间。过长的子程序通常意味着内聚性差，应该被分解。</li>
                        <li><strong>参数的使用：</strong>
                            <ul>
                                <li>参数数量应尽可能少，通常不超过7个。</li>
                                <li>按“输入-修改-输出”的顺序排列参数。</li>
                                <li>不要将输入参数用作工作变量；应该创建一个新的局部变量。</li>
                                <li>确保接口的抽象一致性。</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </details>
        </section>

        <section id="ch8">
            <details>
                <summary>第八章: 防御式编程</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>防御式编程的核心思想：</strong> 像防御式驾驶一样，假设其他模块可能会出错。一个健壮的程序不会因为接收到坏数据而崩溃。其目标是“垃圾进，无害出”或“垃圾进，错误信息出”，而不是传统的“垃圾进，垃圾出”。
                    </div>
                    <h3>关键技术</h3>
                    <ul>
                        <li><strong>保护程序免遭非法输入：</strong>
                            <ul>
                                <li>检查所有来自外部源（文件、用户、网络）的数据。</li>
                                <li>检查所有子程序的输入参数。</li>
                                <li>决定如何处理坏数据（返回中立值、记录日志、返回错误码、关闭程序等）。</li>
                            </ul>
                        </li>
                        <li><strong>断言（Assertions）：</strong>
                            <div class="viewpoint">断言用于检查<strong>绝不应该发生</strong>的情况，而错误处理代码用于处理<strong>预期可能发生</strong>的异常情况。断言是可执行的文档，用于在开发期间暴露代码中的逻辑错误。</div>
                            <ul>
                                <li>用断言来文档化和验证前条件（preconditions）和后条件（postconditions）。</li>
                                <li>避免在断言中放入有副作用的可执行代码，因为在生产环境中，断言可能会被关闭。</li>
                            </ul>
                        </li>
                        <li><strong>错误处理技术：</strong> 根据软件的类型选择合适的错误处理策略。
                            <ul>
                                <li><strong>健壮性（Robustness） vs. 正确性（Correctness）：</strong> 健壮性意味着软件持续运行，即使有时结果不准确；正确性意味着绝不返回不准确的结果，宁愿不返回结果。消费类应用倾向于健壮性，而安全攸关系统倾向于正确性。</li>
                            </ul>
                        </li>
                        <li><strong>异常（Exceptions）：</strong>
                            <ul>
                                <li>仅用于处理真正异常的情况，即那些无法在本地处理且不应被忽略的错误。</li>
                                <li>在与接口相同的抽象层次上抛出异常。例如，一个<code>GetEmployeeData()</code>方法不应抛出底层的<code>IOException</code>，而应抛出更抽象的<code>EmployeeDataNotAvailableException</code>。</li>
                                <li>避免在构造函数和析构函数中抛出异常，因为这会使资源管理变得异常复杂。</li>
                                <li>避免空的<code>catch</code>块。</li>
                            </ul>
                        </li>
                        <li><strong>隔离舱（Barricades）：</strong> 在程序中建立“安全”区域。在数据跨越“隔离舱”边界时进行检查和清理。一旦数据进入安全区，内部代码就可以假定数据是合法的，并使用断言来验证这一假设。</li>
                        <li><strong>调试辅助代码：</strong>
                            <div class="viewpoint"><strong>进攻式编程（Offensive Programming）：</strong> 在开发版本中，让错误尽可能早地、明显地暴露出来。例如，让断言直接终止程序，而不是允许程序员忽略它。</div>
                        </li>
                    </ul>
                </div>
            </details>
        </section>

        <section id="ch9">
            <details>
                <summary>第九章: 伪代码编程过程 (PPP)</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>伪代码编程过程（Pseudocode Programming Process, PPP）是一种系统化的方法，用于将设计思想平滑地转化为高质量的代码和文档。</strong> 它通过在编写实际代码之前用简单的、类似英语的伪代码来详细设计子程序，从而提高设计质量、简化编码、并自动生成有用的注释。
                    </div>
                    <h3>PPP的步骤</h3>
                    <ol>
                        <li><strong>设计子程序（Design the Routine）：</strong>
                            <ul>
                                <li>清晰地定义子程序要解决的问题，包括输入、输出、前条件和后条件。</li>
                                <li>为子程序起一个精确的、描述其所有功能的名字。</li>
                                <li>用类似英语的、高层次的伪代码来描述子程序的逻辑。
                                    <ul>
                                        <li><strong>编写好的伪代码：</strong> 描述“做什么”（意图），而不是“怎么做”（实现细节）。避免使用目标编程语言的语法。</li>
                                        <li><strong>迭代求精：</strong> 从高层伪代码开始，逐步细化，直到伪代码的每一步都足够简单，可以直接翻译成几行代码。</li>
                                    </ul>
                                </li>
                                <li>在伪代码层面进行思考和评审，这比在代码层面修改要容易得多。</li>
                            </ul>
                        </li>
                        <li><strong>编写代码（Code the Routine）：</strong>
                            <ul>
                                <li>将伪代码转换成代码中的注释。</li>
                                <li>在每条注释下面编写对应的代码。</li>
                                <li>这个过程应该是机械的、自然的。如果感觉困难，说明伪代码设计得还不够详细，应该返回上一步。</li>
                            </ul>
                        </li>
                        <li><strong>检查代码（Check the Code）：</strong>
                            <ul>
                                <li>在心中默想一遍代码的执行路径。</li>
                                <li>打开编译器的最高警告级别，并修复所有警告。</li>
                                <li>在调试器中单步执行代码，确保每一行都如预期那样工作。</li>
                                <li>用之前构想的测试用例进行测试。</li>
                            </ul>
                        </li>
                        <li><strong>清理并重复（Clean Up and Repeat）：</strong>
                            <ul>
                                <li>重构代码，检查接口、变量名、格式等是否符合标准。</li>
                                <li>移除那些因为代码本身已经足够清晰而变得多余的注释。</li>
                                <li>这是一个迭代的过程，如果发现代码质量不高，就回到伪代码阶段重新设计。</li>
                            </ul>
                        </li>
                    </ol>
                    <div class="viewpoint">
                        <strong>PPP的优势：</strong>
                        <ul>
                            <li><strong>简化设计：</strong> 让你在不受语法束缚的情况下专注于逻辑。</li>
                            <li><strong>简化编码：</strong> 编码变成了一个简单的翻译过程。</li>
                            <li><strong>自动生成高质量注释：</strong> 伪代码直接成为注释，解释了代码的“意图”，而不是简单重复代码。</li>
                            <li><strong>易于评审：</strong> 评审伪代码比评审源代码更高效。</li>
                            <li><strong>提高代码质量：</strong> 在成本最低的阶段（设计阶段）发现并修复错误。</li>
                        </ul>
                    </div>
                </div>
            </details>
        </section>

        <!-- PART VII -->
        <section id="ch31">
            <details>
                <summary>第三十一章: 布局与风格</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>格式化的基本定理：</strong> 好的视觉布局能够清晰地反映程序的逻辑结构。可读性不仅仅是美学问题，它有坚实的心理学基础：程序员对代码的组织方式有强烈的预期，违反这些预期会严重影响理解速度。
                    </div>
                    <h3>布局的目标</h3>
                    <ul>
                        <li><strong>准确地表现逻辑结构：</strong> 缩进和分组应与控制流和数据结构一致。</li>
                        <li><strong>一致地表现逻辑结构：</strong> 风格规则应普遍适用，避免太多例外。</li>
                        <li><strong>提高可读性：</strong> 使代码易于浏览和理解。</li>
                        <li><strong>易于修改和维护：</strong> 格式不应在代码修改时变得难以维护。</li>
                    </ul>
                    <h3>关键技术</h3>
                    <ul>
                        <li><strong>空白（White Space）：</strong>
                            <ul>
                                <li><strong>分组：</strong> 用空白将逻辑上相关的代码块组织在一起，如同文章中的段落。</li>
                                <li><strong>空行：</strong> 用空行来分隔不同的代码“段落”，突出注释，或分隔子程序。</li>
                                <li><strong>缩进：</strong> 这是展示逻辑从属关系最重要的方式。研究表明，2到4个空格的缩进最有利于理解。</li>
                            </ul>
                        </li>
                        <li><strong>括号：</strong> 在复杂的布尔或算术表达式中，不要依赖操作符优先级规则，应使用括号来明确意图，减少读者的认知负荷。</li>
                        <li><strong>块布局风格：</strong>
                            <ul>
                                <li><strong>纯块（Pure Blocks）：</strong> 像Visual Basic中的<code>If...End If</code>，块的开始和结束关键字对齐。</li>
                                <li><strong>模拟纯块（Emulating Pure Blocks）：</strong> 在C++/Java中，将开括号<code>{</code>放在控制语句的同一行，关括号<code>}</code>与控制语句对齐。这是Java的官方风格，也是一种非常好的风格。</li>
                                <li><strong>使用花括号界定块：</strong> 将开括号<code>{</code>放在控制语句的下一行，并与控制语句对齐，关括号<code>}</code>与之对齐。这也是一种清晰且可维护的风格。</li>
                            </ul>
                        </li>
                        <li><strong>单个语句：</strong> 每行只写一条语句。这有助于调试、编辑和清晰地展示代码的复杂性。</li>
                    </ul>
                    <div class="viewpoint">
                        <strong>避免过度格式化：</strong> 过于华丽的注释（如用星号框起来）会增加维护成本，并可能因为难以维护而最终变得过时和误导。简洁、一致的风格远胜于复杂的装饰。
                    </div>
                </div>
            </details>
        </section>
        
        <section id="ch32">
            <details>
                <summary>第三十二章: 自说明代码</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>好的代码是它自身最好的文档：</strong> 在编写注释之前，应尽力通过良好的编程风格（清晰的结构、直接的逻辑、好的变量和子程序名、使用命名常量等）来让代码尽可能地自说明。注释是锦上添花，而不是为烂代码擦屁股。
                    </div>
                    <h3>注释的类型与价值</h3>
                    <p>有效的注释解释代码的<strong>“意图”（Why）</strong>，而不是<strong>“如何做”（How）</strong>。</p>
                    <ul>
                        <li><strong>应该避免的注释：</strong>
                            <ul>
                                <li><strong>重复代码的注释：</strong> 只是用更啰嗦的语言复述了一遍代码，增加了阅读量而没有提供新信息。</li>
                                <li><strong>解释烂代码的注释：</strong> 如果一段代码需要长篇大论来解释，那么应该重写代码，而不是添加注释。名言：“不要给坏代码加注释——重写它。”</li>
                            </ul>
                        </li>
                        <li><strong>有价值的注释：</strong>
                            <ul>
                                <li><strong>总结性注释：</strong> 将几行代码的逻辑总结为一句话，帮助读者快速浏览。</li>
                                <li><strong>意图性注释：</strong> 解释代码背后的目的和设计思想。这是最有价值的注释，因为它提供了代码本身无法表达的上下文。</li>
                                <li><strong>无法用代码表达的信息：</strong> 版权声明、版本号、对算法来源的引用、对语言或环境的陷阱的说明等。</li>
                            </ul>
                        </li>
                    </ul>
                    <h3>高效注释的技巧</h3>
                    <ul>
                        <li><strong>在伪代码编程过程中编写注释：</strong> 在编写代码之前先用伪代码设计，然后将伪代码直接转为注释。这使得注释工作几乎没有额外成本。</li>
                        <li><strong>关注代码本身：</strong> 与其花时间写一个复杂的注释，不如花时间改进变量名、重构逻辑，让代码自己说话。</li>
                        <li><strong>为数据声明添加注释：</strong> 解释变量的单位（米、秒）、允许的数值范围、或特殊值的含义。</li>
                        <li><strong>为控制结构添加注释：</strong> 在每个循环或复杂的<code>if</code>语句前，用一句话说明其目的。</li>
                        <li><strong>为子程序和类编写头注释：</strong> 简要描述其职责、接口假设和局限性。使用像Javadoc这样的工具可以规范化这个过程。</li>
                    </ul>
                    <div class="fact">
                        <strong>注释密度：</strong> IBM的研究发现，平均每10行代码有一条注释时，代码的清晰度达到峰值。过多或过少的注释都会降低可理解性。
                    </div>
                </div>
            </details>
        </section>

        <section id="ch33">
            <details>
                <summary>第三十三章: 个人性格</summary>
                <div class="chapter-content">
                    <h3>核心要点</h3>
                    <div class="viewpoint">
                        <strong>编程是一种高度内省的智力活动，因此程序员的个人性格对其产出质量有着决定性的影响。</strong> 你无法被监督着成为一个优秀的程序员；这取决于你的个人选择和品格。
                    </div>
                    <h3>优秀程序员的关键性格特质</h3>
                    <ul>
                        <li><strong>谦虚（Humility）：</strong> 最优秀的程序员是那些认识到自己大脑容量有限的人。他们不会试图将整个复杂程序装进脑子里，而是通过各种实践（如模块化、代码审查、编写短小的子程序）来弥补自己智力上的局限。承认自己会犯错是进步的前提。</li>
                        <li><strong>好奇心（Curiosity）：</strong> 软件行业技术日新月异。一个有好奇心的程序员会持续学习，探索新的工具和技术，阅读书籍和文章，并乐于通过实验来理解事物的工作原理。没有好奇心，程序员很快就会变成“技术恐龙”。</li>
                        <li><strong>诚实（Intellectual Honesty）：</strong>
                            <ul>
                                <li>不假装自己是专家，坦然承认自己的无知。</li>
                                <li>坦率地承认自己的错误，并从中学习。</li>
                                <li>不通过“编译运行看结果”的方式来编程，而是在提交代码前真正理解它。</li>
                                <li>提供真实的项目状态报告和进度估算，即使这可能不是管理者想听到的。</li>
                            </ul>
                        </li>
                        <li><strong>沟通与合作（Communication and Cooperation）：</strong> 编程首先是与人沟通，其次才是与计算机沟通。编写可读性强的代码是团队合作精神的核心体现。</li>
                        <li><strong>创造力与纪律的平衡（Creativity and Discipline）：</strong> 纪律（如遵循标准和约定）并不会扼杀创造力，反而会解放它。通过在不重要的事情上遵循约定，你可以将创造力集中在真正需要解决的核心问题上。</li>
                        <li><strong>开明的懒惰（Enlightened Laziness）：</strong> 这不是指拖延，而是指为了从长远上减少总体工作量而付出的努力。例如，编写一个工具来自动化重复性任务，或者精心编写文档以减少未来回答问题的次数。</li>
                    </ul>
                    <h3>不太重要的特质</h3>
                    <ul>
                        <li><strong>经验（Experience）：</strong> 在快速变化的软件领域，“多年的经验”可能意味着“一年经验的多次重复”。持续学习和反思比单纯的年头更重要。</li>
                        <li><strong>坚持（Persistence）：</strong> 面对难题时，顽固的坚持（“牛角尖”）往往是低效的。知道何时该放弃一种方法，稍作休息，或寻求他人帮助，是更明智的策略。</li>
                    </ul>
                </div>
            </details>
        </section>
        
        <section id="ch34">
            <details>
                <summary>第三十四章: 软件工艺的主题</summary>
                <div class="chapter-content">
                    <p class="viewpoint">本章提炼了贯穿全书的核心思想，它们是区分“黑客”与“软件工匠”的关键。</p>
                    <h3>软件工艺的核心主题</h3>
                    <ul>
                        <li><strong>征服复杂性（Conquer Complexity）：</strong> 这是软件开发的首要技术使命。所有优秀实践，如模块化、信息隐藏、编写短小的子程序、避免全局变量等，都是为了将复杂问题分解成人类大脑可以处理的小块。</li>
                        <li><strong>选择你的过程（Pick Your Process）：</strong> 你采用的开发过程（无论是敏捷、瀑布还是其他）对最终产品的质量有巨大影响。优秀的程序员会有意识地选择并改进他们的工作流程。</li>
                        <li><strong>为人写程序，其次才是为计算机（Write Programs for People First, Computers Second）：</strong> 代码的主要读者是人。可读性不是可选项，它直接影响代码的可理解性、可维护性、调试效率和最终质量。</li>
                        <li><strong>编程“到”一种语言中，而不是“在”一种语言中（Program into Your Language, Not in It）：</strong> 不要让你的思维被特定语言的特性所局限。先想清楚你希望如何表达解决方案，然后利用语言的工具来实现它，甚至通过约定和自建工具来弥补语言的不足。</li>
                        <li><strong>利用约定来集中注意力（Focus Your Attention with the Help of Conventions）：</strong> 约定（如命名约定、格式约定）通过将任意性决策标准化，解放了你的脑力，让你能专注于解决更重要的问题。</li>
                        <li><strong>基于问题领域编程（Program in Terms of the Problem Domain）：</strong> 尽可能地使用与现实世界问题相关的词汇和抽象（例如，使用<code>Employee</code>, <code>Invoice</code>等类），而不是计算机科学的底层术语（如链表、哈希表）。这使得代码更易于理解和修改。</li>
                        <li><strong>警惕“掉落的岩石”（Watch for Falling Rocks）：</strong> 编程中充满了预示着问题的“警示信号”。例如，“这段代码很tricky”、一个模块的缺陷率异常高、深度嵌套、糟糕的变量名等。优秀的程序员对这些信号保持警惕，并将其视为改进代码的机会。</li>
                        <li><strong>迭代，再迭代（Iterate, Repeatedly, Again and Again）：</strong> 无论是需求、设计、编码还是估算，迭代都是一个强大的工具。第一次的尝试很少是最好的，通过多次迭代和改进，可以逐步逼近更优的解决方案。</li>
                        <li><strong>将软件与宗教分离（Thou Shalt Rend Software and Religion Asunder）：</strong> 避免对任何单一方法论、工具或风格的盲目、教条式崇拜。保持开放和怀疑的心态，采取兼容并蓄（eclecticism）的态度，通过实验来验证哪种方法最适合当前的问题。</li>
                    </ul>
                </div>
            </details>
        </section>
        
        <section id="dev-way" class="dev-way">
            <h2>开发者之道 (The Developer's Way)</h2>
            <p>像代码工匠一样思考。</p>
            <p>这并非仅仅因为你编写代码，而是因为你将世界视为一个可以被理解、改进和重建的系统。这是《代码大全》所揭示的软件工艺精神。</p>
            <p>开发者之道，是一场<strong>征服复杂性</strong>的终身战争。你承认自己头脑的容量严格有限，因此你保持谦逊。你将庞然大物分解为可管理的模块，隐藏信息以便你能安心遗忘，并构建抽象让你能只见森林，不被树木所困。</p>
            <p>你<strong>为人类编写程序，其次才是为机器</strong>。每一行代码都是一次与未来的对话——与你的团队，也与未来的你。因此，清晰不是一种特性，而是基础。好的命名不是奢侈品，而是必需品。你的代码，就是它自身最好的文档。</p>
            <p>你<strong>编程“到”一种语言中，而不是“在”一种语言中</strong>。你不被工具所限，而是驾驭工具。当语言有缺陷时，你用约定和纪律来弥补，创造出你需要的结构。</p>
            <p>开发者之道，是<strong>迭代之道</strong>。你深知第一次的尝试很少是最好的。你设计、编码、测试、重构——在一次次的循环中，将粗糙的石头打磨成宝石。你的基本法则是：每一次演进都必须提升代码的内部质量，而不是降低它。</p>
            <p>你对“警示信号”保持警惕。一段“tricky”的代码、一个难以命名的变量、一个过深的嵌套——这些都是宇宙在低语：“这里有问题。” 每一个缺陷都是一堂课，让你更深刻地理解你的系统和自己。</p>
            <p>你拥抱<strong>诚实与谦逊</strong>。你坦然承认错误，因为你知道错误是通往真知的必经之路。你拒绝通过“编译运行”来猜测，而是先在头脑中构建确定性。</p>
            <p>这不仅仅是关于构建软件。</p>
            <p>这是关于你如何对待你的手艺：</p>
            <p>带着谦逊、精确，以及对质量毫不动摇的承诺。</p>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            const sidebarLinks = document.querySelectorAll('#sidebar a');
            const sections = document.querySelectorAll('#main-content section');

            // Smooth scroll for sidebar links
            sidebarLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetSection = document.querySelector(targetId);
                    if (targetSection) {
                        targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
            });

            // Highlight active link on scroll
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        sidebarLinks.forEach(link => {
                            link.classList.remove('active');
                            if (link.getAttribute('href') === `#${entry.target.id}`) {
                                link.classList.add('active');
                            }
                        });
                    }
                });
            }, { threshold: 0.3, rootMargin: '0px 0px -50% 0px' });

            sections.forEach(section => {
                observer.observe(section);
            });
        });
    </script>

<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="book_code_complete._files/book.html" target="_blank">源链接</a>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>