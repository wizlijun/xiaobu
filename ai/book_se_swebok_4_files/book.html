<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>《swe》</title>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: 'FangSong', '仿宋', 'STFangSong', '华文仿宋', serif;
            line-height: 1.8;
            color: #333333;
            background-color: #fefefe;
            max-width: 700px;
            margin: 0 auto;
            padding: 3rem 2rem;
            font-size: 1.1rem;
            text-align: justify;
        }

        /* 浮动目录按钮 */
        .toc-toggle {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            background: rgba(96, 165, 250, 0.5);
            color: white;
            border: none;
            border-radius: 8px;
            width: 48px;
            height: 48px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .toc-toggle:hover {
            background: rgba(96, 165, 250, 0.8);
            transform: translateY(-50%) scale(1.1);
        }

        /* 浮动目录面板 */
        .toc-sidebar {
            position: fixed;
            left: -320px;
            top: 0;
            width: 300px;
            height: 100vh;
            background: #ffffff;
            border-right: 1px solid #e2e8f0;
            box-shadow: 4px 0 12px rgba(0, 0, 0, 0.1);
            z-index: 999;
            transition: left 0.3s ease;
            overflow-y: auto;
            padding: 2rem 1rem;
        }

        .toc-sidebar.active {
            left: 0;
        }

        .toc-sidebar h3 {
            font-size: 1.2rem;
            color: #1a202c;
            margin-bottom: 1rem;
            text-align: center;
            border-bottom: 2px solid #3182ce;
            padding-bottom: 0.5rem;
        }

        /* 目录区域 - 用于插入目录内容 */
        .toc-content {
            /* 目录内容将插入到这里 */
        }

        /* 遮罩层 */
        .toc-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 998;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .toc-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* 简洁的目录样式 */
        .simple-toc ul {
            list-style: none;
            padding-left: 0;
            margin: 0;
        }

        .simple-toc ul ul {
            padding-left: 1rem;
            margin-top: 0.25rem;
        }

        .simple-toc li {
            margin-bottom: 0.25rem;
        }

        .simple-toc a {
            display: block;
            padding: 0.5rem 0.75rem;
            color: #4a5568;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .simple-toc a:hover {
            background-color: #edf2f7;
            color: #3182ce;
            transform: translateX(4px);
        }

        /* 标题样式 */
        h1, h2, h3, h4, h5, h6 {
            font-family: 'FangSong', '仿宋', 'STFangSong', '华文仿宋', serif;
            color: #2d3748;
            margin-top: 2rem;
            margin-bottom: 1.2rem;
            line-height: 1.4;
            font-weight: normal;
            text-align: center;
        }

        h1 {
            font-size: 1.8rem;
            border-bottom: 2px solid #718096;
            padding-bottom: 0.8rem;
            margin-top: 0;
            margin-bottom: 2.5rem;
        }

        h2 {
            font-size: 1.5rem;
            border-bottom: 1px solid #cbd5e0;
            padding-bottom: 0.6rem;
            margin-top: 2.5rem;
        }

        h3 {
            font-size: 1.3rem;
            color: #4a5568;
        }

        h4 {
            font-size: 1.2rem;
            color: #4a5568;
        }

        h5 {
            font-size: 1.1rem;
            color: #4a5568;
        }

        h6 {
            font-size: 1rem;
            color: #718096;
            font-weight: normal;
        }

        /* 段落样式 */
        p {
            margin-bottom: 1.5rem;
            text-align: justify;
            word-break: break-word;
            text-indent: 2em;
            font-family: 'FangSong', '仿宋', 'STFangSong', '华文仿宋', serif;
        }

        /* 链接样式 */
        a {
            color: #3182ce;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        a:hover {
            color: #2c5282;
            text-decoration: underline;
        }

        /* 图片样式 - 居中显示 */
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 2rem auto;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* 列表样式 */
        ul, ol {
            margin: 1.25rem 0;
            padding-left: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        ul ul, ol ol, ul ol, ol ul {
            margin: 0.5rem 0;
        }

        /* 代码样式 */
        code {
            font-family: 'Courier New', 'Monaco', 'Consolas', 'Ubuntu Mono', monospace;
            background-color: #f8f9fa;
            color: #d63384;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9rem;
        }

        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 1.5rem;
            margin: 2rem 0;
            overflow-x: auto;
            font-family: 'Courier New', 'Monaco', 'Consolas', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        pre code {
            background: none;
            color: inherit;
            padding: 0;
            border-radius: 0;
            font-size: inherit;
        }

        /* 引用样式 */
        blockquote {
            border-left: 4px solid #a0aec0;
            margin: 2rem 0;
            padding: 1.2rem 1.8rem;
            background-color: #f7fafc;
            color: #4a5568;
            font-style: italic;
            border-radius: 0 6px 6px 0;
            font-family: 'FangSong', '仿宋', 'STFangSong', '华文仿宋', serif;
        }

        blockquote p:last-child {
            margin-bottom: 0;
        }

        /* 表格样式 */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            background-color: #ffffff;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        th, td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        th {
            background-color: #f7fafc;
            font-weight: 600;
            color: #2d3748;
        }

        tr:hover {
            background-color: #f7fafc;
        }

        /* 分隔线 */
        hr {
            border: none;
            border-top: 2px solid #e2e8f0;
            margin: 3rem 0;
        }

        /* 页面分隔器 */
        .page-separator {
            border-top: 2px solid #e2e8f0;
            margin: 3rem 0;
            text-align: center;
            position: relative;
        }

        .page-separator::after {
            content: "• • •";
            background-color: #ffffff;
            color: #a0aec0;
            padding: 0 1rem;
            position: relative;
            top: -0.75rem;
        }

        /* 强调样式 */
        strong, b {
            font-weight: 700;
            color: #1a202c;
        }

        em, i {
            font-style: italic;
            color: #4a5568;
        }

        /* 目标标题高亮 */
        h1:target, h2:target, h3:target, h4:target, h5:target, h6:target {
            background-color: #fff3cd;
            padding: 1rem;
            border-radius: 6px;
            margin: 1.5rem 0;
            border-left: 4px solid #ffc107;
            animation: highlight 2s ease-in-out;
        }

        @keyframes highlight {
            0% {
                background-color: #fff3cd;
                transform: scale(1.02);
            }
            100% {
                background-color: transparent;
                transform: scale(1);
            }
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            body {
                padding: 1.5rem;
                font-size: 1rem;
                max-width: 100%;
            }

            .toc-toggle {
                left: 10px;
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .toc-sidebar {
                width: 280px;
                left: -300px;
                padding: 1rem;
            }

            h1 {
                font-size: 1.6rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            h4 {
                font-size: 1.1rem;
            }

            table {
                font-size: 0.9rem;
            }

            th, td {
                padding: 0.6rem 0.8rem;
            }

            pre {
                padding: 1.2rem;
                font-size: 0.85rem;
            }

            blockquote {
                padding: 1rem 1.2rem;
                margin: 1.5rem 0;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 1.2rem;
                font-size: 0.95rem;
            }

            .toc-sidebar {
                width: 260px;
                left: -280px;
            }

            h1, h2, h3, h4, h5, h6 {
                margin-top: 1.5rem;
            }

            ul, ol {
                padding-left: 1.5rem;
            }
            
            p {
                text-indent: 1.5em;
            }
        }

        /* 打印样式 */
        @media print {
            .toc-toggle,
            .toc-sidebar,
            .toc-overlay {
                display: none !important;
            }

            body {
                max-width: none;
                padding: 0;
                font-size: 12pt;
                line-height: 1.5;
                color: #000;
            }

            h1, h2, h3, h4, h5, h6 {
                page-break-after: avoid;
            }

            img {
                max-width: 100% !important;
                page-break-inside: avoid;
            }

            blockquote, pre {
                page-break-inside: avoid;
            }

            a {
                color: #000;
                text-decoration: underline;
            }
        }
    </style>
</head>
<body>
<!-- 浮动目录按钮 -->
<button class="toc-toggle" onclick="toggleToc()" title="打开/关闭目录">
        ☰
    </button>
<!-- 浮动目录面板 -->
<div class="toc-sidebar" id="tocSidebar">
<h3 id="目录">目录</h3>
<div class="toc-content simple-toc"><ul>
<li><ul>
<li><ul>
<li><a href="#目录">目录</a></li>
</ul></li>
</ul></li>
<li><a href="#swe">《swe》</a></li>
<li><a href="#软件工程知识体系指南">软件工程知识体系指南</a></li>
<li><ul>
<li><a href="#编者">编者</a></li>
</ul></li>
<li><a href="#软件工程知识体系指南-1">软件工程知识体系指南</a></li>
<li><a href="#软件工程知识体系指南-2">软件工程知识体系指南</a></li>
<li><ul>
<li><a href="#编者-1">编者</a></li>
<li><a href="#ieee计算机协会出版物工作人员">IEEE计算机协会出版物工作人员</a></li>
</ul></li>
<li><a href="#目录-1">目录</a></li>
<li><ul>
<li><a href="#第01章">第01章</a></li>
<li><a href="#软件需求-1-1">软件需求
[1-1]</a></li>
<li><ul>
<li><a href="#1-软件需求基础-1-2">1. 软件需求基础 [1-2]</a></li>
<li><a href="#2-需求获取-1-6">2. 需求获取 [1-6]</a></li>
<li><a href="#3-需求分析-1-8">3. 需求分析 [1-8]</a></li>
<li><a href="#4-需求规约-1-10">4. 需求规约 [1-10]</a></li>
<li><a href="#5-需求验证-1-15">5. 需求验证 [1-15]</a></li>
<li><a href="#6-需求管理活动-1-16">6. 需求管理活动 [1-16]</a></li>
<li><a href="#7-实践考虑-1-17">7. 实践考虑 [1-17]</a></li>
<li><a href="#8-软件需求工具-1-20">8. 软件需求工具 [1-20]</a></li>
</ul></li>
<li><a href="#第02章">[第02章]</a></li>
<li><a href="#第03章">[第03章]</a></li>
<li><a href="#第04章">第04章</a></li>
<li><a href="#第05章">[第05章]</a></li>
<li><a href="#1210-可测试性testability-5-5">1.2.10. 可测试性(Testability) 5-5</a></li>
<li><a href="#1211-测试执行与自动化test-execution-and-automation-5-5">1.2.11.
测试执行与自动化(Test Execution and Automation) 5-5</a></li>
<li><a href="#1212-可扩展性scalability-5-5">1.2.12. 可扩展性(Scalability) 5-5</a></li>
<li><a href="#1213-测试有效性test-effectiveness-5-5">1.2.13. 测试有效性(Test
Effectiveness) 5-5</a></li>
<li><a href="#1214-可控性可复现性与通用性controllability-replication-and-generalization-5-5">1.2.14.
可控性、可复现性与通用性(Controllability, Replication, and
Generalization) 5-5</a></li>
<li><a href="#1215-离线测试与在线测试off-line-vs-online-testing-5-6">1.2.15.
离线测试与在线测试(Off-Line vs. Online Testing) 5-6</a></li>
<li><a href="#13-测试与其他活动的关系-5-6">1.3. 测试与其他活动的关系 5-6</a></li>
</ul></li>
<li><a href="#2-测试级别-5-6">2. 测试级别 5-6</a></li>
<li><ul>
<li><a href="#21-测试目标-5-6">2.1. 测试目标 5-6</a></li>
<li><ul>
<li><a href="#211-单元测试unit-testing-5-6">2.1.1. 单元测试(Unit Testing) 5-6</a></li>
<li><a href="#212-集成测试integration-testing-5-7">2.1.2. 集成测试(Integration
Testing) 5-7</a></li>
<li><a href="#213-系统测试-5-7">2.1.3. 系统测试 5-7</a></li>
<li><a href="#214-验收测试acceptance-testing-5-7">2.1.4. 验收测试(Acceptance
Testing) 5-7</a></li>
</ul></li>
<li><a href="#22-测试目的-5-7">2.2. 测试目的 5-7</a></li>
<li><ul>
<li><a href="#221-符合性测试conformance-testing-5-7">2.2.1. 符合性测试(Conformance
Testing) 5-7</a></li>
<li><a href="#222-合规性测试compliance-testing-5-8">2.2.2. 合规性测试(Compliance
Testing) 5-8</a></li>
<li><a href="#223-安装测试installation-testing-5-8">2.2.3. 安装测试(Installation
Testing) 5-8</a></li>
<li><a href="#224-alpha与beta测试-5-8">2.2.4. Alpha与Beta测试 5-8</a></li>
<li><a href="#225-回归测试regression-testing-5-8">2.2.5. 回归测试(Regression
Testing) 5-8</a></li>
<li><a href="#226-优先级测试prioritization-testing-5-8">2.2.6.
优先级测试(Prioritization Testing) 5-8</a></li>
<li><a href="#227-非功能性测试non-functional-testing-5-8">2.2.7.
非功能性测试(Non-functional Testing) 5-8</a></li>
<li><a href="#228-安全测试security-testing-5-9">2.2.8. 安全测试(Security Testing)
5-9</a></li>
<li><a href="#229-隐私测试privacy-testing-5-9">2.2.9. 隐私测试(Privacy Testing)
5-9</a></li>
<li><a href="#2210-接口与应用程序接口api测试-5-10">2.2.10.
接口与应用程序接口(API)测试 5-10</a></li>
<li><a href="#2211-配置测试configuration-testing-5-10">2.2.11.
配置测试(Configuration Testing) 5-10</a></li>
<li><a href="#2212-可用性与人机交互测试-5-10">2.2.12. 可用性与人机交互测试
5-10</a></li>
</ul></li>
</ul></li>
<li><a href="#3-测试技术-5-10">3. 测试技术 5-10</a></li>
<li><ul>
<li><a href="#31-基于规格说明的技术-5-10">3.1. 基于规格说明的技术 5-10</a></li>
<li><ul>
<li><a href="#311-等价类划分equivalence-partitioning-5-10">3.1.1.
等价类划分(Equivalence Partitioning) 5-10</a></li>
<li><a href="#312-边界值分析boundary-value-analysis-5-11">3.1.2.
边界值分析(Boundary-Value Analysis) 5-11</a></li>
<li><a href="#313-语法测试syntax-testing-5-11">3.1.3. 语法测试(Syntax Testing)
5-11</a></li>
<li><a href="#314-组合测试技术combinatorial-test-techniques-5-11">3.1.4.
组合测试技术(Combinatorial Test Techniques) 5-11</a></li>
<li><a href="#315-判定表decision-table-5-11">3.1.5. 判定表(Decision Table)
5-11</a></li>
<li><a href="#316-因果图cause-effect-graphing-5-11">3.1.6. 因果图(Cause-Effect
Graphing) 5-11</a></li>
<li><a href="#317-状态转换测试state-transition-testing-5-11">3.1.7.
状态转换测试(State Transition Testing) 5-11</a></li>
<li><a href="#318-基于场景的测试scenario-based-testing-5-12">3.1.8.
基于场景的测试(Scenario-Based Testing) 5-12</a></li>
<li><a href="#319-随机测试random-testing-5-12">3.1.9. 随机测试(Random Testing)
5-12</a></li>
<li><a href="#3110-基于证据evidence-based-5-12">3.1.10. 基于证据(Evidence-Based)
5-12</a></li>
<li><a href="#3111-强制异常forcing-exception-5-12">3.1.11. 强制异常(Forcing
Exception) 5-12</a></li>
</ul></li>
<li><a href="#32-基于结构的测试技术-5-12">3.2. 基于结构的测试技术 5-12</a></li>
<li><ul>
<li><a href="#321-控制流测试control-flow-testing-5-13">3.2.1. 控制流测试(Control
Flow Testing) 5-13</a></li>
<li><a href="#322-数据流测试data-flow-testing-5-13">3.2.2. 数据流测试(Data Flow
Testing) 5-13</a></li>
<li><a href="#323-基于结构的测试技术参考模型-5-13">3.2.3.
基于结构的测试技术参考模型 5-13</a></li>
</ul></li>
<li><a href="#33-基于经验的技术-5-13">3.3. 基于经验的技术 5-13</a></li>
<li><ul>
<li><a href="#331-错误推测error-guessing-5-13">3.3.1. 错误推测(Error Guessing)
5-13</a></li>
<li><a href="#332-探索性测试exploratory-testing-5-13">3.3.2.
探索性测试(Exploratory Testing) 5-13</a></li>
<li><a href="#333-其他基于经验的技术-5-14">3.3.3. 其他基于经验的技术 5-14</a></li>
</ul></li>
<li><a href="#34-基于故障的技术与变异技术fault-based-and-mutation-techniques-5-14">3.4.
基于故障的技术与变异技术(Fault-Based and Mutation Techniques) 5-14</a></li>
<li><a href="#35-基于使用的技术-5-15">3.5. 基于使用的技术 5-15</a></li>
<li><ul>
<li><a href="#351-运行剖面operational-profile-5-15">3.5.1. 运行剖面(Operational
Profile) 5-15</a></li>
<li><a href="#352-用户观察启发式方法user-observation-heuristics-5-15">3.5.2.
用户观察启发式方法(User Observation Heuristics) 5-15</a></li>
</ul></li>
<li><a href="#36-基于应用性质的技术-5-15">3.6. 基于应用性质的技术 5-15</a></li>
<li><a href="#37-技术选择与组合-5-16">3.7. 技术选择与组合 5-16</a></li>
<li><ul>
<li><a href="#371-功能性与结构性的组合-5-16">3.7.1. 功能性与结构性的组合 5-16</a></li>
<li><a href="#372-确定性与随机性-5-16">3.7.2. 确定性与随机性 5-16</a></li>
</ul></li>
<li><a href="#38-基于派生知识的技术-5-16">3.8. 基于派生知识的技术 5-16</a></li>
</ul></li>
<li><a href="#4-测试相关度量-5-16">4. 测试相关度量 5-16</a></li>
<li><ul>
<li><a href="#41-被测系统sut的评估-5-17">4.1. 被测系统(SUT)的评估 5-17</a></li>
<li><ul>
<li><a href="#411-帮助规划和设计测试的sut度量-5-17">4.1.1.
帮助规划和设计测试的SUT度量 5-17</a></li>
<li><a href="#412-故障类型分类与统计-5-17">4.1.2. 故障类型、分类与统计 5-17</a></li>
<li><a href="#413-故障密度fault-density-5-17">4.1.3. 故障密度(Fault Density)
5-17</a></li>
<li><a href="#414-寿命测试可靠性评估-5-17">4.1.4. 寿命测试、可靠性评估 5-17</a></li>
<li><a href="#415-可靠性增长模型reliability-growth-models-5-17">4.1.5.
可靠性增长模型(Reliability Growth Models) 5-17</a></li>
</ul></li>
<li><a href="#42-已执行测试的评估-5-17">4.2. 已执行测试的评估 5-17</a></li>
<li><ul>
<li><a href="#421-故障注入fault-injection-5-18">4.2.1. 故障注入(Fault Injection)
5-18</a></li>
<li><a href="#422-变异分数mutation-score-5-18">4.2.2. 变异分数(Mutation Score)
5-18</a></li>
<li><a href="#423-不同技术的比较与相对有效性-5-18">4.2.3.
不同技术的比较与相对有效性 5-18</a></li>
</ul></li>
</ul></li>
<li><a href="#5-测试过程-5-18">5. 测试过程 5-18</a></li>
<li><ul>
<li><a href="#51-实践考虑-5-18">5.1. 实践考虑 5-18</a></li>
<li><ul>
<li><a href="#511-态度无我编程attitudesegoless-programming-5-19">5.1.1.
态度/无我编程(Attitudes/Egoless Programming) 5-19</a></li>
<li><a href="#512-测试指南与组织流程-5-19">5.1.2. 测试指南与组织流程 5-19</a></li>
<li><a href="#513-测试管理与动态测试过程-5-19">5.1.3. 测试管理与动态测试过程
5-19</a></li>
<li><a href="#514-测试文档-5-19">5.1.4. 测试文档 5-19</a></li>
<li><a href="#515-测试团队-5-19">5.1.5. 测试团队 5-19</a></li>
<li><a href="#516-测试过程度量-5-20">5.1.6. 测试过程度量 5-20</a></li>
<li><a href="#517-测试监控与控制-5-20">5.1.7. 测试监控与控制 5-20</a></li>
<li><a href="#518-测试完成-5-20">5.1.8. 测试完成 5-20</a></li>
<li><a href="#519-测试可复用性-5-20">5.1.9. 测试可复用性 5-20</a></li>
</ul></li>
<li><a href="#52-测试子过程与活动-5-21">5.2. 测试子过程与活动 5-21</a></li>
<li><ul>
<li><a href="#521-测试规划过程-5-21">5.2.1. 测试规划过程 5-21</a></li>
<li><a href="#522-测试设计与实现-5-21">5.2.2. 测试设计与实现 5-21</a></li>
<li><a href="#523-测试环境搭建与维护-5-21">5.2.3. 测试环境搭建与维护 5-21</a></li>
<li><a href="#524-受控实验与测试执行-5-21">5.2.4. 受控实验与测试执行 5-21</a></li>
<li><a href="#525-测试事件报告-5-22">5.2.5. 测试事件报告 5-22</a></li>
</ul></li>
<li><a href="#53-人员配备-5-22">5.3. 人员配备 5-22</a></li>
</ul></li>
<li><a href="#6-软件测试在开发过程与应用领域中的应用-5-22">6.
软件测试在开发过程与应用领域中的应用 5-22</a></li>
<li><ul>
<li><a href="#61-软件开发过程中的测试-5-23">6.1. 软件开发过程中的测试 5-23</a></li>
<li><ul>
<li><a href="#611-传统过程中的测试-5-23">6.1.1. 传统过程中的测试 5-23</a></li>
<li><a href="#612-与左移运动shift-left-movement一致的测试-5-23">6.1.2.
与左移运动(Shift-Left Movement)一致的测试 5-23</a></li>
</ul></li>
<li><a href="#62-应用领域中的测试-5-24">6.2. 应用领域中的测试 5-24</a></li>
</ul></li>
<li><a href="#7-新兴技术的测试与通过新兴技术进行测试-5-26">7.
新兴技术的测试与通过新兴技术进行测试 5-26</a></li>
<li><ul>
<li><a href="#71-新兴技术的测试-5-26">7.1. 新兴技术的测试 5-26</a></li>
<li><a href="#72-通过新兴技术进行测试-5-27">7.2. 通过新兴技术进行测试 5-27</a></li>
</ul></li>
<li><a href="#8-软件测试工具-5-28">8. 软件测试工具 5-28</a></li>
<li><ul>
<li><a href="#81-测试工具支持与选择-5-29">8.1. 测试工具支持与选择 5-29</a></li>
<li><a href="#82-工具类别-5-29">8.2. 工具类别 5-29</a></li>
</ul></li>
<li><a href="#第06章">第06章</a></li>
<li><a href="#1-软件工程运维基础-6-3">1. 软件工程运维基础 6-3</a></li>
<li><ul>
<li><a href="#11-软件工程运维的定义-6-3">1.1. 软件工程运维的定义 6-3</a></li>
<li><a href="#12-软件工程运维流程-6-4">1.2. 软件工程运维流程 6-4</a></li>
<li><a href="#13-软件安装-6-5">1.3. 软件安装 6-5</a></li>
<li><a href="#14-脚本编写与自动化-6-5">1.4. 脚本编写与自动化 6-5</a></li>
<li><a href="#15-有效测试与故障排除-6-5">1.5. 有效测试与故障排除 6-5</a></li>
<li><a href="#16-性能可靠性与负载均衡-6-6">1.6. 性能、可靠性与负载均衡 6-6</a></li>
</ul></li>
<li><a href="#2-软件工程运维规划-6-6">2. 软件工程运维规划 6-6</a></li>
<li><ul>
<li><a href="#21-运维计划与供应商管理-6-6">2.1. 运维计划与供应商管理 6-6</a></li>
<li><ul>
<li><a href="#211-运维计划-6-6">2.1.1. 运维计划 6-6</a></li>
<li><a href="#212-供应商管理-6-7">2.1.2. 供应商管理 6-7</a></li>
</ul></li>
<li><a href="#22-开发与运维环境-6-7">2.2. 开发与运维环境 6-7</a></li>
<li><a href="#23-软件可用性连续性与服务级别-6-8">2.3.
软件可用性、连续性与服务级别 6-8</a></li>
<li><a href="#24-软件容量管理-6-8">2.4. 软件容量管理 6-8</a></li>
<li><a href="#25-软件备份灾难恢复与故障切换-6-8">2.5.
软件备份、灾难恢复与故障切换 6-8</a></li>
<li><a href="#26-软件与数据的安全性完整性保护与控制-6-9">2.6.
软件与数据的安全性、完整性、保护与控制 6-9</a></li>
</ul></li>
<li><a href="#3-软件工程运维交付-6-9">3. 软件工程运维交付 6-9</a></li>
<li><ul>
<li><a href="#31-运维测试验证与验收-6-9">3.1. 运维测试、验证与验收 6-9</a></li>
<li><a href="#32-部署发布工程-6-10">3.2. 部署/发布工程 6-10</a></li>
<li><a href="#33-回滚与数据迁移-6-10">3.3. 回滚与数据迁移 6-10</a></li>
<li><a href="#34-问题解决-6-11">3.4. 问题解决 6-11</a></li>
</ul></li>
<li><a href="#4-软件工程运维控制-6-11">4. 软件工程运维控制 6-11</a></li>
<li><ul>
<li><a href="#41-事件管理incident-management-6-11">4.1. 事件管理(Incident
Management) 6-11</a></li>
<li><a href="#42-变更管理-6-11">4.2. 变更管理 6-11</a></li>
<li><a href="#43-监控测量跟踪与审查-6-11">4.3. 监控、测量、跟踪与审查 6-11</a></li>
<li><a href="#44-运维支持-6-12">4.4. 运维支持 6-12</a></li>
<li><a href="#45-服务报告-6-12">4.5. 服务报告 6-12</a></li>
</ul></li>
<li><a href="#5-实践考虑-6-12">5. 实践考虑 6-12</a></li>
<li><ul>
<li><a href="#51-事件与问题预防-6-12">5.1. 事件与问题预防 6-12</a></li>
<li><a href="#52-运维风险管理-6-12">5.2. 运维风险管理 6-12</a></li>
<li><a href="#53-软件工程运维自动化-6-12">5.3. 软件工程运维自动化 6-12</a></li>
<li><a href="#第七章">第七章</a></li>
<li><a href="#第八章">第八章</a></li>
<li><a href="#第九章">第九章</a></li>
<li><a href="#第十章">第十章</a></li>
</ul></li>
<li><a href="#2-生命周期">2. 生命周期</a></li>
<li><ul>
<li><a href="#21-生命周期定义过程类别和术语">2.1.
生命周期定义、过程类别和术语</a></li>
<li><a href="#22-生命周期的基本原理">2.2. 生命周期的基本原理</a></li>
<li><a href="#23-过程模型和生命周期模型的概念">2.3.
过程模型和生命周期模型的概念</a></li>
<li><a href="#24-开发生命周期模型的一些范式">2.4. 开发生命周期模型的一些范式</a></li>
<li><a href="#25-开发生命周期模型及其工程维度">2.5.
开发生命周期模型及其工程维度</a></li>
<li><a href="#26-slcp的管理">2.6. SLCP的管理</a></li>
<li><a href="#27-软件工程过程管理">2.7. 软件工程过程管理</a></li>
<li><a href="#28-软件生命周期适配">2.8. 软件生命周期适配</a></li>
<li><a href="#29-实际考虑因素">2.9. 实际考虑因素</a></li>
<li><a href="#210-软件过程基础设施工具方法">2.10.
软件过程基础设施、工具、方法</a></li>
<li><a href="#211-软件工程过程监控及其与软件产品的关系">2.11.
软件工程过程监控及其与软件产品的关系</a></li>
</ul></li>
<li><a href="#3-软件过程评估和改进">3. 软件过程评估和改进</a></li>
<li><ul>
<li><a href="#31-软件过程评估和改进概述">3.1. 软件过程评估和改进概述</a></li>
<li><a href="#32-目标-问题-度量-gqm">3.2. 目标-问题-度量 (GQM)</a></li>
<li><a href="#33-基于框架的方法">3.3. 基于框架的方法</a></li>
<li><a href="#34-敏捷中的过程评估和改进">3.4. 敏捷中的过程评估和改进</a></li>
</ul></li>
<li><a href="#第11章">第11章</a></li>
<li><ul>
<li><a href="#软件工程模型和方法">软件工程模型和方法</a></li>
<li><a href="#1-建模">1. 建模</a></li>
<li><ul>
<li><a href="#11-建模原则">1.1. 建模原则</a></li>
<li><a href="#12-模型的属性和表达">1.2. 模型的属性和表达</a></li>
<li><a href="#13-语法语义和语用学">1.3. 语法、语义和语用学</a></li>
<li><a href="#14-前置条件后置条件和不变量">1.4. 前置条件、后置条件和不变量</a></li>
</ul></li>
<li><a href="#2-模型类型">2. 模型类型</a></li>
<li><ul>
<li><a href="#21-结构建模">2.1. 结构建模</a></li>
<li><a href="#22-行为建模">2.2. 行为建模</a></li>
</ul></li>
<li><a href="#3-模型分析">3. 模型分析</a></li>
<li><ul>
<li><a href="#31-完整性分析">3.1. 完整性分析</a></li>
<li><a href="#32-一致性分析">3.2. 一致性分析</a></li>
<li><a href="#33-正确性分析">3.3. 正确性分析</a></li>
<li><a href="#34-可追溯性分析">3.4. 可追溯性分析</a></li>
<li><a href="#35-交互性分析">3.5. 交互性分析</a></li>
</ul></li>
<li><a href="#4-软件工程方法">4. 软件工程方法</a></li>
<li><ul>
<li><a href="#41-启发式方法">4.1. 启发式方法</a></li>
<li><a href="#42-形式化方法">4.2. 形式化方法</a></li>
<li><a href="#43-原型法">4.3. 原型法</a></li>
<li><a href="#44-敏捷方法">4.4. 敏捷方法</a></li>
</ul></li>
</ul></li>
<li><a href="#第12章">第12章</a></li>
<li><ul>
<li><a href="#软件质量">软件质量</a></li>
<li><a href="#1-软件质量基础">1. 软件质量基础</a></li>
<li><ul>
<li><a href="#11-软件工程文化和道德规范">1.1. 软件工程文化和道德规范</a></li>
<li><a href="#12-质量的价值和成本">1.2. 质量的价值和成本</a></li>
<li><a href="#13-标准模型和认证">1.3. 标准、模型和认证</a></li>
<li><a href="#14-软件可靠性和完整性级别">1.4. 软件可靠性和完整性级别</a></li>
<li><ul>
<li><a href="#141-可靠性">1.4.1 可靠性</a></li>
<li><a href="#142-软件完整性级别">1.4.2. 软件完整性级别</a></li>
</ul></li>
</ul></li>
<li><a href="#2-软件质量管理过程">2. 软件质量管理过程</a></li>
<li><ul>
<li><a href="#21-软件质量改进">2.1. 软件质量改进</a></li>
<li><a href="#22-规划质量管理">2.2. 规划质量管理</a></li>
<li><a href="#23-评估质量管理">2.3. 评估质量管理</a></li>
<li><ul>
<li><a href="#231-软件质量度量">2.3.1 软件质量度量</a></li>
</ul></li>
<li><a href="#24-执行纠正和预防措施">2.4. 执行纠正和预防措施</a></li>
<li><ul>
<li><a href="#241-缺陷特征描述">2.4.1. 缺陷特征描述</a></li>
</ul></li>
</ul></li>
<li><a href="#3-软件质量保证过程">3. 软件质量保证过程</a></li>
<li><ul>
<li><a href="#31-准备质量保证">3.1. 准备质量保证</a></li>
<li><a href="#32-执行过程保证">3.2. 执行过程保证</a></li>
<li><a href="#33-执行产品保证">3.3. 执行产品保证</a></li>
<li><a href="#34-vv和测试">3.4. V&amp;V和测试</a></li>
<li><ul>
<li><a href="#341-静态分析技术">3.4.1 静态分析技术</a></li>
<li><a href="#342-动态分析技术">3.4.2. 动态分析技术</a></li>
<li><a href="#343-形式化分析技术">3.4.3. 形式化分析技术</a></li>
<li><a href="#344-软件质量控制和测试">3.4.4. 软件质量控制和测试</a></li>
<li><a href="#345-技术评审和审计">3.4.5. 技术评审和审计</a></li>
</ul></li>
</ul></li>
<li><a href="#4-软件质量工具">4. 软件质量工具</a></li>
</ul></li>
<li><a href="#第13章">第13章</a></li>
<li><ul>
<li><a href="#软件安全">软件安全</a></li>
<li><a href="#1-软件安全基础">1. 软件安全基础</a></li>
<li><ul>
<li><a href="#11-软件安全">1.1. 软件安全</a></li>
<li><a href="#12-信息安全">1.2. 信息安全</a></li>
<li><a href="#13-网络安全">1.3. 网络安全</a></li>
</ul></li>
<li><a href="#2-安全管理和组织">2. 安全管理和组织</a></li>
<li><ul>
<li><a href="#21-能力成熟度模型">2.1. 能力成熟度模型</a></li>
<li><a href="#22-信息安全管理系统">2.2. 信息安全管理系统</a></li>
<li><a href="#23-软件安全的敏捷实践">2.3. 软件安全的敏捷实践</a></li>
</ul></li>
<li><a href="#3-软件安全工程和过程">3. 软件安全工程和过程</a></li>
<li><ul>
<li><a href="#31-安全工程和安全开发生命周期-sdlc">3.1. 安全工程和安全开发生命周期
(SDLC)</a></li>
<li><a href="#32-信息技术安全评估通用准则">3.2. 信息技术安全评估通用准则</a></li>
</ul></li>
<li><a href="#4-软件系统的安全工程">4. 软件系统的安全工程</a></li>
<li><ul>
<li><a href="#41-安全需求">4.1. 安全需求</a></li>
<li><a href="#42-安全设计">4.2. 安全设计</a></li>
<li><a href="#43-安全模式">4.3. 安全模式</a></li>
<li><a href="#44-安全构造">4.4. 安全构造</a></li>
<li><a href="#45-安全测试">4.5. 安全测试</a></li>
<li><a href="#46-漏洞管理">4.6. 漏洞管理</a></li>
</ul></li>
<li><a href="#5-软件安全工具">5. 软件安全工具</a></li>
<li><ul>
<li><a href="#51-安全漏洞检查工具">5.1. 安全漏洞检查工具</a></li>
<li><a href="#52-渗透测试工具">5.2. 渗透测试工具</a></li>
</ul></li>
<li><a href="#6-特定领域的软件安全">6. 特定领域的软件安全</a></li>
<li><ul>
<li><a href="#61-容器和云的安全">6.1. 容器和云的安全</a></li>
<li><a href="#62-物联网软件的安全">6.2. 物联网软件的安全</a></li>
<li><a href="#63-基于机器学习的应用的安全">6.3. 基于机器学习的应用的安全</a></li>
</ul></li>
</ul></li>
<li><a href="#第14章">第14章</a></li>
<li><ul>
<li><a href="#软件工程职业实践">软件工程职业实践</a></li>
<li><a href="#1-专业性">1. 专业性</a></li>
<li><ul>
<li><a href="#11-认可认证和资格许可">1.1. 认可、认证和资格、许可</a></li>
<li><ul>
<li><a href="#111-认可">1.1.1. 认可</a></li>
<li><a href="#112-认证和资格">1.1.2. 认证和资格</a></li>
<li><a href="#113-许可">1.1.3. 许可</a></li>
</ul></li>
<li><a href="#12-道德规范和职业行为准则">1.2. 道德规范和职业行为准则</a></li>
<li><a href="#13-专业协会的性质和作用">1.3. 专业协会的性质和作用</a></li>
<li><a href="#14-软件工程标准的性质和作用">1.4. 软件工程标准的性质和作用</a></li>
<li><a href="#15-软件的经济影响">1.5. 软件的经济影响</a></li>
<li><a href="#16-雇佣合同">1.6. 雇佣合同</a></li>
<li><a href="#17-法律问题">1.7. 法律问题</a></li>
<li><ul>
<li><a href="#171-标准">1.7.1. 标准</a></li>
<li><a href="#172-商标">1.7.2. 商标</a></li>
<li><a href="#173-专利">1.7.3. 专利</a></li>
<li><a href="#174-版权">1.7.4. 版权</a></li>
<li><a href="#175-商业秘密">1.7.5. 商业秘密</a></li>
<li><a href="#176-职业责任">1.7.6. 职业责任</a></li>
<li><a href="#177-法律要求">1.7.7. 法律要求</a></li>
<li><a href="#178-贸易合规">1.7.8. 贸易合规</a></li>
<li><a href="#179-网络犯罪">1.7.9. 网络犯罪</a></li>
<li><a href="#1710-数据隐私">1.7.10. 数据隐私</a></li>
</ul></li>
<li><a href="#18-文档">1.8. 文档</a></li>
<li><a href="#19-权衡分析">1.9. 权衡分析</a></li>
</ul></li>
<li><a href="#2-群体动力学和心理学">2. 群体动力学和心理学</a></li>
<li><ul>
<li><a href="#21-团队小组协作的动力学">2.1. 团队/小组协作的动力学</a></li>
<li><a href="#22-个体认知">2.2. 个体认知</a></li>
<li><a href="#23-处理问题复杂性">2.3. 处理问题复杂性</a></li>
</ul></li>
<li><a href="#第15章">第15章</a></li>
<li><a href="#第16章">第16章</a></li>
<li><a href="#第17章">[第17章]</a></li>
<li><a href="#第18章">第18章</a></li>
<li><ul>
<li><a href="#xxv">xxv</a></li>
</ul></li>
</ul></li>
<li><a href="#指南简介">指南简介</a></li>
<li><ul>
<li><a href="#2014年版前言">2014年版前言</a></li>
<li><a href="#2004年版前言">2004年版前言</a></li>
<li><a href="#知识领域编辑">知识领域编辑</a></li>
<li><ul>
<li><a href="#软件需求">软件需求</a></li>
<li><a href="#软件架构">软件架构</a></li>
<li><a href="#软件设计">软件设计</a></li>
<li><a href="#软件构造">软件构造</a></li>
<li><a href="#软件测试">软件测试</a></li>
<li><a href="#软件工程运维">软件工程运维</a></li>
<li><a href="#软件维护">软件维护</a></li>
<li><a href="#软件配置管理">软件配置管理</a></li>
<li><a href="#软件工程管理">软件工程管理</a></li>
<li><a href="#软件工程过程">软件工程过程</a></li>
<li><a href="#软件工程模型和方法-1">软件工程模型和方法</a></li>
<li><a href="#软件质量-1">软件质量</a></li>
<li><a href="#软件安全-1">软件安全</a></li>
<li><a href="#软件工程专业实践">软件工程专业实践</a></li>
<li><a href="#软件工程经济学">软件工程经济学</a></li>
<li><a href="#计算基础">计算基础</a></li>
<li><a href="#数学基础">数学基础</a></li>
<li><a href="#工程基础">工程基础</a></li>
<li><a href="#附录a知识领域描述规范">附录A：知识领域描述规范</a></li>
<li><a href="#附录b支持swebok的ieee和isoiec标准">附录B：支持SWEBOK的IEEE和ISO/IEC标准</a></li>
<li><a href="#附录c综合参考文献列表">附录C：综合参考文献列表</a></li>
</ul></li>
<li><a href="#贡献编辑">贡献编辑</a></li>
<li><a href="#指导小组">指导小组</a></li>
<li><a href="#swebok早期版本的知识领域编辑">SWEBOK早期版本的知识领域编辑</a></li>
<li><ul>
<li><a href="#软件需求-1">软件需求</a></li>
<li><a href="#软件设计-1">软件设计</a></li>
<li><a href="#软件构造-1">软件构造</a></li>
<li><a href="#软件测试-1">软件测试</a></li>
<li><a href="#软件维护-1">软件维护</a></li>
<li><a href="#软件配置管理-1">软件配置管理</a></li>
<li><a href="#软件工程管理-1">软件工程管理</a></li>
<li><a href="#软件工程过程-1">软件工程过程</a></li>
<li><a href="#软件工程工具和方法">软件工程工具和方法</a></li>
<li><a href="#软件质量-2">软件质量</a></li>
</ul></li>
<li><a href="#审阅团队">审阅团队</a></li>
<li><a href="#致谢">致谢</a></li>
<li><a href="#关于批准swebok指南v40的决议">关于批准SWEBOK指南V4.0的决议</a></li>
<li><a href="#关于批准swebok指南v30的决议">关于批准SWEBOK指南V3.0的决议</a></li>
<li><a href="#指南简介-1">指南简介</a></li>
<li><a href="#1-什么是软件工程">1. 什么是软件工程？</a></li>
<li><a href="#2-swebok指南的目标是什么">2. SWEBOK指南的目标是什么？</a></li>
<li><a href="#层次化组织">层次化组织</a></li>
</ul></li>
<li><a href="#14-软件工程专业实践">14. 软件工程专业实践</a></li>
<li><a href="#15-软件工程经济学">15. 软件工程经济学</a></li>
<li><a href="#16-计算基础">16. 计算基础</a></li>
<li><a href="#17-数学基础">17. 数学基础</a></li>
<li><a href="#18-工程基础">18. 工程基础</a></li>
<li><ul>
<li><a href="#处理深度">处理深度</a></li>
<li><a href="#参考资料和矩阵">参考资料和矩阵</a></li>
<li><a href="#知识领域描述的结构">知识领域描述的结构</a></li>
<li><a href="#附录a-知识领域描述规范">附录A. 知识领域描述规范</a></li>
<li><a href="#附录b-ieee和isoiec标准">附录B. IEEE和ISO/IEC标准</a></li>
<li><a href="#附录c-综合参考文献列表">附录C. 综合参考文献列表</a></li>
<li><a href="#参考文献">参考文献</a></li>
<li><a href="#第01章-1">第01章</a></li>
</ul></li>
<li><a href="#软件需求-2">软件需求</a></li>
<li><ul>
<li><a href="#软件需求定义">软件需求定义</a></li>
<li><a href="#软件需求知识体系结构">软件需求知识体系结构</a></li>
<li><ul>
<li><a href="#基础概念">基础概念</a></li>
<li><ul>
<li><a href="#软件产品定义">软件产品定义</a></li>
</ul></li>
<li><a href="#需求分类">需求分类</a></li>
<li><ul>
<li><a href="#软件产品需求与软件项目需求">软件产品需求与软件项目需求</a></li>
<li><a href="#功能需求与非功能需求">功能需求与非功能需求</a></li>
</ul></li>
</ul></li>
<li><a href="#22-常见需求获取技术-1-c7-2-s43">2.2. 常见需求获取技术 [1*, c7]
[2*, s4.3]</a></li>
<li><a href="#3-需求分析-1-c8-9">3. 需求分析 [1*, c8-9]</a></li>
<li><ul>
<li><a href="#31-基本需求分析-1-c8-9">3.1. 基本需求分析 [1*, c8-9]</a></li>
<li><a href="#32-服务质量约束的经济学-3">3.2. 服务质量约束的经济学 [3*]</a></li>
</ul></li>
<li><a href="#33-形式化分析">3.3. 形式化分析</a></li>
<li><a href="#34-处理需求冲突">3.4. 处理需求冲突</a></li>
<li><a href="#4-需求规约">4. 需求规约</a></li>
</ul></li>
<li><a href="#软件需求规格说明">软件需求规格说明</a></li>
<li><ul>
<li><a href="#41-非结构化自然语言需求规格说明">4.1.
非结构化自然语言需求规格说明</a></li>
<li><a href="#42-结构化自然语言需求规格说明">4.2. 结构化自然语言需求规格说明</a></li>
<li><a href="#43-基于验收标准的需求规格说明">4.3. 基于验收标准的需求规格说明</a></li>
<li><a href="#44-基于模型的需求规范">4.4. 基于模型的需求规范</a></li>
<li><a href="#验证">验证</a></li>
<li><ul>
<li><a href="#52-模拟和执行">5.2. 模拟和执行</a></li>
<li><a href="#53-原型">5.3. 原型</a></li>
</ul></li>
<li><a href="#6-需求管理活动">6. 需求管理活动</a></li>
<li><ul>
<li><a href="#61-需求精简requirements-scrubbing">6.1. 需求精简(Requirements
Scrubbing)</a></li>
<li><a href="#62-需求变更控制">6.2. 需求变更控制</a></li>
<li><a href="#63-范围匹配scope-matching">6.3. 范围匹配(Scope Matching)</a></li>
</ul></li>
</ul></li>
<li><a href="#7-实际考虑因素">7. 实际考虑因素</a></li>
<li><ul>
<li><a href="#71-需求过程的迭代性质-2-s42">7.1. 需求过程的迭代性质 [2*,
s4.2]</a></li>
<li><a href="#72-需求优先级排序-1-c16">7.2. 需求优先级排序 [1*, c16]</a></li>
<li><a href="#73-需求追踪-1-c29">7.3. 需求追踪 [1*, c29]</a></li>
<li><a href="#8-软件需求工具-1-c30">8. 软件需求工具 [1*, c30]</a></li>
<li><ul>
<li><a href="#81-需求管理工具">8.1 需求管理工具</a></li>
<li><a href="#74-需求稳定性和波动性">7.4 需求稳定性和波动性</a></li>
<li><a href="#75-需求度量">7.5 需求度量</a></li>
<li><a href="#76-需求过程质量和改进">7.6 需求过程质量和改进</a></li>
<li><a href="#82-需求建模工具">8.2 需求建模工具</a></li>
<li><a href="#83-功能测试用例生成工具">8.3 功能测试用例生成工具</a></li>
</ul></li>
<li><a href="#1-软件需求基础">1. 软件需求基础</a></li>
<li><a href="#2-需求获取requirements-elicitation">2. 需求获取(Requirements
Elicitation)</a></li>
<li><a href="#3-需求分析">3. 需求分析</a></li>
<li><a href="#4-需求规格说明">4. 需求规格说明</a></li>
<li><a href="#5-需求验证">5. 需求验证</a></li>
<li><a href="#6-需求管理活动-1">6. 需求管理活动</a></li>
<li><a href="#7-实践考虑">7. 实践考虑</a></li>
<li><a href="#8-软件需求工具">8. 软件需求工具</a></li>
<li><a href="#参考文献-1">参考文献</a></li>
<li><a href="#第二章">第二章</a></li>
</ul></li>
<li><a href="#软件架构-1">软件架构</a></li>
<li><ul>
<li><a href="#缩略语">缩略语</a></li>
<li><a href="#引言">引言</a></li>
<li><a href="#1-软件架构基础">1. 软件架构基础</a></li>
<li><ul>
<li><a href="#11-架构的含义-2-c2-6-c61-29-c6">1.1. “架构”的含义 [2*, c2] [6*,
c6.1] [29*, c6]</a></li>
</ul></li>
</ul></li>
<li><a href="#软件架构-2">软件架构</a></li>
<li><ul>
<li><a href="#软件架构知识领域的主题分解">软件架构知识领域的主题分解</a></li>
<li><ul>
<li><a href="#12-利益相关者和关注点">1.2. 利益相关者和关注点</a></li>
</ul></li>
<li><a href="#1-思维的排序">1. 思维的排序</a></li>
<li><ul>
<li><a href="#13-架构的用途">1.3. 架构的用途</a></li>
</ul></li>
<li><a href="#2-软件架构描述">2. 软件架构描述</a></li>
</ul></li>
<li><a href="#软件架构-3">软件架构</a></li>
<li><ul>
<li><a href="#24-架构作为重大决策">2.4. 架构作为重大决策</a></li>
<li><a href="#3-软件架构过程">3. 软件架构过程</a></li>
<li><ul>
<li><a href="#31-架构的上下文">3.1. 架构的上下文</a></li>
<li><ul>
<li><a href="#311-架构与设计的关系">3.1.1. 架构与设计的关系</a></li>
</ul></li>
<li><a href="#32-架构设计">3.2. 架构设计</a></li>
<li><ul>
<li><a href="#321-架构分析">3.2.1. 架构分析</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#架构分析基于已识别的设计原则和方法">架构分析基于已识别的设计原则和方法</a></li>
<li><ul>
<li><a href="#322-架构综合-2-c20">3.2.2. 架构综合 [2*, c20]</a></li>
<li><a href="#323-架构评估-2-c21-38-c14">3.2.3. 架构评估 [2*, c21] [38*, c14]</a></li>
<li><a href="#33-架构实践方法和策略">3.3. 架构实践、方法和策略</a></li>
<li><a href="#34-大规模架构设计">3.4. 大规模架构设计</a></li>
<li><a href="#4-软件架构评估">4. 软件架构评估</a></li>
<li><ul>
<li><a href="#41-架构的优良性">4.1. 架构的”优良性”</a></li>
<li><a href="#42-架构审查-2-c21">4.2. 架构审查 [2*, c21]</a></li>
<li><a href="#43-架构审查-2-c21">4.3. 架构审查 [2*, c21]</a></li>
</ul></li>
</ul></li>
<li><a href="#架构权衡分析方法atam">架构权衡分析方法（ATAM）</a></li>
<li><ul>
<li><a href="#42-架构推理">4.2. 架构推理</a></li>
<li><a href="#44-架构度量">4.4. 架构度量</a></li>
<li><a href="#扩展阅读">扩展阅读</a></li>
</ul></li>
<li><a href="#参考文献-2">参考文献</a></li>
<li><ul>
<li><a href="#第三章">第三章</a></li>
</ul></li>
<li><a href="#软件设计-2">软件设计</a></li>
<li><ul>
<li><a href="#引言-1">引言</a></li>
<li><a href="#软件设计主题分解">软件设计主题分解</a></li>
<li><a href="#1-软件设计基础-34">1. 软件设计基础 [3*][4*]</a></li>
<li><ul>
<li><a href="#11-设计思维-3-c1-3-4-c1-2">1.1. 设计思维 [3*, c1-3] [4*, c1-2]</a></li>
<li><a href="#12-软件设计的上下文-4-c13-14-21-c19-20">1.2. 软件设计的上下文 [4*,
c13-14] [21*, c19-20]</a></li>
</ul></li>
<li><a href="#13-软件设计中的关键问题-3-p69ff-4-c1711-21-c6-7">1.3.
软件设计中的关键问题 [3*, p69ff] [4*, c17.1.1] [21*, c6-7]</a></li>
<li><a href="#14-软件设计原则-4-c42">1.4. 软件设计原则 [4*, c4.2]</a></li>
<li><a href="#2-软件设计过程">2. 软件设计过程</a></li>
</ul></li>
<li><a href="#21-高层设计-3-c5-4-c6">2.1. 高层设计 [3*, c5] [4*, c6]</a></li>
<li><a href="#3-软件设计质量-4-c4">3. 软件设计质量 [4*, c4]</a></li>
<li><ul>
<li><a href="#31-并发性-21-c17">3.1. 并发性 [21*, c17]</a></li>
<li><a href="#32-控制和事件处理-21-c21">3.2. 控制和事件处理 [21*, c21]</a></li>
<li><a href="#33-数据持久化-21-c6-c16">3.3. 数据持久化 [21*, c6, c16]</a></li>
<li><a href="#34-组件分布-21-c17">3.4. 组件分布 [21*, c17]</a></li>
<li><a href="#35-错误和异常处理容错-21-c11">3.5. 错误和异常处理、容错 [21*,
c11]</a></li>
<li><a href="#36-集成和互操作性-4-c11-c14-c16">3.6. 集成和互操作性 [4*, c11, c14,
c16]</a></li>
<li><a href="#37-保证安全性和安全-21-c10-14">3.7. 保证、安全性和安全 [21*,
c10-14]</a></li>
<li><a href="#38-可变性-7">3.8. 可变性 [7*]</a></li>
</ul></li>
<li><a href="#4-记录软件设计-1-4-c7-8">4. 记录软件设计 [1*] [4* c7-8]</a></li>
<li><ul>
<li><a href="#41-基于模型的设计-4-c73-21-c55">4.1. 基于模型的设计 [4*, c7.3]
[21*, c5.5]</a></li>
<li><a href="#46-设计原理-3-c164-c12-21-c61">4.6. 设计原理 [3*, c16][4*, c12]
[21*, c6.1]</a></li>
<li><a href="#5-软件设计策略和方法-21-c3">5. 软件设计策略和方法 [21*, c3]</a></li>
<li><ul>
<li><a href="#51-通用策略-4-c13">5.1. 通用策略 [4*, c13]</a></li>
<li><a href="#52-面向功能或结构化设计-4-c9">5.2. 面向功能(或结构化)设计 [4*,
c9]</a></li>
<li><a href="#53-以数据为中心的设计-4-c9-21-c541">5.3. 以数据为中心的设计 [4*,
c9] [21*, c5.4.1]</a></li>
<li><a href="#54-面向对象设计-4-c10-21-c3">5.4. 面向对象设计 [4*, c10] [21*,
c3]</a></li>
<li><a href="#55-以用户为中心的设计-3-c9">5.5. 以用户为中心的设计 [3*, c9]</a></li>
<li><a href="#56-事件驱动设计">5.6. 事件驱动设计</a></li>
</ul></li>
<li><a href="#56-基于组件的设计-cbd-1-c25-c29-4-c11-c16-21-c16">5.6.
基于组件的设计 (CBD) [1*, c25, c29] [4*, c11, c16] [21*, c16]</a></li>
<li><a href="#57-事件驱动设计-21-c542">5.7. 事件驱动设计 [21*, c5.4.2]</a></li>
<li><a href="#58-面向方面的设计-aod-1-c10-21-c31">5.8. 面向方面的设计 (AOD) [1*,
c10] [21*, c31]</a></li>
<li><a href="#59-基于约束的设计-3-c11">5.9. 基于约束的设计 [3*, c11]</a></li>
<li><a href="#510-领域驱动设计-4-c1362-c183">5.10. 领域驱动设计 [4*, c13.6.2,
c18.3]</a></li>
<li><a href="#511-其他方法-21-c18c21">5.11. 其他方法 [21*, c18–c21]</a></li>
<li><a href="#6-软件设计质量分析和评估-4-c7-21-c24">6. 软件设计质量分析和评估
[4*, c7] [21*, c24]</a></li>
<li><ul>
<li><a href="#61-设计审查和审计-4-c53">6.1. 设计审查和审计 [4*, c5.3]</a></li>
<li><a href="#62-质量属性-21-c24">6.2. 质量属性 [21*, c24]</a></li>
<li><a href="#63-质量分析和评估技术-21-c24">6.3. 质量分析和评估技术 [21*,
c24]</a></li>
</ul></li>
<li><a href="#64-度量和指标">6.4. 度量和指标</a></li>
<li><a href="#65-验证确认和认证">6.5. 验证、确认和认证</a></li>
<li><a href="#主题与参考资料对照矩阵">主题与参考资料对照矩阵</a></li>
<li><a href="#延伸阅读">延伸阅读</a></li>
<li><a href="#参考文献-3">参考文献</a></li>
<li><a href="#第04章-1">第04章</a></li>
</ul></li>
<li><a href="#软件架构-4">软件架构</a></li>
<li><ul>
<li><a href="#软件构造主题分解">软件构造主题分解</a></li>
<li><ul>
<li><a href="#1-软件构造基础">1. 软件构造基础</a></li>
<li><ul>
<li><a href="#12-预见和拥抱变化">1.2. 预见和拥抱变化</a></li>
<li><a href="#13-为验证而构造">1.3. 为验证而构造</a></li>
</ul></li>
</ul></li>
<li><a href="#14-资产复用-2-c15">1.4. 资产复用 [2-c15]</a></li>
<li><a href="#1sup5-在构建中应用标准-1-c4">1.sup&gt;5. 在构建中应用标准
[1-c4]</a></li>
<li><a href="#2-管理构建">2. 管理构建</a></li>
<li><ul>
<li><a href="#21-生命周期模型中的构建-1-c2-c3-c27-c29-2-c3-c7-3-c1">2.1.
生命周期模型中的构建 [1-c2, c3, c27, c29, 2-c3, c7, 3-c1]</a></li>
<li><a href="#22-构建规划-1-c3-c4-c21-c27-c29">2.2. 构建规划 [1-c3, c4, c21,
c27-c29]</a></li>
<li><a href="#23-构建度量-1-c25-c28">2.3. 构建度量 [1-c25, c28]</a></li>
<li><a href="#24-管理依赖关系-2-c25">2.4. 管理依赖关系 [2-c25]</a></li>
</ul></li>
<li><a href="#3-实际考虑因素">3. 实际考虑因素</a></li>
<li><ul>
<li><a href="#31-构建设计-1-c3-c5-c24-2-c7">3.1. 构建设计 [1-c3, c5, c24,
2-c7]</a></li>
<li><a href="#32-构建语言-1-c4">3.2. 构建语言 [1-c4]</a></li>
<li><a href="#33-编码-1-c3-c5-c24-2-c7">3.3. 编码 [1-c3, c5, c24, 2-c7]</a></li>
<li><a href="#33-编码">3.3. 编码</a></li>
<li><a href="#34-构建测试">3.4. 构建测试</a></li>
<li><a href="#35-构建中的复用">3.5. 构建中的复用</a></li>
<li><a href="#36-构建质量">3.6. 构建质量</a></li>
</ul></li>
</ul></li>
<li><a href="#软件构建">软件构建</a></li>
<li><ul>
<li><a href="#将可重用的软件资产集成到当前软件中">将可重用的软件资产集成到当前软件中</a></li>
<li><ul>
<li><a href="#单元测试和集成测试见第34节构建测试">单元测试和集成测试（见第3.4节，构建测试）</a></li>
</ul></li>
<li><a href="#测试驱动开发见软件测试知识域第612节">测试驱动开发（见软件测试知识域第6.1.2节）</a></li>
<li><a href="#使用断言和防御性编程">使用断言和防御性编程</a></li>
<li><a href="#调试">调试</a></li>
<li><a href="#检查">检查</a></li>
<li><a href="#技术评审包括面向安全的评审见软件质量知识域第23节">技术评审，包括面向安全的评审（见软件质量知识域第2.3节）</a></li>
<li><a href="#静态分析见软件质量知识域第221节">静态分析（见软件质量知识域第2.2.1节）</a></li>
<li><a href="#37-集成">3.7. 集成</a></li>
<li><a href="#38-跨平台开发和迁移">3.8. 跨平台开发和迁移</a></li>
<li><a href="#4-构建技术">4. 构建技术</a></li>
<li><ul>
<li><a href="#41-api设计和使用">4.1. API设计和使用</a></li>
<li><a href="#42-面向对象的运行时问题">4.2. 面向对象的运行时问题</a></li>
</ul></li>
<li><a href="#43-参数化模板和泛型">4.3. 参数化、模板和泛型</a></li>
<li><a href="#44-断言契约式设计和防御性编程">4.4.
断言、契约式设计和防御性编程</a></li>
<li><a href="#45-错误处理异常处理和容错">4.5. 错误处理、异常处理和容错</a></li>
<li><a href="#46-可执行模型">4.6. 可执行模型</a></li>
<li><a href="#47-基于状态和表驱动的构建技术">4.7. 基于状态和表驱动的构建技术</a></li>
</ul></li>
<li><a href="#47-基于状态的和基于表格的构造技术-1-c6-5">4.7.
基于状态的和基于表格的构造技术 [1-c6, 5]</a></li>
<li><ul>
<li><a href="#48-运行时配置和国际化-1-c3-c10">4.8. 运行时配置和国际化 [1-c3,
c10]</a></li>
<li><a href="#49-基于文法的输入处理-1-8">4.9. 基于文法的输入处理 [1, 8]</a></li>
<li><a href="#410-并发原语-9-c6">4.10. 并发原语 [9-c6]</a></li>
<li><a href="#411-中间件-5-c1-8-c8">4.11. 中间件 [5-c1, 8-c8]</a></li>
<li><a href="#412-分布式和基于云的软件的构造方法-2-c17-c18-9-c2">4.12.
分布式和基于云的软件的构造方法 [2-c17, c18, 9-c2]</a></li>
<li><a href="#413-异构系统的构造方法-2-c14">4.13. 异构系统的构造方法 [2-c14]</a></li>
</ul></li>
<li><a href="#客户端-服务器三层架构n层架构">客户端-服务器、三层架构、N层架构</a></li>
<li><ul>
<li><a href="#5-软件构建工具">5. 软件构建工具</a></li>
<li><a href="#53-单元测试工具-1-c22-2-c8">5.3. 单元测试工具 [1-c22, 2-c8]</a></li>
<li><a href="#54-性能分析性能分析和切片工具-1-c25-c26">5.4.
性能分析、性能分析和切片工具 [1-c25, c26]</a></li>
<li><a href="#主题与参考资料对照表">主题与参考资料对照表</a></li>
</ul></li>
<li><a href="#第5章-软件测试">第5章 软件测试</a></li>
<li><ul>
<li><a href="#缩略语-1">缩略语</a></li>
<li><a href="#引言-2">引言</a></li>
<li><a href="#延伸阅读-1">延伸阅读</a></li>
<li><a href="#参考文献-4">参考文献</a></li>
</ul></li>
<li><a href="#软件测试-2">软件测试</a></li>
<li><ul>
<li><a href="#11-故障与失效">1.1 故障与失效</a></li>
</ul></li>
<li><a href="#1-软件测试基础">1. 软件测试基础</a></li>
<li><ul>
<li><a href="#12-关键问题">1.2. 关键问题</a></li>
<li><ul>
<li><a href="#121-测试用例创建">1.2.1. 测试用例创建</a></li>
<li><a href="#122-测试选择和充分性标准">1.2.2. 测试选择和充分性标准</a></li>
<li><a href="#123-优先级排序最小化">1.2.3. 优先级排序/最小化</a></li>
<li><a href="#124-测试目的">1.2.4. 测试目的</a></li>
<li><a href="#125-评估和认证">1.2.5. 评估和认证</a></li>
<li><a href="#126-质量保证改进测试">1.2.6. 质量保证/改进测试</a></li>
<li><a href="#127-预言机问题">1.2.7. 预言机问题</a></li>
<li><a href="#128-理论和实际限制">1.2.8. 理论和实际限制</a></li>
<li><a href="#129-测试有效性">1.2.9. 测试有效性</a></li>
<li><a href="#1210-可测试性">1.2.10. 可测试性</a></li>
<li><a href="#1211-测试执行和自动化">1.2.11. 测试执行和自动化</a></li>
<li><a href="#1212-可扩展性">1.2.12. 可扩展性</a></li>
<li><a href="#129-不可行路径问题">1.2.9 不可行路径问题</a></li>
<li><a href="#1210-可测试性-1">1.2.10 可测试性</a></li>
<li><a href="#1213-测试有效性">1.2.13 测试有效性</a></li>
<li><a href="#1214-可控性可复现性和泛化性">1.2.14 可控性、可复现性和泛化性</a></li>
<li><a href="#1215-离线测试与在线测试">1.2.15 离线测试与在线测试</a></li>
<li><a href="#13-测试与其他活动的关系">1.3 测试与其他活动的关系</a></li>
</ul></li>
<li><a href="#2-测试级别">2. 测试级别</a></li>
<li><ul>
<li><a href="#21-测试的目标">2.1 测试的目标</a></li>
<li><ul>
<li><a href="#211-单元测试">2.1.1 单元测试</a></li>
<li><a href="#212-集成测试">2.1.2 集成测试</a></li>
</ul></li>
<li><a href="#22-测试的目标">2.2 测试的目标</a></li>
</ul></li>
<li><a href="#213-系统测试">2.1.3. 系统测试</a></li>
<li><a href="#214-验收测试">2.1.4. 验收测试</a></li>
<li><ul>
<li><a href="#221-一致性测试">2.2.1. 一致性测试</a></li>
<li><a href="#222-合规性测试">2.2.2 合规性测试</a></li>
<li><a href="#223-安装测试">2.2.3. 安装测试</a></li>
<li><a href="#224-alpha测试和beta测试">2.2.4. Alpha测试和Beta测试</a></li>
<li><a href="#225-回归测试">2.2.5. 回归测试</a></li>
<li><a href="#226-优先级测试">2.2.6. 优先级测试</a></li>
<li><a href="#227-非功能测试">2.2.7. 非功能测试</a></li>
</ul></li>
<li><a href="#228-安全测试">2.2.8. 安全测试</a></li>
<li><a href="#229-隐私测试">2.2.9. 隐私测试</a></li>
<li><a href="#2210-接口和应用程序接口api测试">2.2.10.
接口和应用程序接口(API)测试</a></li>
<li><a href="#32-基于结构的测试技术">3.2. 基于结构的测试技术</a></li>
<li><a href="#33-基于经验的技术">3.3. 基于经验的技术</a></li>
<li><a href="#34-基于缺陷和变异技术">3.4. 基于缺陷和变异技术</a></li>
<li><a href="#38-基于衍生知识的技术">3.8. 基于衍生知识的技术</a></li>
<li><a href="#41-sut的评估">4.1. SUT的评估</a></li>
<li><ul>
<li><a href="#411-有助于规划和设计测试的sut度量">4.1.1.
有助于规划和设计测试的SUT度量</a></li>
<li><a href="#412-故障类型分类和统计">4.1.2. 故障类型、分类和统计</a></li>
<li><a href="#413-故障密度">4.1.3. 故障密度</a></li>
<li><a href="#414-寿命测试可靠性评估">4.1.4. 寿命测试、可靠性评估</a></li>
<li><a href="#415-可靠性增长模型">4.1.5. 可靠性增长模型</a></li>
</ul></li>
<li><a href="#42-已执行测试的评估">4.2. 已执行测试的评估</a></li>
<li><ul>
<li><a href="#421-故障注入">4.2.1. 故障注入</a></li>
</ul></li>
<li><a href="#5-测试过程">5. 测试过程</a></li>
<li><ul>
<li><a href="#422-变异分数-1-c3s5-6">4.2.2. 变异分数 [1*, c3s5; 6]</a></li>
<li><a href="#423-不同技术的比较和相对有效性-1-c1s7-5-9">4.2.3.
不同技术的比较和相对有效性 [1*, c1s7; 5; 9]</a></li>
</ul></li>
<li><a href="#5-测试过程-1">5. 测试过程</a></li>
<li><ul>
<li><a href="#51-实际考虑因素-4-part-1">5.1. 实际考虑因素 [4, part 1]</a></li>
<li><ul>
<li><a href="#511-态度无我编程egoless-programming-1-c16-2-c3">5.1.1.
态度/无我编程(Egoless Programming) [1, c16; 2, c3]</a></li>
<li><a href="#512-测试指南和组织过程-1-c12s1-2-c8-4-part-2-part-3-14-c7s3">5.1.2.
测试指南和组织过程 [1, c12s1, 2 c8; 4, part 2, part 3; 14*,
c7s3]</a></li>
<li><a href="#513-测试管理和动态测试过程-1-c12-4-part-2-part-3-14-c7s3">5.1.3.
测试管理和动态测试过程 [1, c12; 4, part 2, part 3, 14,
c7s3]</a></li>
<li><a href="#514-测试文档-1-c8s12-14-c7s8-4-part-3">5.1.4. 测试文档 [1,
c8s12; 14, c7s8; 4, part 3]</a></li>
<li><a href="#515-测试团队-1-c16-2-c23s5-4-part-2-part-3">5.1.5. 测试团队 [1,
c16; 2 c23s5; 4, part 2, part 3]</a></li>
</ul></li>
</ul></li>
<li><a href="#524-受控实验和测试执行">5.2.4. 受控实验和测试执行</a></li>
<li><a href="#522-测试设计和实现">5.2.2. 测试设计和实现</a></li>
<li><a href="#525-测试事件报告">5.2.5. 测试事件报告</a></li>
<li><a href="#53-人员配置">5.3. 人员配置</a></li>
<li><a href="#6-开发过程和应用领域中的软件测试">6.
开发过程和应用领域中的软件测试</a></li>
<li><a href="#7-新兴技术的测试与通过新兴技术进行测试">7.
新兴技术的测试与通过新兴技术进行测试</a></li>
<li><ul>
<li><a href="#71-新兴技术的测试">7.1. 新兴技术的测试</a></li>
<li><a href="#72-通过新兴技术进行测试">7.2. 通过新兴技术进行测试</a></li>
</ul></li>
<li><a href="#8-软件测试工具">8. 软件测试工具</a></li>
<li><ul>
<li><a href="#81-测试工具支持和选择">8.1. 测试工具支持和选择</a></li>
</ul></li>
<li><a href="#82-工具类别">8.2. 工具类别</a></li>
<li><a href="#主题与参考材料对照表">主题与参考材料对照表</a></li>
</ul></li>
<li><a href="#2-测试级别-1">2. 测试级别</a></li>
<li><ul>
<li><a href="#21-测试的目标-1">2.1. 测试的目标</a></li>
<li><ul>
<li><a href="#211-单元测试-1">2.1.1. 单元测试</a></li>
<li><a href="#212-集成测试-1">2.1.2. 集成测试</a></li>
<li><a href="#213-系统测试-1">2.1.3. 系统测试</a></li>
<li><a href="#214-验收测试-1">2.1.4. 验收测试</a></li>
</ul></li>
<li><a href="#22-测试的目的">2.2. 测试的目的</a></li>
<li><ul>
<li><a href="#221-符合性测试">2.2.1. 符合性测试</a></li>
<li><a href="#222-合规性测试-1">2.2.2. 合规性测试</a></li>
<li><a href="#223-安装测试-1">2.2.3. 安装测试</a></li>
<li><a href="#224-alpha-和-beta-测试">2.2.4. Alpha 和 Beta 测试</a></li>
<li><a href="#225-回归测试-1">2.2.5. 回归测试</a></li>
<li><a href="#226-优先级测试-1">2.2.6. 优先级测试</a></li>
<li><a href="#227-非功能性测试">2.2.7. 非功能性测试</a></li>
<li><a href="#228-安全测试-1">2.2.8. 安全测试</a></li>
<li><a href="#229-隐私测试-1">2.2.9. 隐私测试</a></li>
<li><a href="#2210-接口和-api-测试">2.2.10. 接口和 API 测试</a></li>
<li><a href="#2211-配置测试">2.2.11. 配置测试</a></li>
<li><a href="#2212-可用性和人机交互测试">2.2.12. 可用性和人机交互测试</a></li>
</ul></li>
</ul></li>
<li><a href="#3-测试技术">3. 测试技术</a></li>
<li><ul>
<li><a href="#31-基于规格说明的技术">3.1. 基于规格说明的技术</a></li>
<li><ul>
<li><a href="#311-等价类划分">3.1.1. 等价类划分</a></li>
<li><a href="#312-边界值分析">3.1.2. 边界值分析</a></li>
<li><a href="#313-语法测试">3.1.3. 语法测试</a></li>
<li><a href="#314-组合测试技术">3.1.4. 组合测试技术</a></li>
<li><a href="#315-决策表">3.1.5. 决策表</a></li>
<li><a href="#316-因果图">3.1.6. 因果图</a></li>
<li><a href="#317-状态转换测试">3.1.7. 状态转换测试</a></li>
<li><a href="#318-场景测试">3.1.8. 场景测试</a></li>
<li><a href="#319-随机测试">3.1.9. 随机测试</a></li>
<li><a href="#3110-基于证据的测试">3.1.10. 基于证据的测试</a></li>
<li><a href="#3111-强制异常">3.1.11. 强制异常</a></li>
</ul></li>
<li><a href="#32-基于结构的测试技术-1">3.2. 基于结构的测试技术</a></li>
<li><ul>
<li><a href="#321-控制流测试">3.2.1. 控制流测试</a></li>
<li><a href="#322-数据流测试">3.2.2. 数据流测试</a></li>
<li><a href="#323-基于结构的测试技术参考模型">3.2.3.
基于结构的测试技术参考模型</a></li>
</ul></li>
<li><a href="#33-基于经验的技术-1">3.3. 基于经验的技术</a></li>
<li><ul>
<li><a href="#331-错误推测">3.3.1. 错误推测</a></li>
<li><a href="#332-探索性测试">3.3.2. 探索性测试</a></li>
<li><a href="#333-其他基于经验的技术">3.3.3. 其他基于经验的技术</a></li>
</ul></li>
<li><a href="#34-基于故障的技术和变异技术">3.4. 基于故障的技术和变异技术</a></li>
<li><a href="#35-基于使用的技术">3.5. 基于使用的技术</a></li>
<li><ul>
<li><a href="#351-操作剖面operational-profile">3.5.1. 操作剖面(Operational
Profile)</a></li>
<li><a href="#352-用户观察启发式方法">3.5.2. 用户观察启发式方法</a></li>
</ul></li>
<li><a href="#36-基于应用特性的技术">3.6. 基于应用特性的技术</a></li>
<li><a href="#37-选择和组合技术">3.7. 选择和组合技术</a></li>
<li><ul>
<li><a href="#371-组合功能性和结构性测试">3.7.1. 组合功能性和结构性测试</a></li>
<li><a href="#372-确定性测试与随机测试">3.7.2. 确定性测试与随机测试</a></li>
</ul></li>
<li><a href="#38-基于衍生知识的技术-1">3.8. 基于衍生知识的技术</a></li>
</ul></li>
<li><a href="#4-测试相关度量">4. 测试相关度量</a></li>
<li><ul>
<li><a href="#41-被测系统的评估">4.1. 被测系统的评估</a></li>
<li><ul>
<li><a href="#411-有助于测试规划和设计的被测系统度量">4.1.1.
有助于测试规划和设计的被测系统度量</a></li>
<li><a href="#412-故障类型分类和统计-1">4.1.2. 故障类型、分类和统计</a></li>
<li><a href="#413-故障密度-1">4.1.3. 故障密度</a></li>
<li><a href="#414-寿命测试可靠性评估-1">4.1.4. 寿命测试、可靠性评估</a></li>
<li><a href="#415-可靠性增长模型-1">4.1.5. 可靠性增长模型</a></li>
</ul></li>
<li><a href="#42-已执行测试的评估-1">4.2. 已执行测试的评估</a></li>
<li><ul>
<li><a href="#421-故障注入-1">4.2.1. 故障注入</a></li>
<li><a href="#422-变异分数">4.2.2. 变异分数</a></li>
<li><a href="#423-不同技术的比较和相对有效性">4.2.3.
不同技术的比较和相对有效性</a></li>
</ul></li>
</ul></li>
<li><a href="#5-测试过程-2">5. 测试过程</a></li>
<li><ul>
<li><a href="#51-实践考虑因素">5.1. 实践考虑因素</a></li>
<li><ul>
<li><a href="#511-态度无我编程egoless-programming">5.1.1. 态度/无我编程(Egoless
Programming)</a></li>
<li><a href="#512-测试指南和组织过程">5.1.2. 测试指南和组织过程</a></li>
<li><a href="#513-测试管理和动态测试过程">5.1.3. 测试管理和动态测试过程</a></li>
<li><a href="#514-测试文档">5.1.4. 测试文档</a></li>
<li><a href="#515-测试团队">5.1.5. 测试团队</a></li>
<li><a href="#516-测试过程度量">5.1.6. 测试过程度量</a></li>
<li><a href="#517-测试监控和控制">5.1.7. 测试监控和控制</a></li>
<li><a href="#518-测试完成">5.1.8. 测试完成</a></li>
<li><a href="#519-测试可复用性">5.1.9. 测试可复用性</a></li>
</ul></li>
<li><a href="#52-测试子过程和活动">5.2. 测试子过程和活动</a></li>
<li><ul>
<li><a href="#521-测试规划过程">5.2.1. 测试规划过程</a></li>
<li><a href="#522-测试设计和实现-1">5.2.2. 测试设计和实现</a></li>
<li><a href="#523-测试环境设置和维护">5.2.3. 测试环境设置和维护</a></li>
<li><a href="#524-受控实验和测试执行-1">5.2.4. 受控实验和测试执行</a></li>
<li><a href="#525-测试事件报告-1">5.2.5. 测试事件报告</a></li>
</ul></li>
<li><a href="#53-人员配备">5.3. 人员配备</a></li>
</ul></li>
<li><a href="#6-开发过程和应用领域中的软件测试-1">6.
开发过程和应用领域中的软件测试</a></li>
<li><ul>
<li><a href="#61-软件开发过程中的测试">6.1. 软件开发过程中的测试</a></li>
<li><ul>
<li><a href="#611-传统过程中的测试">6.1.1. 传统过程中的测试</a></li>
<li><a href="#612-符合左移shift-left运动的测试">6.1.2.
符合左移(Shift-Left)运动的测试</a></li>
</ul></li>
<li><a href="#62-应用领域中的测试">6.2. 应用领域中的测试</a></li>
</ul></li>
<li><a href="#7-新兴技术的测试和通过新兴技术进行测试">7.
新兴技术的测试和通过新兴技术进行测试</a></li>
<li><ul>
<li><a href="#71-新兴技术的测试-1">7.1. 新兴技术的测试</a></li>
<li><a href="#72-通过新兴技术进行测试-1">7.2. 通过新兴技术进行测试</a></li>
</ul></li>
<li><a href="#8-软件测试工具-1">8. 软件测试工具</a></li>
<li><ul>
<li><a href="#81-测试工具支持和选择-1">8.1. 测试工具支持和选择</a></li>
<li><a href="#82-工具类别-1">8.2. 工具类别</a></li>
</ul></li>
<li><a href="#第6章-软件工程运维">第6章 软件工程运维</a></li>
<li><ul>
<li><a href="#引言-3">引言</a></li>
<li><a href="#图61-软件工程运维知识领域主题分解">图6.1
软件工程运维知识领域主题分解</a></li>
<li><a href="#参考文献-5">参考文献</a></li>
<li><a href="#1-软件工程运维基础">1. 软件工程运维基础</a></li>
<li><ul>
<li><a href="#11-软件工程运维的定义-1-c3s333-c6s6412">1.1. 软件工程运维的定义
[1, c3s3.3][3, c6s6.4.12]</a></li>
</ul></li>
<li><a href="#16-性能可靠性和负载均衡">1.6. 性能、可靠性和负载均衡</a></li>
</ul></li>
<li><a href="#2-软件工程运维规划">2. 软件工程运维规划</a></li>
<li><ul>
<li><a href="#21-运维计划和供应商管理">2.1. 运维计划和供应商管理</a></li>
<li><ul>
<li><a href="#211-运维计划">2.1.1. 运维计划</a></li>
<li><a href="#212-供应商管理">2.1.2. 供应商管理</a></li>
</ul></li>
<li><a href="#客户和供应商需要执行的活动">客户和供应商需要执行的活动</a></li>
<li><a href="#对现有服务管理框架和服务的变更">对现有服务管理框架和服务的变更</a></li>
<li><a href="#与相关方的沟通">与相关方的沟通</a></li>
<li><a href="#新的或变更的合同和协议以适应业务需求的变化">新的或变更的合同和协议，以适应业务需求的变化</a></li>
<li><a href="#人员配备和招聘需求">人员配备和招聘需求</a></li>
<li><a href="#技能和培训需求">技能和培训需求</a></li>
<li><a href="#与新服务或变更服务相关的流程度量方法和工具">与新服务或变更服务相关的流程、度量、方法和工具</a></li>
<li><a href="#容量管理">容量管理</a></li>
<li><a href="#财务管理">财务管理</a></li>
<li><a href="#预算和时间表">预算和时间表</a></li>
<li><a href="#服务验收标准">服务验收标准</a></li>
<li><a href="#运营新服务的预期成果以可衡量的术语表示">运营新服务的预期成果，以可衡量的术语表示</a></li>
<li><a href="#24-软件容量管理">2.4. 软件容量管理</a></li>
<li><ul>
<li><a href="#备份与恢复规划">备份与恢复规划</a></li>
</ul></li>
<li><a href="#26-软件和数据安全安全性完整性保护和控制">2.6.
软件和数据安全、安全性、完整性、保护和控制</a></li>
<li><a href="#3-软件工程运维交付">3. 软件工程运维交付</a></li>
<li><ul>
<li><a href="#31-运维测试验证和验收">3.1. 运维测试、验证和验收</a></li>
<li><a href="#32-部署发布工程">3.2. 部署/发布工程</a></li>
</ul></li>
<li><a href="#33-回滚和数据迁移">3.3. 回滚和数据迁移</a></li>
<li><a href="#34-问题解决">3.4. 问题解决</a></li>
<li><a href="#4-软件工程运维控制">4. 软件工程运维控制</a></li>
<li><a href="#41-事件管理">4.1. 事件管理</a></li>
<li><a href="#42-变更管理">4.2. 变更管理</a></li>
<li><a href="#43-监控测量跟踪和审查">4.3. 监控、测量、跟踪和审查</a></li>
<li><a href="#44-运维支持-1-c6-c14s5">4.4. 运维支持 [1, c6, c14s5]</a></li>
<li><ul>
<li><a href="#51-事件和问题预防-2-c7">5.1. 事件和问题预防 [2*, c7]</a></li>
</ul></li>
<li><a href="#45-服务报告-1c6s62">4.5. 服务报告 [1,c6s6.2]</a></li>
<li><ul>
<li><a href="#52-运维风险管理-3-c6s64123c4">5.2. 运维风险管理 [3,
c6s6.4.12.3c4]</a></li>
</ul></li>
<li><a href="#5-实践考虑">5. 实践考虑</a></li>
<li><ul>
<li><a href="#53-软件工程运维自动化-2-c8">5.3. 软件工程运维自动化 [2*, c8]</a></li>
<li><a href="#54-小型组织的软件工程运维">5.4. 小型组织的软件工程运维</a></li>
</ul></li>
</ul></li>
<li><a href="#软件工程运维-1">软件工程运维</a></li>
<li><ul>
<li><a href="#6-软件工程运维工具">6. 软件工程运维工具</a></li>
<li><ul>
<li><a href="#61-容器和虚拟化">6.1. 容器和虚拟化</a></li>
<li><a href="#62-部署-2-c12">6.2. 部署 [2*, c12]</a></li>
<li><a href="#63-自动化测试-2-c10">6.3. 自动化测试 [2*, c10]</a></li>
<li><a href="#64-监控和遥测-2-c14-15">6.4. 监控和遥测 [2*, c14-15]</a></li>
</ul></li>
<li><a href="#主题与参考资料矩阵">主题与参考资料矩阵</a></li>
<li><a href="#参考文献-6">参考文献</a></li>
</ul></li>
<li><a href="#第七章-1">第七章</a></li>
<li><a href="#软件维护-2">软件维护</a></li>
<li><ul>
<li><a href="#引言-4">引言</a></li>
<li><a href="#软件维护主题分解">软件维护主题分解</a></li>
<li><ul>
<li><a href="#1-软件维护基础">1. 软件维护基础</a></li>
</ul></li>
</ul></li>
<li><a href="#软件维护的一系列定义这些定义对于理解这一知识领域至关重要">软件维护的一系列定义，这些定义对于理解这一知识领域至关重要。</a></li>
<li><ul>
<li><a href="#11-定义和术语">1.1. 定义和术语</a></li>
<li><a href="#13-软件维护的必要性">1.3. 软件维护的必要性</a></li>
<li><a href="#14-维护成本占大部分">1.4. 维护成本占大部分</a></li>
<li><a href="#15-软件的演进">1.5. 软件的演进</a></li>
<li><a href="#16-软件维护的类别">1.6. 软件维护的类别</a></li>
</ul></li>
<li><a href="#软件维护-3">软件维护</a></li>
<li><ul>
<li><a href="#质量下降">质量下降</a></li>
<li><a href="#反馈系统">反馈系统</a></li>
<li><a href="#2-软件维护的关键问题">2. 软件维护的关键问题</a></li>
<li><ul>
<li><a href="#21-技术问题">2.1. 技术问题</a></li>
<li><a href="#211-有限理解">2.1.1 有限理解</a></li>
<li><a href="#212-测试">2.1.2 测试</a></li>
</ul></li>
<li><a href="#213-影响分析">2.1.3 影响分析</a></li>
<li><a href="#214-可维护性">2.1.4 可维护性</a></li>
<li><a href="#215-软件维护经济学">2.1.5 软件维护经济学</a></li>
<li><a href="#22-管理问题">2.2. 管理问题</a></li>
<li><ul>
<li><a href="#221-与组织目标的一致性">2.2.1. 与组织目标的一致性</a></li>
<li><a href="#222-人员配置">2.2.2. 人员配置</a></li>
<li><a href="#223-流程">2.2.3. 流程</a></li>
<li><a href="#224-供应商管理">2.2.4. 供应商管理</a></li>
<li><a href="#225-维护的组织方面">2.2.5. 维护的组织方面</a></li>
</ul></li>
<li><a href="#23-软件维护成本">2.3. 软件维护成本</a></li>
<li><ul>
<li><a href="#231-技术债务成本估算">2.3.1. 技术债务成本估算</a></li>
<li><a href="#232-维护成本估算">2.3.2. 维护成本估算</a></li>
</ul></li>
<li><a href="#24-软件维护度量">2.4. 软件维护度量</a></li>
</ul></li>
<li><a href="#软件维护-4">软件维护</a></li>
<li><ul>
<li><a href="#321-支持和监控活动">3.2.1. 支持和监控活动</a></li>
<li><a href="#322-软件维护计划">3.2.2. 软件维护计划</a></li>
<li><a href="#323-配置管理">3.2.3. 配置管理</a></li>
<li><a href="#324-软件质量">3.2.4. 软件质量</a></li>
<li><a href="#4-软件维护技术">4. 软件维护技术</a></li>
<li><ul>
<li><a href="#41-程序理解">4.1. 程序理解</a></li>
<li><a href="#42-软件再工程">4.2. 软件再工程</a></li>
<li><a href="#43-逆向工程">4.3. 逆向工程</a></li>
<li><a href="#44-持续集成交付测试和部署">4.4. 持续集成、交付、测试和部署</a></li>
</ul></li>
</ul></li>
<li><a href="#软件维护-5">软件维护</a></li>
<li><ul>
<li><a href="#45-维护可视化">4.5. 维护可视化</a></li>
<li><a href="#5-软件维护工具">5. 软件维护工具</a></li>
<li><a href="#第08章">第08章</a></li>
</ul></li>
<li><a href="#软件配置管理-2">软件配置管理</a></li>
<li><ul>
<li><a href="#1-scm过程管理">1. SCM过程管理</a></li>
<li><ul>
<li><a href="#11-scm的组织环境">1.1 SCM的组织环境</a></li>
</ul></li>
<li><a href="#12-scm过程的约束和指导">1.2 SCM过程的约束和指导</a></li>
<li><a href="#13-scm规划">1.3 SCM规划</a></li>
<li><ul>
<li><a href="#131-scm组织和职责">1.3.1 SCM组织和职责</a></li>
<li><a href="#132-scm资源和进度">1.3.2 SCM资源和进度</a></li>
</ul></li>
<li><a href="#132-软件配置管理资源和进度">1.3.2 软件配置管理资源和进度</a></li>
<li><a href="#133-工具选择和实施">1.3.3 工具选择和实施</a></li>
<li><a href="#134-供应商分包商控制">1.3.4 供应商/分包商控制</a></li>
<li><a href="#135-接口控制">1.3.5 接口控制</a></li>
<li><a href="#14-软件配置管理计划">1.4 软件配置管理计划</a></li>
<li><a href="#15-软件配置管理监控">1.5 软件配置管理监控</a></li>
<li><a href="#151-软件配置管理度量和测量">1.5.1 软件配置管理度量和测量</a></li>
</ul></li>
<li><a href="#软件配置管理-3">软件配置管理</a></li>
<li><ul>
<li><a href="#152-scm的过程中审计">1.5.2 SCM的过程中审计</a></li>
<li><a href="#2-软件配置识别">2. 软件配置识别</a></li>
<li><ul>
<li><a href="#21-识别要控制的项目">2.1 识别要控制的项目</a></li>
<li><ul>
<li><a href="#211-软件配置">2.1.1 软件配置</a></li>
<li><a href="#212-软件配置项">2.1.2 软件配置项</a></li>
</ul></li>
<li><a href="#22-配置项标识符和属性">2.2 配置项标识符和属性</a></li>
<li><a href="#23-基线识别">2.3 基线识别</a></li>
<li><a href="#25-关系方案定义">2.5 关系方案定义</a></li>
</ul></li>
<li><a href="#24-基线属性">2.4 基线属性</a></li>
<li><a href="#26-软件库">2.6 软件库</a></li>
<li><a href="#3-软件配置变更控制">3. 软件配置变更控制</a></li>
<li><ul>
<li><a href="#31-请求评估和批准软件变更">3.1 请求、评估和批准软件变更</a></li>
</ul></li>
<li><a href="#311-软件配置控制委员会">3.1.1 软件配置控制委员会</a></li>
<li><a href="#312-软件变更请求流程">3.1.2 软件变更请求流程</a></li>
<li><a href="#313-软件变更请求表单定义">3.1.3 软件变更请求表单定义</a></li>
<li><a href="#32-实施软件变更">3.2 实施软件变更</a></li>
</ul></li>
<li><a href="#4-软件配置状态核算">4. 软件配置状态核算</a></li>
<li><ul>
<li><a href="#41-软件配置状态信息">4.1 软件配置状态信息</a></li>
<li><a href="#7-软件配置管理工具">7. 软件配置管理工具</a></li>
<li><a href="#第09章">第09章</a></li>
<li><a href="#软件工程管理主题分解">软件工程管理主题分解</a></li>
<li><a href="#11-需求的确定和协商-3-c3">1.1. 需求的确定和协商 [3*, c3]</a></li>
<li><a href="#12-可行性分析-4-c5">1.2. 可行性分析 [4*, c5]</a></li>
</ul></li>
<li><a href="#软件工程管理-2">软件工程管理</a></li>
<li><ul>
<li><a href="#1-启动和范围定义">1. 启动和范围定义</a></li>
<li><ul>
<li><a href="#13-需求审查和修订流程-3-c3">1.3. 需求审查和修订流程 [3*, c3]</a></li>
</ul></li>
<li><a href="#2-软件项目规划">2. 软件项目规划</a></li>
<li><ul>
<li><a href="#21-流程规划">2.1. 流程规划</a></li>
<li><a href="#22-确定可交付成果-3-c4-c5-c6">2.2. 确定可交付成果 [3*, c4, c5,
c6]</a></li>
<li><a href="#24-资源分配-3-c5-c10-c11">2.4. 资源分配 [3*, c5, c10, c11]</a></li>
<li><a href="#26-质量管理-3-c4-4-c2">2.6. 质量管理 [3*, c4] [4*, c2]</a></li>
<li><a href="#27-计划管理-3-c4">2.7. 计划管理 [3*, c4]</a></li>
</ul></li>
<li><a href="#6-软件工程测量">6. 软件工程测量</a></li>
<li><a href="#主题与参考资料对照表-1">主题与参考资料对照表</a></li>
<li><a href="#延伸阅读-2">延伸阅读</a></li>
<li><a href="#参考文献-7">参考文献</a></li>
<li><a href="#第10章">第10章</a></li>
<li><ul>
<li><a href="#11-引言-1c513">1.1 引言 [1,c5],[13]</a></li>
</ul></li>
<li><a href="#25-开发生命周期模型及其工程维度-1">2.5.
开发生命周期模型及其工程维度</a></li>
<li><a href="#软件工程过程-10-7">软件工程过程 10-7</a></li>
<li><ul>
<li><a href="#26-slcp的管理-14">2.6. SLCP的管理 [14]</a></li>
<li><a href="#27-软件工程过程管理-1c52">2.7. 软件工程过程管理 [1*,c5][2]</a></li>
<li><a href="#29-实际考虑因素-8c2-3">2.9. 实际考虑因素 [8*,c2-3]</a></li>
</ul></li>
<li><a href="#28-软件生命周期适配-1">2.8. 软件生命周期适配</a></li>
<li><a href="#210-软件过程基础设施工具和方法">2.10.
软件过程基础设施、工具和方法</a></li>
<li><a href="#211-软件工程过程监控及其与软件产品的关系-1">2.11.
软件工程过程监控及其与软件产品的关系</a></li>
</ul></li>
<li><a href="#3-软件过程评估和改进-1">3. 软件过程评估和改进</a></li>
<li><ul>
<li><a href="#31-软件过程评估和改进概述-1">3.1. 软件过程评估和改进概述</a></li>
<li><a href="#参考文献-8">参考文献</a></li>
<li><a href="#第11章-1">第11章</a></li>
<li><a href="#软件工程模型和方法-2">软件工程模型和方法</a></li>
<li><ul>
<li><a href="#缩略语-2">缩略语</a></li>
<li><a href="#软件工程模型和方法主题分类">软件工程模型和方法主题分类</a></li>
<li><a href="#简介">简介</a></li>
<li><a href="#1-建模-1">1. 建模</a></li>
</ul></li>
<li><a href="#111-建模原则">11.1 建模原则</a></li>
<li><a href="#112-模型的属性和表达">11.2 模型的属性和表达</a></li>
<li><ul>
<li><a href="#33-正确性分析-5-pp8-11">3.3. 正确性分析 [5*, pp8-11]</a></li>
<li><a href="#35-交互分析-2-c10-c11-3-c29s11-c29s5-4-c5">3.5. 交互分析 [2,
c10, c11, 3, c29s1.1, c29s5, 4*, c5]</a></li>
</ul></li>
<li><a href="#4-软件工程方法-1">4. 软件工程方法</a></li>
<li><ul>
<li><a href="#41-启发式方法-1-c13-c15-c16-3-c2s22-c7s1-c5-8-ppxiii-xvii-9-c2s2-11-c1-12-c1s1-19-pp220-242">4.1.
启发式方法 [1, c13, c15, c16, 3, c2s2.2, c7s1, c5, 8,
pp.xiii-xvii 9, c2s2, 11, c1, 12, c1s1, 19, pp.220-242]</a></li>
</ul></li>
<li><a href="#42-形式化方法-1">4.2. 形式化方法</a></li>
<li><a href="#43-原型方法">4.3. 原型方法</a></li>
</ul></li>
<li><a href="#基于计划的软件工程方法与轻量级发布周期">基于计划的软件工程方法与轻量级发布周期</a></li>
<li><ul>
<li><a href="#主题与参考资料矩阵-1">主题与参考资料矩阵</a></li>
<li><ul>
<li><a href="#1-建模-2">1. 建模</a></li>
<li><a href="#2-模型类型-1">2. 模型类型</a></li>
<li><a href="#3-模型分析-1">3. 模型分析</a></li>
<li><a href="#4-软件工程方法-2">4. 软件工程方法</a></li>
</ul></li>
<li><a href="#参考文献-9">参考文献</a></li>
</ul></li>
<li><a href="#第12章-1">第12章</a></li>
<li><a href="#软件质量-3">软件质量</a></li>
<li><ul>
<li><a href="#引言-5">引言</a></li>
</ul></li>
<li><a href="#软件质量-4">软件质量</a></li>
<li><ul>
<li><a href="#软件质量主题分解">软件质量主题分解</a></li>
<li><ul>
<li><a href="#1-软件质量基础-1">1. 软件质量基础</a></li>
<li><ul>
<li><a href="#11-软件工程文化和道德规范-1">1.1. 软件工程文化和道德规范</a></li>
<li><a href="#12-质量成本">1.2. 质量成本</a></li>
</ul></li>
</ul></li>
<li><a href="#12-质量的价值与成本-1-c2s2">1.2. 质量的价值与成本 [1*, c2s2]</a></li>
<li><a href="#13-标准模型和认证-1-c4-7-c24s2">1.3. 标准、模型和认证 [1*, c4] [7,
c24s2]</a></li>
<li><a href="#14-软件可靠性和完整性">1.4. 软件可靠性和完整性</a></li>
</ul></li>
<li><a href="#级别-1-c4s8-c7s33-11-保证案例">级别 [1*, c4s8, c7s3.3] [11]
保证案例</a></li>
<li><ul>
<li><a href="#141-可依赖性-7-c10">1.4.1. 可依赖性 [7, c10]</a></li>
<li><a href="#142-软件完整性级别-1-c4s8-c7s32-11">1.4.2. 软件完整性级别 [1*,
c4s8, c7s3.2] [11]</a></li>
<li><a href="#2-软件质量管理过程-1">2. 软件质量管理过程</a></li>
<li><a href="#21-软件质量改进-1">2.1 软件质量改进</a></li>
<li><a href="#22-规划质量管理-1">2.2 规划质量管理</a></li>
<li><a href="#23-评估质量管理-1">2.3 评估质量管理</a></li>
<li><a href="#231-软件质量测量">2.3.1. 软件质量测量</a></li>
<li><a href="#24-执行纠正和预防措施-1">2.4. 执行纠正和预防措施</a></li>
<li><ul>
<li><a href="#241-缺陷特征分析">2.4.1. 缺陷特征分析</a></li>
</ul></li>
<li><a href="#3-软件质量保证流程">3. 软件质量保证流程</a></li>
<li><ul>
<li><a href="#31-准备质量保证-1">3.1. 准备质量保证</a></li>
</ul></li>
<li><a href="#32-执行过程保证-1">3.2. 执行过程保证</a></li>
<li><a href="#33-执行产品保证-1">3.3. 执行产品保证</a></li>
<li><a href="#34-vv和测试-1">3.4. V&amp;V和测试</a></li>
<li><a href="#标准-10122016-11">标准 1012:2016 [11]</a></li>
<li><ul>
<li><a href="#341-静态分析技术-1">3.4.1. 静态分析技术</a></li>
<li><a href="#342-动态分析技术-1">3.4.2. 动态分析技术</a></li>
<li><a href="#343-形式化分析技术-7-c10s5">3.4.3. 形式化分析技术 [7*, c10s5]</a></li>
<li><a href="#344-软件质量控制和测试-1-c7s10">3.4.4. 软件质量控制和测试 [1*,
c7s10]</a></li>
<li><a href="#345-技术评审和审计-1-c5-c6-23-s4-s5">3.4.5. 技术评审和审计 [1*, c5,
c6] [23, s4, s5]</a></li>
</ul></li>
</ul></li>
<li><a href="#不同类型的工作产品评审">不同类型的工作产品评审</a></li>
<li><ul>
<li><a href="#4-软件质量工具-1">4. 软件质量工具</a></li>
<li><a href="#主题与参考资料对照矩阵-1">主题与参考资料对照矩阵</a></li>
<li><a href="#11-软件工程文化与伦理">1.1. 软件工程文化与伦理</a></li>
<li><a href="#12-质量的价值与成本">1.2. 质量的价值与成本</a></li>
<li><a href="#13-标准模型与认证">1.3. 标准、模型与认证</a></li>
<li><a href="#14-软件可靠性与完整性级别">1.4. 软件可靠性与完整性级别</a></li>
<li><ul>
<li><a href="#21-软件质量改进-2">2.1. 软件质量改进</a></li>
<li><a href="#22-质量管理规划">2.2. 质量管理规划</a></li>
<li><a href="#23-质量管理评估">2.3. 质量管理评估</a></li>
<li><a href="#24-执行纠正与预防措施">2.4. 执行纠正与预防措施</a></li>
<li><a href="#31-质量保证准备">3.1. 质量保证准备</a></li>
<li><a href="#32-执行过程保证-2">3.2. 执行过程保证</a></li>
<li><a href="#33-执行产品保证-2">3.3. 执行产品保证</a></li>
<li><a href="#34-验证确认与测试">3.4. 验证、确认与测试</a></li>
</ul></li>
<li><a href="#第13章-1">第13章</a></li>
</ul></li>
<li><a href="#软件安全-2">软件安全</a></li>
<li><ul>
<li><a href="#2-安全管理与组织">2. 安全管理与组织</a></li>
<li><a href="#3-软件安全工程与过程">3. 软件安全工程与过程</a></li>
<li><a href="#4-软件系统的安全工程-1-c1-c33-c1-c3">4. 软件系统的安全工程 [1*,
c1, c3][3*, c1, c3]</a></li>
<li><a href="#42-安全设计-1">4.2. 安全设计</a></li>
<li><ul>
<li><a href="#43-安全模式-1c41920-21">4.3. 安全模式 [1*,c4][19][20, 21]</a></li>
<li><a href="#44-安全构建-1c53c20c3122-23-24">4.4. 安全构建
[1*,c5][3*,c20,c31][22, 23, 24]</a></li>
<li><a href="#45-安全测试-1c52c73c24c3126-27">4.5. 安全测试
[1*,c5][2,c7][3*,c24,c31][26, 27]</a></li>
<li><a href="#46-漏洞管理-1c53c242829-30">4.6. 漏洞管理 [1*,c5][3*,c24][28,29,
30]</a></li>
</ul></li>
<li><a href="#5-软件安全工具-1">5. 软件安全工具</a></li>
<li><ul>
<li><a href="#51-安全漏洞检查工具-1c625">5.1. 安全漏洞检查工具 [1*,c6][25]</a></li>
<li><a href="#52-渗透测试工具-2c4">5.2. 渗透测试工具 [2,c4]</a></li>
</ul></li>
<li><a href="#6-领域特定软件安全">6. 领域特定软件安全</a></li>
<li><ul>
<li><a href="#61-容器和云安全-31-c1-c3">6.1. 容器和云安全 [31*, c1-c3]</a></li>
<li><a href="#62-物联网软件安全-3233">6.2. 物联网软件安全 [32,33]</a></li>
<li><a href="#63-基于机器学习应用的安全-39c8">6.3. 基于机器学习应用的安全
[39,c8]</a></li>
</ul></li>
<li><a href="#主题与参考资料对照表-2">主题与参考资料对照表</a></li>
<li><a href="#进一步阅读">进一步阅读</a></li>
<li><a href="#软件安全-3">软件安全</a></li>
</ul></li>
<li><a href="#第十四章">第十四章</a></li>
<li><a href="#软件工程专业实践-1">软件工程专业实践</a></li>
<li><ul>
<li><a href="#引言-6">引言</a></li>
<li><a href="#软件工程专业实践的主题分类">软件工程专业实践的主题分类</a></li>
<li><ul>
<li><a href="#专业精神professionalism">专业精神（Professionalism）</a></li>
<li><a href="#团队动力学和心理学group-dynamics-and-psychology">团队动力学和心理学（Group
Dynamics and Psychology）</a></li>
<li><a href="#沟通技能communication-skills">沟通技能（Communication
Skills）</a></li>
</ul></li>
</ul></li>
<li><a href="#软件工程专业实践-2">软件工程专业实践</a></li>
<li><ul>
<li><a href="#1-专业素养">1. 专业素养</a></li>
<li><ul>
<li><a href="#11-认证资格认定和执业许可">1.1. 认证、资格认定和执业许可</a></li>
<li><ul>
<li><a href="#111-认证accreditation">1.1.1. 认证(Accreditation)</a></li>
<li><a href="#112-资格认定和资质认证">1.1.2. 资格认定和资质认证</a></li>
<li><a href="#113-执业许可licensing">1.1.3. 执业许可(Licensing)</a></li>
</ul></li>
<li><a href="#12-职业道德和专业行为准则">1.2. 职业道德和专业行为准则</a></li>
<li><a href="#13-专业协会的性质和作用-1">1.3. 专业协会的性质和作用</a></li>
</ul></li>
</ul></li>
<li><a href="#道德准则和职业行为规范">道德准则和职业行为规范</a></li>
<li><ul>
<li><a href="#专业社团">专业社团</a></li>
<li><a href="#14-软件工程标准的性质和作用-1">1.4. 软件工程标准的性质和作用</a></li>
<li><a href="#15-软件的经济影响-1">1.5. 软件的经济影响</a></li>
<li><a href="#16-雇佣合同-1">1.6. 雇佣合同</a></li>
</ul></li>
<li><a href="#工作并转化为更高的利润或更有效的组织">工作并转化为更高的利润或更有效的组织</a></li>
<li><ul>
<li><a href="#16-swebok-指南-v40a">1.6 SWEBOK® 指南 V4.0a</a></li>
<li><a href="#17-法律问题-1">1.7 法律问题</a></li>
<li><ul>
<li><a href="#171-标准-1">1.7.1 标准</a></li>
<li><a href="#172-商标-1">1.7.2 商标</a></li>
<li><a href="#173-专利-1">1.7.3 专利</a></li>
<li><a href="#174-版权-1">1.7.4 版权</a></li>
<li><a href="#175-商业秘密-1">1.7.5 商业秘密</a></li>
</ul></li>
<li><a href="#软件工程专业实践-14-7">软件工程专业实践 14-7</a></li>
<li><ul>
<li><a href="#176-专业责任">1.7.6 专业责任</a></li>
<li><a href="#178-贸易合规-1">1.7.8 贸易合规</a></li>
</ul></li>
<li><a href="#177-法律要求-1">1.7.7. 法律要求</a></li>
<li><a href="#179-网络犯罪-1">1.7.9. 网络犯罪</a></li>
<li><a href="#1710-数据隐私-1">1.7.10. 数据隐私</a></li>
<li><a href="#软件工程师应提供的信息">软件工程师应提供的信息</a></li>
<li><a href="#2-群体动力学与心理学">2. 群体动力学与心理学</a></li>
<li><a href="#2-个体认知过程如何影响问题解决与问题分解">2.
个体认知过程如何影响问题解决与问题分解</a></li>
<li><ul>
<li><a href="#24-与利益相关者互动-4">2.4. 与利益相关者互动 [4*]</a></li>
<li><a href="#25-处理不确定性和模糊性">2.5. 处理不确定性和模糊性</a></li>
<li><a href="#26-处理公平性多样性和包容性">2.6. 处理公平性、多样性和包容性</a></li>
</ul></li>
<li><a href="#3-沟通技能">3. 沟通技能</a></li>
</ul></li>
<li><a href="#第15章-软件工程经济学">第15章 软件工程经济学</a></li>
<li><ul>
<li><a href="#缩略词">缩略词</a></li>
<li><a href="#引言-7">引言</a></li>
<li><a href="#1-专业素养-1">1. 专业素养</a></li>
<li><ul>
<li><a href="#11-认证资格认定和许可">1.1. 认证、资格认定和许可</a></li>
<li><a href="#12-道德准则和职业行为">1.2. 道德准则和职业行为</a></li>
<li><a href="#13-专业协会的性质和作用-2">1.3. 专业协会的性质和作用</a></li>
<li><a href="#14-软件工程标准的性质和作用-2">1.4. 软件工程标准的性质和作用</a></li>
<li><a href="#15-软件的经济影响-2">1.5. 软件的经济影响</a></li>
<li><a href="#16-雇佣合同-2">1.6. 雇佣合同</a></li>
<li><a href="#17-法律问题-2">1.7. 法律问题</a></li>
<li><a href="#18-文档-1">1.8. 文档</a></li>
<li><a href="#19-权衡分析trade-off-analysis">1.9. 权衡分析(Trade-Off
Analysis)</a></li>
</ul></li>
<li><a href="#2-群体动力学和心理学-1">2. 群体动力学和心理学</a></li>
<li><ul>
<li><a href="#21-团队小组工作的动力学">2.1. 团队/小组工作的动力学</a></li>
<li><a href="#22-个体认知-1">2.2. 个体认知</a></li>
<li><a href="#23-处理问题复杂性-1">2.3. 处理问题复杂性</a></li>
<li><a href="#24-与利益相关者互动">2.4. 与利益相关者互动</a></li>
<li><a href="#25-处理不确定性和模糊性-1">2.5. 处理不确定性和模糊性</a></li>
<li><a href="#26-处理公平多样性和包容性">2.6. 处理公平、多样性和包容性</a></li>
</ul></li>
<li><a href="#3-沟通技能-1">3. 沟通技能</a></li>
<li><ul>
<li><a href="#31-阅读理解和总结">3.1. 阅读、理解和总结</a></li>
<li><a href="#32-写作">3.2. 写作</a></li>
<li><a href="#33-团队和小组沟通">3.3. 团队和小组沟通</a></li>
<li><a href="#34-演讲技能">3.4. 演讲技能</a></li>
</ul></li>
<li><a href="#进一步阅读-1">进一步阅读</a></li>
<li><a href="#参考文献-10">参考文献</a></li>
</ul></li>
<li><a href="#软件工程经济学-1">软件工程经济学</a></li>
<li><ul>
<li><a href="#软件工程经济学主题分解">软件工程经济学主题分解</a></li>
<li><a href="#1-软件工程经济学基础概念">1. 软件工程经济学基础概念</a></li>
<li><ul>
<li><a href="#11-方案-3-c3pp23-24">1.1. 方案 [3*, c3pp23-24]</a></li>
<li><a href="#12-现金流-3-c3pp24-32">1.2. 现金流 [3*, c3pp24-32]</a></li>
</ul></li>
<li><a href="#26-选择首选方案">2.6. 选择首选方案</a></li>
<li><a href="#27-监控所选方案的性能">2.7. 监控所选方案的性能</a></li>
<li><a href="#3-营利性决策">3. 营利性决策</a></li>
<li><a href="#31-最低可接受收益率">3.1. 最低可接受收益率</a></li>
<li><a href="#32-经济寿命">3.2. 经济寿命</a></li>
<li><a href="#33-规划期限">3.3. 规划期限</a></li>
<li><a href="#34-替换决策">3.4. 替换决策</a></li>
<li><a href="#35-退役决策">3.5. 退役决策</a></li>
<li><a href="#36-高级盈利决策考虑因素">3.6. 高级盈利决策考虑因素</a></li>
<li><a href="#4-非营利决策">4. 非营利决策</a></li>
<li><ul>
<li><a href="#41-效益-成本分析">4.1. 效益-成本分析</a></li>
<li><a href="#42-成本效益分析">4.2. 成本效益分析</a></li>
</ul></li>
<li><a href="#5-现值经济决策">5. 现值经济决策</a></li>
<li><ul>
<li><a href="#51-盈亏平衡分析">5.1. 盈亏平衡分析</a></li>
<li><a href="#52-优化分析">5.2. 优化分析</a></li>
</ul></li>
<li><a href="#6-多属性决策">6. 多属性决策</a></li>
<li><ul>
<li><a href="#62-非补偿技术">6.2. 非补偿技术</a></li>
</ul></li>
<li><a href="#7-识别和描述无形资产">7. 识别和描述无形资产</a></li>
<li><a href="#7-无形资产">7. 无形资产</a></li>
</ul></li>
<li><a href="#与每个gia相关的无形资产">与每个GIA相关的无形资产</a></li>
<li><ul>
<li><a href="#75-无形资产特征化">7.5. 无形资产特征化</a></li>
<li><ul>
<li><a href="#质量定量评估">质量定量评估</a></li>
<li><a href="#影响定量评估">影响定量评估</a></li>
<li><a href="#线性值计算">线性值计算</a></li>
</ul></li>
<li><a href="#9-实践考虑">9. 实践考虑</a></li>
<li><a href="#10-相关概念">10. 相关概念</a></li>
</ul></li>
<li><a href="#软件工程经济学-2">软件工程经济学</a></li>
<li><ul>
<li><a href="#103-财务">10.3. 财务</a></li>
<li><a href="#104-控制">10.4. 控制</a></li>
<li><a href="#105-效率和有效性">10.5. 效率和有效性</a></li>
<li><a href="#106-生产力">10.6. 生产力</a></li>
<li><a href="#107-产品">10.7. 产品</a></li>
<li><a href="#108-项目">10.8. 项目</a></li>
<li><a href="#109-计划">10.9. 计划</a></li>
</ul></li>
<li><a href="#软件工程经济学-3">软件工程经济学</a></li>
<li><ul>
<li><a href="#1010-项目组合">10.10. 项目组合</a></li>
<li><a href="#1011-产品生命周期">10.11. 产品生命周期</a></li>
<li><a href="#1012-项目生命周期">10.12. 项目生命周期</a></li>
<li><a href="#1013-价格和定价">10.13. 价格和定价</a></li>
<li><a href="#1014-优先级排序">10.14. 优先级排序</a></li>
</ul></li>
<li><a href="#基础知识">基础知识</a></li>
<li><ul>
<li><a href="#11-提案">1.1. 提案</a></li>
<li><a href="#12-现金流">1.2. 现金流</a></li>
<li><a href="#13-货币的时间价值">1.3. 货币的时间价值</a></li>
<li><a href="#14-等价性">1.4. 等价性</a></li>
<li><a href="#15-比较基础">1.5. 比较基础</a></li>
<li><a href="#16-备选方案">1.6. 备选方案</a></li>
<li><a href="#17-无形资产">1.7. 无形资产</a></li>
<li><a href="#18-商业模式">1.8. 商业模式</a></li>
</ul></li>
<li><a href="#2-工程决策制定过程">2. 工程决策制定过程</a></li>
<li><ul>
<li><a href="#21-流程概述">2.1. 流程概述</a></li>
<li><a href="#22-理解真正的问题">2.2. 理解真正的问题</a></li>
<li><a href="#23-识别所有合理的技术可行解决方案">2.3.
识别所有合理的技术可行解决方案</a></li>
<li><a href="#24-定义选择标准">2.4. 定义选择标准</a></li>
<li><a href="#25-根据选择标准评估每个备选方案">2.5.
根据选择标准评估每个备选方案</a></li>
<li><a href="#26-选择首选备选方案">2.6. 选择首选备选方案</a></li>
<li><a href="#27-监控所选备选方案的性能">2.7. 监控所选备选方案的性能</a></li>
</ul></li>
<li><a href="#3-营利性决策制定">3. 营利性决策制定</a></li>
<li><ul>
<li><a href="#31-最低可接受回报率">3.1. 最低可接受回报率</a></li>
<li><a href="#32-经济寿命-1">3.2. 经济寿命</a></li>
<li><a href="#33-规划期限-1">3.3. 规划期限</a></li>
<li><a href="#34-替换决策-1">3.4. 替换决策</a></li>
<li><a href="#35-退役决策-1">3.5. 退役决策</a></li>
<li><a href="#36-高级营利性决策考虑因素">3.6. 高级营利性决策考虑因素</a></li>
</ul></li>
<li><a href="#4-非营利性决策制定">4. 非营利性决策制定</a></li>
<li><ul>
<li><a href="#41-效益成本分析">4.1. 效益成本分析</a></li>
<li><a href="#42-成本效益分析-1">4.2. 成本效益分析</a></li>
</ul></li>
<li><a href="#5-当前经济决策制定">5. 当前经济决策制定</a></li>
<li><ul>
<li><a href="#51-盈亏平衡分析-1">5.1. 盈亏平衡分析</a></li>
<li><a href="#52-优化分析-1">5.2. 优化分析</a></li>
</ul></li>
<li><a href="#6-多属性决策制定">6. 多属性决策制定</a></li>
<li><ul>
<li><a href="#61-补偿性技术">6.1. 补偿性技术</a></li>
<li><a href="#62-非补偿性技术">6.2. 非补偿性技术</a></li>
</ul></li>
<li><a href="#7-识别和描述无形资产-1">7. 识别和描述无形资产</a></li>
<li><ul>
<li><a href="#71-识别流程并定义业务目标">7.1. 识别流程并定义业务目标</a></li>
<li><a href="#72-识别与业务目标相关的无形资产">7.2.
识别与业务目标相关的无形资产</a></li>
<li><a href="#73-识别支持无形资产的软件产品">7.3. 识别支持无形资产的软件产品</a></li>
<li><a href="#74-定义和衡量指标">7.4. 定义和衡量指标</a></li>
<li><a href="#75-无形资产描述">7.5. 无形资产描述</a></li>
<li><a href="#76-将特定无形资产与业务模式关联">7.6.
将特定无形资产与业务模式关联</a></li>
<li><a href="#77-决策制定">7.7. 决策制定</a></li>
</ul></li>
<li><a href="#8-估算">8. 估算</a></li>
<li><ul>
<li><a href="#81-专家判断">8.1. 专家判断</a></li>
<li><a href="#82-类比法">8.2. 类比法</a></li>
<li><a href="#83-分解法">8.3. 分解法</a></li>
<li><a href="#84-参数法">8.4. 参数法</a></li>
<li><a href="#85-多重估算">8.5. 多重估算</a></li>
</ul></li>
<li><a href="#9-实际考虑因素">9. 实际考虑因素</a></li>
<li><ul>
<li><a href="#91-商业案例">9.1. 商业案例</a></li>
<li><a href="#92-多货币分析">9.2. 多货币分析</a></li>
<li><a href="#93-系统思维">9.3. 系统思维</a></li>
</ul></li>
<li><a href="#10-相关概念-1">10. 相关概念</a></li>
<li><ul>
<li><a href="#101-会计">10.1. 会计</a></li>
<li><a href="#102-成本和成本计算">10.2. 成本和成本计算</a></li>
<li><a href="#103-金融">10.3. 金融</a></li>
<li><a href="#104-控制-1">10.4. 控制</a></li>
<li><a href="#105-效率和有效性-1">10.5. 效率和有效性</a></li>
<li><a href="#106-生产力-1">10.6. 生产力</a></li>
<li><a href="#107-产品或服务">10.7. 产品或服务</a></li>
<li><a href="#108-项目-1">10.8. 项目</a></li>
<li><a href="#109-计划-1">10.9. 计划</a></li>
<li><a href="#1010-投资组合">10.10. 投资组合</a></li>
<li><a href="#1011-产品生命周期-1">10.11. 产品生命周期</a></li>
<li><a href="#1012-项目生命周期-1">10.12. 项目生命周期</a></li>
<li><a href="#1013-价格和定价-1">10.13. 价格和定价</a></li>
<li><a href="#1014-优先级排序-1">10.14. 优先级排序</a></li>
</ul></li>
<li><a href="#延伸阅读-3">延伸阅读</a></li>
<li><a href="#参考文献-11">参考文献</a></li>
<li><ul>
<li><a href="#第16章-1">第16章</a></li>
<li><a href="#计算基础-1">计算基础</a></li>
</ul></li>
<li><a href="#计算基础-2">计算基础</a></li>
<li><ul>
<li><a href="#基本概念">基本概念</a></li>
<li><ul>
<li><a href="#缩写词表">缩写词表</a></li>
</ul></li>
<li><a href="#swebok-指南-v40a">SWEBOK® 指南 V4.0a</a></li>
<li><ul>
<li><a href="#计算基础-3">计算基础</a></li>
<li><ul>
<li><a href="#知识领域主题分解">知识领域主题分解</a></li>
</ul></li>
</ul></li>
<li><a href="#引言-8">引言</a></li>
<li><a href="#计算基础知识领域主题分解">计算基础知识领域主题分解</a></li>
<li><ul>
<li><a href="#1-系统或解决方案的基本概念-6-c10">1. 系统或解决方案的基本概念 [6*,
C10]</a></li>
<li><ul>
<li><a href="#21-计算机架构-8-c11">2.1 计算机架构 [8*, C1.1]</a></li>
</ul></li>
</ul></li>
<li><a href="#2-计算机架构与组织-6-c6">2. 计算机架构与组织 [6*,
C6]</a></li>
<li><ul>
<li><a href="#22-计算机架构类型-8-c414-c5">2.2. 计算机架构类型 [8*, C4.14,
C5]</a></li>
<li><ul>
<li><a href="#221-冯诺依曼架构-8-c19">2.2.1. 冯·诺依曼架构 [8*, C1.9]</a></li>
<li><a href="#222-哈佛架构-20">2.2.2. 哈佛架构 [20*]</a></li>
<li><a href="#223-指令集架构-8-c483">2.2.3. 指令集架构 [8*, C4.8.3]</a></li>
<li><a href="#224-弗林架构或分类法-8-c93">2.2.4. 弗林架构或分类法 [8*, C9.3]</a></li>
</ul></li>
</ul></li>
<li><a href="#23-微架构或计算机组成-8-c4">2.3 微架构或计算机组成 [8*, C4]</a></li>
<li><ul>
<li><a href="#231-算术逻辑单元-8-c12">2.3.1. 算术逻辑单元 [8*, C1.2]</a></li>
<li><a href="#234-控制单元-8-c42">2.3.4. 控制单元 [8*, C4.2]</a></li>
<li><a href="#232-内存单元-8-c6">2.3.2. 内存单元 [8*, C6]</a></li>
</ul></li>
<li><a href="#3-数据结构和算法-8-c2-18-c10-part-v">3. 数据结构和算法 [8*, C2]
[18*, C10 Part V]</a></li>
<li><ul>
<li><a href="#233-输入输出设备-8-c7">2.3.3. 输入/输出设备 [8*, C7]</a></li>
</ul></li>
</ul></li>
<li><a href="#算法的常用属性">算法的常用属性</a></li>
<li><ul>
<li><a href="#34-算法复杂度-5-s1-s3-s4-s5-s6-s7-s11-s12">3.4. 算法复杂度 [5*, S1,
S3, S4, S5, S6, S7, S11, S12]</a></li>
<li><a href="#35-复杂度的度量-5-s11-s3-s4-s5-s6-s111-s121">3.5. 复杂度的度量
[5*, S1.1, S3, S4, S5, S6, S11.1, S12.1]</a></li>
<li><a href="#36-算法设计-18-part-iv-part-vi">3.6. 算法设计 [18*, Part IV, Part
VI]</a></li>
<li><a href="#37-排序技术-18-c6-c9">3.7. 排序技术 [18*, C6-C9]</a></li>
<li><a href="#38-搜索技术">3.8. 搜索技术</a></li>
<li><a href="#39-哈希">3.9. 哈希</a></li>
<li><a href="#4-编程基础和语言">4. 编程基础和语言</a></li>
<li><ul>
<li><a href="#41-编程语言类型">4.1. 编程语言类型</a></li>
<li><a href="#42-编程语法语义类型系统">4.2. 编程语法、语义、类型系统</a></li>
<li><a href="#43-子程序和协程">4.3. 子程序和协程</a></li>
</ul></li>
<li><a href="#44-面向对象编程-4-c65">4.4. 面向对象编程 [4*, C6.5]</a></li>
<li><a href="#45-分布式编程和并行编程-4-c66">4.5. 分布式编程和并行编程 [4*,
C6.6]</a></li>
<li><a href="#47-标准和指南-3-c285-c315">4.7. 标准和指南 [3*, C28.5,
C31.5]</a></li>
<li><a href="#5-操作系统-19">5. 操作系统 [19*]</a></li>
<li><ul>
<li><a href="#52-内存管理-19-c3">5.2. 内存管理 [19*, C3]</a></li>
<li><a href="#53-设备管理">5.3. 设备管理</a></li>
<li><a href="#54-信息管理-19-c4">5.4. 信息管理 [19*, C4]</a></li>
</ul></li>
<li><a href="#53-设备管理-19-c5">5.3. 设备管理 [19*, C5]</a></li>
<li><a href="#55-网络管理-4-c41">5.5. 网络管理 [4*, C4.1]</a></li>
<li><a href="#6-数据库管理">6. 数据库管理</a></li>
<li><ul>
<li><a href="#61-模式-22-c214">6.1. 模式 [22*, C2.1.4]</a></li>
<li><a href="#62-数据模型和存储模型-22-c23">6.2. 数据模型和存储模型 [22*,
C2.3]</a></li>
</ul></li>
<li><a href="#63-数据库管理系统-22-c13">6.3. 数据库管理系统 [22*, C1.3]</a></li>
<li><a href="#64-关系数据库管理系统和规范化-22-c4">6.4.
关系数据库管理系统和规范化 [22*, C4]</a></li>
<li><a href="#65-结构化查询语言-22-c6-c7-c8">6.5. 结构化查询语言 [22*, C6, C7,
C8]</a></li>
<li><a href="#标准化范式">标准化范式</a></li>
<li><ul>
<li><a href="#vii-第六范式或域键范式-6-nfdknf">vii. 第六范式或域/键范式 (6
NF/DKNF)</a></li>
<li><a href="#66-数据挖掘和数据仓库">6.6. 数据挖掘和数据仓库</a></li>
<li><a href="#67-数据库备份和恢复">6.7. 数据库备份和恢复</a></li>
</ul></li>
<li><a href="#7-计算机网络和通信">7. 计算机网络和通信</a></li>
<li><ul>
<li><a href="#71-计算机网络的类型">7.1. 计算机网络的类型</a></li>
<li><a href="#72-网络的分层架构">7.2. 网络的分层架构</a></li>
</ul></li>
<li><a href="#73-开放系统互连模型-24-c15">7.3. 开放系统互连模型 [24*, C1.5]</a></li>
<li><a href="#74-封装与解封装-24-c152">7.4. 封装与解封装 [24*, C1.5.2]</a></li>
<li><a href="#75-应用层协议-24-c2">7.5. 应用层协议 [24*, C2]</a></li>
<li><a href="#76-可靠和高效网络的设计技术-24-c15">7.6. 可靠和高效网络的设计技术
[24*, C1.5]</a></li>
<li><a href="#77-互联网协议套件-24-c3">7.7. 互联网协议套件 [24*, C3]</a></li>
<li><a href="#78-无线和移动网络-24-c7">7.8. 无线和移动网络 [24*, C7]</a></li>
<li><a href="#无线网络类型">无线网络类型</a></li>
<li><a href="#79-安全和漏洞-24-c9">7.9. 安全和漏洞 [24*, C9]</a></li>
</ul></li>
<li><a href="#8-用户和开发者人因">8. 用户和开发者人因</a></li>
<li><ul>
<li><a href="#81-用户界面设计">8.1. 用户界面设计</a></li>
<li><a href="#82-开发者人因-3-c31-c32">8.2. 开发者人因 [3*, C31 - C32]</a></li>
</ul></li>
<li><a href="#计算系统">计算系统</a></li>
<li><ul>
<li><a href="#意识和觉知">意识和觉知</a></li>
<li><a href="#主题与参考资料对照矩阵-2">主题与参考资料对照矩阵</a></li>
<li><a href="#参考文献-12">参考文献</a></li>
</ul></li>
<li><a href="#第17章-1">第17章</a></li>
<li><a href="#数学基础-1">数学基础</a></li>
<li><ul>
<li><a href="#1-基本逻辑-1-c1">1. 基本逻辑 [1*, c1]</a></li>
<li><ul>
<li><a href="#11-命题逻辑">1.1. 命题逻辑</a></li>
</ul></li>
</ul></li>
<li><a href="#数学基础-2">数学基础</a></li>
<li><ul>
<li><a href="#1-逻辑学">1. 逻辑学</a></li>
<li><ul>
<li><a href="#11-命题逻辑-1">1.1. 命题逻辑</a></li>
<li><a href="#12-谓词逻辑">1.2. 谓词逻辑</a></li>
</ul></li>
<li><a href="#2-证明技术">2. 证明技术</a></li>
<li><ul>
<li><a href="#31-集合运算">3.1. 集合运算</a></li>
<li><a href="#32-集合的性质">3.2. 集合的性质</a></li>
<li><a href="#33-关系和函数">3.3. 关系和函数</a></li>
</ul></li>
<li><a href="#42-树">4.2. 树</a></li>
<li><a href="#5-有限状态机-1-c13">5. 有限状态机 [1*, c13]</a></li>
<li><a href="#6-文法">6. 文法</a></li>
<li><ul>
<li><a href="#61-语言识别">6.1. 语言识别</a></li>
</ul></li>
<li><a href="#74-最大公约数greatest-common-divisor">7.4. 最大公约数(Greatest
Common Divisor)</a></li>
<li><a href="#8-计数基础">8. 计数基础</a></li>
<li><a href="#9-离散概率-1-c7">9. 离散概率 [1*, c7]</a></li>
<li><a href="#10-数值精度准确度和误差-2-c1">10. 数值精度、准确度和误差
[2*, c1]</a></li>
<li><a href="#11-代数结构algebraic-structures">11. 代数结构(Algebraic
Structures)</a></li>
<li><ul>
<li><a href="#111-群group">11.1. 群(Group)</a></li>
<li><a href="#112-环ring">11.2. 环(Ring)</a></li>
</ul></li>
<li><a href="#12-工程微积分">12. 工程微积分</a></li>
<li><a href="#13-新进展">13. 新进展</a></li>
<li><ul>
<li><a href="#131-计算神经科学">13.1. 计算神经科学</a></li>
<li><a href="#132-基因组学">13.2. 基因组学</a></li>
</ul></li>
<li><a href="#第18章-1">第18章</a></li>
<li><ul>
<li><a href="#42-观察性研究">4.2. 观察性研究</a></li>
</ul></li>
<li><a href="#72-测量理论对编程语言的影响">7.2. 测量理论对编程语言的影响</a></li>
<li><a href="#75-评估可靠性">7.5. 评估可靠性</a></li>
<li><a href="#76-目标-问题-度量范式为什么要测量">7.6.
目标-问题-度量范式:为什么要测量?</a></li>
<li><a href="#8-标准">8. 标准</a></li>
<li><a href="#91-根因分析技术">9.1. 根因分析技术</a></li>
<li><a href="#9-根本原因分析">9. 根本原因分析</a></li>
<li><ul>
<li><a href="#91-根本原因分析技术">9.1. 根本原因分析技术</a></li>
<li><a href="#92-基于根本原因的改进">9.2. 基于根本原因的改进</a></li>
</ul></li>
<li><a href="#10-工业40与软件工程">10. 工业4.0与软件工程</a></li>
<li><a href="#2-收集有关该问题及其原因的证据">2.
收集有关该问题及其原因的证据</a></li>
<li><a href="#工业40的持续系统和软件工程">工业4.0的持续系统和软件工程</a></li>
<li><a href="#主题与参考资料矩阵-2">主题与参考资料矩阵</a></li>
<li><ul>
<li><a href="#1-工程过程">1. 工程过程</a></li>
<li><a href="#2-工程设计">2. 工程设计</a></li>
<li><a href="#3-抽象和封装">3. 抽象和封装</a></li>
<li><a href="#4-经验方法和实验技术">4. 经验方法和实验技术</a></li>
<li><a href="#5-统计分析">5. 统计分析</a></li>
<li><a href="#6-建模仿真和原型设计">6. 建模、仿真和原型设计</a></li>
<li><a href="#7-测量">7. 测量</a></li>
<li><a href="#8-标准-1">8. 标准</a></li>
<li><a href="#9-根本原因分析技术">9. 根本原因分析技术</a></li>
<li><a href="#10-工业40与软件工程-1">10. 工业4.0与软件工程</a></li>
</ul></li>
<li><a href="#延伸阅读-4">延伸阅读</a></li>
<li><a href="#参考文献-13">参考文献</a></li>
<li><a href="#知识领域描述规范">知识领域描述规范</a></li>
<li><a href="#知识领域内主题分解的标准和要求">知识领域内主题分解的标准和要求</a></li>
<li><a href="#主题描述的标准和要求">主题描述的标准和要求</a></li>
<li><a href="#参考资料的标准和要求">参考资料的标准和要求</a></li>
<li><a href="#通用结构">通用结构</a></li>
<li><a href="#我们所说的普遍认可的知识是什么意思">我们所说的”普遍认可的知识”是什么意思？</a></li>
<li><a href="#ka描述的长度">KA描述的长度</a></li>
<li><a href="#其他详细指南">其他详细指南</a></li>
<li><a href="#编辑">编辑</a></li>
<li><a href="#版权发布">版权发布</a></li>
<li><a href="#ieee和isoiec标准">IEEE和ISO/IEC标准</a></li>
<li><a href="#参考文献-14">参考文献</a></li>
</ul></li>
<li><a href="#标准">标准</a></li>
<li><ul>
<li><a href="#缩略语-3">缩略语</a></li>
<li><a href="#支持软件工程知识体系swebok">支持软件工程知识体系(SWEBOK)</a></li>
<li><ul>
<li><a href="#1-概述">1. 概述</a></li>
<li><ul>
<li><a href="#11-swebok与标准">1.1 SWEBOK与标准</a></li>
<li><a href="#12-标准类型">1.2 标准类型</a></li>
<li><a href="#13-软件工程标准的来源">1.3 软件工程标准的来源</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#附录-b-软件工程标准">附录 B - 软件工程标准</a></li>
<li><ul>
<li><a href="#流程标准">流程标准</a></li>
<li><a href="#2-软件工程标准全景">2. 软件工程标准全景</a></li>
</ul></li>
<li><a href="#系统之系统sos软件测试验证确认isoiecieee-标准体系">系统之系统(SoS)、软件测试、验证/确认、ISO/IEC/IEEE
标准体系</a></li>
<li><ul>
<li><a href="#生命周期过程标准">生命周期过程标准</a></li>
<li><a href="#4-isoiecieee-12207-的扩展和专业化应用">4. ISO/IEC/IEEE 12207
的扩展和专业化应用</a></li>
<li><ul>
<li><a href="#41-概念和若干过程的说明">4.1 概念和若干过程的说明</a></li>
</ul></li>
<li><a href="#42-更专业的扩展">4.2 更专业的扩展</a></li>
<li><a href="#5-单一流程标准">5. 单一流程标准</a></li>
<li><a href="#6-产品线方法和工具的标准">6. 产品线、方法和工具的标准</a></li>
<li><a href="#合并参考文献列表">合并参考文献列表</a></li>
</ul></li>
<li><a href="#综合参考文献列表">综合参考文献列表</a></li>
</ul>
</div>
</div>
<!-- 遮罩层 -->
<div class="toc-overlay" id="tocOverlay" onclick="closeToc()"></div>
<!-- 主要内容 -->
<header id="title-block-header">
<h1 class="title" id="swe">《swe》</h1>
</header>
<h1 id="软件工程知识体系指南">软件工程知识体系指南</h1>
<p>v4.0a</p>
<p>2025年9月发布</p>
<h2 id="编者">编者</h2>
<p><strong>Hironori Washizaki</strong></p>
<p>早稻田大学，IEEE计算机协会</p>
<p>2025年主席</p>
<h1 id="软件工程知识体系指南-1">软件工程知识体系指南</h1>
<p>v4.0a</p>
<p><strong>IEEE计算机协会项目</strong></p>
<h1 id="软件工程知识体系指南-2">软件工程知识体系指南</h1>
<p>v4.0a</p>
<h2 id="编者-1">编者</h2>
<p>Hironori Washizaki，早稻田大学</p>
<p>（IEEE计算机协会2025年主席）</p>
<p><strong><em>版权和转载许可。</em></strong>
允许免费将本材料用于教育或个人用途，前提是此类副本1）不以营利为目的或代替为课程购买副本，且本声明和对原作品的完整引用出现在副本的第一页上，2）不暗示IEEE对任何第三方产品或服务的认可。若要出于商业、广告或促销目的或为转售或再分发而创建新的集体作品而转载/重新发布本材料，必须通过写信至IEEE知识产权办公室（地址：445
Hoes Lane, Piscataway, NJ 08854-4141）或发送电子邮件至<a href="mailto:pubs-permissions@ieee.org">pubs-permissions@ieee.org</a>获得IEEE的许可。</p>
<p>提及任何特定商业产品、流程或服务并不意味着IEEE的认可。本文档中提到的产品、服务和公司名称可能是其各自所有者的商标。在本文档中提及不构成认可。本作品中表达的观点和意见不一定反映IEEE的观点和意见。</p>
<p>IEEE”按原样”提供本文档，对本文档的准确性、能力、效率、适销性或功能不作任何明示或暗示的保证。在任何情况下，即使IEEE已被告知可能发生此类损害，IEEE也不对任何一般性、后果性、间接性、附带性、示例性或特殊损害负责。</p>
<p>版权所有 © 2014–2025 IEEE。保留所有权利。</p>
<p><em>SWEBOK指南</em> V4.0a的数字副本可通过<a href="https://computer.org/swebok">https://computer.org/swebok</a>免费下载用于个人和学术用途。</p>
<h2 id="ieee计算机协会出版物工作人员">IEEE计算机协会出版物工作人员</h2>
<p>Melissa A. Russell，<em>执行董事</em></p>
<p>Eric Berkowitz，<em>会员总监</em></p>
<p>Michelle Phon，<em>专业教育与认证项目协调员</em></p>
<p>Jennie Zhu-Mai，<em>创意设计经理</em></p>
<p><strong><em>IEEE计算机协会产品和服务。</em></strong>
享誉全球的IEEE计算机协会出版、推广和分发各种权威的计算机科学与工程期刊、杂志、会议论文集和专业教育产品。</p>
<p>访问计算机协会网站<a href="http://www.computer.org">www.computer.org</a>了解更多信息。</p>
<h1 id="目录-1">目录</h1>
<p>前言 <a href="#calibre_link-1">xxv</a></p>
<p>2014版前言 [xxvi]</p>
<p>2004版前言 [xxvii]</p>
<p>编者 [xxix]</p>
<p>知识领域编者 [xxix]</p>
<p>特约编者 [xxx]</p>
<p>指导小组 [xxxi]</p>
<p>SWEBOK先前版本的知识领域编者 [xxxi]</p>
<p>评审团队 [xxxiii]</p>
<p>致谢 [xxxiv]</p>
<p>IEEE计算机协会主席 [xxxiv]</p>
<p>2024年专业与教育活动委员会成员 [xxxiv]</p>
<p>关于批准SWEBOK指南V4.0的动议 [xxxv]</p>
<p>关于批准SWEBOK指南V3.0的动议 [xxxv]</p>
<p>关于批准SWEBOK指南2004版的动议 [xxxvi]</p>
<p>指南介绍 [xxxvii]</p>
<h2 id="第01章">第01章</h2>
<h2 id="软件需求-1-1"><strong>软件需求</strong>
[<strong>1-1</strong>]</h2>
<p>引言 [1-1]</p>
<h3 id="1-软件需求基础-1-2">1. 软件需求基础 [1-2]</h3>
<p>1.1. 软件需求的定义 [1-2]</p>
<p>1.2. 软件需求的分类 [1-3]</p>
<p>1.3. 软件产品需求和软件项目需求 [1-3]</p>
<p>1.4. 功能需求 [1-4]</p>
<p>1.5. 非功能需求 [1-4]</p>
<p>1.6. 技术约束 [1-4]</p>
<p>1.7. 服务质量约束 [1-4]</p>
<p>1.8. 为什么要这样对需求分类？ [1-5]</p>
<p>1.9. 系统需求和软件需求 [1-5]</p>
<p>1.10. 派生需求 [1-6]</p>
<p>1.11. 软件需求活动 [1-6]</p>
<h3 id="2-需求获取-1-6">2. 需求获取 [1-6]</h3>
<p>2.1. 需求来源 [1-6]</p>
<p>2.2. 常见的需求获取技术 [1-7]</p>
<h3 id="3-需求分析-1-8">3. 需求分析 [1-8]</h3>
<p>3.1. 基本需求分析 [1-8]</p>
<p>3.2. 服务质量约束的经济性 [1-8]</p>
<p>3.3. 形式化分析 [1-9]</p>
<p>3.4. 处理需求中的冲突 [1-10]</p>
<h3 id="4-需求规约-1-10">4. 需求规约 [1-10]</h3>
<p>4.1. 非结构化自然语言需求规约 [1-11]</p>
<p>4.2. 结构化自然语言需求规约 [1-12]</p>
<p>4.3. 基于验收标准的需求规约 [1-12]</p>
<p>4.4. 基于模型的需求规约 [1-14]</p>
<p>4.5. 需求的附加属性 [1-14]</p>
<p>4.6. 增量式和全面的需求规约 [1-15]</p>
<h3 id="5-需求验证-1-15">5. 需求验证 [1-15]</h3>
<p>5.1. 需求评审 [1-15]</p>
<p>5.2. 仿真和执行 [1-16]</p>
<p>5.3. 原型法 [1-16]</p>
<h3 id="6-需求管理活动-1-16">6. 需求管理活动 [1-16]</h3>
<p>6.1. 需求清理 [1-16]</p>
<p>6.2. 需求变更控制 [1-17]</p>
<p>6.3. 范围匹配 [1-17]</p>
<h3 id="7-实践考虑-1-17">7. 实践考虑 [1-17]</h3>
<p>7.1. 需求过程的迭代性质 [1-17]</p>
<p>7.2. 需求优先级排序 [1-17]</p>
<p>7.3. 需求跟踪 [1-18]</p>
<p>7.4. 需求稳定性和波动性 [1-19]</p>
<p>7.5. 需求度量 [1-19]</p>
<p>7.6. 需求过程质量和改进 [1-19]</p>
<h3 id="8-软件需求工具-1-20">8. 软件需求工具 [1-20]</h3>
<p>8.1. 需求管理工具 [1-20]</p>
<p>8.2. 需求建模工具 [1-20]</p>
<p>8.3. 功能测试用例生成工具 [1-20]</p>
<p>主题与参考资料对照表 [1-21]</p>
<p>[延伸阅读 [1-22]]</p>
<p>[参考文献 [1-23]]</p>
<h2 id="第02章">[<strong>第02章</strong>]</h2>
<p>[[<strong>软件架构</strong>] [[<strong>2-1</strong>]]]</p>
<p>[引言 [2-1]]</p>
<p>[1. 软件架构基础 [2-1]]</p>
<p>[1.1. “架构”的多重含义 [2-1]]</p>
<p>[1.2. 利益相关者与关注点 [2-3]]</p>
<p>[1.3. 架构的用途 [2-4]]</p>
<p>[2. 软件架构描述 [2-4]]</p>
<p>[2.1. 架构视图与视点 [2-5]]</p>
<p>[2.2. 架构模式、风格与参考架构 [2-6]]</p>
<p>[2.3. 架构描述语言与架构框架 [2-7]]</p>
<p>[2.4. 架构作为重要决策 [2-7]]</p>
<p>[3. 软件架构过程 [2-8]]</p>
<p>[3.1. 架构的上下文 [2-8]]</p>
<p>[3.1.1. 架构与设计的关系 [2-9]]</p>
<p><a href="#目录">目录</a> vii</p>
<p>[3.2. 架构设计 [2-9]]</p>
<p>[3.2.1. 架构分析 [2-9]]</p>
<p>[3.2.2. 架构综合 [2-9]]</p>
<p>[3.2.3. 架构评估 [2-10]]</p>
<p>[3.3. 架构实践、方法与策略 [2-10]]</p>
<p>[3.4. 大规模架构 [2-10]]</p>
<p>[4. 软件架构评估 [2-10]]</p>
<p>[4.1. 架构的优良性 [2-10]]</p>
<p>[4.2. 架构推理 [2-11]]</p>
<p>[4.3. 架构评审 [2-11]]</p>
<p>[4.4. 架构度量 [2-11]]</p>
<p>[主题与参考资料矩阵 [2-12]]</p>
<p>[延伸阅读 [2-13]]</p>
<p>[参考文献 2-14]</p>
<h2 id="第03章">[<strong>第03章</strong>]</h2>
<p>[[<strong>软件设计</strong>] [[<strong>3-1</strong>]]]</p>
<p>[引言 3-1]</p>
<p>[1. 软件设计基础 [3-2]]</p>
<p>[1.1. 设计思维 [3-2]]</p>
<p>[1.2. 软件设计的上下文 [3-2]]</p>
<p>[1.3. 软件设计中的关键问题 [3-3]]</p>
<p>[1.4. 软件设计原则 [3-3]]</p>
<p>[2. 软件设计过程 [3-5]]</p>
<p>[2.1. 高层设计 [3-6]]</p>
<p>[2.2. 详细设计 [3-6]]</p>
<p>[3. 软件设计质量 [3-6]]</p>
<p>[3.1. 并发 3-6]</p>
<p>[3.2. 控制与事件处理 [3-6]]</p>
<p>[3.3. 数据持久化 [3-7]]</p>
<p>[3.4. 组件分布 [3-7]]</p>
<p>[3.5. 错误与异常处理、容错 [3-7]]</p>
<p>[3.6. 集成与互操作性 [3-7]]</p>
<p>[3.7. 保证、安全性与安全 [3-7]]</p>
<p>[3.8. 可变性 3-7]</p>
<p>[4. 记录软件设计 [3-7]]</p>
<p>[4.1. 基于模型的设计 [3-8]]</p>
<p>[4.2. 结构设计描述 [3-9]]</p>
<p>[4.3. 行为设计描述 [3-9]]</p>
<p>[4.4. 设计模式与风格 [3-10]]</p>
<p>[4.5. 专用与领域特定语言 [3-10]]</p>
<p>[4.6. 设计理由 [3-11]]</p>
<p>[5. 软件设计策略与方法 [3-11]]</p>
<p>[5.1. 通用策略 [3-11]]</p>
<p>[5.2. 面向功能(或结构化)设计 [3-11]]</p>
<p>[5.3. 以数据为中心的设计 [3-11]] viii [<em>SWEBOK</em>] [<em>®</em>][
指南 V4.0a]</p>
<p>[5.4. 面向对象设计 [3-11]]</p>
<p>[5.5. 以用户为中心的设计 [3-12]]</p>
<p>[5.6. 基于组件的设计(CBD) [3-12]]</p>
<p>[5.7. 事件驱动设计 [3-12]]</p>
<p>[5.8. 面向方面的设计(AOD) [3-12]]</p>
<p>[5.9. 基于约束的设计 [3-12]]</p>
<p>[5.10. 领域驱动设计 [3-13]]</p>
<p>[5.11. 其他方法 [3-13]]</p>
<p>[6. 软件设计质量分析与评估 [3-13]]</p>
<p>[6.1. 设计评审与审计 [3-13]]</p>
<p>[6.2. 质量属性 [3-13]]</p>
<p>[6.3. 质量分析与评估技术 [3-13]]</p>
<p>[6.4. 度量与指标 [3-14]]</p>
<p>[6.5. 验证、确认与认证 [3-14]]</p>
<p>[主题与参考资料矩阵 [3-14]]</p>
<p>[延伸阅读 [3-15]]</p>
<p>[参考文献 3-16]</p>
<h2 id="第04章"><a href="#第04章-1"><strong>第04章</strong></a></h2>
<p>[[<strong>软件构建</strong>] [[<strong>4-1</strong>]]]</p>
<p>[引言 4-1]</p>
<p>[1. 软件构建基础 [4-2]]</p>
<p>[1.1. 最小化复杂性 [4-2]]</p>
<p>[1.2. 预见和拥抱变化 [4-2]]</p>
<p>[1.3. 为验证而构建 [4-4]]</p>
<p>[1.4. 资产重用 [4-4]]</p>
<p>[1.5. 在构建中应用标准 [4-4]]</p>
<p>[2. 管理构建 [4-4]]</p>
<p>[2.1. 生命周期模型中的构建 [4-4]]</p>
<p>[2.2. 构建规划 [4-5]]</p>
<p>[2.3. 构建度量 [4-5]]</p>
<p>[2.4. 管理依赖关系 [4-5]]</p>
<p>[3. 实践考虑 4-6]</p>
<p>[3.1. 构建设计 [4-6]]</p>
<p>[3.2. 构建语言 [4-6]]</p>
<p>[3.3. 编码 [4-7]]</p>
<p>[3.4. 构建测试 [4-7]]</p>
<p>[3.5. 构建中的重用 [4-8]]</p>
<p>[3.6. 构建质量 [4-8]]</p>
<p>[3.7. 集成 4-9]</p>
<p>[3.8. 跨平台开发与迁移 [4-9]]</p>
<p>[4. 构建技术 [4-10]]</p>
<p>[4.1. API设计与使用 [4-10]]</p>
<p>[4.2. 面向对象运行时问题 [4-10]]</p>
<p>[4.3. 参数化、模板与泛型 [4-10]]</p>
<p>[4.4. 断言、契约式设计与防御式编程 [4-10]]</p>
<p>[4.5. 错误处理、异常处理与容错 [4-11]]</p>
<p><a href="#目录">目录</a> ix</p>
<p>[4.6. 可执行模型 4-11]</p>
<p>[4.7. 基于状态与表驱动的构建技术 4-11]</p>
<p>[4.8. 运行时配置与国际化 4-12]</p>
<p>[4.9. 基于语法的输入处理 4-12]</p>
<p>[4.10. 并发原语 4-12]</p>
<p>[4.11. 中间件 4-12]</p>
<p>[4.12. 分布式与云端软件的构建方法 4-13]</p>
<p>[4.13. 构建异构系统 4-13]</p>
<p>[4.14. 性能分析与调优 4-13]</p>
<p>[4.15. 平台标准 4-13]</p>
<p>[4.16. 测试先行编程 4-14]</p>
<p>[4.17. 构建反馈循环 4-14]</p>
<p>[5. 软件构建工具 4-14]</p>
<p>[5.1. 开发环境 4-14]</p>
<p>[5.2. 可视化编程与低代码/零代码平台 4-14]</p>
<p>[5.3. 单元测试工具 4-15]</p>
<p>[5.4. 性能分析、性能分析与切片工具 4-15]</p>
<p>[主题与参考资料矩阵 4-15]</p>
<p>[延伸阅读 4-18]</p>
<p>[参考文献 4-18]</p>
<h2 id="第05章">[<strong>第05章</strong>]</h2>
<p>[[<strong>软件测试</strong>] [<strong>5-1</strong>]]</p>
<p>[引言 5-1]</p>
<p>[1. 软件测试基础 5-3]</p>
<p>[1.1. 故障与失效 5-3]</p>
<p>[1.2. 关键问题 5-4]</p>
<p>[1.2.1. 测试用例创建 5-4]</p>
<p>[1.2.2. 测试选择与充分性标准 5-4]</p>
<p>[1.2.3. 优先级/最小化 5-4]</p>
<p>[1.2.4. 测试目的 5-4]</p>
<p>[1.2.5. 评估与认证 5-4]</p>
<p>[1.2.6. 质量保证/改进测试 5-4]</p>
<p>[1.2.7. 预言机问题 5-4]</p>
<p>[1.2.8. 理论与实践限制 5-5]</p>
<p>[1.2.9. 不可行路径问题 5-5]</p>
<h2 id="1210-可测试性testability-5-5">1.2.10. 可测试性(Testability) 5-5</h2>
<h2 id="1211-测试执行与自动化test-execution-and-automation-5-5">1.2.11.
测试执行与自动化(Test Execution and Automation) 5-5</h2>
<h2 id="1212-可扩展性scalability-5-5">1.2.12. 可扩展性(Scalability) 5-5</h2>
<h2 id="1213-测试有效性test-effectiveness-5-5">1.2.13. 测试有效性(Test
Effectiveness) 5-5</h2>
<h2 id="1214-可控性可复现性与通用性controllability-replication-and-generalization-5-5">1.2.14.
可控性、可复现性与通用性(Controllability, Replication, and
Generalization) 5-5</h2>
<h2 id="1215-离线测试与在线测试off-line-vs-online-testing-5-6">1.2.15.
离线测试与在线测试(Off-Line vs. Online Testing) 5-6</h2>
<h2 id="13-测试与其他活动的关系-5-6">1.3. 测试与其他活动的关系 5-6</h2>
<h1 id="2-测试级别-5-6">2. 测试级别 5-6</h1>
<h2 id="21-测试目标-5-6">2.1. 测试目标 5-6</h2>
<h3 id="211-单元测试unit-testing-5-6">2.1.1. 单元测试(Unit Testing) 5-6</h3>
<h3 id="212-集成测试integration-testing-5-7">2.1.2. 集成测试(Integration
Testing) 5-7</h3>
<p>x <em>SWEBOK® GUIDE V4.0a</em></p>
<h3 id="213-系统测试-5-7">2.1.3. 系统测试 5-7</h3>
<h3 id="214-验收测试acceptance-testing-5-7">2.1.4. 验收测试(Acceptance
Testing) 5-7</h3>
<h2 id="22-测试目的-5-7">2.2. 测试目的 5-7</h2>
<h3 id="221-符合性测试conformance-testing-5-7">2.2.1. 符合性测试(Conformance
Testing) 5-7</h3>
<h3 id="222-合规性测试compliance-testing-5-8">2.2.2. 合规性测试(Compliance
Testing) 5-8</h3>
<h3 id="223-安装测试installation-testing-5-8">2.2.3. 安装测试(Installation
Testing) 5-8</h3>
<h3 id="224-alpha与beta测试-5-8">2.2.4. Alpha与Beta测试 5-8</h3>
<h3 id="225-回归测试regression-testing-5-8">2.2.5. 回归测试(Regression
Testing) 5-8</h3>
<h3 id="226-优先级测试prioritization-testing-5-8">2.2.6.
优先级测试(Prioritization Testing) 5-8</h3>
<h3 id="227-非功能性测试non-functional-testing-5-8">2.2.7.
非功能性测试(Non-functional Testing) 5-8</h3>
<h3 id="228-安全测试security-testing-5-9">2.2.8. 安全测试(Security Testing)
5-9</h3>
<h3 id="229-隐私测试privacy-testing-5-9">2.2.9. 隐私测试(Privacy Testing)
5-9</h3>
<h3 id="2210-接口与应用程序接口api测试-5-10">2.2.10.
接口与应用程序接口(API)测试 5-10</h3>
<h3 id="2211-配置测试configuration-testing-5-10">2.2.11.
配置测试(Configuration Testing) 5-10</h3>
<h3 id="2212-可用性与人机交互测试-5-10">2.2.12. 可用性与人机交互测试
5-10</h3>
<h1 id="3-测试技术-5-10">3. 测试技术 5-10</h1>
<h2 id="31-基于规格说明的技术-5-10">3.1. 基于规格说明的技术 5-10</h2>
<h3 id="311-等价类划分equivalence-partitioning-5-10">3.1.1.
等价类划分(Equivalence Partitioning) 5-10</h3>
<h3 id="312-边界值分析boundary-value-analysis-5-11">3.1.2.
边界值分析(Boundary-Value Analysis) 5-11</h3>
<h3 id="313-语法测试syntax-testing-5-11">3.1.3. 语法测试(Syntax Testing)
5-11</h3>
<h3 id="314-组合测试技术combinatorial-test-techniques-5-11">3.1.4.
组合测试技术(Combinatorial Test Techniques) 5-11</h3>
<h3 id="315-判定表decision-table-5-11">3.1.5. 判定表(Decision Table)
5-11</h3>
<h3 id="316-因果图cause-effect-graphing-5-11">3.1.6. 因果图(Cause-Effect
Graphing) 5-11</h3>
<h3 id="317-状态转换测试state-transition-testing-5-11">3.1.7.
状态转换测试(State Transition Testing) 5-11</h3>
<h3 id="318-基于场景的测试scenario-based-testing-5-12">3.1.8.
基于场景的测试(Scenario-Based Testing) 5-12</h3>
<h3 id="319-随机测试random-testing-5-12">3.1.9. 随机测试(Random Testing)
5-12</h3>
<h3 id="3110-基于证据evidence-based-5-12">3.1.10. 基于证据(Evidence-Based)
5-12</h3>
<h3 id="3111-强制异常forcing-exception-5-12">3.1.11. 强制异常(Forcing
Exception) 5-12</h3>
<h2 id="32-基于结构的测试技术-5-12">3.2. 基于结构的测试技术 5-12</h2>
<h3 id="321-控制流测试control-flow-testing-5-13">3.2.1. 控制流测试(Control
Flow Testing) 5-13</h3>
<h3 id="322-数据流测试data-flow-testing-5-13">3.2.2. 数据流测试(Data Flow
Testing) 5-13</h3>
<h3 id="323-基于结构的测试技术参考模型-5-13">3.2.3.
基于结构的测试技术参考模型 5-13</h3>
<h2 id="33-基于经验的技术-5-13">3.3. 基于经验的技术 5-13</h2>
<h3 id="331-错误推测error-guessing-5-13">3.3.1. 错误推测(Error Guessing)
5-13</h3>
<h3 id="332-探索性测试exploratory-testing-5-13">3.3.2.
探索性测试(Exploratory Testing) 5-13</h3>
<h3 id="333-其他基于经验的技术-5-14">3.3.3. 其他基于经验的技术 5-14</h3>
<h2 id="34-基于故障的技术与变异技术fault-based-and-mutation-techniques-5-14">3.4.
基于故障的技术与变异技术(Fault-Based and Mutation Techniques) 5-14</h2>
<h2 id="35-基于使用的技术-5-15">3.5. 基于使用的技术 5-15</h2>
<h3 id="351-运行剖面operational-profile-5-15">3.5.1. 运行剖面(Operational
Profile) 5-15</h3>
<h3 id="352-用户观察启发式方法user-observation-heuristics-5-15">3.5.2.
用户观察启发式方法(User Observation Heuristics) 5-15</h3>
<h2 id="36-基于应用性质的技术-5-15">3.6. 基于应用性质的技术 5-15</h2>
<h2 id="37-技术选择与组合-5-16">3.7. 技术选择与组合 5-16</h2>
<h3 id="371-功能性与结构性的组合-5-16">3.7.1. 功能性与结构性的组合 5-16</h3>
<h3 id="372-确定性与随机性-5-16">3.7.2. 确定性与随机性 5-16</h3>
<h2 id="38-基于派生知识的技术-5-16">3.8. 基于派生知识的技术 5-16</h2>
<h1 id="4-测试相关度量-5-16">4. 测试相关度量 5-16</h1>
<h2 id="41-被测系统sut的评估-5-17">4.1. 被测系统(SUT)的评估 5-17</h2>
<h3 id="411-帮助规划和设计测试的sut度量-5-17">4.1.1.
帮助规划和设计测试的SUT度量 5-17</h3>
<h3 id="412-故障类型分类与统计-5-17">4.1.2. 故障类型、分类与统计 5-17</h3>
<h3 id="413-故障密度fault-density-5-17">4.1.3. 故障密度(Fault Density)
5-17</h3>
<h3 id="414-寿命测试可靠性评估-5-17">4.1.4. 寿命测试、可靠性评估 5-17</h3>
<h3 id="415-可靠性增长模型reliability-growth-models-5-17">4.1.5.
可靠性增长模型(Reliability Growth Models) 5-17</h3>
<h2 id="42-已执行测试的评估-5-17">4.2. 已执行测试的评估 5-17</h2>
<h3 id="421-故障注入fault-injection-5-18">4.2.1. 故障注入(Fault Injection)
5-18</h3>
<h3 id="422-变异分数mutation-score-5-18">4.2.2. 变异分数(Mutation Score)
5-18</h3>
<h3 id="423-不同技术的比较与相对有效性-5-18">4.2.3.
不同技术的比较与相对有效性 5-18</h3>
<h1 id="5-测试过程-5-18">5. 测试过程 5-18</h1>
<h2 id="51-实践考虑-5-18">5.1. 实践考虑 5-18</h2>
<h3 id="511-态度无我编程attitudesegoless-programming-5-19">5.1.1.
态度/无我编程(Attitudes/Egoless Programming) 5-19</h3>
<h3 id="512-测试指南与组织流程-5-19">5.1.2. 测试指南与组织流程 5-19</h3>
<h3 id="513-测试管理与动态测试过程-5-19">5.1.3. 测试管理与动态测试过程
5-19</h3>
<h3 id="514-测试文档-5-19">5.1.4. 测试文档 5-19</h3>
<h3 id="515-测试团队-5-19">5.1.5. 测试团队 5-19</h3>
<h3 id="516-测试过程度量-5-20">5.1.6. 测试过程度量 5-20</h3>
<h3 id="517-测试监控与控制-5-20">5.1.7. 测试监控与控制 5-20</h3>
<h3 id="518-测试完成-5-20">5.1.8. 测试完成 5-20</h3>
<h3 id="519-测试可复用性-5-20">5.1.9. 测试可复用性 5-20</h3>
<h2 id="52-测试子过程与活动-5-21">5.2. 测试子过程与活动 5-21</h2>
<h3 id="521-测试规划过程-5-21">5.2.1. 测试规划过程 5-21</h3>
<h3 id="522-测试设计与实现-5-21">5.2.2. 测试设计与实现 5-21</h3>
<h3 id="523-测试环境搭建与维护-5-21">5.2.3. 测试环境搭建与维护 5-21</h3>
<h3 id="524-受控实验与测试执行-5-21">5.2.4. 受控实验与测试执行 5-21</h3>
<h3 id="525-测试事件报告-5-22">5.2.5. 测试事件报告 5-22</h3>
<h2 id="53-人员配备-5-22">5.3. 人员配备 5-22</h2>
<h1 id="6-软件测试在开发过程与应用领域中的应用-5-22">6.
软件测试在开发过程与应用领域中的应用 5-22</h1>
<h2 id="61-软件开发过程中的测试-5-23">6.1. 软件开发过程中的测试 5-23</h2>
<h3 id="611-传统过程中的测试-5-23">6.1.1. 传统过程中的测试 5-23</h3>
<h3 id="612-与左移运动shift-left-movement一致的测试-5-23">6.1.2.
与左移运动(Shift-Left Movement)一致的测试 5-23</h3>
<h2 id="62-应用领域中的测试-5-24">6.2. 应用领域中的测试 5-24</h2>
<h1 id="7-新兴技术的测试与通过新兴技术进行测试-5-26">7.
新兴技术的测试与通过新兴技术进行测试 5-26</h1>
<h2 id="71-新兴技术的测试-5-26">7.1. 新兴技术的测试 5-26</h2>
<h2 id="72-通过新兴技术进行测试-5-27">7.2. 通过新兴技术进行测试 5-27</h2>
<h1 id="8-软件测试工具-5-28">8. 软件测试工具 5-28</h1>
<h2 id="81-测试工具支持与选择-5-29">8.1. 测试工具支持与选择 5-29</h2>
<h2 id="82-工具类别-5-29">8.2. 工具类别 5-29</h2>
<p>主题与参考材料对照表 5-30</p>
<p>参考文献 5-33</p>
<h1 id="第06章"><strong>第06章</strong></h1>
<p><strong>软件工程运维</strong> <strong>6-1</strong></p>
<p>引言 6-1</p>
<h1 id="1-软件工程运维基础-6-3">1. 软件工程运维基础 6-3</h1>
<h2 id="11-软件工程运维的定义-6-3">1.1. 软件工程运维的定义 6-3</h2>
<h2 id="12-软件工程运维流程-6-4">1.2. 软件工程运维流程 6-4</h2>
<p>xii <em>SWEBOK® GUIDE V4.0a</em></p>
<h2 id="13-软件安装-6-5">1.3. 软件安装 6-5</h2>
<h2 id="14-脚本编写与自动化-6-5">1.4. 脚本编写与自动化 6-5</h2>
<h2 id="15-有效测试与故障排除-6-5">1.5. 有效测试与故障排除 6-5</h2>
<h2 id="16-性能可靠性与负载均衡-6-6">1.6. 性能、可靠性与负载均衡 6-6</h2>
<h1 id="2-软件工程运维规划-6-6">2. 软件工程运维规划 6-6</h1>
<h2 id="21-运维计划与供应商管理-6-6">2.1. 运维计划与供应商管理 6-6</h2>
<h3 id="211-运维计划-6-6">2.1.1. 运维计划 6-6</h3>
<h3 id="212-供应商管理-6-7">2.1.2. 供应商管理 6-7</h3>
<h2 id="22-开发与运维环境-6-7">2.2. 开发与运维环境 6-7</h2>
<h2 id="23-软件可用性连续性与服务级别-6-8">2.3.
软件可用性、连续性与服务级别 6-8</h2>
<h2 id="24-软件容量管理-6-8">2.4. 软件容量管理 6-8</h2>
<h2 id="25-软件备份灾难恢复与故障切换-6-8">2.5.
软件备份、灾难恢复与故障切换 6-8</h2>
<h2 id="26-软件与数据的安全性完整性保护与控制-6-9">2.6.
软件与数据的安全性、完整性、保护与控制 6-9</h2>
<h1 id="3-软件工程运维交付-6-9">3. 软件工程运维交付 6-9</h1>
<h2 id="31-运维测试验证与验收-6-9">3.1. 运维测试、验证与验收 6-9</h2>
<h2 id="32-部署发布工程-6-10">3.2. 部署/发布工程 6-10</h2>
<h2 id="33-回滚与数据迁移-6-10">3.3. 回滚与数据迁移 6-10</h2>
<h2 id="34-问题解决-6-11">3.4. 问题解决 6-11</h2>
<h1 id="4-软件工程运维控制-6-11">4. 软件工程运维控制 6-11</h1>
<h2 id="41-事件管理incident-management-6-11">4.1. 事件管理(Incident
Management) 6-11</h2>
<h2 id="42-变更管理-6-11">4.2. 变更管理 6-11</h2>
<h2 id="43-监控测量跟踪与审查-6-11">4.3. 监控、测量、跟踪与审查 6-11</h2>
<h2 id="44-运维支持-6-12">4.4. 运维支持 6-12</h2>
<h2 id="45-服务报告-6-12">4.5. 服务报告 6-12</h2>
<h1 id="5-实践考虑-6-12">5. 实践考虑 6-12</h1>
<h2 id="51-事件与问题预防-6-12">5.1. 事件与问题预防 6-12</h2>
<h2 id="52-运维风险管理-6-12">5.2. 运维风险管理 6-12</h2>
<h2 id="53-软件工程运维自动化-6-12">5.3. 软件工程运维自动化 6-12</h2>
<h2 id="第七章"><strong>第七章</strong></h2>
<p><strong>软件维护 7-1</strong></p>
<p>引言 7-1</p>
<ol type="1">
<li>软件维护基础 7-2</li>
</ol>
<p>1.1. 定义和术语 7-2</p>
<p>1.2. 软件维护的本质 7-2</p>
<p>1.3. 软件维护的需求 7-3</p>
<p>1.4. 维护成本的主要部分 7-3</p>
<p>1.5. 软件演化(Evolution) 7-3</p>
<p>1.6. 软件维护的类别 7-4</p>
<ol start="2" type="1">
<li>软件维护中的关键问题 7-5</li>
</ol>
<p>2.1. 技术问题 7-5</p>
<p>2.1.1 有限的理解 7-5</p>
<p>2.1.2 测试 7-5</p>
<p>2.1.3 影响分析 7-6</p>
<p>2.1.4 可维护性 7-6</p>
<p>2.2. 管理问题 7-7</p>
<p>2.2.1. 与组织目标的一致性 7-7</p>
<p>2.2.2. 人员配备 7-7</p>
<p>2.2.3. 流程 7-8</p>
<p>2.2.4. 供应商管理 7-8</p>
<p>2.2.5. 维护的组织方面 7-8</p>
<p>2.3. 软件维护成本 7-9</p>
<p>2.3.1. 技术债务(Technical Debt)成本估算 7-9</p>
<p>2.3.2. 维护成本估算 7-9</p>
<p>2.4. 软件维护度量 7-10</p>
<ol start="3" type="1">
<li>软件维护过程 7-11</li>
</ol>
<p>3.1. 软件维护过程 7-11</p>
<p>3.2. 软件维护活动和任务 7-11</p>
<p>3.2.1. 支持和监控活动 7-12</p>
<p>3.2.2. 规划活动 7-12</p>
<p>3.2.3. 配置管理 7-13</p>
<p>3.2.4. 软件质量 7-13</p>
<ol start="4" type="1">
<li>软件维护技术 7-13</li>
</ol>
<p>4.1. 程序理解 7-13</p>
<p>4.2. 软件再工程(Reengineering) 7-13</p>
<p>4.3. 逆向工程(Reverse Engineering) 7-14</p>
<p>4.4. 持续集成、交付、测试和部署 7-14</p>
<p>4.5. 维护可视化 7-15</p>
<ol start="5" type="1">
<li>软件维护工具 7-15</li>
</ol>
<p>主题与参考材料对照矩阵 7-16</p>
<p>延伸阅读 7-17</p>
<p>参考文献 7-17</p>
<h2 id="第八章"><strong>第八章</strong></h2>
<p><strong>软件配置管理 8-1</strong></p>
<p>引言 8-1</p>
<ol type="1">
<li>SCM过程的管理 8-2</li>
</ol>
<p>1.1. SCM的组织环境 8-2</p>
<p>1.2. SCM过程的约束和指导 8-3</p>
<p>1.3. SCM规划 8-3</p>
<p>1.3.1. SCM组织和职责 8-4</p>
<p>1.3.2. SCM资源和进度 8-4</p>
<p>1.3.3. 工具选择和实施 8-4</p>
<p>1.3.4. 供应商/分包商控制 8-5</p>
<p>1.3.5. 接口控制 8-5</p>
<p>1.4. SCM计划 8-5</p>
<p>1.5. 软件配置管理的监控 8-5</p>
<p>1.5.1 SCM度量和测量 8-6</p>
<p>1.5.2 SCM的过程审计 8-6</p>
<ol start="2" type="1">
<li>软件配置标识 8-6</li>
</ol>
<p>2.1. 识别要控制的项目 8-6</p>
<p>2.1.1 软件配置 8-6</p>
<p>2.1.2 软件配置项 8-6</p>
<p>2.2. 配置项标识符和属性 8-7</p>
<p>2.3. 基线标识 8-7</p>
<p>2.4. 基线属性 8-7</p>
<p>2.5. 关系模式定义 8-7</p>
<p>2.6. 软件库 8-8</p>
<ol start="3" type="1">
<li>软件配置变更控制 8-9</li>
</ol>
<p>3.1. 请求、评估和批准软件变更 8-9</p>
<p>3.1.1 软件配置控制委员会 8-10</p>
<p>3.1.2 软件变更请求流程 8-10</p>
<p>3.1.3 软件变更请求表单定义 8-10</p>
<p>3.2. 实施软件变更 8-10</p>
<p>3.3. 偏差和豁免 8-11</p>
<ol start="4" type="1">
<li>软件配置状态记录 8-11</li>
</ol>
<p>4.1. 软件配置状态信息 8-11</p>
<p>4.2. 软件配置状态报告 8-11</p>
<ol start="5" type="1">
<li>软件配置审计 8-12</li>
</ol>
<p>5.1. 软件功能配置审计 8-12</p>
<p>5.2. 软件物理配置审计 8-12</p>
<p>5.3. 软件基线的过程审计 8-12</p>
<ol start="6" type="1">
<li>软件发布管理和交付 8-13</li>
</ol>
<p>6.1. 软件构建 8-13</p>
<p>6.2. 软件发布管理 8-13</p>
<ol start="7" type="1">
<li>软件配置管理工具 8-14</li>
</ol>
<p>主题与参考材料对照矩阵 8-15</p>
<p>延伸阅读 8-16</p>
<p>参考文献 8-17</p>
<h2 id="第九章"><strong>第九章</strong></h2>
<p><strong>软件工程管理 9-1</strong></p>
<p>引言 9-1</p>
<ol type="1">
<li>启动和范围定义 9-6</li>
</ol>
<p>1.1. 需求的确定和协商 9-6</p>
<p>1.2. 可行性分析 9-6</p>
<p>1.3. 需求审查和修订流程 9-7</p>
<ol start="2" type="1">
<li>软件项目规划 9-7</li>
</ol>
<p>2.1. 流程规划 9-8</p>
<p>2.2. 确定交付物 9-8</p>
<p>2.3. 工作量、进度和成本估算 9-8</p>
<p>2.4. 资源分配 9-9</p>
<p>2.5. 风险管理 9-9</p>
<p>2.6. 质量管理 9-9</p>
<p>2.7. 计划管理 9-10</p>
<ol start="3" type="1">
<li>软件项目执行 9-11</li>
</ol>
<p>3.1. 计划的实施 9-11</p>
<p>3.2. 软件采购和供应商合同管理 9-11</p>
<p>3.3. 测量过程的实施 9-12</p>
<p>3.4. 监控过程 9-12</p>
<p>3.5. 控制过程 9-12</p>
<p>3.6. 报告 9-13</p>
<ol start="4" type="1">
<li>软件审查和评估 9-13</li>
</ol>
<p>4.1. 确定需求满足情况 9-13</p>
<p>4.2. 审查和评估绩效 9-13</p>
<ol start="5" type="1">
<li>收尾 9-13</li>
</ol>
<p>5.1. 确定收尾 9-13</p>
<p>5.2. 收尾活动 9-14</p>
<ol start="6" type="1">
<li>软件工程度量 9-14</li>
</ol>
<p>6.1. 建立和维持度量承诺 9-14</p>
<p>6.2. 规划度量过程 9-15</p>
<p>6.3. 执行度量过程 9-15</p>
<p>6.4. 评估度量 9-16</p>
<ol start="7" type="1">
<li>软件工程管理工具 9-16</li>
</ol>
<p>主题与参考材料对照矩阵 9-17</p>
<p>延伸阅读 9-18</p>
<p>参考文献 9-18</p>
<h2 id="第十章"><strong>第十章</strong></h2>
<p><strong>软件工程过程 10-1</strong></p>
<p>引言 10-1</p>
<ol type="1">
<li>软件工程过程基础 10-1</li>
</ol>
<p>1.1. 引言 10-1</p>
<p>1.2. 软件工程过程定义 10-3</p>
<h1 id="2-生命周期">2. 生命周期</h1>
<h2 id="21-生命周期定义过程类别和术语">2.1.
生命周期定义、过程类别和术语</h2>
<h2 id="22-生命周期的基本原理">2.2. 生命周期的基本原理</h2>
<h2 id="23-过程模型和生命周期模型的概念">2.3.
过程模型和生命周期模型的概念</h2>
<h2 id="24-开发生命周期模型的一些范式">2.4. 开发生命周期模型的一些范式</h2>
<h2 id="25-开发生命周期模型及其工程维度">2.5.
开发生命周期模型及其工程维度</h2>
<h2 id="26-slcp的管理">2.6. SLCP的管理</h2>
<h2 id="27-软件工程过程管理">2.7. 软件工程过程管理</h2>
<h2 id="28-软件生命周期适配">2.8. 软件生命周期适配</h2>
<h2 id="29-实际考虑因素">2.9. 实际考虑因素</h2>
<h2 id="210-软件过程基础设施工具方法">2.10.
软件过程基础设施、工具、方法</h2>
<h2 id="211-软件工程过程监控及其与软件产品的关系">2.11.
软件工程过程监控及其与软件产品的关系</h2>
<h1 id="3-软件过程评估和改进">3. 软件过程评估和改进</h1>
<h2 id="31-软件过程评估和改进概述">3.1. 软件过程评估和改进概述</h2>
<h2 id="32-目标-问题-度量-gqm">3.2. 目标-问题-度量 (GQM)</h2>
<h2 id="33-基于框架的方法">3.3. 基于框架的方法</h2>
<h2 id="34-敏捷中的过程评估和改进">3.4. 敏捷中的过程评估和改进</h2>
<p>主题与参考资料矩阵</p>
<p>参考文献</p>
<h1 id="第11章"><strong>第11章</strong></h1>
<h2 id="软件工程模型和方法"><strong>软件工程模型和方法</strong></h2>
<p>引言</p>
<h2 id="1-建模">1. 建模</h2>
<h3 id="11-建模原则">1.1. 建模原则</h3>
<h3 id="12-模型的属性和表达">1.2. 模型的属性和表达</h3>
<h3 id="13-语法语义和语用学">1.3. 语法、语义和语用学</h3>
<h3 id="14-前置条件后置条件和不变量">1.4. 前置条件、后置条件和不变量</h3>
<h2 id="2-模型类型">2. 模型类型</h2>
<h3 id="21-结构建模">2.1. 结构建模</h3>
<h3 id="22-行为建模">2.2. 行为建模</h3>
<h2 id="3-模型分析">3. 模型分析</h2>
<h3 id="31-完整性分析">3.1. 完整性分析</h3>
<h3 id="32-一致性分析">3.2. 一致性分析</h3>
<h3 id="33-正确性分析">3.3. 正确性分析</h3>
<h3 id="34-可追溯性分析">3.4. 可追溯性分析</h3>
<h3 id="35-交互性分析">3.5. 交互性分析</h3>
<h2 id="4-软件工程方法">4. 软件工程方法</h2>
<h3 id="41-启发式方法">4.1. 启发式方法</h3>
<h3 id="42-形式化方法">4.2. 形式化方法</h3>
<h3 id="43-原型法">4.3. 原型法</h3>
<h3 id="44-敏捷方法">4.4. 敏捷方法</h3>
<p>主题与参考资料矩阵</p>
<p>参考文献</p>
<h1 id="第12章"><strong>第12章</strong></h1>
<h2 id="软件质量"><strong>软件质量</strong></h2>
<p>引言</p>
<h2 id="1-软件质量基础">1. 软件质量基础</h2>
<h3 id="11-软件工程文化和道德规范">1.1. 软件工程文化和道德规范</h3>
<h3 id="12-质量的价值和成本">1.2. 质量的价值和成本</h3>
<h3 id="13-标准模型和认证">1.3. 标准、模型和认证</h3>
<h3 id="14-软件可靠性和完整性级别">1.4. 软件可靠性和完整性级别</h3>
<h4 id="141-可靠性">1.4.1 可靠性</h4>
<h4 id="142-软件完整性级别">1.4.2. 软件完整性级别</h4>
<h2 id="2-软件质量管理过程">2. 软件质量管理过程</h2>
<h3 id="21-软件质量改进">2.1. 软件质量改进</h3>
<h3 id="22-规划质量管理">2.2. 规划质量管理</h3>
<h3 id="23-评估质量管理">2.3. 评估质量管理</h3>
<h4 id="231-软件质量度量">2.3.1 软件质量度量</h4>
<h3 id="24-执行纠正和预防措施">2.4. 执行纠正和预防措施</h3>
<h4 id="241-缺陷特征描述">2.4.1. 缺陷特征描述</h4>
<h2 id="3-软件质量保证过程">3. 软件质量保证过程</h2>
<h3 id="31-准备质量保证">3.1. 准备质量保证</h3>
<h3 id="32-执行过程保证">3.2. 执行过程保证</h3>
<h3 id="33-执行产品保证">3.3. 执行产品保证</h3>
<h3 id="34-vv和测试">3.4. V&amp;V和测试</h3>
<h4 id="341-静态分析技术">3.4.1 静态分析技术</h4>
<h4 id="342-动态分析技术">3.4.2. 动态分析技术</h4>
<h4 id="343-形式化分析技术">3.4.3. 形式化分析技术</h4>
<h4 id="344-软件质量控制和测试">3.4.4. 软件质量控制和测试</h4>
<h4 id="345-技术评审和审计">3.4.5. 技术评审和审计</h4>
<h2 id="4-软件质量工具">4. 软件质量工具</h2>
<p>主题与参考资料矩阵</p>
<p>延伸阅读</p>
<p>参考文献</p>
<h1 id="第13章"><strong>第13章</strong></h1>
<h2 id="软件安全"><strong>软件安全</strong></h2>
<p>引言</p>
<h2 id="1-软件安全基础">1. 软件安全基础</h2>
<h3 id="11-软件安全">1.1. 软件安全</h3>
<h3 id="12-信息安全">1.2. 信息安全</h3>
<h3 id="13-网络安全">1.3. 网络安全</h3>
<h2 id="2-安全管理和组织">2. 安全管理和组织</h2>
<h3 id="21-能力成熟度模型">2.1. 能力成熟度模型</h3>
<h3 id="22-信息安全管理系统">2.2. 信息安全管理系统</h3>
<h3 id="23-软件安全的敏捷实践">2.3. 软件安全的敏捷实践</h3>
<h2 id="3-软件安全工程和过程">3. 软件安全工程和过程</h2>
<h3 id="31-安全工程和安全开发生命周期-sdlc">3.1. 安全工程和安全开发生命周期
(SDLC)</h3>
<h3 id="32-信息技术安全评估通用准则">3.2. 信息技术安全评估通用准则</h3>
<h2 id="4-软件系统的安全工程">4. 软件系统的安全工程</h2>
<h3 id="41-安全需求">4.1. 安全需求</h3>
<h3 id="42-安全设计">4.2. 安全设计</h3>
<h3 id="43-安全模式">4.3. 安全模式</h3>
<h3 id="44-安全构造">4.4. 安全构造</h3>
<h3 id="45-安全测试">4.5. 安全测试</h3>
<h3 id="46-漏洞管理">4.6. 漏洞管理</h3>
<h2 id="5-软件安全工具">5. 软件安全工具</h2>
<h3 id="51-安全漏洞检查工具">5.1. 安全漏洞检查工具</h3>
<h3 id="52-渗透测试工具">5.2. 渗透测试工具</h3>
<h2 id="6-特定领域的软件安全">6. 特定领域的软件安全</h2>
<h3 id="61-容器和云的安全">6.1. 容器和云的安全</h3>
<h3 id="62-物联网软件的安全">6.2. 物联网软件的安全</h3>
<h3 id="63-基于机器学习的应用的安全">6.3. 基于机器学习的应用的安全</h3>
<p>主题与参考资料矩阵</p>
<p>延伸阅读</p>
<p>参考文献</p>
<h1 id="第14章"><strong>第14章</strong></h1>
<h2 id="软件工程职业实践"><strong>软件工程职业实践</strong></h2>
<p>引言</p>
<h2 id="1-专业性">1. 专业性</h2>
<h3 id="11-认可认证和资格许可">1.1. 认可、认证和资格、许可</h3>
<h4 id="111-认可">1.1.1. 认可</h4>
<h4 id="112-认证和资格">1.1.2. 认证和资格</h4>
<h4 id="113-许可">1.1.3. 许可</h4>
<h3 id="12-道德规范和职业行为准则">1.2. 道德规范和职业行为准则</h3>
<h3 id="13-专业协会的性质和作用">1.3. 专业协会的性质和作用</h3>
<h3 id="14-软件工程标准的性质和作用">1.4. 软件工程标准的性质和作用</h3>
<h3 id="15-软件的经济影响">1.5. 软件的经济影响</h3>
<h3 id="16-雇佣合同">1.6. 雇佣合同</h3>
<h3 id="17-法律问题">1.7. 法律问题</h3>
<h4 id="171-标准">1.7.1. 标准</h4>
<h4 id="172-商标">1.7.2. 商标</h4>
<h4 id="173-专利">1.7.3. 专利</h4>
<h4 id="174-版权">1.7.4. 版权</h4>
<h4 id="175-商业秘密">1.7.5. 商业秘密</h4>
<h4 id="176-职业责任">1.7.6. 职业责任</h4>
<h4 id="177-法律要求">1.7.7. 法律要求</h4>
<h4 id="178-贸易合规">1.7.8. 贸易合规</h4>
<h4 id="179-网络犯罪">1.7.9. 网络犯罪</h4>
<h4 id="1710-数据隐私">1.7.10. 数据隐私</h4>
<h3 id="18-文档">1.8. 文档</h3>
<h3 id="19-权衡分析">1.9. 权衡分析</h3>
<h2 id="2-群体动力学和心理学">2. 群体动力学和心理学</h2>
<h3 id="21-团队小组协作的动力学">2.1. 团队/小组协作的动力学</h3>
<h3 id="22-个体认知">2.2. 个体认知</h3>
<h3 id="23-处理问题复杂性">2.3. 处理问题复杂性</h3>
<p>[2.4. 与利益相关者互动 [14-10]]</p>
<p>[2.5. 处理不确定性和模糊性 [14-11]]</p>
<p>[2.6. 处理公平性、多样性和包容性 [14-11]]</p>
<p>[3. 沟通技能 [14-11]]</p>
<p>[3.1. 阅读、理解和总结 [14-12]]</p>
<p>[3.2. 写作 14-12]</p>
<p>[3.3. 团队和小组沟通 [14-12]]</p>
<p>[3.4. 演示技能 [14-12]]</p>
<p><a href="#目录">目录</a> xix</p>
<p>[主题与参考资料矩阵 [14-13]]</p>
<p>[延伸阅读 [14-14]]</p>
<p>[参考文献 [14-14]]</p>
<h2 id="第15章"><strong>第15章</strong></h2>
<p><strong>软件工程经济学</strong> [[<strong>15-1</strong>]]</p>
<p>[引言 [15-1]]</p>
<p>[1. 软件工程经济学基础 [15-3]]</p>
<p>[1.1. 提案 [15-3]]</p>
<p>[1.2. 现金流 [15-3]]</p>
<p>[1.3. 货币时间价值 [15-3]]</p>
<p>[1.4. 等价性 [15-4]]</p>
<p>[1.5. 比较基础 [15-4]]</p>
<p>[1.6. 备选方案 [15-4]]</p>
<p>[1.7. 无形资产 [15-4]]</p>
<p>[1.8. 商业模式 [15-5]]</p>
<p>[2. 工程决策过程 [15-5]]</p>
<p>[2.1. 流程概述 [15-5]]</p>
<p>[2.2. 理解真正的问题 [15-5]]</p>
<p>[2.3. 识别所有合理的技术可行解决方案 [15-6]]</p>
<p>[2.4. 定义选择标准 [15-6]]</p>
<p>[2.5. 根据选择标准评估每个备选方案 [15-6]]</p>
<p>[2.6. 选择首选方案 [15-6]]</p>
<p>[2.7. 监控所选方案的性能 [15-7]]</p>
<p>[3. 营利性决策 [15-7]]</p>
<p>[3.1. 最低可接受回报率 [15-7]]</p>
<p>[3.2. 经济寿命 [15-7]]</p>
<p>[3.3. 规划期限 [15-8]]</p>
<p>[3.4. 替换决策 [15-8]]</p>
<p>[3.5. 退役决策 [15-9]]</p>
<p>[3.6. 高级营利性决策考虑因素 [15-9]]</p>
<p>[4. 非营利决策 [15-9]]</p>
<p>[4.1. 成本效益分析 [15-9]]</p>
<p>[4.2. 成本效果分析 [15-9]]</p>
<p>[5. 当前经济决策 [15-9]]</p>
<p>[5.1. 盈亏平衡分析 [15-9]]</p>
<p>[5.2. 优化分析 [15-9]]</p>
<p>[6. 多属性决策 [15-10]]</p>
<p>[6.1. 补偿性技术 [15-10]]</p>
<p>[6.2. 非补偿性技术 [15-10]]</p>
<p>[7. 识别和表征无形资产 [15-10]]</p>
<p>[7.1. 识别流程并定义业务目标 [15-10]]</p>
<p>[7.2. 识别与业务目标相关的无形资产 [15-11]]</p>
<p>[7.3. 识别支持无形资产的软件产品 [15-11]]</p>
<p>[7.4. 定义和测量指标 [15-11]]</p>
<p>[7.5. 无形资产表征 [15-11]] xx [<em>SWEBOK</em>] [<em>®</em>][ 指南
V4.0a]</p>
<p>[7.6. 将特定无形资产与商业模式关联 [15-13]]</p>
<p>[7.7. 决策 15-13]</p>
<p>[8. 估算 15-13]</p>
<p>[8.1. 专家判断 [15-14]]</p>
<p>[8.2. 类比法 15-15]</p>
<p>[8.3. 分解法 15-15]</p>
<p>[8.4. 参数法 15-15]</p>
<p>[8.5. 多重估算 [15-15]]</p>
<p>[9. 实践考虑因素 [15-16]]</p>
<p>[9.1. 商业案例 [15-16]]</p>
<p>[9.2. 多币种分析 [15-16]]</p>
<p>[9.3. 系统思维 [15-16]]</p>
<p>[10. 相关概念 [15-16]]</p>
<p>[10.1. 会计 15-16]</p>
<p>[10.2. 成本和成本核算 [15-16]]</p>
<p>[10.3. 财务 15-17]</p>
<p>[10.4. 控制 15-17]</p>
<p>[10.5. 效率和有效性 [15-17]]</p>
<p>[10.6. 生产力 15-18]</p>
<p>[10.7. 产品或服务 [15-18]]</p>
<p>[10.8. 项目 15-18]</p>
<p>[10.9. 计划 15-18]</p>
<p>[10.10. 投资组合 [15-18]]</p>
<p>[10.11. 产品生命周期 [15-19]]</p>
<p>[10.12. 项目生命周期 [15-19]]</p>
<p>[10.13. 价格和定价 [15-19]]</p>
<p>[10.14. 优先级排序 15-19]</p>
<p>[主题与参考资料矩阵 [15-20]]</p>
<p>[延伸阅读 [15-22]]</p>
<p>[参考文献 15-22]</p>
<h2 id="第16章"><strong>第16章</strong></h2>
<p><strong>计算基础</strong> [[<strong>16-1</strong>]]</p>
<p>[引言 16-2]</p>
<p>[1. 系统或解决方案的基本概念 [16-2]]</p>
<p>[2. 计算机体系结构和组成 [16-3]]</p>
<p>[2.1. 计算机体系结构 [16-3]]</p>
<p>[2.2. 计算机体系结构类型 [16-3]]</p>
<p>[2.2.1. 冯·诺依曼架构 [16-3]]</p>
<p>[2.2.2. 哈佛架构 [16-4]]</p>
<p>[2.2.3. 指令集架构 [16-4]]</p>
<p>[2.2.4. Flynn架构或分类法 [16-5]]</p>
<p>[2.2.5. 系统架构 [16-5]]</p>
<p>[2.3. 微架构或计算机组成 [16-5]]</p>
<p>[2.3.1. 算术逻辑单元 [16-5]]</p>
<p>[2.3.2. 存储单元 [16-6]]</p>
<p><a href="#目录">目录</a> xxi</p>
<p>[2.3.3. 输入/输出设备 16-6]</p>
<p>[2.3.4. 控制单元 [16-6]]</p>
<p>[3. 数据结构和算法 [16-6]]</p>
<p>[3.1. 数据结构类型 [16-6]]</p>
<p>[3.2. 数据结构操作 [16-7]]</p>
<p>[3.3. 算法和算法属性 [16-7]]</p>
<p>[3.4. 算法复杂度 [16-8]]</p>
<p>[3.5. 复杂度测量 [16-8]]</p>
<p>[3.6. 算法设计 [16-8]]</p>
<p>[3.7. 排序技术 [16-9]]</p>
<p>[3.8. 搜索技术 [16-10]]</p>
<p>[3.9. 哈希 16-10]</p>
<p>[4. 编程基础和语言 [16-10]]</p>
<p>[4.1. 编程语言类型 [16-10]]</p>
<p>[4.2. 编程语法、语义、类型系统 [16-11]]</p>
<p>[4.3. 子程序和协程 [16-11]]</p>
<p>[4.4. 面向对象编程 [16-12]]</p>
<p>[4.5. 分布式编程和并行编程 [16-13]]</p>
<p>[4.6. 调试 16-13]</p>
<p>[4.7. 标准和指南 [16-13]]</p>
<p>[5. 操作系统 [16-15]]</p>
<p>[5.1. 处理器管理 [16-15]]</p>
<p>[5.2. 内存管理 [16-16]]</p>
<p>[5.3. 设备管理 [16-16]]</p>
<p>[5.4. 信息管理 [16-16]]</p>
<p>[5.5. 网络管理 [16-16]]</p>
<p>[6. 数据库管理 [16-17]]</p>
<p>[6.1. 模式 16-17]</p>
<p>[6.2. 数据模型和存储模型 [16-17]]</p>
<p>[6.3. 数据库管理系统 [16-18]]</p>
<p>[6.4. 关系数据库管理系统和规范化 [16-18]]</p>
<p>[6.5. 结构化查询语言 [16-19]]</p>
<p>[6.6. 数据挖掘和数据仓库 [16-19]]</p>
<p>[6.7. 数据库备份和恢复 [16-20]]</p>
<p>[7. 计算机网络和通信 [16-20]]</p>
<p>[7.1. 计算机网络类型 [16-20]]</p>
<p>[7.2. 网络分层架构 [16-21]]</p>
<p>[7.3. 开放系统互连模型 [16-21]]</p>
<p>[7.4. 封装和解封装 [16-22]]</p>
<p>[7.5. 应用层协议 [16-22]]</p>
<p>[7.6. 可靠和高效网络的设计技术 [16-22]]</p>
<p>[7.7. 互联网协议套件 [16-23]]</p>
<p>[7.8. 无线和移动网络 [16-23]]</p>
<p>[7.9. 安全性和漏洞 [16-23]]</p>
<p>[8. 用户和开发者人因 [16-24]]</p>
<p>[8.1. 用户人因[16-24]]</p>
<p>[8.2. 开发者人因[16-24]]</p>
<p>[9. 人工智能与机器学习[16-25]] xxii [<em>SWEBOK</em>] [<em>®</em>][
GUIDE V4.0a]</p>
<p>[9.1. 推理 16-25]</p>
<p>[9.2. 学习 16-26]</p>
<p>[9.3. 模型 16-26]</p>
<p>[9.4. 感知与问题解决[16-27]]</p>
<p>[9.5. 自然语言处理[16-27]]</p>
<p>[9.6. 人工智能与软件工程[16-27]]</p>
<p>[主题与参考材料矩阵[16-28]]</p>
<p>[参考文献 16-32]</p>
<h2 class="calibre12" id="第17章">[<strong>第17章</strong>]</h2>
<p>[[<strong>数学基础</strong> ] [[<strong>17-1</strong>]]]</p>
<p>[引言 17-1]</p>
<p>[1. 基础逻辑[17-1]]</p>
<p>[1.1. 命题逻辑[17-1]]</p>
<p>[1.2. 谓词逻辑[17-3]]</p>
<p>[2. 证明技术 17-3]</p>
<p>[2.1. 直接证明[17-4]]</p>
<p>[2.2. 反证法[17-4]]</p>
<p>[2.3. 归纳法[17-4]]</p>
<p>[2.4. 举例证明[17-5]]</p>
<p>[3. 集合、关系、函数[17-5]]</p>
<p>[3.1. 集合运算[17-6]]</p>
<p>[3.2. 集合性质[17-6]]</p>
<p>[3.3. 关系与函数[17-7]]</p>
<p>[4. 图与树[17-8]]</p>
<p>[4.1. 图 17-8]</p>
<p>[4.2. 树 17-10]</p>
<p>[5. 有限状态机 17-12]</p>
<p>[6. 语法 17-13]</p>
<p>[6.1. 语言识别[17-14]]</p>
<p>[7. 数论 17-14]</p>
<p>[7.1. 数的类型[17-15]]</p>
<p>[7.2. 整除性 17-15]</p>
<p>[7.3. 质数[17-15]]</p>
<p>[7.4. 最大公约数[17-16]]</p>
<p>[8. 计数基础 17-16]</p>
<p>[9. 离散概率 17-17]</p>
<p>[10. 数值精度、准确度与误差[17-18]]</p>
<p>[11. 代数结构 17-19]</p>
<p>[11.1. 群 17-19]</p>
<p>[11.2. 环 17-20]</p>
<p>[12. 工程微积分[17-21]]</p>
<p>[13. 新进展[17-21]]</p>
<p>[13.1. 计算神经科学[17-21]]</p>
<p>[13.2. 基因组学 17-21]</p>
<p>[主题与参考材料矩阵[17-22]]</p>
<p>[参考文献 17-22]</p>
<p><a href="#目录">目录</a> xxiii</p>
<h2 class="calibre22" id="第18章"><a href="#第18章"><strong>第18章</strong></a></h2>
<p>[[<strong>工程基础</strong> ] [[<strong>18-1</strong>]]]</p>
<p>[引言 18-1]</p>
<p>[1. 工程过程[18-1]]</p>
<p>[2. 工程设计[18-2]]</p>
<p>[2.1. 工程教育中的工程设计[18-2]]</p>
<p>[2.2. 作为问题解决活动的设计[18-3]]</p>
<p>[3. 抽象与封装[18-3]]</p>
<p>[3.1. 抽象层次[18-4]]</p>
<p>[3.2. 封装 18-4]</p>
<p>[3.3. 层次结构 18-4]</p>
<p>[3.4. 替代抽象[18-4]]</p>
<p>[4. 实证方法与实验技术[18-4]]</p>
<p>[4.1. 设计实验[18-5]]</p>
<p>[4.2. 观察性研究[18-5]]</p>
<p>[4.3. 回顾性研究[18-5]]</p>
<p>[5. 统计分析[18-5]]</p>
<p>[5.1. 分析单元(抽样单元)、总体与样本[18-5]]</p>
<p>[5.2. 相关性与回归[18-8]]</p>
<p>[6. 建模、仿真与原型设计[18-8]]</p>
<p>[6.1. 建模 18-8]</p>
<p>[6.2. 仿真[18-9]]</p>
<p>[6.3. 原型设计 18-9]</p>
<p>[7. 测量 18-10]</p>
<p>[7.1. 测量层次(量表)[18-10]]</p>
<p>[7.2. 测量理论对编程语言的影响[18-12]]</p>
<p>[7.3. 直接测量与派生测量[18-13]]</p>
<p>[7.4. 可靠性与有效性[18-14]]</p>
<p>[7.5. 评估可靠性[18-14]]</p>
<p>[7.6. 目标-问题-度量范式(Goal-Question-Metric
Paradigm)：为什么要测量？[18-15]]</p>
<p>[8. 标准 18-15]</p>
<p>[9. 根本原因分析[18-16]]</p>
<p>[9.1. 根本原因分析技术[18-16]]</p>
<p>[9.2. 基于根本原因的改进[18-17]]</p>
<p>[10. 工业4.0与软件工程[18-17]]</p>
<p>[主题与参考材料矩阵[18-18]]</p>
<p>[延伸阅读[18-19]]</p>
<p>[参考文献 18-20]</p>
<p>[<strong>附录A</strong>]</p>
<p>[[<strong>知识领域描述规范</strong> ] [[<strong>A-1</strong>]]]</p>
<p>[引言 A-1]</p>
<p>[Swebok指南是IEEE计算机协会软件工程产品套件的基础文档]</p>
<p>[基线与变更控制[A-1]] xxiv [<em>SWEBOK</em>] [<em>®</em>][ GUIDE
V4.0a]</p>
<p>[知识领域内主题分解的标准与要求[A-2]]</p>
<p>[描述主题的标准与要求[A-2]]</p>
<p>[参考材料的标准与要求[A-2]]</p>
<p>[通用结构[A-4]]</p>
<p>[“普遍认可的知识”是什么意思？[A-4]]</p>
<p>[知识领域描述的长度[A-5]]</p>
<p>[重要相关文档[A-5]]</p>
<p>[其他详细指南[A-6]]</p>
<p>[编辑 A-6]</p>
<p>[版权释放[A-6]]</p>
<p>[参考文献 A-6]</p>
<p>[<strong>附录B</strong>]</p>
<p>[[<strong>支持软件工程知识体系(SWEBOK)的IEEE和ISO/IEC标准</strong>]
]</p>
<p>[[<strong>B-1</strong>]]]</p>
<p>[1. 概述 B-1]</p>
<p>[1.1. SWEBOK与标准[B-1]]</p>
<p>[1.2. 标准类型[B-2]]</p>
<p>[1.3. 软件工程标准来源[B-2]]</p>
<p>[2. 软件工程标准全景[B-3]]</p>
<p>[3. 生命周期过程标准[B-4]]</p>
<p>[4. ISO/IEC/IEEE 12207的扩展与专业应用[B-5]]</p>
<p>[4.1. 概念与若干过程的解释[B-5]]</p>
<p>[4.2. 更专业的扩展[B-8]]</p>
<p>[4.3. 体系之体系(SoS)标准[B-9]]</p>
<p>[5. 单一过程标准[B-9]]</p>
<p>[6. 产品线、方法和工具标准[B-9]]</p>
<p>[7. 过程评估标准[B-10]]</p>
<p>[8. 专业技能与知识标准[B-11]]</p>
<p>[9. 精选软件工程标准[B-11]]</p>
<p>[<strong>附录C</strong>]</p>
<p>[[<strong>综合参考文献列表</strong> ] [[<strong>C-1</strong>]]]</p>
<p>[综合参考文献列表[C-1]]</p>
<h3 class="calibre23" id="xxv">xxv</h3>
<p>[<strong>前言</strong> ]</p>
<p>《软件工程知识体系指南(SWEBOK Guide)》由IEEE计算机协会(IEEE
CS)出版，代表了当前软件工程理论与实践相互作用下普遍接受、基于共识的知识现状。其目标包括为学习者、研究人员和从业者提供指导，以识别和分享对软件工程”普遍认可的知识”的共同理解，界定软件工程与相关学科之间的边界，并为认证和教育课程提供基础。</p>
<p>该指南的起源可以追溯到21世纪初。与软件工程学科一样，该指南在过去20年中不断演进，以反映社会在工业、教育、社会、技术和科技方面的变化。2014版指南的出版</p>
<h1 id="指南简介">指南简介</h1>
<p>《软件工程知识体系指南》(SWEBOK Guide
V3)是确立软件工程作为公认工程学科的重要里程碑。</p>
<p>开发此次更新版本(SWEBOK Guide
V4)的目标是提高指南的时效性、可读性、一致性和可用性。本指南由18个知识领域(KA)和若干附录组成。知识领域是软件工程中由其知识要求定义的可识别领域,通过其组成过程、实践、输入、输出、工具和技术来描述。三个附录分别提供了知识领域描述的规范、每个知识领域的相关标准注释集,以及本指南中引用的参考文献列表。</p>
<p>自Guide
V3出版以来,所有知识领域都已更新以反映软件工程的变化,包括现代开发实践、新技术和标准的进步。一个重大变化是敏捷(Agile)和DevOps已被纳入几乎所有知识领域,因为自上一版指南出版以来,这些模型已被广泛接受。敏捷模型通常涉及在短迭代周期内向客户频繁展示可工作的软件。敏捷实践存在于各个知识领域中。此外,新兴平台和技术,包括人工智能(AI)、机器学习(ML)和物联网(IoT),已被纳入基础知识领域。</p>
<p>为了反映在现代软件工程中变得尤为重要的领域,增加了以下知识领域:软件架构知识领域、软件安全知识领域和软件工程运营知识领域。</p>
<p>本指南在IEEE计算机协会专业与教育活动委员会的主持下编写,代表了软件工程专业演进的下一步。</p>
<p><strong>Steve McConnell</strong></p>
<p><em>Construx Software首席执行官</em></p>
<p><strong>Hironori Washizaki</strong></p>
<p><em>IEEE计算机协会2024年当选主席、2025年主席</em></p>
<p>xxvi SWEBOK® GUIDE V4.0a</p>
<h2 id="2014年版前言">2014年版前言</h2>
<p>每个专业都基于一个知识体系,尽管该知识体系并不总是以简洁的方式定义。在没有正式性的情况下,知识体系被从业者”普遍认可”,并可能以多种方式编撰用于多种不同用途。但在许多情况下,知识体系指南是正式记录的,通常以允许其用于诸如学术和培训项目的开发和认证、专家认证或专业许可等目的的形式。通常,专业协会或类似机构维护知识体系正式定义的管理权。</p>
<p>在过去四十五年中,软件工程已从一个会议流行语发展成为一个工程专业,其特征包括:1)专业协会,2)规定普遍接受的专业实践的标准,3)职业道德准则,4)会议论文集,5)教科书,6)课程指南和课程,7)认证标准和经认证的学位项目,8)认证和许可,以及9)本知识体系指南。</p>
<p>在本《软件工程知识体系指南》中,IEEE计算机协会提出了以前记录为SWEBOK
2004的知识体系的修订和更新版本;这个修订和更新版本被称为SWEBOK Guide
V3。这项工作是协会履行促进软件工程专业理论和实践进步责任的部分内容。</p>
<p>应该注意的是,本指南并未呈现软件工程的全部知识体系,而是作为四十多年来发展起来的知识体系的指南。软件工程知识体系在不断演变。尽管如此,本指南构成了对软件工程专业的宝贵特征描述。</p>
<p>1958年,世界知名统计学家John
Tukey创造了”软件”一词。软件工程一词在1968年德国举行的北约会议标题中使用。IEEE计算机协会于1972年首次出版《软件工程汇刊》,并于1976年在IEEE计算机协会内成立了制定软件工程标准的委员会。</p>
<p>1990年,开始规划一项国际标准以提供软件工程的总体视图。该标准于1995年完成,编号为ISO/IEC
12207,标题为《软件生命周期过程标准》。12207的IEEE版本于1996年出版,为SWEBOK
2004中获取的知识体系提供了主要基础。当前版本的12207编号为ISO/IEC
12207:2008和IEEE 12207-2008;它为本SWEBOK Guide V3提供了基础。</p>
<p>本《软件工程知识体系指南》呈现给您——读者,作为您作为软件工程专业人员在终身职业发展中获取所需知识的机制。</p>
<p><strong>Dick Fairley,主席</strong></p>
<p><em>软件与系统工程委员会</em></p>
<p><em>IEEE计算机协会</em></p>
<p><strong>Don Shafer,副主席</strong></p>
<p><em>专业活动委员会</em></p>
<p><em>IEEE计算机协会</em></p>
<h2 id="2004年版前言">2004年版前言</h2>
<p>在本指南中,IEEE计算机协会首次为软件工程领域的知识体系建立了基线,这项工作部分履行了协会促进该领域理论和实践进步的责任。在此过程中,协会以历史更悠久的学科的经验为指导,但既不受其问题也不受其解决方案的束缚。</p>
<p>需要注意的是，本《指南》并不声称定义知识体系本身，而是作为过去四十年来一直在发展和演进的知识体系的纲要和指南。此外，这个知识体系并非静态的。随着软件工程的成熟，《指南》必然会不断发展和演进。尽管如此，它仍然构成了软件工程基础设施的重要组成部分。</p>
<p>1958年，世界知名统计学家John
Tukey创造了”软件”(software)一词。“软件工程”(software
engineering)一词首次被用作1968年在德国举行的北约会议的标题。</p>
<p>IEEE计算机协会于1972年首次出版了《软件工程汇刊》(Transactions on
Software
Engineering)。IEEE计算机协会内部成立的软件工程标准开发委员会于1976年成立。</p>
<p>IEEE计算机协会对软件工程的首个整体性观点源于Fletcher
Buckley领导的一项工作,即制定IEEE
730软件质量保证标准,该标准于1979年完成。IEEE标准730的目的是为软件质量保证计划的准备和内容提供统一的、最低可接受的要求。该标准对完成以下主题的标准开发产生了重要影响:配置管理、软件测试、软件需求、软件设计和软件验证与确认。</p>
<p>在1981-1985年期间，IEEE计算机协会举办了一系列关于软件工程标准应用的研讨会。这些研讨会让实践者分享他们使用现有标准的经验。研讨会还举行了关于未来标准规划的会议，包括一场关于软件工程产品和过程的度量和指标(metrics)的会议。这些规划还促成了IEEE标准1002《软件工程标准分类》(Taxonomy
of Software Engineering
Standards)(1986年)的制定，该标准提供了软件工程的新的整体性观点。该标准描述了软件工程标准分类的形式和内容。它解释了各种类型的软件工程标准、它们的功能和外部关系，以及参与软件生命周期的各种职能的角色。</p>
<p>1990年，开始规划制定具有整体性观点的国际标准。规划重点是调和IEEE标准1074和修订后的美国国防部标准2167A中的软件过程观点。该修订版最终以国防部标准498的形式发布。国际标准于1995年完成，编号为ISO/IEC
12207，标题为《软件生命周期过程标准》(Standard for Software Life Cycle
Processes)。标准ISO/IEC
12207为本书所记录的知识体系提供了重要的出发点。</p>
<p>正是IEEE计算机协会理事会在1993年5月批准了Fletcher
Buckley提出的动议，才促成了本书的编写。美国计算机协会(ACM)理事会在1993年8月批准了一项相关动议。这两项动议促成了由Mario
Barbacci和Stuart
Zweben担任联合主席领导的联合委员会。联合委员会的使命声明是”建立适当的软件工程专业实践标准和规范，以此作为行业决策、专业认证和教育课程的基础。”</p>
<p>指导委员会在以下领域组织了工作组:</p>
<ol type="1">
<li>定义所需知识体系和推荐实践</li>
<li>定义伦理和专业标准</li>
<li>定义本科生、研究生和继续教育的教育课程</li>
</ol>
<p>本书提供了第一个组成部分:所需知识体系和推荐实践。</p>
<p>软件工程的职业伦理和专业实践守则于1998年完成，并获得了ACM理事会和IEEE计算机协会理事会的批准。它已被众多公司和其他组织采用，并被收录在近期的几本教科书中。</p>
<p>本科生教育课程正在由IEEE计算机协会和ACM联合完成，预计将于2004年完成。</p>
<p>每个专业都基于知识体系和推荐实践，尽管它们并非总是以精确的方式定义。在许多情况下，这些被正式记录下来，通常采用允许用于学术项目认证、教育和培训项目开发、专家认证或专业执照等目的的形式。通常，专业协会或相关机构负责维护此类正式定义。在不存在这种正式性的情况下，知识体系和推荐实践由从业者”普遍认可”，并可能以各种方式编纂用于不同用途。</p>
<p>希望读者能发现本书在引导他们获取作为软件工程专业人员在终身职业发展中所需的知识和资源方面是有用的。</p>
<p>本书献给Fletcher
Buckley，以表彰他致力于推动软件工程成为一门专业学科的承诺，以及他在雷达应用领域作为软件工程从业者的卓越表现。</p>
<p><strong>Leonard L. Tripp, IEEE Fellow 2003</strong></p>
<p><em>IEEE计算机协会专业实践委员会主席 (2001-2003)</em></p>
<p><em>IEEE计算机协会和ACM联合指导委员会主席</em></p>
<p><em>推动软件工程成为一门专业 (1998-1999)</em></p>
<p><em>IEEE计算机协会软件工程标准委员会主席</em></p>
<p><em>(1992-1998)</em></p>
<div class="page-separator"></div>
<p><strong>编辑</strong></p>
<p>Hironori Washizaki，<em>早稻田大学</em> / <em>国立信息学研究所</em> /
<em>eXmotion</em> /</p>
<p><em>日本人类环境大学</em>, <a href="mailto:washizaki@waseda.jp"><em>washizaki@waseda.jp</em></a></p>
<h2 id="知识领域编辑">知识领域编辑</h2>
<h3 id="软件需求">软件需求</h3>
<p>Steve Tockey, <em>Construx Software, 美国</em></p>
<h3 id="软件架构">软件架构</h3>
<p>Rich Hilliard, <em>美国</em></p>
<h3 id="软件设计">软件设计</h3>
<p>Rich Hilliard, <em>美国</em></p>
<h3 id="软件构造">软件构造</h3>
<p>Xin Peng, <em>中国复旦大学软件学院</em></p>
<p>Steve Schwarm, <em>Synopsys - Black Duck Software, 美国</em></p>
<h3 id="软件测试">软件测试</h3>
<p>Eda Marchetti, <em>ISTI-CNR, 意大利</em></p>
<p>Said Daoudagh, <em>ISTI-CNR, 意大利</em></p>
<h3 id="软件工程运维">软件工程运维</h3>
<p>Francis Bordeleau, <em>加拿大高等技术学院 (ÉTS)</em></p>
<p>Alain April, <em>加拿大高等技术学院 (ÉTS)</em></p>
<h3 id="软件维护">软件维护</h3>
<p>Ali Ouni, <em>加拿大高等技术学院 (ÉTS)</em></p>
<p>Alain April, <em>加拿大高等技术学院 (ÉTS)</em></p>
<p>Peter Leather, <em>Exceptional Performance, 英国</em></p>
<h3 id="软件配置管理">软件配置管理</h3>
<p>Maria Isabel Sánchez Segura, <em>西班牙马德里卡洛斯三世大学</em></p>
<p>Bob Aiello, <em>CM Best Practices, 美国</em></p>
<h3 id="软件工程管理">软件工程管理</h3>
<p>Kenneth E. Nidiffer, <em>美国乔治梅森大学</em></p>
<h3 id="软件工程过程">软件工程过程</h3>
<p>Juan Garbajosa, <em>西班牙马德里理工大学</em></p>
<h3 id="软件工程模型和方法-1">软件工程模型和方法</h3>
<p>Hironori Washizaki, <em>日本早稻田大学</em></p>
<p>Akinori Ihara, <em>日本和歌山大学</em></p>
<p>Shinpei Ogata, <em>日本信州大学</em></p>
<p>xxx [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<h3 id="软件质量-1">软件质量</h3>
<p>Alain April, <em>加拿大高等技术学院 (ÉTS)</em></p>
<p>Steve Tockey, <em>Construx Software, 美国</em></p>
<p>Steve Schwarm, <em>Synopsys - Black Duck Software, 美国</em></p>
<h3 id="软件安全-1">软件安全</h3>
<p>Nobukazu Yoshioka, <em>日本早稻田大学</em></p>
<p>Seiji Munetoh, <em>IBM Research, 日本</em></p>
<h3 id="软件工程专业实践">软件工程专业实践</h3>
<p>Katsuhisa Shintani, <em>日本早稻田大学</em></p>
<p>Eiji Hayashiguchi, <em>日本早稻田大学</em></p>
<h3 id="软件工程经济学">软件工程经济学</h3>
<p>Maria Isabel Sánchez Segura, <em>西班牙马德里卡洛斯三世大学</em></p>
<p>Steve Tockey, <em>Construx Software, 美国</em></p>
<h3 id="计算基础">计算基础</h3>
<p>Yatheendranath TJ, <em>DhiiHii Labs Private Limited, 印度</em></p>
<h3 id="数学基础">数学基础</h3>
<p>Yatheendranath TJ, <em>DhiiHii Labs Private Limited, 印度</em></p>
<p>Steve Tockey, <em>Construx Software, 美国</em></p>
<h3 id="工程基础">工程基础</h3>
<p>Yatheendranath TJ, <em>DhiiHii Labs Private Limited, 印度</em></p>
<p>Steve Tockey, <em>Construx Software, 美国</em></p>
<h3 id="附录a知识领域描述规范">附录A：知识领域描述规范</h3>
<p>Juan Garbajosa, <em>西班牙马德里理工大学</em></p>
<p>Hironori Washizaki, <em>日本早稻田大学</em></p>
<h3 id="附录b支持swebok的ieee和isoiec标准">附录B：支持SWEBOK的IEEE和ISO/IEC标准</h3>
<p>Annette Reilly, <em>美国</em></p>
<h3 id="附录c综合参考文献列表">附录C：综合参考文献列表</h3>
<p>Hironori Washizaki, <em>日本早稻田大学</em></p>
<h2 id="贡献编辑">贡献编辑</h2>
<p>以下人员为<em>SWEBOK指南V4</em>的编辑工作做出了贡献：</p>
<p>Michelle Phon</p>
<p>Eric Berkowitz</p>
<h2 id="指导小组">指导小组</h2>
<p>以下专家在项目初期组成<em>SWEBOK指南V4</em>指导小组，为指南的初始架构提供指导：</p>
<p>Hironori Washizaki V.S. Mani Juan Garbajosa</p>
<p>Yatheendranath TJ Hari Prasad Devarapalli Maria Isabel Sánchez
Segura</p>
<p>Rich Hilliard Annette Reilly Peter Leather</p>
<p>Kenneth Nidiffer Narendra S Chowdhury Andy Chen</p>
<p>Pete Brink Dharanipragada Janakiram Steve Schwarm</p>
<h2 id="swebok早期版本的知识领域编辑">SWEBOK早期版本的知识领域编辑</h2>
<p>以下人员曾担任2001年发布的试用版、2004年版本和/或2014年版本（SWEBOK
V3）的知识领域编辑。所列单位为各人员担任知识领域编辑时所属的单位。</p>
<h3 id="软件需求-1">软件需求</h3>
<p>Peter Sawyer, <em>英国兰卡斯特大学计算系</em></p>
<p>Gerald Kotonya, <em>英国兰卡斯特大学计算系</em></p>
<h3 id="软件设计-1">软件设计</h3>
<p>Guy Tremblay, <em>加拿大魁北克大学蒙特利尔分校信息学系</em></p>
<p>Yanchun Sun, <em>中国北京大学电子工程与计算机科学学院</em></p>
<h3 id="软件构造-1">软件构造</h3>
<p>Steve McConnell, <em>Construx Software, 美国</em></p>
<p>Terry Bollinger, <em>the MITRE Corporation, 美国</em></p>
<p>Philippe Gabrini, <em>加拿大魁北克大学蒙特利尔分校信息学系</em></p>
<p>Louis Martin, <em>加拿大魁北克大学蒙特利尔分校信息学系</em></p>
<p>Xin Peng, <em>中国复旦大学软件学院</em></p>
<h3 id="软件测试-1">软件测试</h3>
<p>Antonia Bertolino, <em>ISTI-CNR, 意大利</em></p>
<p>Eda Marchetti, <em>ISTI-CNR, 意大利</em></p>
<h3 id="软件维护-1">软件维护</h3>
<p>Thomas M. Pigoski, <em>Techsoft Inc., 美国</em></p>
<p>Alain April, <em>加拿大高等技术学院</em></p>
<p>Mira Kajko-Mattsson, <em>瑞典皇家理工学院信息与通信技术学院</em></p>
<h3 id="软件配置管理-1">软件配置管理</h3>
<p>John A. Scott, <em>美国劳伦斯利弗莫尔国家实验室</em></p>
<p>David Nisse, <em>美国</em></p>
<p>Roger Champagne, <em>加拿大高等技术学院 (ÉTS)</em></p>
<p>Alain April, <em>加拿大高等技术学院 (ÉTS)</em></p>
<p>xxxii [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<h3 id="软件工程管理-1">软件工程管理</h3>
<p>Dennis Frailey, <em>Raytheon Company, 美国</em></p>
<p>Stephen G. MacDonell, <em>新西兰奥克兰理工大学</em></p>
<p>Andrew R. Gray, <em>新西兰奥塔哥大学</em></p>
<p>James McDonald, <em>美国蒙莫斯大学计算机科学与软件工程系</em></p>
<h3 id="软件工程过程-1">软件工程过程</h3>
<p>Khaled El Emam, <em>曾任职于加拿大国家研究委员会</em></p>
<p>Annette Reilly, <em>Lockheed Martin Information Systems &amp; Global
Solutions, 美国</em></p>
<p>Richard E. Fairley, <em>Software and Systems Engineering Associates
(S2EA), 美国</em></p>
<h3 id="软件工程工具和方法">软件工程工具和方法</h3>
<p>David Carrington,
<em>澳大利亚昆士兰大学信息技术与电气工程学院</em></p>
<p>Michael F. Siok, <em>Lockheed Martin Aeronautics Company,
美国</em></p>
<h3 id="软件质量-2">软件质量</h3>
<p>Alain April, <em>加拿大高等技术学院</em></p>
<p>Dolores Wallace, <em>退休于美国国家标准与技术研究院</em></p>
<p>Larry Reeker, <em>NIST, 美国</em></p>
<p>J. David Blaine, <em>美国</em></p>
<p>Durba Biswas, <em>Tata Consultancy Services, 印度</em></p>
<p><strong>软件工程专业实践</strong></p>
<p>Aura Sheffield，<em>美国</em></p>
<p>Hengming Zou，<em>上海交通大学，中国</em></p>
<p><strong>软件工程经济学</strong></p>
<p>Christof Ebert，<em>Vector Consulting Services，德国</em></p>
<p><strong>计算基础</strong></p>
<p>Hengming Zou，<em>上海交通大学，中国</em></p>
<p><strong>数学基础</strong></p>
<p>Nabendu Chaki，<em>加尔各答大学，印度</em></p>
<p><strong>工程基础</strong></p>
<p>Amitava Bandyopadhayay，<em>印度统计研究所，印度</em> Mary Jane
Willshire，<em>软件和系统工程协会（S2EA），美国</em></p>
<p><strong>附录B：支持SWEBOK的IEEE和ISO/IEC标准</strong></p>
<p>James W. Moore，<em>美国</em></p>
<p><strong>参考文献编辑</strong></p>
<p>Marc Bouisset，<em>魁北克大学蒙特利尔分校信息学系</em></p>
<h2 id="审阅团队">审阅团队</h2>
<p>下列人员参与了《SWEBOK指南V4》的公开审阅过程。</p>
<p>参与此审阅过程不要求IEEE计算机协会的会员资格，也未要求审阅者提供会员信息。共收集并妥善处理了超过1300条个人意见。</p>
<p>Aakashjit Bhattacharya, Hector Teran, Micheal Tuape</p>
<p>Adil Aliyev, Helmut Neukirchen, Mirna Muñoz</p>
<p>Alaa Mahjoub, Hernan Guarda, Mohammad Samarah</p>
<p>Alberto Córdoba Izaguirre, Hiroyuki Sato, Muthu Ramachandran</p>
<p>Ang Boon Chong, Hossein Saiedian, Myneni Madhu Bala</p>
<p>Antonio Navarro, Ian Hirst, Nancy Mead</p>
<p>Arjun Remadevi Somanathan, Irina Marudina, Nandakumar Ramanathan</p>
<p>Atilla Elci, Jack McKenzie, Nauman Ahmad</p>
<p>Beatri Beltrán Martínez, Jack Pope, Nenad Medvidović</p>
<p>Biswaranjan Senapati, James C Davis, Nicolae Giurescu</p>
<p>Brandon Thorin Klein, James Purtilo, Norha Villegas</p>
<p>Brian Kirkpatrick, Jason Adcock, Omar</p>
<p>Carol Woody, Javier Gonzalez Huerta, Oscar A. Schivo</p>
<p>ChandraSR K, Joanna Isabelle Olszewska, Pankaj Kamthan</p>
<p>Christof Ebert, Joanna Leng, Paola Britos</p>
<p>Clive Boughton, Joao Marcelo Borovina Josko, Peter Schoo</p>
<p>Dale Dzielski, Jon D Hagar, Phillip A. Laplante</p>
<p>Daniel Medeiros Rocha, Jonathan Oliver, Pieter Botman</p>
<p>David Budgen, Joshua Cook, Piotr Karocki</p>
<p>David Mack Endres, Juris Borzovs, Prashant Verma</p>
<p>Dmytro Lenda, Kamidi Raja, Qusay F. Hassan</p>
<p>Duncan Hall, Karol Szkudlarek, Radoslav Rakovic</p>
<p>Ed Zuk, Kiyoshi Endo, Ravindra Joshi</p>
<p>Eka Arriyanti, Kiyoshi Honda, Reddy Gowrigari</p>
<p>Elena Williams, Konstantinos Domdouzis, Ren-Her Hwang</p>
<p>Emmanuelle Wintergerst, Kun Hsiang Wu, Rik Essenius</p>
<p>Ernesto Cuadros-Vargas, Lolita Narag, Robert Lemay</p>
<p>Fabrício Laguna, Magesh Kasthuri, Rodrigo Martins Pagliares</p>
<p>Fabricio Lantieri, Maher Ben Abdessalem, Roland Illig</p>
<p>Fedor Dzerzhinskiy, Manu Mitra, Rupesh Sreeraman</p>
<p>Fernando Pinciroli, Marc Blumberg, Samuel J. Crawford</p>
<p>Francisco Valdés-Souto, Marcia Ito, Saurabh Kumar</p>
<p>Gabriel Tamura, Maria-Isabel Sanchez-Segura, Shailendra
Suryawanshi</p>
<p>Gavin Howard, Martin Kropp, Shelly Sachdeva</p>
<p>Gopal T V, Masahiko Ishikawa, Sheydi Anel Zamudio López</p>
<p>Graham Lee, Matteo Große-Kampmann, Sravan Kumar Reddy</p>
<p>Stefan Malich, Takehisa Okazaki, Vivienne Bičak</p>
<p>Stefano Pietroiusti, Tarig Ahmed Khalid, Walter Green</p>
<p>Steffen Becker, Tateki Sano, Weihan Goh</p>
<p>Steve France, Tetsu Nagata, Weijia Yang</p>
<p>Sudheer Kumar, Thomas M. Prinz, William Uemura</p>
<p>Susanne Müller, Tim Bond, Yarlagadda Padma Sai</p>
<p>Sushil Birla, Trent Leopold, Yasuko Okazaki</p>
<p>Syed Mohamed Thameem, Tyler Thomas Procko, Yuseon Yu</p>
<p>Nizamudeen, Vivek Dave, Zheng Wang</p>
<h2 id="致谢">致谢</h2>
<p>《SWEBOK指南V4》的开发资金由IEEE计算机协会提供。编辑团队感谢知识领域编辑和贡献编辑所做的重要工作，以及指导小组成员的贡献。编辑团队还感谢审阅者不可或缺的贡献。</p>
<p>最后，肯定还有其他直接或间接为本指南做出贡献的人员，我们无意中遗漏了他们的名字。对于这些人，我们表示默默的感谢，并为遗漏明确的致谢而道歉。</p>
<p><strong>IEEE计算机协会主席</strong></p>
<p>Leila De Floriani，<em>2020年主席</em></p>
<p>Forrest Shull，<em>2021年主席</em></p>
<p>William “Bill” Gropp，<em>2022年主席</em></p>
<p>Nita Patel，<em>2023年主席</em></p>
<p>Jyotika Athavale，<em>2024年主席</em></p>
<p>Hironori Washizaki，<em>2025年主席</em></p>
<p><strong>专业与教育活动委员会2024年成员</strong></p>
<p>Cyril Onwubiko，<em>主席</em> Sao-Jie Chen, Kwabena Boateng, Deborah
Silver, Akinori Ihara, Eric Berkowitz, Hironori Washizaki, Kiyoshi
Honda, Michelle Phon, Rajendra Raj, Andrew Seely, Ernesto
Cuadros-Vargas, Megha Ben</p>
<h2 id="关于批准swebok指南v40的决议">关于批准SWEBOK指南V4.0的决议</h2>
<p><strong>IEEE计算机协会专业与教育活动委员会于2024年9月一致通过以下决议：</strong></p>
<p><em>IEEE计算机协会专业活动委员会认定《软件工程知识体系指南4.0版》已成功完成；批准《软件工程知识体系指南4.0版》，并推荐给IEEE计算机协会理事会批准。</em></p>
<p><strong>IEEE计算机协会理事会于2024年10月通过以下决议：</strong></p>
<p><em>动议：IEEE计算机协会理事会批准《软件工程知识体系指南4.0版》，并授权专业活动委员会主席进行印刷出版。</em></p>
<h2 id="关于批准swebok指南v30的决议">关于批准SWEBOK指南V3.0的决议</h2>
<p>《SWEBOK指南V3.0》于2013年11月提交给经验证的IEEE计算机协会成员进行投票，投票问题为：“您是否批准《SWEBOK指南V3.0》手稿进入排版和出版阶段？”投票结果为259票赞成，5票反对。</p>
<p><strong>IEEE计算机协会专业活动委员会于2013年12月一致通过以下决议：</strong></p>
<p><em>IEEE计算机协会专业活动委员会认定《软件工程知识体系指南</em></p>
<p><strong>关于SWEBOK指南2004版本的批准动议</strong></p>
<p><strong>SWEBOK指南项目工业咨询委员会于2004年2月一致通过以下动议：</strong></p>
<p><em>工业咨询委员会认为，1998年启动的软件工程知识体系项目已成功完成；并认可《SWEBOK指南》2004版，向IEEE计算机协会理事会推荐批准。</em></p>
<p><strong>IEEE计算机协会理事会于2004年2月通过以下动议：</strong></p>
<p><em>动议：IEEE计算机协会理事会批准《软件工程知识体系指南》2004版，并授权专业实践委员会主席进行印刷。</em></p>
<p>另请注意，《软件工程知识体系指南》2004版由IEEE计算机协会提交给ISO/IEC，未作任何修改，并被认可为技术报告ISO/IEC
TR 19759:2005。</p>
<h2 id="指南简介-1">指南简介</h2>
<p><strong>缩略词</strong></p>
<ul>
<li>KA：知识领域（Knowledge Area）</li>
<li>SWEBOK：软件工程知识体系（Software Engineering Body of
Knowledge）</li>
</ul>
<p>2014年版《软件工程知识体系指南》（SWEBOK指南V3）的出版是将软件工程确立为公认工程学科的重要里程碑。开发本次更新（第4版）的目标是提高《SWEBOK指南》的时效性、可读性、一致性和可用性。《指南》的内容包括18个知识领域（KA）以及若干附录。知识领域是软件工程的一个确定领域，以其普遍接受的知识来描述，例如其组成过程、实践、输入、输出、工具和技术。三个附录分别提供了知识领域描述的规范、每个知识领域的相关标准注释集以及《指南》中引用的参考文献列表。</p>
<p>所有知识领域都已更新，以反映自《指南V3》出版以来软件工程的变化，包括现代开发实践、新技术和标准的进步。一个重要变化是，敏捷（Agile）和开发运维（DevOps）已被纳入几乎所有知识领域，因为这些模型自上一版《指南》出版以来已被广泛接受。敏捷模型通常涉及在短迭代周期内向客户频繁展示可工作的软件。敏捷实践存在于各个知识领域。此外，新兴平台和技术，包括人工智能（AI）、机器学习（ML）和物联网（IoT），已被纳入基础知识领域。</p>
<p>为反映在现代软件工程中变得特别重要的领域，添加了以下知识领域：软件架构知识领域、软件安全知识领域和软件工程运维知识领域。</p>
<p>本《指南》在IEEE计算机协会专业与教育活动委员会的支持下编写，代表了软件工程专业发展的下一步。</p>
<h2 id="1-什么是软件工程">1. 什么是软件工程？</h2>
<p>ISO/IEC/IEEE系统与软件工程词汇表（SEVOCAB）[1]
将软件定义为”计算机程序、过程以及可能相关的文档和数据，用于计算机系统的操作”[1]。软件工程被定义为”对软件的开发、运行和维护应用系统化的、规范的、可量化的方法；即将工程应用于软件”[1]。历史上，软件工程有各种定义，例如”将科学知识实际应用于计算机程序的设计和构造，以及开发、操作和维护它们所需的相关文档”[2]，以及”涉及软件产品系统化生产和维护的技术和管理学科，这些产品按时并在成本估算范围内开发和修改”[3]。尽管这些定义在细节上有所不同，但它们有一个基本共同点，即都涉及软件开发和维护。此外，科学知识的应用（第一个定义中提到的）可以描述为技术学科（第二个定义中使用的短语）。</p>
<p>人工智能（AI）、机器学习（ML）和物联网（IoT）已被纳入基础知识领域。为反映在现代软件工程中变得特别重要的领域，添加了以下知识领域：软件架构知识领域、软件安全知识领域和软件工程运维知识领域。</p>
<p>本《指南》在IEEE计算机协会专业与教育活动委员会的支持下编写，代表了软件工程专业发展的下一步。</p>
<p>同行评审和评估质量成本是几个与计算机科学几乎无关的关键软件工程实践的例子。在工程中，科学和实践被应用于为现实世界问题生成潜在解决方案，工程经济学用于识别</p>
<p>[1] https://www.computer.org/sevocab</p>
<p>系统化和可量化的方法，最初的定义也表达了该学科过去定义中的一个共同理念。</p>
<p>软件工程占据着一个位置，一方面是计算机科学和技术的数学和物理学科，另一方面是应用这些发现来解决特定应用领域问题的工作[3]。科学是关于发现新事物的。另一方面，工程是关于应用这些知识以有限的资源有效地解决现实世界问题。因此，给定科学领域的工程学科需要关于相关”实践”的技能和知识。此外，由于工程关注的是现实世界问题的成本效益解决方案，所有工程学科都涉及工程经济学(Engineering
Economics)，即对理论上可行的解决方案进行分析，以确定最具成本效益的方案。从本质上讲，本指南将计算机科学和工程的相关理论提炼到三个基础知识领域中，而其余的知识领域则对软件工程的实践和工程经济学进行分类。</p>
<p>软件工程技术可以被视为更通用学科技术的专业化，例如项目管理、系统工程和质量管理[3]。此外，软件项目必须实现由跨领域学科施加的需求，例如可靠性和安全性。软件工程和计算机科学是相关但不同的，就像化学工程和化学是相关但不同的一样。科学学科，如计算机科学和化学，旨在扩展人类知识。有效的需求获取技术、诸如内聚和耦合之类的设计原则、适当的分支合并策略、进行适当的最具成本效益的解决方案。同样，派遣化学家去解决化学工程问题是没有意义的，派遣计算机科学家去解决软件工程问题也是没有意义的。</p>
<p>除了计算机科学之外，软件工程还与其他几个学科和专业领域相关，例如工业工程、可靠性工程以及安全和保障工程。</p>
<h2 id="2-swebok指南的目标是什么">2. SWEBOK指南的目标是什么？</h2>
<p>本指南不应与知识体系本身混淆，后者存在于已发表的文献中。本指南的目的是描述知识体系中普遍接受的部分，组织该部分，并提供对其的主题访问。</p>
<p>SWEBOK指南的建立具有以下五个目标：</p>
<ol type="1">
<li>促进全球对软件工程的一致看法</li>
<li>明确软件工程相对于其他学科（如计算机科学、项目管理、计算机工程和数学）的范围和地位</li>
<li>描述软件工程学科的内容特征</li>
<li>提供对软件工程知识体系的主题访问</li>
<li>为课程开发以及个人认证和许可材料提供基础</li>
</ol>
<p>第一个目标，即促进全球对软件工程的一致看法，得到了一个开发过程的支持，该过程吸引了来自不同</p>
<p><a href="#引言">引言</a> xxxix</p>
<p>国家的130多位审稿人。有关开发过程的更多信息可以在www.swebok.org找到。参与软件工程的专业和学术协会以及公共机构被联系，被告知这个更新SWEBOK指南的项目，并被邀请参与审查过程。副编辑从美洲、亚洲、欧洲和大洋洲招募。在各种国际场合对该项目进行了介绍。</p>
<p>第二个目标，即明确软件工程的范围，是本指南基本组织的基础。属于该学科的材料被组织到表I.1中列出的18个知识领域中。每个知识领域在本指南中作为一个章节处理。其中，第1-15章被视为软件工程知识领域，而第16-18章涉及基础知识领域。</p>
<p><strong>表I.1. 18个SWEBOK知识领域</strong></p>
<ol type="1">
<li>软件需求</li>
<li>软件架构</li>
<li>软件设计</li>
<li>软件构造</li>
<li>软件测试</li>
<li>软件工程运维</li>
<li>软件维护</li>
<li>软件配置管理</li>
<li>软件工程管理</li>
<li>软件工程过程</li>
<li>软件工程模型和方法</li>
<li>软件质量</li>
<li>软件安全 14-18章（未在此段显示）</li>
</ol>
<p>在明确学科范围时，识别与软件工程相交的学科也很重要。为此，SWEBOK
V4指南继续承认11个相关学科，如表I.2所示。软件工程师当然应该了解这些学科（本指南中的知识领域描述可能会提到它们）。然而，描述相关学科的知识不是SWEBOK指南的目标。</p>
<p><strong>表I.2. 相关学科</strong></p>
<ul>
<li>业务分析</li>
<li>计算机工程</li>
<li>计算机科学</li>
<li>网络安全</li>
<li>数据科学</li>
<li>通用管理</li>
<li>信息系统和技术</li>
<li>数学</li>
<li>项目管理</li>
<li>质量管理</li>
<li>系统工程</li>
</ul>
<p>计算机科学、数学和工程基础的相关要素在本指南的计算基础知识领域、数学基础知识领域和工程基础知识领域中呈现（第16、17和18章）。</p>
<h2 id="层次化组织">层次化组织</h2>
<p>知识领域章节的组织支持</p>
<h1 id="14-软件工程专业实践">14. 软件工程专业实践</h1>
<p>第三个项目目标——描述软件工程的内容特征。项目编辑团队向副编辑提供的关于知识领域(KA)描述内容的详细规范可以在附录A中找到。</p>
<p>本《指南》使用分层组织结构将每个知识领域分解为一组具有可识别标签的主题。每个知识领域提供两级或三级分解，这为查找感兴趣的主题提供了合理的方式。</p>
<h1 id="15-软件工程经济学">15. 软件工程经济学</h1>
<h1 id="16-计算基础">16. 计算基础</h1>
<h1 id="17-数学基础">17. 数学基础</h1>
<h1 id="18-工程基础">18. 工程基础</h1>
<p>xl <em>SWEBOK® 指南 V4.0a</em></p>
<p>本《指南》以与主要思想流派兼容的方式处理选定的主题，并将主题分为通常在行业、软件工程文献和标准中发现的子主题。这些分解不是为特定的应用领域、业务用途、管理理念、开发方法等设计的。每个主题描述仅旨在让读者对该主题有一般性的理解，并使读者能够找到参考资料。知识主体存在于参考资料中，而不是在《指南》中。</p>
<p>请注意，本《指南》并不试图在引用方面做到全面。许多合适且优秀的材料未被引用。但是，综合参考文献列表中包含的材料提供了有关所述主题的更多信息。</p>
<h2 id="处理深度">处理深度</h2>
<p>为了实现《指南》的第五个目标——为课程开发、认证和许可提供基础——已应用了”普遍接受”的知识标准。这不同于高级和研究知识(基于成熟度)以及专业知识(基于应用的普遍性)。等效术语”普遍认可”来自项目管理协会:[2]</p>
<p>软件在各种应用和技术领域中发挥核心作用,如汽车、法律、医疗保健和金融。应用领域和业务模式(例如定制应用程序和开源应用程序)以及系统类型(例如企业和云系统、嵌入式和物联网系统以及基于AI/ML的系统)的差异可能会影响采用哪些实践。某些系统类型特有的主要特殊技术和实践也在一些知识领域中讨论,特别是软件需求知识领域、软件测试知识领域、软件质量知识领域、软件安全知识领域和计算基础知识领域。</p>
<p>“普遍认可意味着所述知识和实践适用于大多数项目的大多数情况,并且对其价值和有用性存在共识。”</p>
<p>然而,术语”普遍接受”和”普遍认可”并不意味着指定的知识应统一应用于所有软件工程工作——每个项目的需求决定应用什么知识以及如何应用。但是,有能力的软件工程师应具备这些知识以供潜在应用。因此,在毕业生获得四年工作经验后参加的软件工程专业认证和许可考试的学习材料中应包括适当选择的普遍接受的知识。</p>
<h2 id="参考资料和矩阵">参考资料和矩阵</h2>
<p>为了提供对知识的主题访问——第四个项目目标——《指南》为每个知识领域确定了权威参考资料。此外,附录C为整个《指南》提供了综合参考文献列表。每个知识领域都包括来自综合参考文献列表的相关参考文献,以及将参考资料与所涵盖主题连接起来的矩阵。</p>
<h2 id="知识领域描述的结构">知识领域描述的结构</h2>
<p>每一章提供一个知识领域的描述。这些描述的结构如下。</p>
<p>[2]
[《项目管理知识体系指南》,第7版,项目管理协会,2021年,www.pmi.org.]</p>
<p>引言
xl《指南》简要定义了知识领域,并概述了其范围及其与其他知识领域的关系。</p>
<p>每个知识领域中主题的分解构成了知识领域描述的核心,显示了知识领域分解为子领域、主题和子主题。对于每个主题或子主题,给出简短描述,以及一个或多个参考文献。</p>
<p>这些参考资料被选为与该主题相关知识的最佳可用呈现。矩阵将主题与参考资料链接起来。</p>
<p>每个知识领域描述的最后部分是推荐参考文献和建议进一步阅读的列表。每个知识领域的相关标准在《指南》的附录B中呈现。</p>
<h2 id="附录a-知识领域描述规范">附录A. 知识领域描述规范</h2>
<p>附录A描述了编辑团队向副编辑提供的关于知识领域描述的内容、推荐参考文献、格式和风格的规范。</p>
<h2 id="附录b-ieee和isoiec标准">附录B. IEEE和ISO/IEC标准</h2>
<p>为《SWEBOK指南》的每个知识领域提供了IEEE计算机协会和ISO的标准列表。</p>
<h2 id="附录c-综合参考文献列表">附录C. 综合参考文献列表</h2>
<p>附录C包含知识领域中引用的推荐参考文献的综合列表。这些参考文献在正文中用星号(*)标记。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] ISO/IEC/IEEE, “ISO/IEC/IEEE
24765:2017系统与软件工程——词汇表”,第2版,2017年。</p>
<p>[2] Barry W. Boehm, “软件工程”, <em>IEEE计算机学报</em>, 卷C-25,
第12期, 1976年。</p>
<p>[3] James W. Moore, “软件工程标准:用户路线图”, IEEE计算机协会,
1998年。</p>
<p>附录B列出了相关标准的注释列表，主要来自IEEE</p>
<h2 id="第01章-1"><strong>第01章</strong></h2>
<p>软件需求</p>
<p><strong>缩略语</strong></p>
<ul>
<li>ATDD：验收测试驱动开发(Acceptance Test Driven Development)</li>
<li>BDD：行为驱动开发(Behavior Driven Development)</li>
<li>CIA：机密性、完整性和可用性(Confidentiality, Integrity, and
Availability)</li>
<li>FSM：功能规模测量(Functional Size Measurement)</li>
<li>INCOSE：国际系统工程理事会(International Council on Systems
Engineering)</li>
<li>JAD：联合应用开发(Joint Application Development)</li>
<li>JRP：联合需求规划(Joint Requirements Planning)</li>
<li>SME：主题专家(Subject Matter Expert)</li>
<li>TDD：测试驱动开发(Test Driven Development)</li>
<li>SysML：系统建模语言(Systems Modeling Language)</li>
<li>UML：统一建模语言(Unified Modeling Language)</li>
</ul>
<p><strong>引言</strong></p>
<p>软件需求应从两个角度来看。第一个角度是将其作为对软件产品或项目的需求和约束的表达，这些需求和约束有助于解决现实世界的问题。第二个角度是开发和维护软件产品需求以及构建该产品的项目所需的活动。本知识领域(KA)呈现了这两个角度。</p>
<p>如果团队在确定需求方面做得不好，项目、产品或两者都可能遭受额外成本、延误、取消和缺陷。原因之一是每个软件产品需求通常会导致许多设计决策。每个设计决策通常会导致许多代码级决策。每个决策还可能涉及多个测试决策。换句话说，正确确定需求是高风险的工作。如果不及早发现和修复，缺失的、误解的和不正确的需求可能会导致指数级的级联返工来纠正它们。</p>
<p>现实世界的软件项目往往会遭受两个主要的需求相关问题：</p>
<ol type="1">
<li>不完整性：利益相关者的需求和必要的细节没有被揭示并传达给软件工程师；</li>
<li>模糊性：需求的传达方式可能有多种解释，但只有一种可能的解释是正确的。</li>
</ol>
<p>除了需求在初始软件构建中发挥的明显短期作用外，它们在长期维护中也发挥着不太被认可但仍然重要的作用。在接收到没有任何支持文档的软件时，软件工程师有几种方法来确定代码的功能，例如执行它、使用调试器逐步执行它、手工执行它、静态分析它等等。挑战在于确定代码的<em>预期功能</em>。通常称为<em>bug</em>的东西——更准确地说应该称为<em>缺陷</em>——只是软件预期功能与实际功能之间可观察到的差异。需求文档在软件整个服务生命周期中的作用是为维护代码的软件工程师捕获和传达意图，这些工程师可能不是代码的原始作者。</p>
<p>1-1</p>
<p>1-2 <em>SWEBOK® GUIDE V4.0a</em></p>
<p>软件需求KA关注开发软件需求并在软件服务生命周期内管理这些需求。本KA提供了对软件需求的理解：</p>
<p>•
不一定是软件开发生命周期的离散前端活动，而是在项目开始时启动的过程，通常在软件的整个服务生命周期内继续细化；
• 需要根据组织和项目上下文进行定制。</p>
<p>术语<em>需求工程</em>(requirements
engineering)通常用来表示对需求的系统化处理。为了保持一致性，本KA将不使用术语<em>工程</em>(engineering)，除非是指软件工程本身。</p>
<p>软件需求KA与软件架构、软件设计、软件构造、软件测试和软件维护KA以及软件工程模型和方法KA中的模型主题关系最为密切，因为以模型形式指定需求可能具有很高的价值。</p>
<p>本KA还与软件工程过程KA中的软件生命周期主题相关，因为本KA的重点是<em>什么</em>以及<em>如何</em>完成需求工作，而项目的生命周期决定<em>何时</em>完成该工作。例如，在瀑布生命周期中，所有需求工作基本上都在离散的<em>需求阶段</em>完成，并且预期在该阶段基本完成。</p>
<p>项目中软件需求工作的<em>什么</em>和<em>如何</em>应该由所构建软件的性质决定，而不是由构建它的生命周期决定。就需求文档捕获和传达软件意图而言，下游维护人员不应该仅从需求形式就能辨别出早期开发中使用的生命周期。</p>
<p>本KA还与软件配置管理、软件工程管理和软件质量KA相关，但关系稍弱。软件配置管理方法可以应用于跟踪和管理需求；软件质量关注需求的形式如何良好，工程管理可以使用需求状态来评估项目的完成情况。</p>
<p><strong>软件需求的主题分解</strong></p>
<p>软件需求KA的主题分解如图1.1所示。</p>
<p><strong>1. 软件需求基础</strong></p>
<p><em>1.1. 软件需求的定义</em></p>
<p>正式地说，<em>软件需求</em>已被定义为：</p>
<p>• 用户为解决问题或实现目标所需的条件或能力； •
系统或系统组件为满足合同、标准、规范或其他正式文件所必须具备或拥有的条件或能力；</p>
<h1 id="软件需求-2">软件需求</h1>
<p>在任何后续阶段的架构、设计和构建工作之前完成。在某些迭代式生命周期中，初始的高层级需求工作在<strong>启动阶段</strong>完成，进一步细化则在一个或多个<strong>细化阶段</strong>完成。在敏捷生命周期中，需求工作是增量式、即时完成的，随着每个功能元素的构建而进行。</p>
<h2 id="软件需求定义">软件需求定义</h2>
<p><strong>需求</strong>的正式定义包括：</p>
<ul>
<li>满足合同、标准、规范或其他正式强制文档所需的组件能力</li>
<li>如上述(1)或(2)所述的文档化表示或能力</li>
</ul>
<p>本知识领域(KA)将这一正式定义扩展为包括软件项目需求和约束的表达。</p>
<h2 id="软件需求知识体系结构">软件需求知识体系结构</h2>
<figure>
<img alt="图1.1. 软件需求知识领域主题分解" src="软件需求主题分解图"/>
<figcaption aria-hidden="true">图1.1.
软件需求知识领域主题分解</figcaption>
</figure>
<h3 id="基础概念">基础概念</h3>
<h4 id="软件产品定义">软件产品定义</h4>
<p>在最基本的层面上，软件需求是为解决现实问题而必须展现的属性。它可能旨在自动化支持组织业务策略和流程的全部或部分任务、纠正现有软件的缺陷，或控制设备——这只是软件解决方案可以解决的众多问题中的几个例子。</p>
<p>业务策略和流程以及设备功能通常非常复杂。相应地，软件需求通常是来自不同组织层级的各种利益相关者(stakeholder)的复杂需求组合，这些利益相关者参与或关联软件将要运行的环境的某些方面。</p>
<p>客户、顾客和用户通常会提出需求。然而，其他第三方，如监管机构，在某些情况下，软件组织或项目本身也可能提出需求。(另见[5,
c1] [6, c1] [9, c4]。)</p>
<h3 id="需求分类">需求分类</h3>
<p>[1*, c1pp7-12] [2*, s4.1]</p>
<p>图1.2展示了本知识领域定义的软件需求类别及其关系。(另见[5, c1] [6, c1]
[9, c4]。)下文将进一步描述每个类别。</p>
<h4 id="软件产品需求与软件项目需求">软件产品需求与软件项目需求</h4>
<p>[1*, c1pp14-15]</p>
<p><strong>软件产品需求</strong>指定软件预期的形式、适配性或功能。<strong>软件项目需求</strong>——也称为流程需求或有时称为<strong>业务需求</strong>——约束构建软件的项目。项目需求通常约束成本、进度和/或人员配置，但也可以约束软件项目的其他方面，如测试环境、数据迁移、用户培训和维护。软件项目需求可以在项目章程或其他高层项目启动文档中捕获。它们与项目管理方式(参见软件工程管理知识领域)或应使用的生命周期过程(参见软件工程过程知识领域)最为相关。本知识领域不进一步讨论软件项目需求。</p>
<figure>
<img alt="图1.2. 软件需求类别" src="软件需求类别图"/>
<figcaption aria-hidden="true">图1.2. 软件需求类别</figcaption>
</figure>
<h4 id="功能需求与非功能需求">功能需求与非功能需求</h4>
<p><strong>功能需求</strong>描述软件必须执行的功能。</p>
<p><strong>非功能需求</strong>可能影响实现：使用什么计算平台？使用什么数据库引擎？结果需要多精确？结果必须多快呈现？需要存储多少条特定类型的记录？某些非功能需求可能与软件的运行有关。(参见运行和维护知识领域。)(另见[5,
c1] [6, c11] [9, c4]。)</p>
<p>非功能需求可以进一步分为技术约束和服务质量约束。它们之间存在重要关系，相互之间产生正面或负面影响，因此每当修改非功能需求时，都需要考虑其可能产生的影响。</p>
<p><em>1.4. 功能性需求</em></p>
<p>[1*, c1p9] [2*, s4.1.1]</p>
<p><em>功能性需求</em>指定软件应提供的可观察行为——例如银行软件中的策略可能是”一个账户必须始终至少有一个客户作为其所有者”，以及”账户余额永远不能为负”。示例流程可以指定向账户存款、从账户取款以及从一个账户转账到另一个账户的含义。</p>
<p>即使是高度技术性的(非面向业务的)软件，例如实现传输控制协议/互联网协议(TCP/IP)网络通信协议的软件，也有策略和流程：“一个端口可以与零个、一个或多个关联的连接一起存在，但一个连接必须恰好存在于一个关联的端口上”，“连接的可接受状态应为’listen’、‘syn
sent’、‘established’、‘closing’，…”，以及”如果段的生存时间达到零，该段应被删除”。(另见[5,
c1] [6, c10] [9, c4]。)</p>
<p><em>1.5. 非功能性需求</em></p>
<p>[1*, c1pp10-11] [2*, s4.1.2]</p>
<p><em>非功能性需求</em>在某种程度上约束了要使用的技术，对其他方面的影响应予以考虑。</p>
<p><em>1.6. 技术约束</em></p>
<p>这些需求强制要求——或禁止——使用特定的、命名的自动化技术或定义的基础设施。示例包括要求使用特定的计算平台(例如Windows™、macOS™、Android
OS™、iOS™)、编程语言(例如Java、C++、C#、Python)、与特定网页浏览器的兼容性(例如Chrome™、Safari™、Edge™)、给定的数据库引擎(例如Oracle™、SQL
Server™、MySQL™)，以及通用技术(例如精简指令集计算机(RISC)、关系数据库)。禁止使用指针的需求是另一个例子。(另见[9,
c4]。)</p>
<p><em>1.7. 服务质量约束</em></p>
<p>这些需求不约束特定命名技术的使用。相反，这些要求指定自动化解决方案必须展现的可接受性能水平。示例包括响应时间、吞吐量、准确性、可靠性和可扩展性。ISO/IEC
25010：“系统和软件工程——系统和软件质量需求与评估(SQuaRE)——系统和软件质量模型”[27]包含一个大量可能与软件相关的质量特性列表。(另见[9,
c4]。)安全和安保也是一个特别重要的主题，在这方面需求往往被忽视。(有关应考虑的特定安全需求类型的详细信息，请参见安全知识领域。)(另见[2*,
c13]。)</p>
<p><em>1.8. 为什么要这样分类需求？</em></p>
<p>以这种方式对需求进行分类很有用，原因如下：</p>
<p>• 一个类别中的需求往往来自与其他类别不同的来源； •
启发技术(elicitation)通常因来源而异； • 分析技术因类别而异； •
规格说明技术因类别而异； • 验证权威因类别而异； •
不同类别以不同方式影响最终软件。</p>
<p>此外，将需求组织成这些类别还有以下好处：</p>
<p>•
可以更好地管理复杂性，因为可以分别处理不同的领域；软件工程师可以处理策略和流程复杂性，而无需同时担心自动化技术问题(反之亦然)。一个大问题变成了两个小问题。这是经典的<em>分而治之</em>复杂性管理方法；
•
可以隔离不同的专业领域；利益相关者(stakeholder)，而非软件工程师，是要自动化的策略和流程的专家。软件工程师，而非利益相关者，是技术专家。当业务专家被给予穿插的功能性需求时</p>
<p><a href="#软件需求">软件需求</a> 1-5</p>
<p><em>完美技术过滤器</em>最初在[18, c1-4]中描述，但也在[8]和[9,
c4]中进行了解释，有助于将功能性需求与非功能性需求分开。简单来说，功能性需求是那些即使存在具有无限速度、无限内存、零成本、无故障等特性的计算机来构建软件，仍然需要陈述的需求。所有其他软件产品需求都是对自动化技术的约束，因此是非功能性的。</p>
<p>大型系统通常跨越多个主题领域或域。如[9, c6]中所述，递归设计(recursive
design)展示了父域中的非功能性需求如何可以成为或可以引发子域中的功能性需求。例如，父银行域中关于用户安全的非功能性需求可以成为或可以引发子安全域中的功能性需求。同样，父银行域中关于审计和事务管理的跨领域非功能性需求可以成为或引发子审计域和子事务域中的功能性需求。将大型系统分解为一组相关域显著降低了复杂性。</p>
<p><em>1.9. 系统需求与软件需求</em></p>
<p>国际系统工程委员会(INCOSE)将<em>系统</em>定义为”为完成定义的目标而相互作用的元素组合。这些元素包括硬件、软件、固件、人员、信息、技术、设施、服务和其他支持元素”[24]。</p>
<p>在某些情况下，区分系统需求和软件需求是有用的或强制性的。系统需求</p>
<p>以及对更大系统的非功能性需求——例如，审查或验证，但他们可能会放弃，因为自动驾驶汽车。软件需求他们不理解——或者甚至不关心——技术问题。仅适用于该大型系统中的软件元素。一些软件需求</p>
<p>相关的需求审查员可以专注于仅与他们相关的需求子集。可能源自系统需求。（另见[5,
c1]。）在其他情况下，软件本身就是关注的系统，硬件和1-6 [<em>SWEBOK</em>]
[<em>®</em>][ 指南 V4.0a]</p>
<p>[需求] [整体而言，需求开发可以]</p>
<p>被视为”就要构建什么软件达成共识”。相反，需求管理可以被[需求]
[需求开发，作为一个整体，]</p>
<p>[开发] [管理]
视为”随时间维护该共识”。本知识领域中呈现了每项活动。[获取] [审查]</p>
<p>[分析] [需求开发活动被呈现] [变更控制] [规格说明]
为单独的主题，需求管理被呈现为单个主题。（另见<a href="#验证">验证</a>
[范围匹配] [5, c1] [6, 2]。）</p>
<p>[<strong>图 1.3.</strong>][ 软件需求活动]</p>
<p><strong>2. 需求获取</strong></p>
<p><strong>[1*, c6-7] [2*, s4.3]</strong></p>
<p>支持系统被视为平台或基础设施，因此系统需求主要是软件需求。[需求获取的目标是发现候选需求。它也被称为]</p>
<p><em>需求捕获</em>、<em>需求发现</em>或<em>需求采集</em>。如前所述，在真实世界</p>
<p><em>1.10. 派生需求(Derived Requirements)</em>
软件项目的需求工作中的一个问题是不完整性。这</p>
<p>在实践中，<em>需求</em>可能是上下文敏感的，并且可能取决于视角。外部[可能是不充分的获取的结果。]</p>
<p>利益相关者可以施加范围需求，[尽管无法保证一组需求]</p>
<p>这将成为整个项目的需求——即使该项目涉及数百名软件工程师。架构师决定使用管道-过滤器架构[是完整的，但执行良好的获取]</p>
<p>风格从整体项目利益相关者的角度来看不是一个需求，[有助于最大限度地减少不完整性。（另见]</p>
<p>而是一个设计决策。但是同样的决策，[5, c2-3] [6, c3-7]。）</p>
<p>当从负责构建特定过滤器的子团队的角度来看时，将被视为需求。<em>2.1.
需求来源</em></p>
<p>[[1*, c6] [2*, s4.3]]</p>
<p>航空航天行业长期使用术语<em>派生需求(derived
requirement)</em>来表示不是由[需求来自——可以从——许多不同来源获取。应识别和评估所有潜在的需求来源。<em>利益相关者(stakeholder)</em>可以定义为任何：]</p>
<p>整体项目外部的利益相关者提出的需求，而是在更大的开发团队内部施加的需求。架构师的管道-过滤器决策符合</p>
<p>这个定义。从外部利益相关者的角度来看，该选择将被视为•
积极参与项目的；</p>
<p>• 受项目结果影响的；</p>
<p>设计决策，但对于负责开发每个过滤器的子团队来说，则是一个需求。•
能影响项目结果的人、团体或组织。</p>
<p>（另见[9, c4]。）[软件项目的典型利益相关者包括但不限于以下内容：]</p>
<p><em>1.11. 软件需求活动</em></p>
<p>[1*, c1pp15-18] [2*, s4.2] [•
客户——为要构建的软件付费的人（例如，组织管理层）；]</p>
<p>图1.3显示了需求开发和管理活动。[•
顾客——决定软件产品是否投入使用的人；]</p>
<p><a href="#软件需求">软件需求</a> 1-7</p>
<p>[• 用户——直接或间接与软件交互的人；用户通常]</p>
<p>可以进一步细分为不同的用户类，这些用户类在使用频率、执行的任务、技能和知识水平、权限级别等方面有所不同；[能进一步分解为在使用频率、执行的任务、技能和知识]</p>
<p>[水平、权限级别等方面不同的不同用户类；]</p>
<p>• 主题专家(SME)；</p>
<p>• 运营人员；</p>
<p>• 一线产品支持人员；• 首次产品支持人员；</p>
<p>• 相关专业机构；• 相关专业团体；</p>
<p>• 监管机构；• 监管机构；</p>
<p>• 特殊利益团体；[• 特殊利益团体；]</p>
<p>• 如果项目成功可能受到负面影响的人；[•
如果项目成功可能受到负面影响的人；]</p>
<p>• 开发人员。• 开发人员。</p>
<p><em>利益相关者类(Stakeholder
classes)</em>是具有相似视角和[利益相关者类是具有相似视角和]</p>
<p>需求的利益相关者群体。在软件项目中以利益相关者类而不是个别利益相关者的方式工作[需求的利益相关者群体。在软件项目中以]</p>
<p>可以产生重要的额外洞察。[利益相关者类而不是个别利益相关者的方式工作]</p>
<p>[可以产生重要的额外洞察。]</p>
<p>许多项目受益于执行利益相关者分析以识别尽可能多的[许多项目受益于执行利益相关者分析以识别尽可能多的]</p>
<p>重要利益相关者类。这减少了需求偏向于代表性较好的利益[重要利益相关者类。这]</p>
<p>相关者而偏离代表性较差的利益相关者的可能性。[减少了需求]</p>
<p>[偏向于代表性较好的利益]</p>
<p><em>2.2. 获取技术</em>[相关者而偏离代表性较差的利益]</p>
<p>[[1*, c6-7, c9] [2*, s4.3]] [相关者的可能性。]</p>
<p>一旦识别了利益相关者类，软件工程师就必须从每个类中获取需求。在某些<em>2.2.
获取技术</em></p>
<p>[[1*, c6-7, c9] [2*, s4.3]]</p>
<p>情况下，各个利益相关者在帮助软件工程师获取需求方面差异很大。某些获取[一旦识别了利益相关者类，软件工程师]</p>
<p>[就必须从每个类中获取需求。在某些]</p>
<p>[情况下，各个利益相关者在帮助软件]</p>
<p>[工程师获取需求方面差异很大。某些获取]</p>
<p>[技术对某些利益相关者类比其他类效果更好。常见的利益相关者获取技术包括]</p>
<p>以下内容：</p>
<p>• 访谈；</p>
<p>• 会议，可能包括头脑风暴；</p>
<p>[• 联合应用开发(JAD)]</p>
<p>[[13]、联合需求规划(JRP)]</p>
<p>[[14]和其他促进式研讨会；]</p>
<p>• 协议分析；</p>
<p>• 焦点小组；</p>
<p>• 问卷和市场调查；</p>
<p>[• 探索性原型制作，包括]</p>
<p>[低保真和高保真用户界面]</p>
<p>原型制作[1*, c15]；</p>
<p>• 用户故事映射。</p>
<p>[获取可能很困难，软件]</p>
<p>工程师需要知道（例如）用户可能难以描述他们的任务，</p>
<p>[遗漏重要信息或不愿意或无法合作。获取]</p>
<p>[不是一项被动活动。即使有合作且善于表达的利益相关者可用，]</p>
<p>利益相关者(stakeholder)。利益相关者分析还可以在一个利益相关者类别的需求与另一个利益相关者类别的需求发生冲突时,为协商和冲突解决提供信息。</p>
<p>(另见 [5, c3] [6, c3]。)</p>
<p>需求不仅限于来自人的需求。其他非人员需求来源可能包括:</p>
<p>• 系统的早期版本; • 文档,如早期版本的需求、使命陈述、操作概念; •
其他系统; • 更广泛的业务环境,包括组织政策和流程; • 计算环境。</p>
<h2 id="22-常见需求获取技术-1-c7-2-s43">2.2. 常见需求获取技术 [1*, c7]
[2*, s4.3]</h2>
<p>可以使用多种技术从利益相关者那里获取需求。一些需求来自于利益相关者以外的来源。这些来源和技术包括:</p>
<p>• 早期版本的系统; • 早期版本的缺陷跟踪数据库; •
与正在开发的系统接口的系统; • 竞争基准(competitive benchmarking); •
文献检索; • 质量功能展开(QFD)的质量屋(House of Quality) [15]; •
观察,软件工程师研究工作内容和工作环境; •
学徒式学习(apprenticing),软件工程师通过实际工作来学习; • 使用场景描述; •
分解(例如,将能力分解为史诗,再分解为特性,再分解为故事); • 任务分析 [16];
• 设计思维(同理心、定义、构思、原型、测试) [17]; • ISO/IEC
25010:“系统和软件工程——系统和软件质量需求和评估(SQuaRE)——系统和软件质量模型”
[27]; • 安全需求,如安全知识领域所讨论的; • 适用的标准和法规。</p>
<p>(另见 [5, c3] [6, c4-7]。)</p>
<h2 id="3-需求分析-1-c8-9">3. 需求分析 [1*, c8-9]</h2>
<p>需求不太可能以最终形式被获取。通常需要进一步调查才能揭示最初获取的信息所暗示的完整、真实的需求。需求分析帮助软件开发人员理解候选需求的含义和影响,无论是单独理解还是在整体需求集的上下文中理解。</p>
<p>软件工程师必须努力获取正确的信息。许多产品需求是隐性的,或者只能在尚未收集的信息中找到。</p>
<p>需求也可以从利益相关者以外的来源获取。这些来源和技术包括以下内容:</p>
<h3 id="31-基本需求分析-1-c8-9">3.1. 基本需求分析 [1*, c8-9]</h3>
<p>以下需求的理想属性列表可以指导基本需求分析。软件工程师寻求建立任何尚未成立的这些属性。每个需求应该:</p>
<p>• 明确无歧义(只能以一种方式解释); •
可测试(可量化),意味着可以清楚地证明是否符合或不符合; •
有约束力,意味着客户愿意为其付费并且不愿意没有它; • 原子性,代表单一决策;
• 代表真实的、实际的利益相关者需求; • 使用利益相关者的词汇; •
为所有利益相关者所接受。</p>
<p>整体需求集合应该:</p>
<p>• 完整——需求充分处理边界条件、异常条件和安全需求; •
简洁——需求中没有多余的内容; • 内部一致——没有需求与其他任何需求冲突; •
外部一致——没有需求与任何源材料冲突; •
可行——可以在成本、进度、人员配置和其他约束条件内创建可行的、具有成本效益的解决方案。</p>
<p>在某些情况下,获取的陈述代表要实施的解决方案,而不是要解决的真正问题。这存在实施次优解决方案的风险。<em>5个为什么</em>技术(例如,[3*,
c4])涉及反复询问”为什么这是需求?“以收敛到真正的问题。当答案是”如果不这样做,那么利益相关者的问题就没有得到解决”时,重复就会停止。通常,真正的问题会在两到三个循环中达到,但该技术被称为<em>5个为什么</em>是为了激励工程师尽可能深入地推进。</p>
<h3 id="32-服务质量约束的经济学-3">3.2. 服务质量约束的经济学 [3*]</h3>
<p>服务质量约束可能特别具有挑战性。这通常是因为工程师不从经济角度考虑它们
[9,
c4]。图1.4说明了典型服务质量约束的经济视角,例如容量、吞吐量和可靠性,其中价值随性能水平增加。对于价值随性能水平增加而降低的服务质量约束(响应时间和平均修复时间将是示例),此曲线垂直镜像。</p>
<p>在相关性能水平范围内,如果系统以该水平执行,利益相关者具有相应的价值。价值曲线有两个重要点:</p>
<ol type="1">
<li><p>完美点(Perfection
point)——这是最有利的性能水平,超过此水平不会有额外的收益。即使系统可以比完美点表现得更好,客户也无法使用该容量。例如,支持的成员数量超过世界人口的社交媒体系统将具有这种过剩容量。</p></li>
<li><p>失败点(Fail
point)——这是最不利的性能水平,超过此水平不会进一步减少收益。例如,社交媒体系统可能需要至少支持最小市场份额才能作为平台可行。</p></li>
</ol>
<figure>
<img alt="图1.4. 价值作为性能水平的函数" src="media/image.png"/>
<figcaption aria-hidden="true">图1.4.
价值作为性能水平的函数</figcaption>
</figure>
<p>量化的需求点,即使明确说明,通常也是任意的。它通常基于客户认为有理由要求的内容,考虑到他们为此付出的费用。</p>
<p>无法构建一个完全满足最具成本效益的既定需求点的系统，软件。即使软件工程师</p>
<p>超过了客户的期望。此外，超越需求点的能力[性能水平]在某些情况下可以显著提升价值。通常仍然具有价值；只是价值较低[[性能水平]]</p>
<p><strong>图 1.5. 最具成本效益的性能水平</strong></p>
<p>达到给定性能水平的成本通常是一个阶跃函数。首先，对于给定的投资水平，存在某个最大可实现的性能水平。然后，需要额外的投资，这些进一步的投资使性能提升到一个新的、更有利的最大值。例如，代码的可修改性越高，其可靠性往往也越高，因为可修改性和可靠性在一定程度上都是代码整洁度的结果。另一方面，代码速度越高，可修改性可能越低，因为高速度通常通过优化来实现，而这些优化使代码更加复杂。</p>
<p>图 1.5
展示了最具成本效益的性能水平——即该性能水平的价值与实现它的成本之间的正向差异最大的性能水平。</p>
<p>(有关执行此类经济分析的更多信息，请参阅软件工程经济学知识领域或
[3*])</p>
<p>软件工程师应特别关注服务质量约束之间的正向和负向关系(例如，[1*, c14]
中的图
14-1)。某些服务质量约束是相互支持的；提高一个的性能水平将自动提高另一个的性能水平。</p>
<h2 id="33-形式化分析">3.3. 形式化分析</h2>
<p><strong>[2*, s12.3.2-12.3.3]</strong></p>
<p>形式化分析在某些应用领域已显示出益处，特别是高完整性系统(high-integrity
systems)(例如，[5,
c6])。需求的形式化表达依赖于使用具有正式定义语义的规范语言。形式化有两个好处。首先，形式化需求精确且简洁，(原则上)这将减少误解的可能性。其次，可以对形式化需求进行推理，允许证明指定软件的期望属性。这允许静态验证需求指定的软件确实具有客户、用户和软件工程师期望的属性(例如，无死锁)。</p>
<p>本主题与软件工程模型和方法知识领域中的形式化方法相关。</p>
<h2 id="34-处理需求冲突">3.4. 处理需求冲突</h2>
<p>当项目有更多且更多样化的利益相关者时，需求之间的冲突更有可能发生。需求分析的一个特别重要的方面是识别和管理这些冲突(例如，[6,
c17])。一旦识别出冲突的需求，工程师可以考虑两种不同的方法来管理该冲突(可能还有其他方法)，并确定最合适的行动方案。</p>
<p>一种方法是在冲突的利益相关者之间协商解决方案。在大多数情况下，软件工程师单方面做决定是不明智的，因此有必要与利益相关者协商以达成共识解决方案。出于合同原因，这些决策通常也需要能够追溯到客户，这一点很重要。一个具体的例子是项目范围管理(project
scope
management)——即在既定软件产品需求中所需的内容与在成本、进度、人员配置和其他项目级约束的要求下可以完成的内容之间取得平衡。关于谈判和冲突解决，有许多有用的信息来源
[25]。</p>
<p>另一种方法是应用产品族开发(product family
development)(例如，[20])。这涉及将需求分为两类。第一类包含不变需求(invariant
requirements)。这些是所有利益相关者都同意的需求。第二类包含可变需求(variant
requirements)，其中存在冲突。</p>
<p>软件工程师可以专注于理解满足所有利益相关者所需的变化范围。软件可以使用不变设计(design
to invariants)来设计，以适应不变需求，并使用变化设计(design for
change)来整合定制点，以配置系统实例，从而最适合相关利益相关者。在一个简单的例子中，天气应用的某些用户需要以摄氏度显示温度，而其他用户需要华氏度。</p>
<h2 id="4-需求规约">4. 需求规约</h2>
<p><strong>[1*, c10-14, c20-26] [2*, s4.4, c5]</strong></p>
<p>需求规约(Requirements
specification)涉及记录需求，以便它们能够被记住和传达。需求规约可能是本知识领域中最具争议的主题。争论集中在以下问题上：</p>
<p>• 需求是否应该被写下来？ • 如果需求被写下来，应该采用什么形式？ •
如果需求被写下来，是否也应该随时间维护？</p>
<p>这些问题没有标准答案；每个问题的答案可能取决于以下因素：</p>
<p>• 软件工程师对业务领域的熟悉程度； • 此类软件的先例； •
不正确需求的风险程度(例如，概率、严重性)； •
软件服务期内预期的人员流动； • 开发团队成员的地理分布； •
项目过程中利益相关者的参与程度； •
是否预期使用第三方服务、打包解决方案或开源库； •
是否将任何设计或构建外包；</p>
<h1 id="软件需求规格说明">软件需求规格说明</h1>
<p>• 需要进行多大程度的基于需求的测试？如何将这些信息打包和呈现？</p>
<p>•
使用候选规格说明技术所需的工作量；这样每个使用者都能以最小的努力获得所需的信息？</p>
<p>•
基于需求的估算所需的准确性；需求分析和规格说明之间存在一定程度的重叠和依赖关系。</p>
<p>•
必要的需求追溯程度（如果有）；使用某些需求规格说明技术——特别是基于模型的需求规格说明——允许并鼓励进行超出已呈现内容的需求分析。</p>
<p>• 对需求规格说明内容和格式的合同约束。</p>
<p>如本知识领域导言所述，文档化的软件需求应该与软件生命周期过程的其他交付物遵循相同的配置管理实践。项目中软件需求工作的”做什么”和”怎么做”应该由所构建软件的性质决定，而不是由构建它的生命周期决定。（详细讨论请参见配置管理知识领域。）此外，在实际可行的情况下，单个需求也要接受配置管理和可追溯性管理，这通常由需求管理工具支持。下游维护人员不应该仅从这些需求的形式就能辨别出早期开发中使用的生命周期。（参见主题8：软件需求工具。）</p>
<p>所选生命周期的影响应该仅限于项目中任何时点需求的完整性。在瀑布生命周期下，需求应在需求阶段结束时完全规格化。有几种通用类别的需求规格说明技术，下文将分别讨论。给定项目的需求规格说明也可能使用各种技术。在敏捷生命周期下，需求预期会不断变化、增长或被淘汰，直到项目结束才会完整。ISO/IEC/IEEE
29148 [26]，以及 [1*, c10-14]、[5, c4]、[6, c16]
等许多资料提供了需求文档的模板。</p>
<p>有些组织有记录需求的文化；有些则没有。由强大的产品愿景和有限资源驱动的动态创业项目，其团队可能会将需求文档视为不必要的开销。但随着这些产品的演进和成熟，软件工程师通常会认识到他们需要恢复激发产品功能的需求，以评估建议更改的影响。因此，需求文档和变更管理对长期成功变得重要。</p>
<h2 id="41-非结构化自然语言需求规格说明">4.1.
非结构化自然语言需求规格说明</h2>
<p>[1*, c11] [2*, s4.4.1]</p>
<p>项目的需求方法，特别是需求规格说明方法，可能会在软件的服务生命周期内演变。自然语言需求规格说明用普通的常用语言表达需求。自然语言需求规格说明可以是非结构化的或结构化的。</p>
<p>对于需求文档的最基本建议是基于受众分析来做决策。典型的非结构化自然语言需求规格说明是自然语言陈述的集合，例如”系统应当……“。谁是需要从需求规格说明中获取信息的不同使用者？他们需要何种程度的基于需求的信息？例如，业务规则是定义或约束要自动化业务的结构或行为某些方面的陈述。”如果仍有未支付的学费，学生不能注册下学期的课程”就是一个业务规则示例，作为大学课程注册软件的需求
1-12 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<div class="line-block">用例 #66 | 用例名称：预订航班 |<br/>
触发事件 | 客户请求预订航班 |<br/>
参数 | 乘客、行程、票价等级、付款方式 |<br/>
需要 | 合法行程、满足票价等级限制 |<br/>
保证 | 为乘客在行程航班上预订座位 |<br/>
正常流程 | 非常旅客、全国内行程、经济舱票价等级、信用卡/借记卡 |<br/>
替代流程 | 是常旅客：[无、银卡、金卡、白金卡、精英卡] |<br/>
| 行程：[全国际、国内+国际混合] |<br/>
| 票价等级：[基础经济舱、高级经济舱、商务舱、头等舱] |<br/>
| 付款方式：[代金券、常旅客里程] |<br/>
异常 |
信用卡/借记卡被拒、代金券不存在、代金券过期、常旅客账户不存在、常旅客账户里程不足
|</div>
<p><strong>图1.6.</strong> 单个用例的结构化自然语言规格说明示例</p>
<p>有些项目可以发布用户手册作为满意的需求规格说明，尽管这样做的效果有限。（另见
[5, c4] [26]。）（参见 [11] 获取编写良好用例规格说明的指南。）</p>
<p>用户故事(User
Story)格式：“作为&lt;某类用户&gt;，我想&lt;做某事&gt;，以便&lt;达到某目的&gt;”，以及决策表都是其他示例。（另见
[5, c4] [6, c12, c16] [7, c2-5]。）</p>
<h2 id="42-结构化自然语言需求规格说明">4.2. 结构化自然语言需求规格说明</h2>
<p>[1*, c8] [2*, s4.4.2]</p>
<p>结构化自然语言需求规格说明对需求的表达方式施加约束；目标是提高精确性和简洁性。</p>
<h2 id="43-基于验收标准的需求规格说明">4.3. 基于验收标准的需求规格说明</h2>
<p>这种通用方法包括两个具体变体：验收测试驱动开发(ATDD)和行为驱动开发(Behavior
Driven Development)</p>
<p>最简单的例子可能是行为驱动开发(BDD)。</p>
<p>演员-动作格式。演员是[ATDD [2*, s3.2.3, s8.2] 是更大的]</p>
<p>负责执行动作的实体，[测试驱动开发(TDD)方法的一部分。]</p>
<p>动作是需要发生的事情。触发事件[(参见软件测试知识领域。)TDD的主要]</p>
<p>可能在演员之前，[思想是测试用例先于构建。]</p>
<p>动作后面可能跟着可选的[因此，除非至少有一个测试用例失败，]</p>
<p>条件或限定。语句[否则不编写新的生产代码]</p>
<p>“当订单发货时，系统应[也不修改现有代码，无论是在]</p>
<p>创建发票，除非订单条款[单元测试级别还是在验收测试级别。]</p>
<p>为’预付款’“使用演员-动作格式。ATDD过程有三个步骤：</p>
<p>触发事件是”当订单</p>
<p>发货时。“演员是”系统。“[1. 选择一个功能单元(例如，用户故事)]</p>
<p>动作是”创建发票。“条件/[用于实现。]</p>
<p>限定是”除非订单条款为[2. 一个或多个软件工程师、一个或]</p>
<p>‘预付款’。“[多个业务领域专家，可能还有]</p>
<p>另一个例子是用例规范[一个或多个QA/测试专业人员]</p>
<p>模板，如图1.6所示。(参见[在任何生产设计或]</p>
<p><a href="#软件需求">软件需求</a> 1-13</p>
<p>构建工作完成之前会面——达成一致]</p>
<p>[一组必须通过的测试用例，以证明]</p>
<p>[功能单元已被]</p>
<p>[正确实现。]</p>
<p>[3. 至少有一个验收测试用例]</p>
<p>[在现有软件上必须失败。]</p>
<p>[至少存在一个失败的测试用例]</p>
<p>[使软件工程师有权限]</p>
<p>[创建或修改生产代码]</p>
<p>[以通过所有商定的测试用例。]</p>
<p>[此步骤可能需要多次迭代。]</p>
<p>[在此步骤中还可以重构代码。]</p>
<p>当所有验收测试用例都通过时，</p>
<p>并且大概所有单元和集成测试用例也通过时，</p>
<p>那么功能单元就被认为已完整且正确地实现。</p>
<p>ATDD过程返回到[步骤1，选择一个新的功能单元，]</p>
<p>循环重复。</p>
<p>ATDD可能看起来像一种测试技术</p>
<p>而不是需求规范技术。另一方面，测试用例</p>
<p>的一般形式是”当给定看起来像X的输入时，</p>
<p>我们期望软件产生看起来像Y的结果。”</p>
<p>关键是下划线短语”我们期望软件产生”。</p>
<p>如果我们简单地修改该短语为</p>
<p>“软件应产生”，如”当给定看起来像X的输入时，</p>
<p>软件应产生看起来像Y的结果”，</p>
<p>最初看起来像测试用例的内容现在</p>
<p>看起来像需求。从技术上讲，一个</p>
<p>验收测试用例可以包含多个单一需求，</p>
<p>但总体思想是ATDD测试用例</p>
<p>本质上是精确、明确的需求陈述。</p>
<p>BDD方法 [19] 稍微更</p>
<p>结构化，业务领域专家通常</p>
<p>更喜欢它而不是ATDD，因为它</p>
<p>在外观上不太技术化。在BDD中，功能单元</p>
<p>被描述为用户故事，</p>
<p>形式如下：“作为&lt;角色&gt;，我想要&lt;目标&gt;</p>
<p>以便&lt;收益&gt;。“这导致</p>
<p>识别和规范一组</p>
<p>“场景”，形式如下：“给定&lt;前置条件文本&gt;
[和&lt;更多前置条件&gt;]，当&lt;事件发生&gt;时</p>
<p>[那么&lt;结果&gt; [并且&lt;更多结果&gt;]。”</p>
<p>[如果故事是”作为银行客户，我想]</p>
<p>[从自动柜员机(ATM)取现金]</p>
<p>[以便我可以在不去银行的情况下得到钱]</p>
<p>[”]，一个场景可能是[账户有足够余额。”]</p>
<p>[此场景可以详细描述为”给定]</p>
<p>[账户余额为500美元，客户的]</p>
<p>[银行卡有效，自动柜员机]</p>
<p>[在其现金箱中有足够的钱，]</p>
<p>[当账户持有人请求100美元时，]</p>
<p>[那么ATM应分发100美元，]</p>
<p>[账户余额应为400美元，]</p>
<p>[客户的银行卡应被退回。”]</p>
<p>[另一个场景可能是]</p>
<p>[“账户余额不足”]</p>
<p>[可以详细描述为”给定账户余额为50美元，]</p>
<p>[客户的银行卡有效，]</p>
<p>[自动柜员机在其现金箱中有足够的钱，]</p>
<p>[当账户持有人请求100美元时，]</p>
<p>[那么ATM不应分发任何钱，]</p>
<p>[ATM应显示余额不足，]</p>
<p>[余额应保持在50美元，]</p>
<p>[客户的银行卡应被退回。”]</p>
<p>[BDD的目标是为每个功能单元]</p>
<p>[提供一套全面的场景。]</p>
<p>[在取现金的情况下，]</p>
<p>[“银行客户的银行卡已被禁用”和]</p>
<p>[“ATM现金箱中没有足够的钱”]</p>
<p>[等额外场景是必要的。]</p>
<p>[验收测试用例从]</p>
<p>[BDD场景中显而易见。]</p>
<p>[基于验收标准的需求]</p>
<p>[规范直接解决了需求]</p>
<p>[歧义问题。自然语言]</p>
<p>[本质上是模糊的，但测试用例语言]</p>
<p>[不是。在基于验收标准的]</p>
<p>[需求规范中，需求]</p>
<p>[使用测试用例语言编写，]</p>
<p>[非常精确。另一方面，这并不]</p>
<p>[inherently解决不完整性问题。]</p>
<p>[然而，将ATDD或BDD与]</p>
<p>[适当的功能测试覆盖标准]</p>
<p>[结合，如域测试、边界]</p>
<p>[值分析和成对测试(参见]</p>
<p>[软件测试知识领域)，可以降低]</p>
<p>1-14 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<p>需求不完整的可能性。</p>
<p>(另见 [9, c1, c12]。)</p>
<h2 id="44-基于模型的需求规范">4.4. 基于模型的需求规范</h2>
<p>[1*, c12] [2*, c5] [4*]</p>
<ol start="2" type="1">
<li>半形式化建模，例如 [9,</li>
</ol>
<p>c6-12]，提供了建模</p>
<p>语言语义的定义([9, 附录</p>
<p>L])，但该定义尚未被</p>
<p>正式证明是完整和</p>
<p>一致的。</p>
<p>另一种避免自然语言固有歧义性的方法是使用建模语言，例如统一建模语言™
(UML) 或系统建模语言™ (SysML)
的选定元素。就像建筑施工中使用的蓝图一样，这些建模语言可以以不依赖于计算技术的方式来精确简洁地指定功能需求
[9,
c1-2]。这个主题与软件工程模型和方法知识领域密切相关。需求模型分为两大类别：</p>
<ol type="1">
<li><p>用于指定要执行策略的结构模型：这些是逻辑类模型，例如 [9, c8]
中所述。它们也被称为概念数据模型、逻辑数据模型和实体关系图。</p></li>
<li><p>用于指定要执行过程的行为模型：这些模型包括 [9, c7]
中描述的用例建模、[9, c9] 中描述的交互图以及 [9, c10]
中描述的状态建模。其他例子包括 UML 活动图和数据流建模，如 [1*,
c12-13]、[8]、[10] 和 [18] 中所述。</p></li>
</ol>
<p>基于模型的需求规约在模型形式化程度上有所不同。考虑以下几点：</p>
<ol type="1">
<li><p>敏捷建模(Agile modeling)（例如，参见
[10]）是最不正式的。敏捷模型可能只是粗略的草图，其目标是传达重要信息而不是展示建模符号的正确使用。在这种类型的建模中，沟通的效果被认为比沟通的形式更重要。</p></li>
<li><p>半形式化建模，例如，使用 UML 或 SysML
的选定元素，提供了比敏捷建模更精确的规约。</p></li>
<li><p>形式化建模，例如 Z、维也纳开发方法 (VDM)、规约和描述语言 (SDL)
以及 [5, c7]
具有非常精确定义的语义，允许对规约进行机械分析以检测特定属性的存在或缺失，从而帮助避免关键的推理错误。术语<em>构造正确性(correctness
by construction)</em>
一直用于这种情况下的开发。（参见软件工程模型和方法知识领域中的形式化方法部分。）</p></li>
</ol>
<p>通常，需求模型越正式，它的歧义性就越小，因此软件工程师误解需求的可能性就越小。更正式的需求模型还可以：</p>
<p>• 更简洁紧凑； • 更容易转换为代码，可能以机械方式进行； •
用作推导验收测试用例的基础。</p>
<p>[4*]
中的一个重要信息是，虽然形式化建模语言比半形式化和敏捷建模更强大，但形式化符号会给模型创建者和人类读者带来负担。Wing
的折衷方案是使用形式化定义的基础（例如，在 Z
中）来支持更易于阅读和编写的表面语法（例如，UML 状态图）。</p>
<p><strong>4.5. 需求的附加属性</strong> [1*, c27pp462-463]</p>
<p>除了已经描述的基本需求语句之外，为部分或全部需求记录附加属性可能很有用。这些补充细节可以帮助软件工程师更好地解释和管理需求
[6, c16]。可能的附加属性包括以下内容：</p>
<p>• 标签以支持需求追踪； • 描述（关于需求的额外细节）； •
理由(rationale)（为什么该需求很重要）； •
来源（提出此需求的利益相关者的角色或姓名）； • 用例或相关触发事件； •
类型（需求的分类或类别 — 例如，功能性、服务质量）； • 依赖关系； •
冲突； • 验收标准； • 优先级（参见本知识领域后面的需求优先级排序）； •
稳定性（参见本知识领域后面的需求稳定性和易变性）； •
该需求对于产品族开发是通用的还是变体的（例如，[20]）； • 支持材料； •
需求的变更历史。</p>
<p>Gilb 的 Planguage（规划语言(Planning Language)的缩写）[7]
推荐使用诸如规模、测量、最小值、目标、杰出、过去、趋势和记录等属性。</p>
<p><strong>4.6. 增量和综合需求规约</strong></p>
<p>明确记录需求的项目采用两种方法之一。一种可以称为<em>增量规约(incremental
specification)</em>。在这种方法中，需求规约的一个版本仅包含与前一个版本的差异
—
添加、修改和删除。这种方法的优点是读者可以在单个文档中理解所有需求，而不必跟踪一系列规约中的累积添加、修改和删除。</p>
<p>一些组织结合这两种方法，产生用增量方式指定的中间版本（例如，x.1、x.2
和 x.3）和用综合方式指定的主要版本（例如，1.0、2.0 和
3.0）。读者只需回溯到上一个主要版本的需求规约就可以获得完整的规约集合。</p>
<p><strong>5. 需求验证</strong> <strong>[1*, c17] [2*,
s4.5]</strong></p>
<p><em>需求验证(Requirements validation)</em>
关注的是确信需求代表了当前理解（并可能记录）的利益相关者的真实需求。关键问题包括以下内容：</p>
<p>• 这些是否代表了此时所有相关的需求？ •
任何已陈述的需求是否不代表利益相关者的需求？ •
这些需求是否得到适当的陈述？ • 需求是否可理解、一致和完整？ •
需求文档是否符合相关标准？</p>
<p>三种需求验证方法往往被使用：需求评审、模拟和执行以及原型设计。（另见
[5, c5] [6, c17] [9, c12]。）</p>
<p><strong>5.1. 需求评审</strong></p>
<h2 id="验证">验证</h2>
<p>与上一个版本相比的优势在于可以产生更小的规范文档量。[[1*,
c17pp332-342] [2*, c4p130]]</p>
<p>另一种方法可以称为<strong>综合规范</strong>。在这种方法中，每个版本的需求规范都包含所有需求，而不仅仅是与之前版本的变更。</p>
<p>最常见的验证方式是通过评审或检查需求文档。要求一位或多位评审者查找错误、遗漏、无效假设、缺乏清晰度以及与公认实践的偏离。[[1-16
<em>SWEBOK® GUIDE V4.0a</em>]]</p>
<p>多视角评审是首选：</p>
<p>• 客户、顾客和用户检查他们的需要和需求是否完整准确地呈现； •
其他具有需求规范专业知识的软件工程师检查文档是否清晰并符合适用标准； •
将要进行架构、设计或构建满足这些需求的软件的软件工程师检查文档是否足以支持他们的工作。</p>
<p>向评审者提供检查清单、质量标准或”完成的定义”可以引导他们关注需求规范的特定方面。（参见软件质量知识领域中的评审和审计。）</p>
<h3 id="52-模拟和执行">5.2. 模拟和执行</h3>
<p>非技术干系人可能不想花时间详细评审规范。有些规范可以进行模拟或实际执行，以代替或补充人工评审。在需求被正式规范化（例如在基于模型的规范中）的程度上，软件工程师可以手工解释该规范并”执行”规范。通过足够的演示场景集，可以说服干系人该规范完整准确地定义了他们的政策和流程。（参见
[9, c12]。）</p>
<h3 id="53-原型">5.3. 原型</h3>
<p>[1*, c17p342] [2*, c4p130]</p>
<p>如果需求规范不是允许直接模拟或执行的形式，一个替代方案是让软件工程师构建一个原型，具体演示实现的某个重要维度。这展示了软件工程师对这些需求的解释。</p>
<p>原型可以帮助揭示软件工程师的假设，并在需要时就为什么这些假设是错误的提供有用的反馈。例如，用户界面的动态行为可能通过动画原型比通过文本描述或图形模型更好理解。然而，原型的一个危险是，原型的外观问题或质量问题可能会分散评审者对核心底层功能的注意力。原型的开发也可能成本高昂。但是，如果原型能帮助工程师避免因试图满足错误需求而造成的浪费，其成本就更容易证明合理性。</p>
<h2 id="6-需求管理活动">6. 需求管理活动</h2>
<p><strong>[1*, c27-28] [2*, s4.6]</strong></p>
<p>需求开发作为一个整体，可以被认为是”就要构建什么软件达成一致意见”。（参见图1.3。）相比之下，需求管理可以被认为是”随着时间推移维护该一致意见”。本主题探讨需求管理。（另见
[5, c9]。）</p>
<h3 id="61-需求精简requirements-scrubbing">6.1. 需求精简(Requirements
Scrubbing)</h3>
<p>需求精简 [22, c14, c32]
的目标是找到最小的简单陈述需求集，以满足干系人的需要。这样做将减少解决方案的规模和复杂性，从而最小化交付所需的工作量、成本和进度。需求精简涉及消除以下需求：</p>
<p>• 超出范围的； • 不会产生足够投资回报的； • 不那么重要的。</p>
<p>该过程的另一个重要部分是简化不必要复杂的需求。</p>
<p>在瀑布和其他基于计划的生命周期中，需求精简可以与需求验证评审协调进行；精简应在验证评审之前进行。在敏捷生命周期中，精简在迭代计划中隐式发生；只有最高优先级的需求被纳入冲刺（迭代）。</p>
<h3 id="62-需求变更控制">6.2. 需求变更控制</h3>
<p>[1*, c28] [2*, s4.6]</p>
<p>变更控制是管理需求的核心。本主题与软件配置管理知识领域密切相关。</p>
<p>使用瀑布或其他基于计划的生命周期的项目应该有一个明确的需求变更控制流程，包括：</p>
<p>• 请求对先前商定的需求进行变更的方法； •
可选的影响分析阶段，以更彻底地检查请求变更的收益和成本； •
负责接受、拒绝或推迟每个变更的责任人或小组；</p>
<h3 id="63-范围匹配scope-matching">6.3. 范围匹配(Scope Matching)</h3>
<p>需求的总范围必须与项目的成本、进度或人员配置约束相匹配。当需求范围超过成本、进度或人员配置约束时，要么必须减少范围（推测通过删除足够数量的最低优先级需求），要么必须增加容量（通过延长进度或增加预算和/或人员配置），或者必须协商某种适当的组合。在可能的情况下，范围匹配应该是定量的而不是定性的，即以功能规模单位表示。</p>
<p>在瀑布和其他基于计划的生命周期中，范围匹配可以与需求验证协调进行；范围匹配应该在验证评审之前进行。在敏捷生命周期中，只要执行某种基于速率的冲刺计划变体，那么允许进入冲刺/迭代的唯一工作将是可以合理预期在该冲刺/迭代期间完成的工作。</p>
<h1 id="7-实际考虑因素">7. 实际考虑因素</h1>
<h2 id="71-需求过程的迭代性质-2-s42">7.1. 需求过程的迭代性质 [2*,
s4.2]</h2>
<p>典型软件的需求不仅范围广泛，而且具有相当的深度。现实项目中，需求的广度和深度同时存在所产生的张力，常常促使团队以迭代方式执行需求活动。在某些时候，需求获取和分析侧重于扩展需求知识的广度，而在其他时候，则需要扩展深度。实际上，不太可能通过对主题的单次遍历就完成所有需求工作。（另见
[6, c2, c9]。）</p>
<h2 id="72-需求优先级排序-1-c16">7.2. 需求优先级排序 [1*, c16]</h2>
<p>在整个软件项目中对需求进行优先级排序非常有用，因为它有助于软件工程师专注于尽早交付最有价值的功能。它还有助于支持涉及冲突解决和范围匹配的智能权衡决策。优先级排序的需求还有助于初始开发项目之外的维护工作。针对高优先级需求提出的缺陷应该优先于针对低优先级需求提出的缺陷进行修复。</p>
<p>有多种优先级排序方案可用。回答几个关键问题可以帮助工程师选择最佳方法。第一个问题是”在确定一个需求优先于另一个需求时，哪些因素是相关的？“以下因素可能与项目相关：</p>
<ul>
<li>价值；期望度；客户和用户满意度</li>
<li>不期望度；客户和用户不满意度（Kano模型，见下文）</li>
<li>交付成本</li>
<li>软件服务生命周期内的维护成本</li>
<li>实施的技术风险</li>
<li>即使实施了用户也不使用的风险</li>
</ul>
<p>Kano模型（作为 [6, c17]
的基础）表明，仅考虑价值、期望度或满意度可能导致错误的优先级。更好地理解优先级需要考虑如果不满足该需求，利益相关者会有多不满意。例如，考虑一个开发电子邮件客户端的项目。两个候选需求可能涉及：</p>
<ol type="1">
<li>拥有有效的垃圾邮件过滤器</li>
<li>处理电子邮件附件</li>
</ol>
<p>优先级排序必须权衡用户拥有某些功能时体验到的满意度和缺少某些功能时体验到的不满意度。例如，用户更可能对有效的垃圾邮件过滤器感到满意，而不是对处理附件的能力感到满意，因此基于满意度标准，垃圾邮件过滤器将获得更高的优先级。另一方面，无法处理附件会让许多用户极度不满——远比没有有效的垃圾邮件过滤器更严重。当考虑实施功能带来的满意度与不实施某些功能带来的不满意度相结合时，开发人员通常会给处理附件比有效垃圾邮件过滤器更高的优先级。</p>
<p>第二个关键问题是”我们如何将相关因素集合转换为优先级表达？“公式
<em>优先级 = 价值 × 成本 / (1-风险)</em> 只是一个<em>目标函数(objective
function)</em>的例子。相关因素的测量方案选择可能会对目标函数施加约束。（参见计算基础中的测量理论。）</p>
<p>一旦确定了需求的优先级，就必须以能够传达给所有利益相关者的方式指定这些优先级。有几种可能的方法，包括：</p>
<ul>
<li>枚举量表（例如，必须有、应该有、最好有）</li>
<li>数字量表（例如，1到10）</li>
<li>按优先级降序排列需求的列表</li>
</ul>
<p>有效的需求优先级排序侧重于找到具有相似优先级的需求组，而不是创建过于严格的测量量表或争论微小差异。</p>
<h2 id="73-需求追踪-1-c29">7.3. 需求追踪 [1*, c29]</h2>
<p><em>需求追踪(Requirements
tracing)</em>可以服务于两个潜在有用的目的。一个是作为记录相关项目工作产品对之间一致性的核算工作。一个重要的问题可能是”对于每个已识别的软件需求，是否有旨在满足它的已识别设计元素？“如果找不到已识别的设计元素，那么要么该需求在该设计中未得到满足，要么设计是正确的并且可以删除一个或多个陈述的需求。类似地，”对于每个已识别的设计元素，是否有已识别的需求</p>
<h2 id="8-软件需求工具-1-c30">8. 软件需求工具 [1*, c30]</h2>
<p>帮助软件工程师处理软件需求的工具大致分为三类：需求管理工具、需求建模工具和功能测试用例生成工具，具体讨论如下。</p>
<h3 id="81-需求管理工具">8.1 需求管理工具</h3>
<p>如果某个特定的系统需求发生变更，例如，该系统需求可以追溯到其关联的软件需求。并非所有关联的软件需求都需要变更。但每个受影响的软件需求都可以追溯到其关联的设计元素。同样，并非所有关联的设计元素都需要变更。但每个受影响的设计元素都可以追溯到相关的代码。受影响的软件需求、设计元素和代码单元也可以追溯到其关联的测试用例，以进行进一步的影响分析。这有助于确定纳入系统需求变更所需的工作量”足迹”。</p>
<p>软件需求可以追溯到源文档，如系统需求、标准文档和其他相关规范。软件需求也可以向前追溯到设计元素和基于需求的测试用例。最后，软件需求还可以向前追溯到用户手册中描述已实现功能的章节。(另见
[23])</p>
<h3 id="74-需求稳定性和波动性">7.4 需求稳定性和波动性</h3>
<p>[2*, s4.6]</p>
<p>有些需求非常稳定；它们在软件的整个服务生命周期中可能永远不会改变。有些需求稳定性较低；它们可能在服务生命周期中发生变更，但在开发项目期间可能不会变更。例如，在银行应用中，计算并将利息记入客户账户的功能需求可能比支持不同免税账户的需求更稳定。前者反映了银行领域的基本特征(账户可以赚取利息)。</p>
<p>另一个目的是协助对提议的需求变更进行影响分析。</p>
<p>立法。最后，有些需求可能非常不稳定；它们可能在项目期间发生变更——可能不止一次。评估需求在给定时间内发生变更的可能性是有用的。识别潜在的易变需求有助于软件工程师建立更能容忍变更的设计(例如，[20])。(另见
[9, c4])</p>
<h3 id="75-需求度量">7.5 需求度量</h3>
<p>[1*, c19]</p>
<p>作为一项实际工作，对特定软件产品的需求<em>规模</em>有一定的概念可能是有用的。这个数字在评估新开发项目的<em>规模</em>或需求变更的规模以及估算开发或维护任务的成本(例如，[9,
c23])时很有用，或者简单地用作其他度量中的分母。功能规模度量(FSM)是一种评估功能需求体规模的技术。故事点(Story
points)也可以被视为需求规模的一种度量。</p>
<p>有关规模度量和标准的更多信息可以在软件工程过程知识领域中找到。</p>
<p>已经开发了许多质量指标，可用于将软件需求规格说明的质量与其他项目变量(如成本、验收、性能、进度和可重现性)相关联。单个软件需求和需求规格说明文档整体的质量指标可以从本知识领域前面第3.1节”基本需求分析”中讨论的理想属性中得出。</p>
<h3 id="76-需求过程质量和改进">7.6 需求过程质量和改进</h3>
<p>[1*, c31]</p>
<p>本主题涉及评估需求过程的质量和改进。其目的是强调需求过程在软件产品的成本和及时性以及客户满意度方面的关键作用。此外,它有助于使需求过程与软件和系统的质量标准和过程改进模型保持一致。过程质量和改进与软件质量知识领域和软件工程过程知识领域密切相关,包括以下内容:</p>
<p>• 过程改进标准和模型对需求过程的覆盖; • 需求过程度量和基准测试; •
改进规划和实施; •
安全性/CIA(机密性、完整性和可用性)改进/规划和实施。</p>
<h3 id="82-需求建模工具">8.2 需求建模工具</h3>
<p>[1*, c30p506] [2*, s12.3.3]</p>
<p>至少,需求建模工具支持可视化地创建、修改和发布基于模型的需求规格说明。一些工具还通过提供静态分析(例如,语法正确性、完整性和一致性)来扩展功能。形式化分析需要工具支持才能对非平凡系统实用,工具通常分为两类:定理证明器或模型检查器。在这两种情况下,证明都不能完全自动化,使用这些工具所需的形式化推理能力限制了更广泛的形式化分析。一些工具还动态执行规格说明和实现(模拟)。</p>
<h3 id="83-功能测试用例生成工具">8.3 功能测试用例生成工具</h3>
<p>[1*, c30]</p>
<p>需求规格说明语言定义得越正式,功能测试用例至少部分地自动派生的可能性就越大。例如,将BDD场景转换为测试用例并不困难。另一个例子涉及状态模型。对于该类模型中定义的每个转换,可以派生正向测试用例。</p>
<p>[1*, c30pp506-510] [模型。负面测试用例可以从]</p>
<p>需求管理工具支持各种活动，包括存储需求[不出现的状态和事件组合中派生。（参见第8.2节，]</p>
<p>属性、跟踪、文档生成和[测试知识领域中的测试工具，了解更多信息。）]</p>
<p>变更控制。事实上，跟踪和变更[从UML需求模型派生测试用例的过程可以在]</p>
<p>控制可能只有在工具支持下才实用。由于需求管理[[9, c12]中找到。]</p>
<p>是良好需求实践的基础，许多组织已经投资了[在最一般的情况下，这些工具只能]</p>
<p>工具。然而，更多组织以更临时且通常[生成测试用例输入。确定]</p>
<p>不太令人满意的方式管理他们的需求（例如电子表格）。（另请参见[预期结果并不总是可行的，可能需要]</p>
<p>[5, c8]。）[额外的业务领域专业知识。]</p>
<p><a href="#软件需求">软件需求</a> 1-21</p>
<p><strong>主题与参考资料矩阵</strong></p>
<p>[<strong>Wiegers</strong>] [<strong>Sommerville</strong>]
[<strong>Tockey</strong>] [<strong>Wing</strong>]</p>
<p>[<strong>2013</strong>] [<strong>2016</strong>]
[<strong>2005</strong>] [<strong>1990</strong>]</p>
<p>[<strong>[1*]</strong>] [<strong>[2*]</strong>]
[<strong>[3*]</strong>] [<strong>[4*]</strong>]</p>
<h2 id="1-软件需求基础">1. 软件需求基础</h2>
<p>[<em>1.1. 软件需求的定义</em>] [c1pp5-6] [c4p102]</p>
<p>[<em>1.2. 软件需求的类别</em>] [c1pp7-12] [s4.1]</p>
<p>[<em>1.3. 软件产品需求和</em>] [c1pp14-15]</p>
<p>[<em>软件项目需求</em>]</p>
<p>[<em>1.4. 功能需求</em>] [c1p9] [s4.1.1]</p>
<p>[<em>1.5. 非功能需求</em>] [c1pp10-11] [s4.1.2]</p>
<p>[<em>1.6. 技术约束</em>]</p>
<p>[<em>1.7. 服务质量约束</em>]</p>
<p>[<em>1.8. 为什么要这样分类需求？</em>]</p>
<p>[<em>1.9. 系统需求和软件需求</em>]</p>
<p>[<em>1.10. 派生需求</em>]</p>
<p>[<em>1.11. 软件需求活动</em>] [c1pp15-18] [s4.2]</p>
<h2 id="2-需求获取requirements-elicitation">2. 需求获取(Requirements
Elicitation)</h2>
<p>[<em>2.1. 需求来源</em>] [c6] [s4.3]</p>
<p>[<em>2.2. 常用需求获取技术</em>] [c7] [s4.3]</p>
<h2 id="3-需求分析">3. 需求分析</h2>
<p>[<em>3.1. 基本需求分析</em>] [c8-9]</p>
<p>[<em>3.2. 服务质量约束的经济学</em>] [c1-27]</p>
<p>[<em>3.3. 形式化分析</em>] [s12.3.2-12.3.3]</p>
<p>[<em>3.4. 处理需求中的冲突</em>]</p>
<h2 id="4-需求规格说明">4. 需求规格说明</h2>
<p>[<em>4.1. 非结构化自然语言</em>] [c11] [s4.4.1]</p>
<p>[<em>需求规格说明</em>]</p>
<p>[<em>4.2. 结构化自然语言</em>] [c8] [s4.4.2]</p>
<p>[<em>需求规格说明</em>]</p>
<p>[<em>4.3. 基于验收标准的需求</em>] [s3.2.3, s8.2]</p>
<p>[<em>规格说明</em>]</p>
<p>[<em>4.4. 基于模型的需求规格说明</em>] [c12] [c5] [pp8-11]</p>
<p>[<em>4.5. 需求的附加属性</em>] [c27pp462-463]</p>
<p>[<em>4.6. 增量式和全面式</em>]</p>
<p>[<em>需求规格说明</em>]</p>
<h2 id="5-需求验证">5. 需求验证</h2>
<p>[<em>5.1. 需求评审</em>] [c17pp332-342] [c4p130]</p>
<p>[<em>5.2. 仿真和执行</em>]</p>
<p>[<em>5.3. 原型</em>] [c17p342] [c4p130]</p>
<p>1-22 [<em>SWEBOK</em>] [<em>®</em>] [指南 V4.0a]</p>
<h2 id="6-需求管理活动-1">6. 需求管理活动</h2>
<p>[<em>6.1. 需求精炼</em>]</p>
<p>[<em>6.2. 需求变更控制</em>] [c28] [s4.6]</p>
<p>[<em>6.3. 范围匹配</em>]</p>
<h2 id="7-实践考虑">7. 实践考虑</h2>
<p>[<em>7.1. 需求过程的迭代性</em>] [s4.2]</p>
<p>[<em>7.2. 需求优先级</em>] [c16]</p>
<p>[<em>7.3. 需求跟踪</em>] [c29]</p>
<p>[<em>7.4. 需求稳定性和易变性</em>] [s4.6]</p>
<p>[<em>7.5. 需求度量</em>] [c19]</p>
<p>[<em>7.6. 需求过程质量和</em>] [c31]</p>
<p>[<em>改进</em>]</p>
<h2 id="8-软件需求工具">8. 软件需求工具</h2>
<p>[<em>8.1. 需求管理工具</em>] [c30pp506-510]</p>
<p>[<em>8.2. 需求建模工具</em>] [c30p506] [s12.3.3]</p>
<p>[<em>8.3. 功能测试用例生成工具</em>]</p>
<p><strong>扩展阅读</strong></p>
<p>[[1*]，提供了关于软件需求的全面讨论。]</p>
<p>IIBA，<em>业务分析知识体系指南® (BABOK® Guide) v3</em> [30]</p>
<p>[T.
Gilb，<em>竞争工程：使用Planguage的系统工程、需求工程和软件工程手册</em>]
[7]</p>
<p>BABOK指南是业务分析社区的参考知识体系，并提供了该学科的全面描述。虽然范围比仅需求和仅软件更广，但BABOK指南的很大一部分内容与软件需求相关。</p>
<p>这本书对需求提出了独特的视角，强调需求的精确性和完整性，以及强大的业务价值驱动动机。</p>
<p>K. Wiegers，<em>软件开发珍珠：来自五十年软件经验的教训</em> [21]</p>
<p>P. LaPlante，<em>软件和系统的需求工程</em> [5]</p>
<p>这本书汇集了基于Wiegers博士丰富实际经验的重要但经常未被认识到的关键成功因素。第2章专门针对软件需求。</p>
<p>这本书是[1*]的一个潜在替代品，提供了关于软件需求的全面讨论。</p>
<p>R. Fisher和W. Ury，<em>达成共识</em> [25]</p>
<p>S. Robertson和J. Robertson，<em>精通需求过程：正确获取需求</em>
[6]</p>
<p>这本书是关于原则性谈判和冲突解决的经典参考，在有多个利益相关者时，可作为解决软件需求中不可避免冲突的良好基础之一。</p>
<p>这本书是[1*]的另一个潜在替代品，</p>
<p><a href="#软件需求">软件需求</a> 1-23</p>
<p>[<em>使用Planguage的软件工程</em>，]</p>
<p>[牛津，英国：Elsevier Butterworth-]</p>
<p>N. Ahmad，<em>电子通信对小型软件开发访谈技术中隐性知识获取的影响</em>
[29]</p>
<p>[Heinemann，2005年。]</p>
<p>[[8] E. Yourdon，<em>现代结构化分析</em>，]</p>
<p>[Englewood Cliffs, NJ: Prentice-]</p>
<p>[Hall，1989年。]</p>
<p>这篇博士论文展示了使用四种不同类型的电子通信如何</p>
<p>[9] S. Tockey，<em>如何进行软件工程</em>，</p>
<p>Hoboken, NJ: Wiley，2019年。</p>
<p>用于在进行半结构化访谈之前与受访者讨论访谈议程细节的工具提高了隐性（hidden）知识的获取。</p>
<h2 id="参考文献-1">参考文献</h2>
<p>[1*] K. E. Wiegers and J. Beatty, <em>Software Requirements</em>,
第3版, Redmond, WA: Microsoft Press, 2013.</p>
<p>[2*] I. Sommerville, <em>Software Engineering</em>, 第10版, New York:
Addison-Wesley, 2016.</p>
<p>[3*] S. Tockey, <em>Return on Software: Maximizing the Return on Your
Software Investment</em>, Boston, MA: Addison-Wesley, 2005.</p>
<p>[4*] J. M. Wing, “A Specifier’s Introduction to Formal Methods,”
<em>Computer</em>, vol. 23, no. 9, 1990, pp. 8, 10-23.</p>
<p>[5] P. Laplante and M. Kassab, <em>Requirements Engineering for
Software and Systems</em>, 第4版, Boca Raton, FL: CRC Press, 2022.</p>
<p>[6] S. Robertson and J. Robertson, <em>Mastering the Requirements
Process: Getting Requirements Right</em>, Upper Saddle River, NJ:
Addison-Wesley, 2013.</p>
<p>[7] T. Gilb, <em>Competitive Engineering: A Handbook for Systems
Engineering, Requirements Engineering, and Software Engineering Using
Planguage</em>, Boston, MA: Butterworth-Heinemann, 2005.</p>
<p>[8] M. Jackson, <em>Software Requirements &amp; Specifications</em>,
Boston, MA: Addison-Wesley, 1995.</p>
<p>[9] A. Davis, <em>Just Enough Requirements Management: Where Software
Development Meets Marketing</em>, New York, NY: Dorset House, 2005.</p>
<p>[10] S. Ambler, <em>Agile Modeling: Effective Practices for eXtreme
Programming and the Unified Process</em>, Hoboken, NJ: Wiley, 2002.</p>
<p>[11] A. Cockburn, <em>Writing Effective Use Cases</em>, Upper Saddle
River, NJ: Addison-Wesley, 2000.</p>
<p>[12] L. Constantine and L. Lockwood, <em>Software for Use</em>,
Reading, MA: Addison-Wesley, 2000.</p>
<p>[13] J. Wood and D. Silver, <em>Joint Application Development</em>,
New York, NY: Wiley, 1995.</p>
<p>[14] E. Gottesdiener, <em>Requirements by Collaboration</em>, Boston,
MA: Addison-Wesley, 2002.</p>
<p>[15] J. Terninko, <em>Step by Step QFD</em>, 第2版, Boca Raton, FL:
CRC Press, 1997.</p>
<p>[16] G. Salvendy, <em>Handbook of Human Factors</em>, 第4版, Hoboken,
NJ: Wiley, 2012.</p>
<p>[17] T. Brown and B. Katz, <em>Change by Design: How Design Thinking
Transforms Organizations and Inspires Innovation</em>, 修订更新版, New
York, NY: Harper Collins, 2019.</p>
<p>[18] S. McMenamin and J. Palmer, <em>Essential Systems Analysis</em>,
New York, NY: Yourdon Press, 1984.</p>
<p>[19] J. Smart, <em>BDD in Action: Behavior-Driven Development for the
Whole Software Lifecycle</em>, Shelter Island, NY: Manning Publications,
2015.</p>
<p>[20] D. Weiss and C. Lai, <em>Software Product-Line Engineering: A
Family-Based Software Development Process</em>, Reading, MA:
Addison-Wesley, 1999.</p>
<p>[21] K. Wiegers, <em>Software Development Pearls: Lessons from Fifty
Years of Software Experience</em>, Boston, MA: Addison-Wesley
Professional, 2021.</p>
<p>[22] S. McConnell, <em>Rapid Development</em>, Redmond, WA: Microsoft
Press, 1996.</p>
<p>[23] O. Gotel and C. W. Finkelstein, “An Analysis of the Requirements
Traceability Problem,” presented at the Proceedings of the 1st
International Conference on Requirements Engineering, 1994.</p>
<p>[24] INCOSE, <em>Systems Engineering Handbook: A Guide for System
Life Cycle Processes and Activities</em>, 3.2.2 版, San Diego, US:
International Council on Systems Engineering, 2012.</p>
<p>[25] R. Fisher and W. Ury, <em>Getting to Yes</em>, 第3版, New York,
NY: Penguin, 2011.</p>
<p>[26] ISO/IEC/IEEE 29148 “Systems and software engineering – Life
cycle processes – Requirements engineering,” <em>International Standards
Organization</em>, 2018.</p>
<p>[27] ISO/IEC 25010: “System and software engineering – Systems and
software Quality Requirements and Evaluation (SQuaRE) – System and
software quality models,” <em>International Standards Organization</em>,
2011.</p>
<p>[28] ISO/IEC/IEEE, “ISO/IEC/IEEE 24765:2017 Systems and Software
Engineering — Vocabulary,” 第2版 2017.</p>
<p>[29] N. Ahmad, <em>Effects of Electronic Communication on the
Elicitation of Tacit Knowledge in Interview Techniques for Small
Software Developments</em>, 博士论文, University of Huddersfield,
2021.</p>
<p>[30] IIBA, <em>A Guide to the Business Analysis Body of Knowledge®
(BABOK® Guide) v3</em>, International Institute of Business Analysis,
Toronto, Ontario, Canada, 2015.</p>
<h2 id="第二章">第二章</h2>
<h1 id="软件架构-1">软件架构</h1>
<h2 id="缩略语">缩略语</h2>
<p>AD 架构描述 ADL 架构描述语言 API 应用程序编程接口 ASR
架构显著需求(Architecturally Significant Requirement) ATAM
架构权衡分析方法(Architectural Tradeoff Analysis Method) IDL
接口描述语言 MVC 模型-视图-控制器 QAW 质量属性研讨会(Quality Attribute
Workshop) RA 参考架构 REST 表述性状态传递 SAAM 软件架构分析方法(Software
Architecture Analysis Method) UML 统一建模语言</p>
<h2 id="引言">引言</h2>
<p>本章从多个角度探讨软件架构：概念；表示和工作产品；上下文、过程和方法；以及分析和评估。</p>
<p>与前一版本不同，本版本创建了一个独立的软件架构知识领域（KA），与软件设计KA分开。</p>
<h2 id="1-软件架构基础">1. 软件架构基础</h2>
<p><strong>[2*, c1] [29*, 附录C] [38*, c2] [41*, c1-3]</strong></p>
<h3 id="11-架构的含义-2-c2-6-c61-29-c6">1.1. “架构”的含义 [2*, c2] [6*,
c6.1] [29*, c6]</h3>
<p>软件工程和相关学科使用”架构”这个词有许多含义。首先，“架构”通常指一门学科：构建事物的艺术和科学——在这种情况下，是软件密集型系统。这门学科涉及社区发现并采用的概念、原则、过程和方法。</p>
<p>其次，“架构”指实现该学科的各种过程。软件架构也被认为是软件设计的一部分；通常被视为一个多阶段过程，分为以下阶段：</p>
<p>• 架构设计阶段 • 高层设计阶段 • 详细设计阶段</p>
<p>软件设计是第3章的重点。本章重点关注<em>架构设计</em>(architecting)和<em>架构设计</em>。</p>
<p>第三，“架构”指应用架构设计学科和过程来设计架构的<em>成果</em></p>
<h1 id="软件架构-2">软件架构</h1>
<p>由于人们对软件系统的极大兴趣，架构作为一门学科自1990年代以来显著发展。架构的成果以<em>架构描述</em>的形式表达。这在主题<em>软件架构描述</em>中讨论。架构的概念已经演变，今天有许多定义在使用中。1990年的一个早期架构定义强调了软件结构：</p>
<p><strong>架构(Architecture)</strong>。系统或组件的组织结构。[来源:
IEEE Std 610.12–1990, <em>IEEE软件工程术语表</em>]</p>
<p>这个定义没有充分反映架构思想的演变；例如，这个定义不允许我们区分模块的详细设计和其Makefile。两个例子都反映了软件系统或组件的<em>组织结构</em>，但不应被视为架构。此外，对结构的强调通常局限于代码的结构，未能涵盖软件系统的所有结构：</p>
<p><em>系统的软件架构是理解系统所需的一组结构。这些结构包括软件元素、它们之间的关系，以及两者的属性。</em>
[2*]</p>
<p>在1990年代中期，软件架构作为一门更广泛的学科出现，涉及对软件结构和架构的更通用研究。许多软件系统结构并不直接反映在代码结构中。两种类型的结构都对整个系统有影响：系统能够实现什么行为？它与其他系统有什么交互？如何处理安全性和保密性等属性？认识到软件包含许多不同的结构，促使人们讨论了许多关于软件架构（以及更广泛的软件设计）的有趣概念，从而产生了当前的定义，例如：</p>
<p><strong>架构(Architecture)（系统的）</strong>。<em>系统在其环境中的基本概念或属性，体现在其元素、关系中，以及其设计和演化的原则中</em>
[23]</p>
<p>该定义中的关键思想如下：(1)
架构是关于软件系统的<em>基本</em>方面；并非每个元素、互连或接口都被视为基本的。(2)
架构考虑系统<em>在其环境中</em>。就像建筑架构一样，软件架构是向外看的；它考虑系统边界之外的上下文，包括系统必须与之交互的人员、组织、软件、硬件和其他设备。</p>
<h2 id="软件架构知识领域的主题分解">软件架构知识领域的主题分解</h2>
<p>软件架构知识领域的主题分解如图2.1所示。</p>
<figure>
<img alt="图2.1. 软件架构知识领域的主题分解" src="media/image-001.png"/>
<figcaption aria-hidden="true">图2.1.
软件架构知识领域的主题分解</figcaption>
</figure>
<p><strong>软件架构</strong></p>
<ul>
<li><strong>软件架构基础</strong>
<ul>
<li>“架构”的含义</li>
<li>利益相关者和关注点</li>
<li>架构的使用</li>
</ul></li>
<li><strong>软件架构描述</strong>
<ul>
<li>架构视图和视点</li>
<li>架构描述语言和框架</li>
</ul></li>
<li><strong>软件架构过程</strong>
<ul>
<li>架构设计</li>
<li>架构风格和模式</li>
<li>架构方法和策略</li>
<li>架构决策</li>
<li>大规模架构</li>
<li>上下文中的架构</li>
</ul></li>
<li><strong>软件架构评估</strong>
<ul>
<li>架构中的优秀性</li>
<li>架构推理</li>
<li>架构评审</li>
<li>架构度量</li>
<li>作为重大决策的架构</li>
</ul></li>
</ul>
<h3 id="12-利益相关者和关注点">1.2. 利益相关者和关注点</h3>
<p>[2*, c3-14] [38*, c8-9] [41*, c3]</p>
<p>软件系统有许多<em>利益相关者(stakeholders)</em>，他们相对于该系统具有不同的角色和利益。这些不同的利益被称为<em>关注点(concerns)</em>，遵循Dijkstra的<em>关注点分离</em>：</p>
<p><em>这是所有智能思考的特征。让我试着向你解释，在我看来什么是良好品味的：那就是一个人愿意深入研究主题的某个方面，为了其自身的一致性而孤立地研究它，同时始终知道自己只是在处理其中一个方面。我们知道程序必须是正确的，我们可以只从那个观点来研究它；我们也知道它应该是高效的，我们可以在另一天研究它的效率，可以这么说。在另一种心情下，我们可能会问自己，如果是这样的话：为什么，程序是可取的。但是同时处理这些不同的方面不会有任何收获——相反！这就是我有时称之为”关注点分离”的东西，即使不能完美实现，也是有效思考的唯一可用技术。</em></p>
<figure>
<img alt="图2.2. 架构关注点示例" src="media/image-002.png"/>
<figcaption aria-hidden="true">图2.2. 架构关注点示例</figcaption>
</figure>
<p>示例包括：可负担性、敏捷性、保障性、自主性、可用性、行为、业务目标和策略、复杂性、法规遵从性、并发性、控制、成本、数据可访问性、可部署性、可处置性、能源效率、可演化性、可扩展性、可行性、保障性、进程间通信、互操作性、已知限制、可维护性、灵活性、功能性、信息可维护性、可修改性、模块化、开放性、性能、隐私、服务质量、可靠性、资源利用、可重用性、安全性、可伸缩性、进度、保密性、系统模式、软件结构、子系统集成、可持续性、系统特性、可测试性、可用性、使用、用户体验</p>
<p>关注点涵盖广泛的问题，可能涉及环境中对系统的任何影响，包括开发</p>
<h2 id="1-思维的排序">1. 思维的排序</h2>
<p><em>这是我所知道的思维排序方法。这就是</em><em>我所说的”将注意力集中于某个方面”</em>
<em>的含义：它并不意味着忽视其他方面，</em><em>而是公正地对待这样一个事实：从这个</em><em>方面的角度来看，其他方面是无关的。</em><em>这是同时做到单轨和多轨思维。</em></p>
<p>系统的基本要素会根据利益相关者的关注点和角色而变化。因此，软件结构也会随着利益相关者的角色和关注点而变化。（另见软件设计知识领域中的<em>设计方法</em>主题。）</p>
<p>软件系统的客户最关心的是系统何时准备就绪以及构建和运营需要多少成本。用户最关心的是它做什么以及如何使用它。构建系统的设计师和程序员有自己的关注点，例如算法是否满足系统需求。那些负责确保系统安全运行的人员有不同的关注点。</p>
<p>这些关注点涉及开发、技术、业务、运营、组织、政治、经济、法律、监管、生态和社会影响。与软件需求一样，它们可以被归类为功能性、非功能性或约束性。（参见软件需求知识领域。）关注点以各种熟悉的形式表现出来，包括需求、质量属性或”能力”、涌现属性（emergent
properties）（可能是期望的或禁止的）以及各种约束（如上所列）。参见软件质量知识领域。主题2，<em>软件架构描述</em>，展示了关注点如何塑造架构以及描述这些架构的工作产品。图2.2中描绘了关注点的示例。</p>
<p>关注点不是静态的；关注点会在系统的生命周期中以及随着技术、政策和其他影响因素的演变而演变。例如，由于对气候变化的认识提高，人们对能源效率和可持续性等关注点的兴趣日益增长[24]。</p>
<p>2-4 [<em>SWEBOK</em>][<em>®</em>][ GUIDE V4.0a]</p>
<h3 id="13-架构的用途">1.3. 架构的用途</h3>
<p>[2*, c24] [38*, c30]</p>
<p>软件系统架构的主要用途是让使用它的人对系统有一个共享的理解，以指导其设计和构建。架构还作为软件系统的初步概念，为分析和评估替代方案提供基础。第三个常见用途是通过帮助使用它的人在进行维护、增强或修改之前理解现有软件系统，从而实现逆向工程（或<em>逆向架构</em>）。</p>
<p>为了支持这些用途，架构应该被文档化（参见主题<em>软件架构描述</em>）。</p>
<p>康威定律(Conway’s
Law)认为”设计系统的组织……必然会产生这些组织的通信结构的副本”[11]。实证研究观察到，这些系统的架构通常反映了这些组织的通信结构[28]。根据软件系统和组织的不同，这可能是一个优势或劣势。架构可以增强大型团队内的沟通，也可能损害它。组织的每个部分都可以基于其对架构的了解来进行规划、成本核算和调度活动。</p>
<p>创建一个精心规划和文档化的架构是提高软件设计和组件的适用性和可重用性的一种方法。架构构成了程序设计族或软件产品线的基础。这可以通过识别这些族成员之间的共性，以及设计可重用和可定制的组件来考虑族成员之间的可变性来实现。</p>
<h2 id="2-软件架构描述">2. 软件架构描述</h2>
<p>软件系统的架构是指软件系统在其环境中的基本概念或属性。但是，每个利益相关者可以根据他们的视角对该软件系统的基本要素有不同的概念。对系统架构拥有一个心理模型对于小型系统和单独工作的个人来说可能没问题。然而，对于由团队开发和运营的大型复杂系统，有形的表示是非常宝贵的，特别是随着系统概念的演变，以及人员的加入或离开团队。将具体的表示作为工作产品还可以作为分析架构、组织其设计和指导其实现的基础。</p>
<p>这些工作产品被称为<em>架构描述</em>(architecture descriptions,
ADs)。</p>
<p>AD记录了软件系统的架构。它面向系统的那些利益相关者，这些利益相关者对软件系统的关注点可以通过架构来回答。如主题1，<em>软件架构基础</em>中所述，主要受众包括设计师、工程师和程序员，他们的关注点与构建系统有关。对于这些利益相关者，AD作为<em>蓝图</em>来指导软件系统的构建。对于其他人，AD是他们工作的基础——例如，测试和质量保证、认证、部署、运营以及维护和未来演进。</p>
<p>历史上，AD使用文本和非正式图表来传达架构。然而，利益相关者受众的多样性及其不同的关注点导致了架构表示的多样性。符号的选择应基于需要、目的以及这些选择对需要该信息的利益相关者的效用（如可理解性、熟悉度）。</p>
<p>通常，这些表示会根据相关社区或学科的现有实践进行专门化，以有效地</p>
<p><strong>[2*, c1.2, 22] [38*, c12-13] [40*, c6]</strong>
[处理这些不同利益相关者和关注]</p>
<p><strong>[41*, c6-7]</strong> [点（参见软件设计知识领域和软件]</p>
<p>工程模型与方法知识领域）。</p>
<p>在主题1，<em>软件架构基础</em>中，[这些不同的表示形式被称为<em>架构</em>]</p>
<p>软件架构被定义为<em>视图</em>。</p>
<p><a href="#软件架构">软件架构</a> 2-5</p>
<p><em>2.1. 架构视图和视点</em>
[其他文档化的视点包括可用性、行为、通信]</p>
<p>[6*, c7-9] [29*, c8] [38*, c3] [40*, c6.2] [异常处理、性能、]</p>
<p>可靠性、安全性和保障的视点。</p>
<p><em>架构视图</em>表示架构的一个或多个[每个视点提供了一套词汇或]</p>
<p>方面，用于处理一个或多个关注点[38*]。视图处理不同的语言，用于讨论一组关注点</p>
<p>关注点——例如，逻辑视图（描述[以及处理这些关注点的机制。]</p>
<p>系统如何满足功能需求）；过程视图（描述系统视点语言为利益相关者</p>
<p>如何使用并发）；物理视图[提供了共享的表达方式。视点]</p>
<p>（描述系统如何部署和分发）和开发视图（描述[不限于一个软件系统]</p>
<p>顶层设计如何分解为[而是可以被组织或应用]</p>
<p>实现单元、这些单元之间的依赖关系以及如何构建[社区重复使用于许多类似系统。]</p>
<p>实现）。通过视图分离关注点当使用统一建模语言（UML）等通用表示法时，</p>
<p>允许感兴趣的利益相关者一次专注[它们可以针对系统、其领域]</p>
<p>于少数几件事，并提供了一种管理架构可理解性[或相关组织进行专门化。（参见第]</p>
<p>和整体复杂性的方法。[2.3节<em>架构描述语言和</em>]</p>
<p>架构实践已经从使用<em>架构框架</em>。）</p>
<p>文本和非正式图表演变为使用[除了指定表示形式外，]</p>
<p>更严格的表示法。每个架构视图使用[架构视点还可以捕获]</p>
<p>明确定义的约定、符号和模型描述系统的架构元素[学科或实践]</p>
<p>[38*]。每个视图的约定[社区内的工作方式。例如，软件]</p>
<p>被记录为<em>架构</em>[可靠性视点从软件可靠性社区捕获现有实践]</p>
<p><em>视点</em>[23]。视点指导视图的创建、[用于识别和分析可靠性问题、]</p>
<p>解释和使用。每个视点将利益相关者受众[制定替代方案以及综合]</p>
<p>关注点与一组约定联系起来。在基于模型的[和表示解决方案。就像工程]</p>
<p>架构中，每个视图都可以[手册一样，通用和专用]</p>
<p>根据其视点进行机器检查。[视点提供了一种记录]</p>
<p>常见的视点包括模块[可重复或可重用的方法来处理重复出现的]</p>
<p>视点，用于表达软件系统的软件问题。Clements等人引入了</p>
<p>实现的模块及其组织[2*]；组件和视图类型，建立了视点的三向分类。</p>
<p>连接器视点，用于表达软件的这些类别是</p>
<p>大规模运行时组织和模块、组件和连接器以及分配</p>
<p>交互[2*]；逻辑视点，用于表达软件视图类型[9]。</p>
<p>领域和能力的基本概念[25]；场景[架构描述经常使用]</p>
<p>/用例视点，用于表达用户<em>多个</em>架构视图来表示</p>
<p>如何与系统交互[25]；信息[处理不同]</p>
<p>视点，用于表达系统的关键信息元素以及如何利益相关者各种关注点所需的不同结构。有两种</p>
<p>访问和存储它们[38*]；以及部署[构建视图的常见方法：<em>综合方法</em>和<em>投影</em>]</p>
<p>视点，用于表达系统如何[<em>方法</em>。在综合方法中，架构师]</p>
<p>配置和部署以供操作[38*]。构建感兴趣系统的视图并</p>
<p>[使用对应规则将这些视图集成到架构]</p>
<p>[描述中。在]</p>
<p>[投影方法中，架构师通过某种例程（可能]</p>
<p>[是机械的）从]</p>
<p>[单一统一模型（或”超模型”）中提取每个视图的过程[23]。</p>
<p>2-6 [<em>SWEBOK</em>] [<em>®</em>][ 指南 V4.0a]]</p>
<p>将多个视图引入[• 自适应系统（例如，微内核、]</p>
<p>AD的后果是视图之间可能存在不匹配。[反射和元级架构）]</p>
<p>它们是否一致？它们[• 虚拟机（例如，解释器、基于规则的、]</p>
<p>是在描述同一个系统吗？这被称为<em>多视图问题</em>[39]。过程控制）</p>
<p>投影方法限制了可能的不一致性，</p>
<p>因为视图是从单一[<em>模式目录</em>（或<em>模式系统</em>）用于]</p>
<p>（假定一致的）模型派生的，但代价是[通过协调的模式集表达架构风格和解]</p>
<p>表达能力：底层模型可能[决方案。]</p>
<p>无法捕获任意关注点。[模式目录的例子有[7]、[19]用于]</p>
<p>在综合方法下，架构师集成[n层架构，[13]用于面向服务的]</p>
<p>[架构，[37]用于微服务架构]</p>
<p>将视图整合为一个整体，使用链接或其他形式的可追溯性来交叉引用视图元素以实现一致性[23,25]。视点通常包含用于建立一致性或视图之间其他关系的规则。</p>
<p><em>2.2. 架构模式、风格和参考架构</em> [2*, c2.12] [6*, c6,15] [38*,
c11] [40*, c6.3] [41*, c11]</p>
<p>受到建筑学悠久历史的启发，<em>架构风格</em>是一种特定的构造方式，产生软件系统的特征。架构风格通常表达软件系统的大规模组织。相比之下，<em>架构模式</em>表达了在软件系统上下文<em>中</em>对重复出现问题的通用解决方案——它不需要应用于整个系统。设计模式在软件设计知识领域的4.4节中讨论。</p>
<p>各种架构风格和模式已被记录[7,39]：</p>
<p>• 通用结构（例如分层、调用-返回、管道和过滤器、黑板、服务和微服务） •
分布式系统（例如客户端-服务器、n层、代理、发布-订阅、点对点、表述性状态转移(REST)）
• 方法驱动（例如面向对象、事件驱动、数据流） •
用户-计算机交互（例如模型-视图-控制器、表示-抽象-控制）</p>
<p>模式目录不限于架构风格，可以专注于解决特定关注点，例如安全性[17]。架构风格和模式之间没有严格的分界线。模式和风格都在给定上下文中为特定问题提供解决方案。架构风格通过定义系统或子系统的主要部分以及它们如何交互来表达该（子）系统的全局方面[7,38*]。架构风格可以表达为架构模式[7]。架构模式存在于不同的规模，可以单次应用于系统的单个元素，也可以在整个系统中重复应用。</p>
<p>关于架构视点，它提供了讨论软件系统各个方面的语言，一个统一的概念是模式和风格都是这些语言中用于表达架构（和设计，见软件设计知识领域的4.4节<em>设计模式</em>）特定方面的<em>习语</em>。架构模式或风格使用从视点语言中提取的词汇，以指定的方式讨论视图元素，包括元素和关系类型及其实例，以及组合它们的约束[23,39]。通过这种方式，视点、模式和风格是编纂推荐实践以促进重用的机制。</p>
<p><em>参考架构</em>(RA)是约束或指导其他架构的架构。作为参考架构描述记录，参考架构为开发单个系统、产品线或系统族以及应用领域的架构提供了共同基础。参考架构捕获共性以促进开发、集成和互操作性以及其他类型的标准化的便利性。参考架构已在许多领域开发和使用，包括汽车系统、医疗保健、物联网、云计算、航空电子、制造和电信。</p>
<p><em>2.3. 架构描述语言和架构框架</em> [2*, c22] [29*, c11] [38*, app]
[41*, c6-7]</p>
<p>架构描述语言(ADL)是用于表达软件架构的领域特定语言。ADL源自用于大规模编程的模块互连语言[36]。一些ADL针对单个应用领域或架构风格（例如用于事件驱动风格的航空电子系统的MetaH），其他是跨企业关注点的广谱语言（例如ArchiMate™）。UML由于在软件设计活动中的广泛使用而经常被用作ADL[41*]。ADL通常提供超越描述的能力，以支持架构分析或代码生成。</p>
<p><em>架构框架</em>捕获”在特定应用领域和/或利益相关者社区中建立的用于架构描述的约定、原则和实践”[23]。框架</p>
<p>[软件架构] 2-7</p>
<p>捕获软件系统、其需求以及开发期间和整个生命周期中可用资源。对质量属性的影响以及竞争质量属性之间的权衡通常是设计决策的基础。</p>
<p>架构设计活动创建一个决策网络作为其结果，其中一些决策源自先前的决策。决策可以被明确记录，同时解释每个非平凡决策的基本原理。决策分析提供了一种架构评估方法。（参见主题4，软件架构评估。）</p>
<p><em>架构基本原理</em>捕获架构决策<em>为何</em>被做出。这包括决策前做出的假设、考虑的备选方案，以及用于选择方法和拒绝其他方案的权衡或标准。记录被拒绝的决策及其拒绝的原因也可能有用。将来，这可以防止软件项目做出糟糕的决策——因为忘记原因而早先被拒绝的决策——或允许开发人员认识到相关条件已经改变，他们可以重新审视该决策。</p>
<p><em>架构技术债务</em>被引入以反映今天对架构的决策可能具有重大影响</p>
<h1 id="软件架构-3">软件架构</h1>
<p>在特定领域内规范推荐实践，并作为一套相互关联的视图或架构描述语言(ADL)来实现。例如汽车行业的AUTOSAR、OMG的统一架构框架(UAF®)和ISO的开放分布式处理参考模型。</p>
<h2 id="24-架构作为重大决策">2.4. 架构作为重大决策</h2>
<p>[38*, c8] [40*, c6.1]</p>
<p>架构设计是一个创造性过程。在这个活动中，架构师会做出许多深刻影响架构、下游开发过程和软件系统的决策。许多因素会影响决策，包括利益相关者的主要关注点。</p>
<p>决策延迟可能会在软件系统生命周期后期产生后果。延迟的决策可能会损害系统的可维护性或未来的可演化性，而这些债务通常必须偿还——通常是由其他人偿还，而不一定是造成债务的人。这种债务对系统未来的开发和运营具有经济影响。例如，当一个软件项目时间有限时，它可能会开发一个初始设计，在首次发布时很少考虑模块化。缺乏模块化会对后续版本的开发时间产生不利影响，影响开发人员，并可能损害系统未来的可维护性。额外的功能只能通过进行大量重构来添加，这会影响未来的时间表并引入额外的缺陷。[26]。架构技术债务(technical
debt)可以像其他关注点一样，使用模型和视图进行分析和管理[27]。</p>
<h2 id="3-软件架构过程">3. 软件架构过程</h2>
<p><strong>[29*, c9] [38*, c6-7] [41*, c4]</strong></p>
<p>本节概述了架构设计过程的一般模型。它用于演示架构设计如何融入软件工程过程的一般背景(参见软件工程过程知识领域)，并作为理解当前使用的许多架构方法的框架。它还认识到架构设计可以在各种上下文中进行。</p>
<h3 id="31-架构的上下文">3.1. 架构的上下文</h3>
<p>[29*, c12-13] [41*, c2]</p>
<p>架构发生在多个上下文中。在传统生命周期中，存在一个由软件系统需求驱动的架构设计阶段(参见软件需求知识领域)。一些需求将是<strong>架构驱动因素</strong>(architectural
drivers)，影响关于架构的主要决策，而其他需求则推迟到软件过程的后续阶段，如设计或构建。</p>
<p>在产品线或产品家族设置中，针对一组基本需求、需求和其他因素开发产品线/家族架构。该架构将成为针对特定产品需求开发的一个或多个产品实例的起点，在产品基线上构建。</p>
<p>在敏捷方法中，通常没有架构设计阶段。唯一的架构描述可能是代码本身。在一些敏捷实践中，软件架构据说是通过快速系列的开发周期从基于用户故事的系统编码中”涌现”出来的。虽然这种方法在以用户为中心的信息系统中取得了一些成功，但对于其他类别的应用程序(如嵌入式和信息物理系统)来说，很难确保涌现出足够的架构，因为关键的架构属性可能不会被任何用户故事阐明。</p>
<p>在企业和系统之系统上下文中，如在产品线和家族中，总体架构(企业、系统或产品线/家族的架构)提供主要需求和关于软件架构形式和约束的指导。可以通过规范、附加需求、应用程序编程接口(API)或一致性套件来强制执行此基线。</p>
<h4 id="311-架构与设计的关系">3.1.1. 架构与设计的关系</h4>
<p>[40*, c6] [41*, c2]</p>
<p>设计和架构经常模糊不清。有人说架构是一组不能委托给设计师的决策。</p>
<p>事实上，随着学科的成熟，架构主要从1990年代以来从软件设计中出现。存在各种对比：设计通常关注一组既定的需求，而架构通常必须通过与利益相关者的谈判和需求分析来塑造需求。此外，架构通常必须识别和处理更广泛的关注点，这些关注点可能最终成为或不成为感兴趣的软件系统的需求。</p>
<h3 id="32-架构设计">3.2. 架构设计</h3>
<p>[2*, c19–23]</p>
<p>架构设计是对系统进行以下活动的应用：</p>
<ul>
<li>将系统大规模细化为关键组件</li>
<li>组件之间的通信和交互</li>
<li>将关注点和设计职责分配给组件</li>
<li>组件接口</li>
<li>理解和分析扩展和性能属性、资源消耗属性和可靠性属性</li>
<li>针对主导关注点(如适用的安全性和安全保障)的大规模/系统级方法</li>
</ul>
<p>图2.3展示了架构设计的概述。</p>
<figure>
<img alt="图2.3. 架构设计的一般模型" src="images/000055.jpg"/>
<figcaption aria-hidden="true">图2.3. 架构设计的一般模型</figcaption>
</figure>
<p>架构设计是迭代的，包括三个主要活动：分析、综合和评估。通常，所有三个主要活动在不同粒度级别上同时执行。</p>
<h4 id="321-架构分析">3.2.1. 架构分析</h4>
<p>[2*, c19] [41, c8]</p>
<p>架构分析收集和制定<strong>架构上重要的需求</strong>(ASRs，architecturally
significant
requirements)，定义为”任何影响其架构的软件系统需求”[31]。</p>
<h1 id="架构分析基于已识别的设计原则和方法">架构分析基于已识别的设计原则和方法</h1>
<p>架构分析基于已识别的关注点，以及对软件上下文的理解，包括已知需求、利益相关者需求和环境约束。ASRs（架构重要需求）反映了架构必须解决的设计问题。通常，初始需求和已知约束的组合无法在不影响成本、进度等方面的情况下得到满足。在这种情况下，需要通过协商来修改传入的需求和期望，以使解决方案成为可能。架构分析产生ASRs、初始的系统级决策以及从上下文中派生的任何总体系统原则（参见<em>架构上下文</em>）。</p>
<p>架构设计涉及识别系统的主要组件；它们的职责、属性和接口；以及它们之间和与环境之间的关系和交互。在架构设计中，系统的基本要素被确定，但其他方面，如主要组件的内部细节则被延后处理。</p>
<p>架构设计中的典型关注点包括以下内容：</p>
<p>• 整体架构风格和计算范式</p>
<h2 id="322-架构综合-2-c20">3.2.2. 架构综合 [2*, c20]</h2>
<p>架构综合针对架构分析的结果开发候选解决方案。综合通过制定由ASRs确定的设计问题的详细解决方案来进行，并在这些解决方案之间的交互中进行权衡。这些结果反馈到架构分析中，产生详细的ASRs、原则和决策，然后导致进一步的详细解决方案元素。</p>
<p>2-10 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<h2 id="323-架构评估-2-c21-38-c14">3.2.3. 架构评估 [2*, c21] [38*, c14]</h2>
<p>架构评估验证所选解决方案是否满足ASRs以及何时需要返工。架构评估方法在主题4
<em>软件架构评估</em>中讨论。</p>
<p>• <em>架构实现</em>：监督实现并认证实现符合架构 •
<em>架构维护</em>：管理和扩展实现后的架构 •
<em>架构管理</em>：管理组织的相关架构组合 •
<em>架构知识管理</em>：跨组织提取、维护、共享和利用可重用的架构资产，包括决策、经验教训、规范和文档</p>
<h2 id="33-架构实践方法和策略">3.3. 架构实践、方法和策略</h2>
<p>[2*, c3.4] [29*, c10] [38*, c9-14]</p>
<p>有许多记录在案的架构方法（参见进一步阅读列表）。</p>
<h2 id="34-大规模架构设计">3.4. 大规模架构设计</h2>
<p>[29*, c12, 14] [40*, c19]</p>
<p>架构设计表示生命周期的特定阶段，但只是软件架构设计的一部分。软件架构设计并非在真空中进行，如3.1节<em>架构上下文</em>中所述，而是在通常包括其他架构的环境中进行。例如，应用架构应符合企业架构；为了在系统之系统中”良好运作”，每个组成系统的架构应符合系统之系统架构。在这种情况下，这些关系需要反映为正在架构的软件的ASRs。许多软件架构活动和原则不仅限于软件，同样适用于系统和企业架构[29]。Weinreich和Buchgeher扩展了第3.2节<em>架构设计</em>中使用的Hofmeister等人的模型，以包括这些活动[42]：</p>
<h2 id="4-软件架构评估">4. 软件架构评估</h2>
<p><strong>[2*, c21] [38*, c14] [41*, c8]</strong></p>
<h3 id="41-架构的优良性">4.1. 架构的”优良性”</h3>
<p>[2*, c1.3, 2] [6*, c17]</p>
<p><em>架构分析</em>贯穿创建和维持架构的整个过程。<em>架构评估</em>通常由第三方在确定的里程碑处作为一种评估形式进行。</p>
<p>鉴于软件架构的多关注点、多学科性质，架构”优良”的方面有很多。罗马建筑师维特鲁威提出，所有建筑都应具有<em>firmitas</em>、<em>utilitas</em>和<em>venustas</em>的属性（从拉丁语翻译为坚固、实用和美观）。</p>
<p>对于软件系统及其架构，可以问：</p>
<p>• 它在其生命周期和可能的演进中是否健壮？ • 它是否适合其预期用途？ •
使用此架构构建软件系统是否可行且具有成本效益？ •
它即使不美观，是否至少对那些必须构建、使用和维护软件的人来说清晰易懂？</p>
<p>每个架构关注点都可能成为评估的基础。评估是针对需求（如果可用）或针对需要、期望和规范（在其他情况下）进行的。</p>
<p>[SOFTWARE ARCHITECTURE] 2-11</p>
<p>一个”好的”架构不仅应满足其利益相关者的不同关注点，还应满足它们相互作用的后果。例如，一个安全的架构可能构建和验证成本过高；一个易于构建的架构如果不能在系统生命周期内纳入新技术，则可能无法维护。</p>
<h3 id="42-架构审查-2-c21">4.2. 架构审查 [2*, c21]</h3>
<p>用例到软件架构元素的映射，这些元素将参与执行这些步骤[23]。</p>
<p>有关推理各种关注点的通用框架，请参见Bass等人[3]。</p>
<h3 id="43-架构审查-2-c21">4.3. 架构审查 [2*, c21]</h3>
<h1 id="架构权衡分析方法atam">架构权衡分析方法（ATAM）</h1>
<p>架构评审是评估架构状态和质量以及通过评估一个或多个架构关注点来识别风险的有效方法。许多评审是非正式的或基于专业知识的，有些则更加结构化，围绕要涵盖的主题清单进行组织。</p>
<p>架构权衡分析方法（ATAM）提供了一种基于效用树中的质量属性和说明质量的场景来评估软件架构的系统化方法。分析竞争质量需求及其架构方法之间的权衡是架构评估的关键。Clements等人描述了几种评估方法，包括ATAM、软件架构分析方法（SAAM）和质量属性研讨会（QAW）。SARA报告定义了软件架构评估的通用框架。</p>
<p>Parnas和Weiss提出了一种称为<em>主动评审</em>的有效评审方法，其中每个评估项都需要评审者进行特定活动以获取所需信息，而不是使用检查清单。</p>
<p>许多组织已经建立了制度化的架构评审实践。例如，一个行业组织开发了一个框架，用于定义、执行和记录架构评审及其结果。</p>
<h2 id="42-架构推理">4.2. 架构推理</h2>
<p>每个架构关注点都有不同的评估基础。当评估基于健壮的现有架构描述时，评估最为有效。架构描述（AD）可以被查询、检查和分析。例如，功能或行为的评估受益于拥有该系统方面的显式架构视图或其他表示形式来研究。可靠性、安全性和安全防护等专门关注点通常依赖于各自学科的专门表示。</p>
<p>通常架构文档是未完成的、不完整的、过时的或不存在的。在这种情况下，评估工作必须依赖参与者的知识作为主要信息来源。</p>
<p>用例经常用于通过比较用例中的步骤来检查架构的完整性和一致性（参见软件工程模型和方法知识领域）。</p>
<h2 id="44-架构度量">4.4. 架构度量</h2>
<p><em>架构度量</em>是对架构特征的定量测量。已经定义了各种架构度量。其中许多最初是设计或代码度量，后来被”提升”应用于架构。度量包括组件依赖性、循环性和圈复杂度、内部模块复杂度、模块耦合和内聚、嵌套层级，以及与模式、风格和（必需的）API使用的符合性。</p>
<p>在持续开发范式（如DevOps）中，已经演化出其他度量，这些度量不是直接关注架构，而是关注过程的响应能力，例如变更前置时间、部署频率、平均恢复服务时间和变更失败率等度量——作为架构状态的指示。</p>
<p><strong>主题与参考资料对照表</strong></p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%"/>
<col style="width: 14%"/>
<col style="width: 14%"/>
<col style="width: 14%"/>
<col style="width: 14%"/>
<col style="width: 14%"/>
<col style="width: 14%"/>
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Bass等人</strong></th>
<th><strong>Budgen</strong></th>
<th><strong>Maier等人</strong></th>
<th><strong>Rozanski等人</strong></th>
<th><strong>Sommerville</strong></th>
<th><strong>Taylor等人</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 软件架构基础</strong></td>
<td>c1</td>
<td>附录C</td>
<td>c2</td>
<td>c1-3</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.1. “架构”的含义</em></td>
<td>c2</td>
<td></td>
<td></td>
<td>c6.1</td>
<td>c6</td>
<td></td>
</tr>
<tr>
<td><em>1.2. 利益相关者和关注点</em></td>
<td>c3-14</td>
<td></td>
<td>c8-9</td>
<td></td>
<td>c3</td>
<td></td>
</tr>
<tr>
<td><em>1.3. 架构的用途</em></td>
<td>c24</td>
<td></td>
<td></td>
<td></td>
<td>c30</td>
<td></td>
</tr>
<tr>
<td><strong>2. 软件架构描述</strong></td>
<td>c1.2,22</td>
<td>c12-13</td>
<td>c6</td>
<td></td>
<td>c6-7</td>
<td></td>
</tr>
<tr>
<td><em>2.1. 架构视图和视点</em></td>
<td></td>
<td>c7-9</td>
<td>c8</td>
<td>c3</td>
<td>c6.2</td>
<td></td>
</tr>
<tr>
<td><em>2.2. 架构模式、风格和参考架构</em></td>
<td>c2.12</td>
<td>c6,15</td>
<td>c11</td>
<td>c6.3</td>
<td>c11</td>
<td></td>
</tr>
<tr>
<td><em>2.3. 架构描述语言和架构框架</em></td>
<td>c22</td>
<td>c11</td>
<td>app</td>
<td></td>
<td>c6-7</td>
<td></td>
</tr>
<tr>
<td><em>2.4. 架构作为重要决策</em></td>
<td></td>
<td>c8</td>
<td></td>
<td>c6.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3. 软件架构过程</strong></td>
<td>c12-13</td>
<td>c6-7</td>
<td></td>
<td></td>
<td>c4</td>
<td></td>
</tr>
<tr>
<td><em>3.1. 架构的上下文</em></td>
<td>c12-13</td>
<td></td>
<td></td>
<td></td>
<td>c2</td>
<td></td>
</tr>
<tr>
<td><em>3.1.1. 架构与设计的关系</em></td>
<td></td>
<td>c6</td>
<td></td>
<td></td>
<td>c2</td>
<td></td>
</tr>
<tr>
<td><em>3.2. 架构设计</em></td>
<td>c19-23</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.2.1. 架构分析</em></td>
<td>c19</td>
<td></td>
<td></td>
<td>c8</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.2.2. 架构综合</em></td>
<td>c20</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.2.3. 架构评估</em></td>
<td>c21</td>
<td></td>
<td></td>
<td>c14</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.3. 架构实践、方法和策略</em></td>
<td></td>
<td>c3.4</td>
<td>c10</td>
<td></td>
<td>c9-14</td>
<td></td>
</tr>
<tr>
<td><em>3.4. 大规模架构设计</em></td>
<td>c12,14</td>
<td></td>
<td></td>
<td></td>
<td>c19</td>
<td></td>
</tr>
<tr>
<td><strong>4. 软件架构评估</strong></td>
<td>c21</td>
<td>c14</td>
<td></td>
<td></td>
<td>c8</td>
<td></td>
</tr>
<tr>
<td><em>4.1. 架构的”优良性”</em></td>
<td></td>
<td>c1.3,2</td>
<td></td>
<td></td>
<td>c17</td>
<td></td>
</tr>
<tr>
<td><em>4.2. 架构推理</em></td>
<td></td>
<td>c10</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.3. 架构评审</em></td>
<td>c21</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.4. 架构度量</em></td>
<td>c23</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="扩展阅读">扩展阅读</h2>
<p>Perry和Wolf，《软件架构研究基础》</p>
<p>Perry和Wolf的《基础》在1992年出版前已非正式传阅多年。它确实为软件架构学科的演进奠定了基础，引入了该领域的许多基本思想，包括架构作为一门学科；区分架构；以及反映组织遇到的机遇和约束。</p>
<p>Kruchten，《架构的4+1视图模型》</p>
<p>这篇开创性论文使用五个架构视点组织了一种架构描述方法。前四个用于生成逻辑视图、开发视图、过程视图和物理视图。这些通过选定的用例或场景进行整合。</p>
<p>以及设计；软件架构的要素；多个视图用于说明架构。因此，多个视图；架构风格和类型；模型产生了4+1视图。这些视图用于与其他领域的类比。描述不同利益相关者所设想的软件——例如最终用户、</p>
<p>Bass等人，《软件架构实践》[2*] 开发人员和项目经理。</p>
<p>本书介绍了软件架构的概念和推荐实践，Rozanski和Woods，《软件系统架构》[38*]</p>
<p>即软件如何结构化以及软件组件如何交互。本书详细讨论了几个质量关注点，这是一本面向软件系统架构师的手册。它发展了利益相关者、关注点、架构描述、包括：可用性、可部署性、能源效率、可修改性、性能、可测试性和可用性。作者提供了架构视点和架构视图、架构模式和风格等关键概念，并附有示例。它提供了端到端的架构设计、架构描述、架构评估和管理架构技术债务方面的推荐实践。他们还强调了架构过程。作者提供了一个即用型、实用的视点目录，供架构师使用，大型软件设计所处的业务背景的重要性。在此过程中，他们在适用于广泛系统范围。本书充满了真实世界的环境中展示了软件架构。应用这些概念和方法的指导。</p>
<p>2-14 <em>SWEBOK®指南V4.0a</em></p>
<p>R.N. Taylor, N. Medvidović, E.
Dashofy，风险可能来自狭小的解决方案空间、《软件架构：基础、理论和实践》[41*]</p>
<p>来自极其苛刻的质量要求或来自可能的高风险故障。这是一本关于软件架构许多方面的综合教科书，包括风险驱动的方法与低仪式感和敏捷方法是和谐的。关键思想；软件工程背景下的软件架构；设计过程；Fairbanks认为，架构设计不仅仅是架构师的事情——而是与所有架构建模、分析和可视化；以及关于几个关注点的章节，包括实现、部署、开发人员相关。</p>
<p>适应、非功能属性、信任和安全。</p>
<p>Erder,
Pureur和Woods，《持续架构实践：敏捷和DevOps时代的软件架构》[15]</p>
<p>P. Clements等人，《记录软件架构：视图及更多》第2版[9]</p>
<p>本书展示了”经典”的软件架构思维如何在当今敏捷、基于云和DevOps的软件本书提供了捕获软件架构的最佳实践，使用指导和开发方法的背景下演变，通过提供一系列质量和横切关注点的实用指导，示例来表达利益相关者可以构建、使用和维护该包括安全性、弹性、可扩展性系统的架构。本书介绍了视图的三向分类，因此也包括视点：和新兴技术的集成。</p>
<p>模块、组件和连接器以及分配视图类型，提供了每种类型的大量示例。</p>
<p><strong>参考文献</strong></p>
<p>Brown，《面向开发人员的软件架构》[5]</p>
<p>[[1] M. Ali Babar和I. Gorton，“软件]</p>
<p>Brown从开发人员的角度概述了软件架构主题。他讨论了常见的架构驱动因素，包括架构原则、架构评审：实践现状”，<em>IEEE
Computer</em>，2009年7月。</p>
<p>质量关注点、约束和功能需求。他深入讨论了[2*] L. Bass, P. Clements和R.
Kazman，架构师在开发环境中的角色以及《软件架构实践》第4版，2021年。</p>
<p>架构师所需的知识和技能。他关注交付过程中架构的实际问题以及[3] L.
Bass, J. Ivers, M.H. Klein和风险管理。附录提供了一个案例研究。P.
Merson，推理框架(Reasoning Frameworks)，</p>
<p>CMU/SEI-2005-TR-007，2005年。</p>
<p>Fairbanks，《恰到好处的软件架构：风险驱动的方法》[16]</p>
<p>[4*] F. Brooks，《设计的设计》，</p>
<p>Addison-Wesley，2010年。</p>
<p>Fairbanks提供了一种风险驱动的方法，在开发背景下进行架构设计：只做足够的软件架构[5]
S. Brown，面向开发人员的软件架构，2018，<a href="http://leanpub.com/software-architecture-for-developers">http://leanpub.com/</a><a href="http://leanpub.com/software-architecture-for-developers">software-architecture-for-developers</a>。</p>
<p>来减轻已识别的风险，这些</p>
<p><a href="#软件架构">软件架构</a> 2-15</p>
<p>[6*] D. Budgen，软件设计：为非良构问题创建解决方案，第3版，CRC
Press，2021年。</p>
<p>[7] F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad和M. Stal，[19]
M. Fowler, D. Rice, M. Foemmel,《面向模式的软件架构》，E. Hieatt, R.
Mee和R. Stafford，John Wiley &amp;
Sons，1996年。《企业应用架构模式》，</p>
<p>Addison-Wesley，2003年。</p>
<p>[8] H. Cervantes, R
Kazman，《设计软件架构：实用方法》第2版，Addison-Wesley，2024年。[[20]
C. Hofmeister, P.B. Kruchten, R.L.]</p>
<p>Nord, H. Obbink, A. Ran和P.</p>
<p>[9] P.
Clements等人，《记录软件架构：视图及更多》第2版，America，“从五种工业方法派生的软件架构设计通用模型”，<em>系统与软件学报</em>，80，Addison-Wesley，2011年。</p>
<p>106–126，2007年。</p>
<p>[10] P. Clements, R. Kazman, M. Klein,</p>
<h1 id="参考文献-2">参考文献</h1>
<p><em>Evaluating Software Architectures</em>，[21] C. Hofmeister, R.L.
Nord, and D. Soni, Addison-Wesley, 2001. [<em>Applied Software
Architecture</em>, Addison- Wesley, 2000.</p>
<p>[11] M.E. Conway, “How Do Committees Invent?” <em>Datamation</em>,
14(4), 28-31, 1968. [22] ISO/IEC/IEEE 24765:2017 Systems and Software
Engineering — Vocabulary,</p>
<p>[12] E.W. Dijkstra, “On the role of scientific 2nd ed. 2017.
thought”, 1974, available at https://www.
cs.utexas.edu/users/EWD/transcriptions/ [23] ISO/IEC/IEEE 42010:2011,
EWD04xx/EWD447.html. [Systems and software engineering — Architecture
description.</p>
<p>[13] T. Earl, <em>SOA Design Patterns</em>, Prentice-Hall, 2009 [24]
R. Kazman, S. Haziyev, A. Yakuba, and D.A. Tamburri, Managing Energy</p>
<p>[14] P. Eeles, and P. Cripps, <em>The Process</em> Consumption as an
Architectural <em>of Software Architecting</em>, Addison Quality
Attribute, <em>IEEE Software</em>, Wesley, 2010. 35(5), 102–107,
2018</p>
<p>[15] M. Erder, P. Pureur and E. Woods, [25] P.B. Kruchten, The “4+1”
View Model <em>Continuous Architecture in Practice:</em> of
Architecture, <em>IEEE Software Software Architecture in the Age of
Agility</em> 12(6), 1995. <em>and DevOps</em>, Addison-Wesley, 2021.</p>
<p>[26] P.B. Kruchten, R.L. Nord, and [16] G. Fairbanks, Just Enough
Software I. Ozkaya, <em>Managing Technical</em> Architecture: A
Risk-Driven Approach, <em>Debt: Reducing Friction in Software</em>
Marshall &amp; Brainerd, 2010. [<em>Development</em>. Addison-Wesley,
2019.]</p>
<p>[17] E. Fernandez-Buglioni, Security [27] Z. Li, P. Liang and P.
Avgeriou, Patterns in Practice: Designing Secure Architecture viewpoints
for doc- Architectures Using Software Patterns, umenting architectural
technical Wiley, 2013. debt. <em>Software Quality Assurance</em>,
Elsevier, 2016.</p>
<p>[18] R.T. Fielding and R.N. Taylor, Principled design of the modern
web [28] Alan MacCormack, John Rusnak &amp; architecture, ACM
<em>Transactions on</em> [Carliss Baldwin, Exploring the Duality]
<em>Internet Technology</em>, 2(2), 115–150, 2002. [between Product and
Organizational 2-16 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]]</p>
<p>架构：对”镜像”假说的检验。<em>Research
Policy</em>，41:1309–1324，2012</p>
<p>[29*] M.W. Maier and E. Rechtin, <em>The Art of</em> [35] E. Poort,
H. van Vliet, RCDA: <em>Systems Architecting</em>，第3版，CRC
将架构作为风险和成本管理学科，<em>Journal of</em> Press，2021。
<em>Systems and Software</em>，https://www
.cs.vu.nl/~hans/publications/y2012 /JSS-RCDA.pdf，2012</p>
<p>[30] N. Medvidović, D.S. Rosenblum, D.F. Redmiles and J.E. Robbins,
[36] R. Prieto-Diaz and J.M. Neighbors,
在统一建模语言中建模软件架构，ACM 模块互连语言， <em>Transactions on
Software Engineering</em> <em>Journal of Systems and
Software</em>，6(4)， <em>and Methodology</em>，11(1)，2–57，2002
307–334，1986。</p>
<p>[31] H. Obbink et al., <em>Report on Software</em> [37] C.
Richardson, <em>Microservices Patterns</em>, <em>Architecture Review and
Assessment</em> Manning Publications，2019 (SARA)，version
1.0，available at https://
philippe.kruchten.com/wp-content/uploads/2011/09/sarav1.pdf [38*] N.
Rozanski and E. Woods, <em>Software</em>
philippe.kruchten.com/architecture/ <em>Systems Architecture: Working
with</em> SARAv1.pdf，2002。 <em>Stakeholders Using Viewpoints and</em>
<em>Perspectives</em>，第2版，Addison- Wesley，2011。</p>
<p>[32] D.L. Parnas，“将系统分解为模块时应使用的标准”， [39] M. Shaw and
D. Garlan, <em>Software</em> <em>Communications of the ACM</em> 15(12)，
[<em>Architecture: Perspectives on an Emerging</em>] 1053-1058，1972。
<em>Discipline</em>，Prentice Hall，1996。</p>
<p>[33] D.L. Parnas and D.M. Weiss, [40*] I. Sommerville, <em>Software
Engineering</em>, “主动设计评审：原则和实践”， 第10版，2016。
Proceedings of 8th International Conference on Software [41*] R.N.
Taylor, N. Medvidović, E. Dashofy, Engineering，215-222，1985。
[<em>Software Architecture: Foundations, Theory,</em>] <em>and
Practice</em>，Wiley，2009</p>
<p>[34] D. Perry, A. Wolf，软件架构研究的基础，ACM [42] R. Weinreich and
G. Buchgeher, <em>SIGSOFT Software Engineering Notes</em>，
[支持软件架构生命周期，<em>The Journal of Systems</em>]
17(4)，40–52，1992 <em>and Software</em>，85，546–561，2012。</p>
<h2 id="第三章"><strong>第三章</strong></h2>
<p>软件设计</p>
<p><strong>缩略语</strong></p>
<p>API 应用程序编程接口(Application Programming Interface) AOD
面向方面设计(Aspect-Oriented Design) CRC 类职责协作者(Class
Responsibility Collaborator)（或协作(Collaboration)） CBD
基于组件的设计(Component-Based Design) DFD 数据流图(Data Flow Diagram)
DSL 领域特定语言(Domain-Specific Language) ERD 实体关系图(Entity
Relationship Diagram) IDL 接口描述语言(Interface Description Language)
FOSS 自由和开源软件(Free And Open Source Software) MBD
基于模型的设计(Model-Based Design) MDD 模型驱动设计(Model-Driven
Design)</p>
<p>学科；以及（4）生命周期中产生这些结果的过程所在的<em>阶段</em>。</p>
<p><em>软件设计描述</em>(SDD)记录了软件设计的结果。它是一个”为便于分析、规划、实施和决策而创建的软件表示”。软件设计描述用作传达软件设计信息的媒介，可以被视为系统的蓝图或模型[11]。</p>
<p>SDD可以采用多种形式，它包括将软件细化为组件、这些组件的组织、它们之间以及软件与外部世界之间的接口定义——达到详细的程度。</p>
<h1 id="软件设计-2">软件设计</h1>
<p>[PDL] [程序设计语言] [SDD] [软件设计说明] [OO] [面向对象] [SoC]
[关注点分离] [UML] [统一建模语言]</p>
<p>软件设计，作为一个生命周期活动来看待，是软件工程学科的应用，在其中对软件需求进行分析，以定义软件的外部特性和内部结构，作为软件构建的基础。</p>
<p>软件设计分三个阶段进行：</p>
<h2 id="引言-1">引言</h2>
<p>• 软件系统的架构设计 • 系统及其组件的高层或面向外部的设计 •
详细或面向内部的设计</p>
<p>本章从多个角度考虑软件设计——重点关注基本概念、上下文和过程、软件设计质量和策略，以及记录和评估设计。</p>
<p>架构设计是架构活动的一部分，在软件架构知识领域中讨论。</p>
<p><em>设计</em>以不同但密切相关的方式使用，指代 (1)
<em>学科</em>（“使用科学原理、技术信息和想象力来定义软件系统，以最大的经济性和效率执行[预先指定的]功能”）[11]；(2)
在该学科内执行的<em>过程</em>；(3) 应用该学科的<em>结果</em>。</p>
<h2 id="软件设计主题分解">软件设计主题分解</h2>
<p>软件设计知识领域的主题分解如图3.1所示。</p>
<p><strong>软件设计</strong></p>
<p><strong>软件设计基础</strong> | <strong>软件设计过程</strong> |
<strong>软件设计质量</strong> | <strong>记录软件设计</strong> |
<strong>软件设计策略和方法</strong> |
<strong>软件设计分析和评估</strong></p>
<p>设计思维 | 高层设计 | 并发 | 基于模型的设计 | 设计评审和审计 |
通用策略软件设计的上下文 | 详细设计 | 控制和事件处理 | 面向功能的设计 |
质量属性 | 质量分析和评估技术软件设计中的关键问题 | 设计描述 |
数据持久化 | 以数据为中心的设计 | 行为设计描述 | 度量和指标软件设计原理
| 组件分布 | 面向对象设计 | 用户为中心的设计 | 设计模式 |
错误和异常处理设计基本原理 | 集成和互操作性 | 基于组件的设计 |
专门的软件设计 | 领域特定语言验证、确认和认证 |
事件驱动设计保障、安全和安全性 | 面向方面的设计变异性 |
基于约束的设计领域驱动设计其他方法</p>
<p><strong>图 3.1.</strong> 软件设计知识领域的主题分解</p>
<h2 id="1-软件设计基础-34">1. 软件设计基础 [3*][4*]</h2>
<p>这里介绍的概念、观念和术语构成了理解软件设计的作用和范围的基础。</p>
<h3 id="11-设计思维-3-c1-3-4-c1-2">1.1. 设计思维 [3*, c1-3] [4*, c1-2]</h3>
<p>设计无处不在，存在于为满足需求或解决问题而创建的事物和组织中。</p>
<p>从一般意义上说，设计可以被视为一种问题解决形式。例如，<em>棘手问题</em>(wicked
problem)的概念——一个没有明确解决方案的问题——在理解设计的局限性方面很有趣。许多其他观念和概念帮助我们在一般意义上理解设计：目标、约束、替代方案、表示和解决方案。（另见工程基础知识领域中的<em>设计作为问题解决活动</em>。）</p>
<p><em>设计思维</em>包括两个要素：(1) 理解需求或问题；(2)
设计解决方案。Ross、Goodenough 和 Irvine
提供了适用于软件的设计思维的阐述：</p>
<p><em>这个过程包括五个基本步骤：(1) 明确目的或目标；(2)
制定如何实现目的的概念；(3) 设计实现概念结构的机制；(4)
引入表示机制能力和调用其使用的符号；(5)
描述在特定问题上下文中使用该符号来调用机制以实现目的。[20]</em></p>
<p>这特别合适，因为软件设计的大部分工作在于创建必要的<em>词汇</em>来表达问题、表达其解决方案并实现该解决方案。这些步骤强调了软件设计问题解决的语言性质。这是我们在高层设计、详细设计和架构设计中看到的反复出现的模式（参见软件架构知识领域中的<em>大规模架构</em>）。因此，软件设计是将问题陈述转化为解决方案陈述的实践过程。软件设计与其他类型的设计有共同之处。设计可以通过<em>设计理论</em>进一步理解
[8]。</p>
<h3 id="12-软件设计的上下文-4-c13-14-21-c19-20">1.2. 软件设计的上下文 [4*,
c13-14] [21*, c19-20]</h3>
<p>软件设计是软件开发过程的重要组成部分。要理解软件设计的作用，需要了解它如何融入软件开发生命周期（参见软件过程知识领域）。要理解这个上下文，重要的是理解软件需求、软件构造、软件测试和软件维护的主要特征和作用。上下文因许多因素而异，包括</p>
<p>软件需求、软件构造、软件测试和软件维护的主要特征和作用。上下文因许多因素而异，包括利益相关者和关注点（参见软件架构知识领域中的<em>利益相关者和关注点</em>主题，第1.4节<em>软件设计原理</em>，以及主题5<em>软件设计策略和方法</em>）。相比之下，其他问题”涉及软件行为的某些方面，这些方面不在</p>
<p>形式化程度和生命周期阶段。应用领域，但涉及一些支持领域”[2]。这些问题通常横切系统的功能，被称为<em>方面(aspects)</em>，它们”往往不是软件功能分解的单元，而是以系统化方式影响组件性能或语义的属性”[12]。</p>
<p>软件设计是将客户和其他需求、需要和关注点转化为可实施的设计规范。其上下文包括以下内容:</p>
<p>• 软件设计与软件需求的关系:
需求建立了一组软件设计必须解决的问题。</p>
<p>• 软件设计与软件架构的关系:
在已确立架构的情况下，该架构通过捕获系统的基本方面来约束设计:
例如其主要组件及其互连、应用程序接口(APIs)、要使用的风格和模式，以及要遵守和执行的架构原则。</p>
<p>• 软件设计与软件构造的关系:
软件设计必须为实现者构建系统提供指导。</p>
<p>• 软件设计与软件测试的关系:
软件设计为整体测试策略和测试用例提供基础，以确保设计正确实施并按预期运行。</p>
<h2 id="13-软件设计中的关键问题-3-p69ff-4-c1711-21-c6-7">1.3.
软件设计中的关键问题 [3*, p69ff] [4*, c17.1.1] [21*, c6-7]</h2>
<p>在设计软件时必须处理许多关键问题。有些是所有软件都必须解决的质量<em>关注点(concerns)</em>(性能、安全性、可靠性、可用性、可维护性等)。另一个重要问题是如何细化、组织、互连和打包软件组件。这些问题如此基础，以至于所有设计方法都以某种方式处理它们。</p>
<p>此外，还有一些问题在某个特定应用领域中具有重要意义，但涉及某些支持领域。</p>
<h2 id="14-软件设计原则-4-c42">1.4. 软件设计原则 [4*, c4.2]</h2>
<p><em>原则(principle)</em>是”作为信念或行为系统或推理链基础的基本真理或命题。“[牛津英语词典]
<em>设计原则(Design
principles)</em>为设计过程中的决策提供方向或指导。</p>
<p>有些原则起源于软件工程的早期，其他原则甚至早于该学科，源自与软件无关的工程最佳实践。(见工程基础知识领域。)决策也可以通过定量方法来辅助，如软件工程经济学知识领域中讨论的那样。软件设计原则是关键概念，为许多不同的软件设计概念、方法和方式提供基础。下面列出的原则适用于设计的任何三个阶段。这些原则中的许多是相互关联的。无论是单独使用还是与其他原则结合使用，它们都反映在软件设计的其他地方，产生许多在设计捕获、策略和方法中发现的概念和构造。这本身就是上述设计思维过程的应用。软件设计原则包括以下内容:</p>
<p>•
<em>抽象(Abstraction)</em>是”关注与特定目的相关的信息而忽略其余信息的对象视图”[11]。“抽象原则……有助于识别表面上不同实体的共同本质属性”[20]。(另见计算基础知识领域中的<em>抽象</em>主题。)</p>
<p>• <em>关注点分离(Separation of concerns,
SoC)</em>。<em>设计关注点</em>是”与软件设计有关的感兴趣领域”[11]，与其一个或多个利益相关者相关。通过识别和分离关注点，设计者可以单独关注系统的每个关注点，Dijkstra对此说”即使不能完全做到，[SoC]仍然是有效组织思想的唯一可用技术”[5]。(另见软件架构知识领域中的<em>利益相关者和关注点</em>主题。)</p>
<p>•
<em>模块化(Modularization)</em>(或<em>细化(refinement)</em>或<em>分解(decomposition)</em>)将大型软件结构化为包含较小组件或单元。每个组件都被命名，并具有定义良好的接口来与其他组件交互。较小的组件更容易理解，因此也更容易维护。存在许多模块化策略。(见主题5软件设计策略和方法。)</p>
<p>传统上，目标是将不同的功能和职责放在不同的组件中。David
Parnas倡导</p>
<p>组件如何构建的细节。(见上面的<em>封装(Encapsulation)</em>(或<em>信息隐藏(information
hiding)</em>)。)</p>
<p>•
<em>耦合(Coupling)</em>被定义为”计算机程序中模块之间相互依赖的度量”[11]。大多数设计方法主张模块应该是松散或弱耦合的。</p>
<p>•
<em>内聚(Cohesion)</em>(或<em>局部化(localization)</em>)被定义为”模块内元素关联强度的度量”[11]。内聚强调基于模块组成部分的相关性来组织它们。大多数设计方法主张模块应该最大化其内聚性/局部性。</p>
<p>•
<em>一致性(Uniformity)</em>是跨软件组件保持一致性的原则——应该产生通用解决方案来解决常见或重复出现的问题。这些包括命名方案、符号和语法、定义服务访问的接口和机制，以及元素和参数的排序。这可以通过规则、格式和风格等约定来实现。</p>
<p>•
<em>完整性(Completeness)</em>(或<em>充分性(sufficiency)</em>)意味着确保软件组件捕获抽象的重要特征，不遗漏任何内容。完整性</p>
<p>模块化的特殊情况，这些模块化策略包括关注点分离或分而治之等更通用的策略（参见计算基础中的问题解决技术主题）。</p>
<ul>
<li><p><strong>封装</strong>（或<strong>信息隐藏</strong>(information
hiding)）建立在抽象和模块化原则之上，使得非必要信息不易访问，从而让模块的使用者能够专注于接口的基本要素。</p></li>
<li><p><strong>接口与实现分离</strong>是封装的一种应用，它通过定义组件的公共接口来定义组件，这些接口对客户端是已知且可访问的；将组件的使用与其实现隔离开来。</p></li>
<li><p><strong>其他设计原则</strong>。随着自主系统的日益增多、机器学习和人工智能的使用，以及一般具有更广泛社会影响的系统的出现，<strong>伦理对齐设计</strong>(Ethically
Aligned
Design)方法已被开发出来，以解决包括普世人类价值观、政治自决、数据代理权和技术可靠性等问题
[9]。伦理对齐设计的一般原则包括人权、福祉、数据代理权、有效性、透明度、问责制、对滥用的意识以及能力。</p></li>
</ul>
<h2 id="2-软件设计过程">2. 软件设计过程</h2>
<p><strong>[4*, c3] [21* c2, c7]</strong></p>
<p>软件设计通常被认为是一个多阶段的过程或活动。软件设计可以分为以下阶段或阶段。必要时，我们将阶段与一般活动区分开来：</p>
<ul>
<li>架构设计阶段</li>
<li>高层设计阶段</li>
<li>详细设计阶段</li>
</ul>
<p>架构设计阶段从整体及其与环境的关系角度处理系统的基本问题（参见软件架构知识领域）。</p>
<p>高层设计阶段是<strong>面向外部的</strong> ——
开发软件的顶层结构和组织，识别其各种组件以及软件系统及其组件如何与环境及其元素交互。</p>
<p>详细设计阶段是<strong>面向内部的</strong> ——
以足够的细节规范每个组件，以便于构造并满足其外部义务，包括如何将软件组件进一步细化为模块和单元。</p>
<p>每个阶段都反映了1.1节<strong>设计思维</strong>中概述的基本模式。</p>
<p>并非所有阶段都出现在每个软件过程中。然而，当存在时，每个阶段都会对正在开发的软件产生相应的考虑。</p>
<p>尽管软件开发人员通常遵循类似的指导原则来确定每个阶段发生的事情，但关于必须做什么以及何时做并没有严格的界限。例如，对于许多软件系统，选择排序数据的算法将推迟到程序员那里，在系统需求、架构描述或设计规范提供的约束和指导范围内进行。然而，对于另一个软件系统，合适算法的存在可能在架构上具有重要意义，必须在生命周期早期确定。如果没有该算法，就不可能构造满足其需求的软件。</p>
<p>每个阶段的一些经验法则包括：</p>
<ul>
<li><p><strong>架构设计阶段</strong>定义计算模型、主要计算元素以及它们之间的重要协议和关系。该阶段制定策略来解决横切关注点(crosscutting
concerns)，如性能、可靠性、安全性和安全保障，以及横切决策的阐述，包括系统范围的风格(styles)（例如，事务性n层风格与管道和过滤器风格，以及此类决策的理由）。</p></li>
<li><p><strong>高层设计阶段</strong>包括识别主要计算元素及其之间的重要关系，重点关注每个主要组件的存在、角色和接口。该定义应足够详细，以允许客户端组件的设计者或程序员正确且高效地访问每个服务的功能
—— 而无需阅读其代码。</p></li>
<li><p><strong>详细设计阶段</strong>定义每个模块的内部结构，重点关注算法、数据访问和数据表示的详细说明和选择理由。详细设计规范应足够详细，以允许程序员在构造期间对每个模块进行编码（参见软件构造知识领域）。代码是解决方案的表示，足够详细和完整，以便编译器（或解释器）可以执行它。</p></li>
</ul>
<p><a href="#软件设计">软件设计</a> 3-5</p>
<p>呈现各种形式，其中最重要的可能是针对需求的设计完整性(design
completeness)：设计应足以让设计者演示如何满足需求以及后续工作将如何满足这些需求。设计应该在软件的模式和状态方面是完整的。</p>
<ul>
<li><p><strong>可验证性</strong>(Verifiability)意味着可以获得根据需求和其他约束验证设计所需的信息。这与任何软件都相关，但对于高保障软件(high-assurance
software)尤其重要，例如存在安全性、可靠性或安全关键性考虑的软件。软件设计文档(SDD)应足以作为验证设计的基础。（参见软件测试知识领域和软件质量知识领域。）</p></li>
<li><p>将主要系统组件细化为模块或程序单元，包括它们提供的功能和过程、计算属性、算法、数据访问规则和数据结构。这包括以下内容：</p></li>
</ul>
<h1 id="21-高层设计-3-c5-4-c6">2.1. 高层设计 [3*, c5] [4*, c6]</h1>
<p>高层设计指定系统主要组件之间以及与环境（包括用户、设备和其他系统）的交互。高层设计处理以下内容:</p>
<p>• 系统必须响应的外部事件和消息</p>
<p>• 系统必须产生的事件和消息</p>
<p>• 事件和消息的数据格式和协议规范</p>
<p>• 输入事件和消息与输出事件和消息之间的顺序和时序关系规范</p>
<p>• 端到端事务和事件线程的跟踪和分析</p>
<p>• 数据持久化（数据如何存储和管理）</p>
<p>高层设计在系统软件架构（如果有）建立的范围内进行。上述每一项都可能受到架构指令的指导或约束。例如，事件信号和消息传递将使用架构建立的协议和交互模式。数据格式和协议将使用软件架构指定的数据和通信标准。如果没有明确的架构设计阶段，这些指令中的一些将由软件需求确定或在高层设计期间决定。</p>
<p>• 使用现成组件和应用程序框架的机会</p>
<p>• 将设计职责分配给模块和程序单元</p>
<p>• 模块之间的交互</p>
<p>• 组件、模块和程序单元之间的作用域和可见性</p>
<p>• 组件模式、组件状态及其之间的转换</p>
<p>• 数据和控制相互依赖关系</p>
<p>• 数据组织、打包和实现</p>
<p>• 用户界面</p>
<p>• 必需的算法和数据结构</p>
<h1 id="3-软件设计质量-4-c4">3. 软件设计质量 [4*, c4]</h1>
<p>软件需求和架构指令旨在引导软件实现某些特征或设计质量(design
qualities)。设计质量是关注点的一个重要子类（参见软件架构知识领域中的利益相关者和关注点主题）。设计原则（参见1.4节软件设计原则）的一个作用是帮助软件实现这些质量。设计者感兴趣的特征包括以下内容：</p>
<h2 id="31-并发性-21-c17">3.1. 并发性 [21*, c17]</h2>
<p>并发设计关注软件如何细化为并发单元，如进程(processes)、任务(tasks)和线程(threads)，以及这些决策对效率、原子性、同步和调度的影响。</p>
<h2 id="32-控制和事件处理-21-c21">3.2. 控制和事件处理 [21*, c21]</h2>
<p>事件处理关注如何组织控制流，以及如何通过各种机制（包括同步、隐式调用和回调）处理反应式和时间事件。</p>
<h2 id="33-数据持久化-21-c6-c16">3.3. 数据持久化 [21*, c6, c16]</h2>
<p>数据持久化关注整个系统中数据的存储和管理。</p>
<h2 id="34-组件分布-21-c17">3.4. 组件分布 [21*, c17]</h2>
<p>分布关注软件组件如何分布在硬件（包括计算机、网络和其他设备）上，以及这些组件如何在满足性能、可靠性、可扩展性、可用性、可监控性、业务连续性和其他期望的同时进行通信。</p>
<h2 id="35-错误和异常处理容错-21-c11">3.5. 错误和异常处理、容错 [21*,
c11]</h2>
<p>此关注点涉及如何预防、避免、缓解、容忍和处理错误和异常情况。</p>
<h2 id="36-集成和互操作性-4-c11-c14-c16">3.6. 集成和互操作性 [4*, c11, c14,
c16]</h2>
<p>这个问题出现在企业或系统之系统层面，或者当异构系统或应用程序需要通过数据交换或访问彼此的服务进行互操作时的任何复杂软件中。在软件系统内部，当使用不同框架、库或协议设计组件时会出现这个问题。</p>
<h2 id="37-保证安全性和安全-21-c10-14">3.7. 保证、安全性和安全 [21*,
c10-14]</h2>
<p>高保证(High
assurance)涵盖许多软件质量，包括安全性和安全关注点，涉及软件是否具备限制损害的策略、提供服务连续性、协助修复和恢复。安全设计(Design
for
safety)涉及管理软件在可能导致人员伤亡或财产或环境损失的情况下的行为。</p>
<h2 id="38-可变性-7">3.8. 可变性 [7*]</h2>
<p>可变性关注软件系统中允许的变化。它是大多数软件的一个基本方面[6]。它是为不同市场细分或使用环境创建软件系统变体的能力。</p>
<p>对可变性的兴趣首先出现在软件产品线和系统族中，以适应和管理多个变体的部署，例如针对不同组织或市场。（参见附录B
6，产品线、方法和工具的标准）。它也与软件生态系统和上下文感知软件相关。（另见软件构造知识领域中3.5节构造中的重用）。</p>
<p>特性模型(Feature
models)用于将需求和依赖关系收集到捆绑包中。（参见软件工程模型和方法知识领域中4.1主题敏捷方法下的特性驱动开发）。</p>
<h1 id="4-记录软件设计-1-4-c7-8">4. 记录软件设计 [1*] [4* c7-8]</h1>
<p>设计过程的成果是积累的知识和记录这些知识的工作产品。软件设计的工作产品捕获（1）使用领域词汇表达的待解决问题的各个方面；（2）解决设计问题的解决方案词汇表（参见1.1节设计思维）；（3）已做出的主要决策；</p>
<p>的行为符合预期，特别是在面对危险时。安全性成为分布式应用程序的关键问题，其中组件使用不同的协议和媒介进行通信。<strong>安全设计</strong>关注如何防止未经授权的信息披露、创建、更改、删除或拒绝访问信息和其他资源，以应对系统攻击或系统违规行为。</p>
<p>这些工作产品，通常称为<strong>设计描述</strong>或<strong>设计规范</strong>，可以采用文本、图表、模型和原型的形式，以及(4)每个重要决策的理由说明。记录重要决策的理由可以增强软件产品的长期可维护性(maintainability)，当考虑进行修改或增强时(参见4.6节<em>设计理由</em>)。这些工作产品构成了要实现的软件的蓝图。</p>
<p>软件设计的一个基本方面是设计师之间以及与客户、实施者和其他利益相关者(stakeholders)之间关于设计的沟通。无论软件是使用敏捷、传统还是形式化方法开发的，都是如此。沟通将根据目标受众、所传达的详细程度以及与利益相关者关注点的相关性而有所不同。例如，在使用传统或形式化方法时，设计通常通过一系列设计描述逐步演进，而在敏捷方法中，不断演进的设计可能隐含在开发人员的思维中，仅在代码中显式表达。虽然后一种方法支持开发人员的敏捷性，但其他利益相关者，如那些关注需求、认证、测试和质量保证的人员，可能需要明确的设计信息来完成他们的工作。因此，项目应该根据利益相关者受众、主题和预期用途，有意识地决定需要哪些设计规范。</p>
<p>设计师可以分析和评估这些工作产品，以确定设计是否能够满足软件的需求和约束。软件设计还检查和评估替代方案和权衡(trade-offs)。除了将它们用作构建和测试的输入和起点外，利益相关者还可以使用设计工作产品来规划后续活动，例如系统验证和确认。</p>
<p>随着设计概念的演进，它们的表示方法也在演进(参见1.1节<em>设计思维</em>)；设计过程的一部分涉及为问题和解决方案创建适当的词汇表。非正式的草图可能最适合早期阶段。区分过程中的(“工作”)规范和最终设计产品是有用的。前者是设计团队为设计团队制作的；后者可能是为已知的利益相关者甚至为未知的未来受众制作的。</p>
<p>存在许多表示软件设计工件(artifacts)的符号。软件设计通常使用多种类型的符号进行。两个广泛的关注领域是软件结构和软件行为。有些用于描述设计的结构组织，其他用于表示软件的预期行为。下面，它们被分类为结构和行为关注的符号(分别参见4.2节<em>结构设计描述</em>和4.3节<em>行为设计描述</em>)。某些符号主要用于架构设计，其他主要用于详细设计；有些在软件设计的所有阶段都很有用。有些符号与特定设计方法的上下文紧密相关(参见软件设计策略和方法知识领域)。</p>
<p>统一建模语言(UML)是一个广泛使用的符号系列，解决结构和行为关注，并在从架构到详细设计的所有设计阶段使用[1]。</p>
<h2 id="41-基于模型的设计-4-c73-21-c55">4.1. 基于模型的设计 [4*, c7.3]
[21*, c5.5]</h2>
<p>在软件工程的历史中，包括架构和设计，已经从基于文档的工件演变为基于模型的工件。<strong>基于模型的设计</strong>(Model-Based
Design, MBD)是一种记录设计的方法，其中模型起着重要作用。</p>
<p>这一趋势反映了基于文档的工件的局限性和自动化工具能力的提升。基于文档的工件使用自然语言和非正式图表来传达设计师的意图，这可能引入歧义和不完整性。即使文档使用明确定义的格式，相关信息也可能分散在各个文档中，使理解和分析变得困难。使用MBD，适当的工具可以收集和组织相关信息，供设计师和其他利益相关者以可访问的形式使用。</p>
<p>现代工具加速了从文档到基于模型的工件的趋势。工具支持各种软件方面的动画或仿真、假设场景和权衡的分析以及快速原型制作。工具还促进了持续测试和集成方法、增强的和交互式的可追溯性(traceability)以及知识捕获和管理，这些在基于文档的方法中是低效甚至不可行的。</p>
<p><strong>模型驱动开发</strong>(Model-Driven Development,
MDD)是一种使用模型作为主要工件的开发范式。</p>
<p>• 实体关系图(Entity Relationship Diagrams,
ERDs)用于表示存储在信息库中或作为接口描述一部分的数据的概念、逻辑和物理模型。</p>
<p>• 接口描述语言(Interface Description Languages,
IDLs)是类似编程语言的语言，用于定义软件组件的接口(导出操作的名称和类型)。</p>
<p>• 结构图(Structure charts)用于描述</p>
<p>开发过程的<em>主要</em>产物（参见程序的调用结构（即显示哪些模块调用以及被哪些其他模块调用））。</p>
<p><em>软件工程模型和方法</em> KA）。</p>
<p><strong>4.2. 结构性设计描述</strong></p>
<p>[1*, c4-14][4*, c7, c10] [7*, c4] [21*, c5.3]</p>
<p>以下类型的表示法（大多数是图形化的）用于表示软件设计的结构方面——也就是说，它们用于描述主要组件以及它们如何互连（静态视图）以及职责如何分配给组件和模块：</p>
<p>• 类图和对象图用于表示一组类和对象及其相互关系。 •
组件图用于表示一组<em>组件</em>（系统中可替换的元素，符合并提供一组接口的实现）及其互连。组件模型从早期的模块互连语言演变为像Ada和Java这样的编程语言的包系统，以及当前函数式语言系统（如Haskell和Coq）的复杂模块系统。
•
类职责协作者卡片(CRCs)用于表示组件（类）的名称、它们的职责以及它们与之交互以履行这些职责的组件。
•
部署图用于表示一组物理节点及其互连，以建模软件部署在硬件上的物理方面。</p>
<p><strong>4.3. 行为性设计描述</strong></p>
<p>[1*, c15-24] [4*, c9-10] [7*, c5] [21*, c5.4]</p>
<p>以下表示法和语言（一些是图形化的，一些是文本化的）用于描述软件系统及其组件的动态行为。这些表示法中的许多主要（但不仅限于）在详细设计期间有用。此外，行为描述可以包括设计决策的理由（参见4.6节<em>设计理由</em>）。</p>
<p>•
活动图用于显示从一个活动到另一个活动的计算流程。它们还可以表示并发活动、它们的输入和输出以及并发的机会。
•
交互图描述一组对象之间的交互。交互图有两种主要类型：通信（或协作）图和序列图。通信图显示对象之间的交互，重点是它们的链接以及它们在这些链接上交换的消息。序列图显示对象之间的交互，重点是这些对象之间传递的消息的时间顺序。
•
数据流图(DFDs)用于显示计算元素之间的数据流。DFD提供”基于建模信息在操作元素网络中流动的描述，每个元素使用或修改流入该元素的信息”[4]。DFD还有其他用途，例如安全分析，因为它们识别攻击和机密信息泄露的可能路径。
• 决策表和图用于表示条件和动作的复杂组合。 •
流程图用于表示控制流和相关动作的序列。 •
状态（转换）图和状态图用于显示从一个状态到另一个状态的转换，以及组件的行为如何基于其当前状态和对输入事件的响应而变化。
• 形式化规范语言(Formal specification
languages)主要是基于数学基本概念（例如类型、集合、序列、逻辑命题）的文本语言，用于严格和抽象地定义软件组件接口和行为，通常以前置条件和后置条件、不变量、类型检查和计算模型的形式表示（参见软件工程模型和方法KA中的<em>形式化方法</em>部分）。
•
伪代码和程序设计语言(PDLs)是结构化的、类似编程语言的表示法，用于描述过程的处理行为，通常在详细设计阶段使用。这些语言的使用如今不太常见，但仍然可以在算法文档中找到。</p>
<p><strong>4.4. 设计模式和风格</strong></p>
<p>解释器(interpreter)、迭代器(iterator)、中介者(mediator)、备忘录(memento)、观察者(observer)、对等(peer-to-peer)、发布-订阅(publish-subscribe)、状态(state)、策略(strategy)、模板(template)、访问者(visitor)）</p>
<p>设计模式可以用来反映在过去解决特定设计问题时已被证明有用的习惯用法，建立解决方案词汇表，以及记录和解释设计决策。它们出现在设计的所有阶段，包括架构设计。通常架构风格可以被视为”大规模”的模式，描述了解决架构层面问题的常见解决方案，这些问题在软件中普遍存在。（另见主题2.2架构风格和模式，软件架构KA）。</p>
<p><strong>4.5. 专用和领域特定语言</strong></p>
<p>[21*, c15]</p>
<p>并非每种设计表示都能轻易地归入结构/行为二分法中。例如，用户界面设计混合了用户可能看到的内容的结构布局与基于用户操作的屏幕排序的行为逻辑。诸如安全性和可靠性等专业关注点通常有它们自己的表示形式，这些形式在这些社区的专家中不断演变[21]。</p>
<p>最近的趋势是<em>领域特定语言</em>(DSLs)的成熟以及开发它们的广泛可用工具。在这种方法中，设计过程的一部分是将特定应用领域的概念和构造编码化，以创建该领域的计算机语言，从而使用这些构造表示设计可以导致动画化或可执行的实现。DSL模糊了界限</p>
<p>[3*, c12] [4*, c15] [7*, c1-2] [21*, c7.2]</p>
<p>这种方法中建模语言、设计语言和编程语言之间存在差异。</p>
<p>简洁地说，模式是”在给定上下文中针对常见问题的通用解决方案”[7]。设计模式包括以下几类：</p>
<p>• 创建型模式（例如：建造者、工厂、原型、单例） •
结构型模式（例如：适配器、桥接、组合、装饰器、外观、享元、代理） •
行为型模式（例如：命令</p>
<p>存在针对模拟、实时、响应式和分布式系统、游戏开发、用户界面、测试开发和语言处理工具等领域的DSL(领域特定语言)和支持工具。DSL的发展得益于日益强大的语法驱动工具，这些工具可以根据语言定义生成图形用户界面、语法检查器、代码生成器、编译器和专用语言的链接器。</p>
<p><a href="#软件设计">软件设计</a> 3-11</p>
<h2 id="46-设计原理-3-c164-c12-21-c61">4.6. 设计原理 [3*, c16][4*, c12]
[21*, c6.1]</h2>
<p>一个有价值的设计成果是对所做主要决策的洞察和明确文档，以及对每个决策的原理解释。设计原理捕获了<em>为什么</em>做出某个设计决策。这包括先前的假设、考虑的替代方案、以及为选择一种方法而拒绝其他方法所分析的权衡和标准。虽然这些决策的原因对当前设计团队来说可能是显而易见的，但对于那些在部署后修改或维护系统的人来说可能就不那么明显了。记录原理能够增强软件产品的长期可维护性。在维护期间继续捕获变更的原理也有助于软件的可持续性。</p>
<p>捕获被拒绝的决策及其拒绝原因也很有用。当假设、需求或约束发生变化时，捕获这些原理可以使团队重新审视先前被拒绝的决策。原理的重要性在自由和开源软件(FOSS)项目中尤为明显，这些项目通常涉及人员流动频繁的大型分布式开发团队。</p>
<p>设计原理可以作为软件设计描述的一部分或作为配套工件进行捕获。原理通常以文本形式捕获，但也可以使用其他表示形式，例如将设计描绘为相互关联的决策网络的图表。</p>
<h2 id="5-软件设计策略和方法-21-c3">5. 软件设计策略和方法 [21*, c3]</h2>
<p>存在各种策略和方法来构建和指导设计过程；其中许多从编程风格或范式演变而来。除了体现一种或多种通用策略外，大多数设计方法侧重于将一个或多个设计概念（无论是对象、方法还是事件）作为软件的组织主题。这些主题随后指导设计师首先关注什么、如何进行以及如何构建模块。</p>
<h3 id="51-通用策略-4-c13">5.1. 通用策略 [4*, c13]</h3>
<p>一些经常被引用的在设计过程中有用的通用策略示例包括分而治之和逐步细化策略；自顶向下与自底向上策略；使用启发式、模式和模式语言的策略；以及迭代和增量方法。</p>
<h3 id="52-面向功能或结构化设计-4-c9">5.2. 面向功能(或结构化)设计 [4*,
c9]</h3>
<p>这是经典软件设计方法之一。它侧重于细化(或分解)以识别主要软件功能，以自顶向下的方式对其进行详细阐述。结构化设计通常遵循结构化分析，生成DFD(数据流图)和相关的过程描述。各种工具能够将DFD自动转换为高层设计。</p>
<h3 id="53-以数据为中心的设计-4-c9-21-c541">5.3. 以数据为中心的设计 [4*,
c9] [21*, c5.4.1]</h3>
<p>以数据为中心的设计从程序操作的数据结构开始，而不是从它执行的功能开始。软件设计师指定输入和输出数据结构，然后开发将输入转换为输出的程序单元。已经提出了各种启发式方法来处理特殊情况，例如输入和输出结构之间存在不匹配的情况。</p>
<h3 id="54-面向对象设计-4-c10-21-c3">5.4. 面向对象设计 [4*, c10] [21*,
c3]</h3>
<p>已经提出了许多基于对象的软件设计方法。该领域从1980年代中期的早期面向对象设计(其中名词描述对象；动词描述方法；形容词描述属性)演变而来，其中继承和多态性发挥关键作用，到基于组件的设计(CBD)领域，其中可以定义和访问元信息(例如通过反射)。虽然OOD(面向对象设计)的根源源于数据抽象的概念，但责任驱动设计已被提出作为OOD的替代基础原则。设计策略通常配有助记符，例如SOLID(单一职责、开闭、里氏替换、接口隔离和依赖倒置)类设计原则和SOFA(简短、单一职责、少参数和抽象级别一致性)方法设计原则。</p>
<p>3-12 [<em>SWEBOK</em>®] [<em>GUIDE V4.0a</em>]</p>
<h3 id="55-以用户为中心的设计-3-c9">5.5. 以用户为中心的设计 [3*, c9]</h3>
<h3 id="56-事件驱动设计">5.6. 事件驱动设计</h3>
<p>消费者使用称为主题的通道通过消息代理解耦。这不同于点对点消息传递，其中发送者和接收者需要彼此了解才能传递和接收消息。存在不同类型的事件处理，即简单事件处理、事件流处理和复杂事件处理。基于消息的系统经常在设计中包含可识别的发送者和接收者。事件驱动系统可能不会明确识别发送者和接收者—</p>
<p>以用户为中心的设计不仅仅是一种设计方法，而每个模块都会产生事件，同时监听任何它们关心或需要响应的事件
[14]。“匿名”异步消息和事件处理是可扩展系统的良好策略。</p>
<p>它是一种多学科方法，强调深入理解用户及其需求，作为在组织环境和要完成任务的背景下设计用户体验的基础。它涉及收集用户需求、创建任务和决策的用户流程、创建代表用户界面的原型或模型，以及根据原始需求评估设计解决方案
[16]。</p>
<h2 id="56-基于组件的设计-cbd-1-c25-c29-4-c11-c16-21-c16">5.6.
基于组件的设计 (CBD) [1*, c25, c29] [4*, c11, c16] [21*, c16]</h2>
<p>CBD
将软件系统分解为一个或多个独立的组件，这些组件仅通过定义良好的接口进行通信，并符合系统级的标准组件模型。软件组件是一个独立的单元，具有定义良好的接口和依赖关系，可以独立组合和部署。CBD
解决了提供、开发和集成此类组件以提高重用性的相关问题。CBD
通常强调所有组件的通用 API 以及特定服务或职责的专用 API。</p>
<h2 id="57-事件驱动设计-21-c542">5.7. 事件驱动设计 [21*, c5.4.2]</h2>
<p>事件驱动设计是一种方法，系统或组件通过对事件做出反应来调用其操作（间接调用）[15]。发布/订阅消息传递（广播）通常被用作通过网络将事件传输给所有感兴趣的订阅者的方式。发布/订阅使生产者和消费者保持独立。在事件驱动架构中，每个模块产生事件，同时监听任何它们关心或需要响应的事件
[14]。“匿名”异步消息和事件处理是可扩展系统的良好策略。</p>
<h2 id="58-面向方面的设计-aod-1-c10-21-c31">5.8. 面向方面的设计 (AOD) [1*,
c10] [21*, c31]</h2>
<p>AOD
是一种使用方面(aspect)来实现软件需求中识别出的横切关注点(cross-cutting
concern)和扩展的软件构建方法 [12]。AOD
从面向对象的设计和编程实践演变而来。虽然它尚未成为广泛的设计或编程范式(paradigm)，但面向方面的视角经常用于应用框架和软件库中，其中框架或库的参数可以通过方面声明进行配置。</p>
<h2 id="59-基于约束的设计-3-c11">5.9. 基于约束的设计 [3*, c11]</h2>
<p>约束在设计过程中的作用是限制设计空间的大小，以排除不可行或不可接受的替代方案。约束加快了设计速度，因为它们强制进行一些早期决策。约束可以反映对硬件、软件、数据、操作程序、接口或任何影响软件的事物施加的限制。然后可以使用搜索或回溯方法探索受约束的设计空间。基于约束的设计方法用于用户界面设计、游戏和其他应用。一般来说，约束满足问题在计算上可能难以处理；然而，各种类型的基于约束的编程可用于近似或解决约束问题。</p>
<h2 id="510-领域驱动设计-4-c1362-c183">5.10. 领域驱动设计 [4*, c13.6.2,
c18.3]</h2>
<p>领域驱动设计是一种方法，设计者使用与分析师和其他利益相关者共享的领域特定语言(domain-specific
language)来描述目标软件系统。通过这种共享语言，软件需求中指定的对象、角色、事件和活动可以在软件设计描述中表达。（参见需求知识领域）。</p>
<h2 id="511-其他方法-21-c18c21">5.11. 其他方法 [21*, c18–c21]</h2>
<p>还存在其他设计方法（参见软件工程模型和方法知识领域）。</p>
<p>例如，迭代和自适应方法实现软件增量，并减少对严格软件需求和设计的强调。</p>
<p>面向服务的方法使用在分布式计算机上执行的 Web
服务构建分布式软件。软件系统通常使用来自不同提供商的服务构建，这些服务通过标准协议（例如
HTTP、HTTPS、SOAP）互连，旨在支持服务通信和服务信息交换。</p>
<h2 id="6-软件设计质量分析和评估-4-c7-21-c24">6. 软件设计质量分析和评估
[4*, c7] [21*, c24]</h2>
<h3 id="61-设计审查和审计-4-c53">6.1. 设计审查和审计 [4*, c5.3]</h3>
<p>设计审查旨在对设计进行全面检查，以评估其符合性、质量和可行性。</p>
<h3 id="62-质量属性-21-c24">6.2. 质量属性 [21*, c24]</h3>
<p>各种属性有助于软件设计的质量，包括各种”能力”（模块化、可维护性、可移植性、可测试性、可用性）和”特性”（正确性、健壮性）。质量是关注点的主要子集（参见软件架构知识领域中的利益相关者和关注点主题）。一些质量可以在运行时观察到（例如，性能、安全性、可用性、功能性、可用性）；其他的则不能（例如，可修改性、可移植性、可重用性、可测试性）；有些（例如，概念完整性、正确性、完整性）可以在软件设计中观察到。</p>
<h3 id="63-质量分析和评估技术-21-c24">6.3. 质量分析和评估技术 [21*,
c24]</h3>
<p>各种工具和技术可以帮助分析和评估软件设计质量。（另请参见软件质量知识领域中的软件质量工具主题。）</p>
<p>• 软件设计审查包括非正式和严格的技术，根据 SDD
和其他设计工件确定软件质量，例如，架构审查、设计审查和检查；基于场景的技术；需求追踪。</p>
<p>•
静态分析：可用于评估设计的正式或半正式静态（非可执行）分析（例如，故障树分析或自动交叉检查）。如果安全性是一个问题，可以执行设计漏洞分析（例如，针对安全弱点的静态分析）。正式设计分析使用数学方法来验证设计的正确性。</p>
<p>与设计相关的问题，如状态或完成程度、覆盖需求的情况、未解决的问题和潜在问题。设计评审可以在设计的任何阶段进行。</p>
<p>设计评审可以由设计团队、独立第三方或其他利益相关者进行。设计审计(design
audit)更狭义地关注一组特定的特征（例如功能审计）。（另见软件质量KA中的2.3节<em>评审和审计</em>）</p>
<p>• 仿真和原型：动态技术来评估设计（例如性能仿真或可行性原型）。</p>
<h2 id="64-度量和指标">6.4. 度量和指标</h2>
<p>[4*, c5, c17] [21*, c24.5]</p>
<p>度量可用于评估或定量估计软件设计的各个方面；例如规模、结构或质量。已提出的大多数度量都基于用于生成设计的方法（参见主题5软件设计策略和方法）。这些度量分为两大类：</p>
<p>•
基于功能（结构化）的设计度量：通过分析功能分解获得的度量；通常使用结构图（或层次图）表示，可以在其上计算各种度量。
•
面向对象的设计度量：设计结构通常表示为类图，可以在其上计算各种度量。面向对象度量还考虑基于每个方法的代码行数或发送的消息数量的代码复杂性。</p>
<p>允许设计人员预测行为和验证软件性能的分析模型，而不必完全依赖测试。形式化设计分析可用于检测残留的规范和设计错误（可能由不精确、歧义和有时其他类型的错误引起）。（另见软件工程模型和方法KA。）</p>
<p>还可以计算每个类内部内容的属性。</p>
<h2 id="65-验证确认和认证">6.5. 验证、确认和认证</h2>
<p>[21*, c7-8]</p>
<p>对设计进行系统分析或评估在这三个领域中都起着重要作用：策略和方法。这些包括：</p>
<p>• 验证(verification)：确认设计满足规定的需求； •
确认(validation)：确定设计将使系统满足利益相关者的期望，包括客户、用户、操作员和维护人员；
• 认证(certification)：第三方对设计符合其整体规范和预期用途的证明。</p>
<p>（另见软件质量KA中的2.2节<em>验证和确认</em>。）</p>
<h2 id="主题与参考资料对照矩阵">主题与参考资料对照矩阵</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 16%"/>
<col style="width: 16%"/>
<col style="width: 16%"/>
<col style="width: 16%"/>
<col style="width: 16%"/>
<col style="width: 16%"/>
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Booch等[1*]</strong></th>
<th><strong>Brooks [3*]</strong></th>
<th><strong>Budgen [4*]</strong></th>
<th><strong>Gamma等[7*]</strong></th>
<th><strong>Sommerville [21*]</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 软件设计基础</strong></td>
<td></td>
<td>c1-2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.1. 设计思维</em></td>
<td></td>
<td>c1-3</td>
<td></td>
<td></td>
<td>c1-2</td>
</tr>
<tr>
<td><em>1.2. 软件设计的上下文</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.3. 软件设计中的关键问题</em></td>
<td></td>
<td></td>
<td>c13-14</td>
<td></td>
<td>c19-20</td>
</tr>
<tr>
<td><em>1.4. 软件设计原则</em></td>
<td></td>
<td>p69ff</td>
<td></td>
<td>c17.1.1</td>
<td>c6-7</td>
</tr>
<tr>
<td><strong>2. 软件设计过程</strong></td>
<td></td>
<td>c4.2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.1. 高层设计</em></td>
<td></td>
<td>c3</td>
<td></td>
<td>c2,c7</td>
<td></td>
</tr>
<tr>
<td><em>2.2. 详细设计</em></td>
<td></td>
<td>c5</td>
<td></td>
<td></td>
<td>c6</td>
</tr>
<tr>
<td><strong>3. 软件设计质量</strong></td>
<td></td>
<td></td>
<td>c14</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.1. 并发</em></td>
<td></td>
<td></td>
<td>c4</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.2. 控制和事件处理</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>c17</td>
</tr>
<tr>
<td><em>3.3. 数据持久性</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>c21</td>
</tr>
<tr>
<td><em>3.4. 组件分布</em></td>
<td></td>
<td></td>
<td></td>
<td>c6,c16</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>c17</td>
</tr>
</tbody>
</table>
<div class="line-block"><em>3.5. 错误和异常处理容错</em> | | | | c11 |
|<br/>
<em>3.6. 集成和互操作性</em> | | | | c11, c14, c16 | |<br/>
<em>3.7. 保证、安全和安保</em> | | | | c10-14 | |<br/>
<strong>4. 记录软件设计</strong> | | c1-3 | | | c7-8 |<br/>
<em>4.1. 基于模型的设计</em> | | | c7.3 | | c5.5 |<br/>
<em>4.2. 结构设计描述</em> | c4-14 | | c7, c10 | c4 | c5.3 |<br/>
<em>4.3. 行为设计描述</em> | c15-24 | | c9-10 | c5 | c5.4 |<br/>
<em>4.4. 设计模式和风格</em> | | c12 | c15 | c1-2 | c7.2 |<br/>
<em>4.5. 专用和特定领域语言</em> | | | c15 | | |<br/>
<em>4.6. 设计原理</em> | | | c16 | c12 | c6.1 |<br/>
<strong>5. 软件设计策略和方法</strong> | | c3 | | | |<br/>
<em>5.1. 通用策略</em> | | | c13 | | |<br/>
<em>5.2. 面向功能（或结构化）设计</em> | | | c9 | | |<br/>
<em>5.3. 以数据为中心的设计</em> | | | c9 | | c5.4.1 |<br/>
<em>5.4. 面向对象设计</em> | | | c10 | | |<br/>
<em>5.5. 以用户为中心的设计</em> | | | c9 | | |<br/>
<em>5.6. 基于组件的设计</em> | | | c25, c29 | c11, c16 | c16 |<br/>
<em>5.7. 事件驱动设计</em> | | | | | c5.4.2 |<br/>
<em>5.8. 面向切面设计</em> | | c10 | c31 | | |<br/>
<em>5.9. 基于约束的设计</em> | | | c11 | | |<br/>
<em>5.10. 领域驱动设计</em> | | | | | c13.6.2, c18.3 |<br/>
<em>5.11. 其他方法</em> | | | | | c18-21 |<br/>
<strong>6. 软件设计质量分析和评估</strong> | | c7 | | | c24 |<br/>
<em>6.1. 设计评审和审计</em> | | | | c5.3 | |<br/>
<em>6.2. 质量属性</em> | | | | | c24 |<br/>
<em>6.3. 质量分析和评估技术</em> | | | | | c24 |<br/>
<em>6.4. 度量和指标</em> | | | c5, c17 | | c24.5 |<br/>
<em>6.5. 验证、确认和认证</em> | | | | c7-8 | |</div>
<h2 id="延伸阅读">延伸阅读</h2>
<p>Brooks, <em>The Design of Design</em> [3*]</p>
<p>Brooks是软件工程的先驱之一，提供了关于软件设计各个方面的论文和案例研究集。</p>
<h2 id="参考文献-3">参考文献</h2>
<p>[1*] G. Booch, J. Rumbaugh, and I. Jacobson, <em>The Unified Modeling
Language User Guide</em>, 2nd edition, Addison-Wesley, 2005.</p>
<p>[2] J. Bosch, <em>Design and Use of Software Architectures: Adopting
and Evolving a Product-Line Approach</em>, ACM Press, 2000.</p>
<p>[3*] F. Brooks, <em>The Design of Design</em>, Addison-Wesley,
2010.</p>
<p>[12] G. Kiczales et al., Aspect-Oriented Programming, <em>Proc. 11th
European Conf. Object-Oriented Programming</em> (ECOOP 97), Springer,
1997.</p>
<p>[13] T. Kosar, S. Bohra, M. Mernik, Domain-Specific Languages: A
Systematic Mapping Study, <em>Information and Software Technology</em>,
71, 77-91, 2016.</p>
<p>[14] D. Luckham, <em>The Power of Events: an</em>
和软件工程——词汇表，第2版，2017。</p>
<p><em>复杂事件处理导论</em>,</p>
<p>[4] D. Budgen, <em>软件设计：为结构不良的问题创造解决方案</em>,
Addison-Wesley, 2002, 第3版 CRC Press, 2021.</p>
<p>[15] G. Mühl, L. Fiege, and P. Pietzuch,
<em>分布式基于事件的系统</em>, Springer-Verlag, 2006.</p>
<p>[5] E.W. Dijkstra, 论科学思想的作用. 1974.
http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html.</p>
<p>[16] J. Nielsen, <em>可用性工程(Usability Engineering)</em>, Morgan
Kaufman, 1994.</p>
<p>[6] M. Galster, D. Weyns, D. Tofan, B. Michalik, and P. Avgeriou,
软件系统中的可变性——系统文献综述, <em>IEEE软件工程学报</em>, 40(3),
2014.</p>
<p>[17] D.L. Parnas, 将系统分解为模块的标准, <em>ACM通讯</em> 15(12),
1053–1058, 1972.</p>
<p>[7] E. Gamma et al., <em>设计模式：可复用面向对象软件的元素</em>,
第1版, Addison-Wesley, 1994.</p>
<p>[18] D.L. Parnas and P.C. Clements,
合理的设计过程：如何以及为何要伪造它, <em>IEEE软件工程学报</em> 12(2),
251–257, 1986.</p>
<p>[8] S. Gregor and D. Jones, 设计理论的剖析, Association for
Information Systems, 2007.</p>
<p>[19] D.L. Parnas and D.M. Weiss, 主动设计评审：原则与实践,
<em>系统与软件期刊</em> 7, 259–265, 1987</p>
<p>[9] IEEE Std 7000™-2021,
IEEE在系统设计中处理伦理问题的标准模型流程.</p>
<p>[20] D.T. Ross, J.B. Goodenough, and A. Irvine,
软件工程：过程、原则和目标, <em>IEEE计算机</em>, 1975年5月.</p>
<p>[10] ISO/IEC/IEEE 12207, 系统和软件工程——软件生命周期过程.</p>
<p>[21] I. Sommerville, <em>软件工程</em>, 第10版, Pearson, 2016.</p>
<p>[11] ISO/IEC/IEEE 24765:2017 系统</p>
<h2 id="第04章-1"><strong>第04章</strong></h2>
<p><strong>软件构造</strong></p>
<p><strong>缩略语</strong></p>
<p>[API] 应用程序编程接口(Application Programming Interface)</p>
<p>[TDD] 测试驱动开发(Test-Driven Development)</p>
<p>[UML] 统一建模语言(Unified Modeling Language)</p>
<p>[ASIC] 专用集成电路(Application-Specific Integrated Circuit)</p>
<p>[WYSIWYG] 所见即所得(What You See Is What You Get)</p>
<p>[BaaS] 后端即服务(Backend As A Service)</p>
<p>[CI] 持续集成(Continuous Integration)</p>
<p><strong>引言</strong></p>
<p>[COTS] 商用现货(Commercial Off-The-Shelf)</p>
<p><em>软件构造</em>是指通过编码、验证、单元测试、集成测试和调试来详细创建和维护软件。</p>
<p>[CSS] 层叠样式表(Cascading Style Sheets)</p>
<p>[DSL] 领域特定语言(Domain-Specific Language)</p>
<p>软件构造知识领域(KA)与所有其他知识领域相关联，但它与软件设计和软件测试知识领域的联系最为紧密，因为软件构造过程涉及大量的设计和测试。该过程使用设计输出并为测试提供输入(“设计”和”测试”在这种情况下指的是活动，而不是知识领域)。设计、构造和测试之间的界限(如果有的话)因项目中使用的软件生命周期过程而异。</p>
<p>[DSP] 数字信号处理器(Digital Signal Processor)</p>
<p>[ESB] 企业服务总线(Enterprise Service Bus)</p>
<p>[FPGA] 现场可编程门阵列(Field Programmable Gate Array)</p>
<p>[GPU] 图形处理单元(Graphic Processing Unit)</p>
<p>[GUI] 图形用户界面(Graphical User Interface)</p>
<p>虽然一些详细设计可能在构造之前进行，但大量设计工作是在构造期间完成的。因此，软件构造知识领域与软件设计知识领域紧密相关。</p>
<p>[HTML5] 超文本标记语言第5版(Hypertext Markup Language Version 5)</p>
<p>[IDE] 集成开发环境(Integrated Development Environment)</p>
<p>此外，在整个构造过程中，软件工程师会对他们的工作进行单元测试和集成测试。因此，软件构造知识领域也与软件测试知识领域紧密相关。</p>
<p>[JEE] 雅加达企业版(Jakarta Enterprise Edition)</p>
<p>[MDA] 模型驱动架构(Model-Driven Architecture)</p>
<p>软件构造知识领域还与配置管理、质量、项目管理和计算相关，因此也与相关的知识领域相关。</p>
<p>[NPM] Node包管理器(Node Package Manager)</p>
<p>[OMG] 对象管理组织(Object Management Group)</p>
<p>[PIM] 平台独立模型(Platform Independent Model)</p>
<p>[POSIX] 可移植操作系统接口(Portable Operating System Interface)</p>
<p>[PSM] 平台特定模型(Platform-Specific Model)</p>
<p>[SDK] 软件开发工具包(Software Development Kit)</p>
<p>首先，软件构造通常会产生软件项目中需要管理的最多配置项(例如，源文件、文档、测试用例)。因此，软件构造知识领域与软件配置管理知识领域紧密相关。</p>
<p>其次，虽然质量在所有知识领域中都很重要，但代码是软件项目的最终交付物，而代码是在构造过程中产生的。因此，软件质量知识领域与软件构造知识领域紧密相关。</p>
<p>第三，虽然项目管理涉及各种软件开发任务，但软件构造的工作量通常是最大的。</p>
<p><strong>1.1. 最小化复杂性</strong> [1, c2, c3, c7-9, c24, c27, c28,
c3, 1, c32, c34]</p>
<p>所有人在工作记忆中保持复杂结构和信息的能力都是有限的，特别是在长时间内。这极大地影响了人们如何向计算机传达意图，并推动了软件构造的一个关键目标——最小化复杂性。减少复杂性的需求基本上适用于软件构造的各个方面，对于测试软件构造尤为关键。</p>
<p>软件构造可能会受到几种类型的复杂性的影响。可以使用工具来</p>
<h1 id="软件架构-4">软件架构</h1>
<p>软件构造通常产生软件项目的大多数交付成果。因此，软件构造知识领域与软件工程管理知识领域密切相关。</p>
<p>第四，由于软件构造需要算法和编码实践的知识，该知识领域与计算基础知识领域密切相关，后者涉及支持软件产品设计和构造的计算机科学基础。</p>
<h2 id="软件构造主题分解">软件构造主题分解</h2>
<p>软件架构知识领域的主题分解如图4-1所示。</p>
<h3 id="1-软件构造基础">1. 软件构造基础</h3>
<p>软件构造基础包括以下内容：</p>
<ul>
<li>最小化复杂度</li>
<li>预见和拥抱变化</li>
<li>为验证而构造</li>
<li>复用资产</li>
<li>在构造中应用标准</li>
</ul>
<p>前四个概念既适用于设计，也适用于构造。以下部分定义这些概念并描述它们如何应用于构造。</p>
<p>管理软件组件及其构造的复杂性的不同方面。例如，圈复杂度(cyclomatic
complexity)是一种静态分析度量，衡量代码测试和理解的难度。该工具由Thomas
J. McCabe,
Sr.于1976年开发，计算通过程序源代码的线性独立路径数量。理想情况下，至少应该有相应数量的测试用例。其他例子包括Make等工具，可以构建应用程序，或用于输入、编辑和编译代码的集成开发环境(IDE)。这些工具帮助管理构造过程的复杂性。</p>
<p>在软件构造中，通过创建简单易读的代码而不是巧妙的代码来降低复杂性。这通过使用标准(见第3.1.5节，构造中的标准)、模块化设计(见第3.1节，构造设计)和许多其他特定技术(见第3.3节，编码)来实现。面向构造的质量技术也支持这一点(见第3.6节，构造质量)。</p>
<h4 id="12-预见和拥抱变化">1.2. 预见和拥抱变化</h4>
<p>[1-c3-c5, c24, c31, c32, c34, 2-c1, c3, c9, 3-c1]</p>
<p>大多数软件会随时间变化，预见变化驱动软件构造的许多方面；软件运行环境的变化也以多种方式影响软件。预见必要的变化可能很困难，因此软件工程师应该小心地在软件中构建灵活性和适应性，以便更容易地纳入变化。这些软件团队应该通过采用敏捷开发、实践DevOps以及采用持续交付和部署实践来拥抱变化。这些实践使软件开发过程和管理与演进环境保持一致。</p>
<p>此外，当今的商业环境要求许多组织更频繁、更快速、更可靠地交付和部署软件。预见特定变化有助于软件工程师构建可扩展的软件，在不破坏底层结构的情况下增强软件产品。许多特定技术支持预见变化(见第3.3节，编码)。</p>
<figure>
<img alt="图4.1. 软件构造知识领域主题分解" src="media/image-001.png"/>
<figcaption aria-hidden="true">图4.1.
软件构造知识领域主题分解</figcaption>
</figure>
<h4 id="13-为验证而构造">1.3. 为验证而构造</h4>
<p>[1-c8, c20-c23, c31, c34]</p>
<p>为验证而构造以这样一种方式构建软件：使编写软件的软件工程师以及在独立测试和运营活动期间的测试人员和用户能够轻松发现故障。支持为验证而构造的特定技术包括：遵循编码标准以支持代码审查和单元测试，组织代码以支持自动化测试，限制使用</p>
<ul>
<li>编码标准(例如，命名约定、布局和缩进的标准)</li>
<li>异常处理策略(例如，异常中包含的信息以及捕获后如何处理异常的标准)</li>
<li>平台(例如，操作系统调用的接口标准)</li>
<li>工具(例如，UML(统一建模语言)等符号的图表标准)</li>
</ul>
<p>复杂或难以理解的语言[使用外部标准：构建]</p>
<p>结构，并通过日志记录软件行为[依赖外部标准进行构建]</p>
<p>[语言、构建工具、技术接口]</p>
<p>以及软件之间的交互</p>
<h2 id="14-资产复用-2-c15">1.4. 资产复用 [2-c15]</h2>
<p>构建知识领域(KA)与其他知识领域。标准</p>
<p>来自众多来源，包括硬件</p>
<p><strong>复用</strong>意味着使用现有资产来解决不同的问题。在软件构建中，典型的可复用资产包括框架、库、模块、组件、源代码和商业现货(COTS)资产。复用有两个密切相关的方面：<strong>为复用而构建</strong>和<strong>通过复用构建</strong>。</p>
<p>前者意味着创建可复用的软件资产，而后者意味着复用软件资产来构建新的解决方案。复用通常超越项目边界，这意味着可复用资产可以在其他项目或组织中构建。</p>
<h2 id="1sup5-在构建中应用标准-1-c4">1.sup&gt;5. 在构建中应用标准
[1-c4]</h2>
<p>在构建过程中应用外部或内部开发标准有助于实现项目的效率、质量和成本目标。具体而言，对允许的编程语言子集和使用标准的选择是实现更高安全性的重要辅助手段。</p>
<p>直接影响构建问题的标准包括以下内容：</p>
<p>• 通信方法(例如，文档格式和内容的标准)</p>
<p>• 编程语言(例如，Java和C++等语言的标准)</p>
<p>和软件接口规范(例如，对象管理组织(OMG))以及</p>
<p>国际组织(例如，电气和电子工程师协会</p>
<p>(IEEE)、国际标准化组织(ISO))。</p>
<p>内部标准的使用：标准也可以在组织层面的公司级别创建或用于特定项目。</p>
<p>这些标准支持协调团队活动、最小化复杂性、预测变更和构建以进行验证。</p>
<h2 id="2-管理构建">2. 管理构建</h2>
<h3 id="21-生命周期模型中的构建-1-c2-c3-c27-c29-2-c3-c7-3-c1">2.1.
生命周期模型中的构建 [1-c2, c3, c27, c29, 2-c3, c7, 3-c1]</h3>
<p>已经创建了许多模型来描述软件的开发；有些模型比其他模型更强调构建。</p>
<p>有些模型从构建的角度来看更加线性，例如瀑布模型和分阶段交付生命周期模型。这些</p>
<p>模型将构建视为仅在完成重要的前提工作(包括详细的需求工作、广泛的设计工作和详细的规划)之后才发生的活动。更线性的方法强调构建之前的活动</p>
<p><a href="#软件构建">软件构建</a> 4-5</p>
<p>(需求和设计)，并在活动之间创建更明显的分离。在这些模型中，构建的主要重点可能是编码。</p>
<p>其他模型，例如演进式原型和敏捷开发，更具迭代性。这些方法将构建视为与其他软件开发活动(包括需求、设计和规划)同时发生或重叠的活动。这些方法混合了设计、编码和测试活动，并且它们通常将活动的组合视为构建(参见软件工程管理和软件过程知识领域)。</p>
<p>持续交付和部署的实践进一步混合了编码、测试、交付和部署活动。在这些实践中，构建活动期间进行的软件更新被持续交付和部署到生产环境中。整个过程由部署流水线完全自动化，该流水线由各种测试和部署活动组成。</p>
<p>因此，构建的含义取决于所使用的生命周期模型。一般来说，软件构建主要是编码和调试，但它也涉及构建规划、详细设计、单元测试、集成测试和其他活动。</p>
<h3 id="22-构建规划-1-c3-c4-c21-c27-c29">2.2. 构建规划 [1-c3, c4, c21,
c27-c29]</h3>
<p>构建方法的选择是<strong>构建规划</strong>活动的一个关键方面。这种选择影响构建前提条件的执行程度、执行顺序以及构建与其他活动的重叠程度。</p>
<p>构建规划还定义了组件的创建和集成顺序、集成策略(例如，分阶段或增量集成)、软件质量管理流程、任务分配给特定软件工程师的分配，以及根据选定方法的其他任务。</p>
<h3 id="23-构建度量-1-c25-c28">2.3. 构建度量 [1-c25, c28]</h3>
<p>可以度量许多构建活动和制品，包括开发、修改、复用和销毁的代码；代码复杂度；代码检查统计；故障修复和故障发现率；工作量；和进度安排。</p>
<p>这些度量可用于管理构建、在构建期间确保质量以及改进构建过程等用途(有关更多度量信息，请参见软件工程过程知识领域)。</p>
<h3 id="24-管理依赖关系-2-c25">2.4. 管理依赖关系 [2-c25]</h3>
<p>软件产品通常严重依赖于依赖关系，包括内部和外部(商业或开源)依赖关系，这使开发人员能够复用常用功能，而不是重新发明轮子，从而大幅提高开发人员的生产力。此外，包管理器(例如，Java中的Maven和JavaScript中的NPM)被广泛用于自动化安装、升级、配置和删除依赖关系的过程。</p>
<p>软件产品的直接和间接依赖关系构成了依赖供应链网络。供应链网络中的任何依赖关系都可能给软件产品带来潜在风险</p>
<p>应在建设工作开始之前完成。[应由开发人员或工具来管理。]</p>
<p>施工方法会影响项目团队降低复杂性、预见变化和构建可验证性的能力。每个目标也可以在过程、需求和设计层面得到解决，但施工方法的选择将影响它们。[应避免不必要的依赖以提高构建效率。应避免依赖项与软件产品之间的许可证冲突以降低法律风险。]</p>
<p>[应避免依赖项的缺陷或漏洞传播到软件产品中]以提高软件产品的质量。[应制定法规和监控机制以防止开发人员引入不受信任的外部依赖项。]</p>
<p>4-6 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<h2 id="3-实际考虑因素">3. 实际考虑因素</h2>
<p>构建是软件工程师经常需要处理有时混乱、变化甚至相互冲突的现实世界约束的活动。由于现实世界的约束，实际考虑因素比其他一些知识领域更能驱动构建，与其他活动相比，软件工程在构建活动中可能最具工艺性。</p>
<h3 id="31-构建设计-1-c3-c5-c24-2-c7">3.1. 构建设计 [1-c3, c5, c24,
2-c7]</h3>
<p>一些项目将大量设计活动分配给构建，而其他项目则将设计分配给明确专注于设计的阶段。无论具体分配如何，一些详细的设计工作会在构建层面进行，这些设计工作受到软件所解决的现实世界问题所施加的约束的制约。</p>
<p>正如建造实体结构的建筑工人必须对建筑师计划中未预料到的空白进行小的修改一样,软件构建工作者必须在构建过程中进行小的或大的修改,以充实软件设计细节。</p>
<p>构建层面的设计活动细节基本上与软件设计知识领域中描述的相同,但它们以更小的规模应用于算法、数据结构和接口。</p>
<h3 id="32-构建语言-1-c4">3.2. 构建语言 [1-c4]</h3>
<p><em>构建语言</em>包括人类可以指定问题的可执行解决方案的所有通信形式。因此,构建语言及其实现(例如编译器)可以影响软件质量属性,如性能、可靠性和可移植性。因此,它们可能严重导致安全漏洞。</p>
<p>最简单的构建语言是<em>配置语言</em>,软件工程师从有限的预定义选项集中进行选择,以创建新的或自定义的软件安装。Windows和Unix操作系统中使用的基于文本的配置文件就是这方面的例子,一些程序生成器的菜单式选择列表构成了配置语言的另一个例子。</p>
<p><em>工具包语言</em>用于从工具包中的元素(特定应用的可重用部件的集成集)构建应用程序;它们比配置语言更复杂。工具包语言可以明确定义为应用程序编程语言,或者应用程序可能由工具包的接口集隐含。</p>
<p><em>脚本语言</em>是常用的应用程序编程语言。在某些脚本语言中,脚本被称为<em>批处理文件</em>或<em>宏</em>。</p>
<p><em>编程语言</em>是最灵活的构建语言。它们还包含关于特定应用领域和开发过程的最少信息量。因此,它们需要最多的培训和技能才能有效使用。编程语言的选择会极大地影响在编码过程中引入漏洞的可能性(例如,从安全角度来看,C和C++库函数的不安全使用是值得怀疑的)。</p>
<p>编程语言使用三种通用表示法:</p>
<p>• 语言式(例如C/C++, Java) • 形式化(例如Event-B) •
可视化(例如MATLAB)</p>
<p><em>语言式表示法</em>的特点是使用文本字符串来表示复杂的软件构造。文本字符串在模式中的组合可能具有类似句子的语法。如果使用得当,每个字符串都应该具有强烈的语义内涵,当执行软件构造时,能提供对所发生事情的直观理解。</p>
<p>[SOFTWARE CONSTRUCTION] 4-7</p>
<p><em>形式化表示法</em>较少依赖单词和文本字符串的直观日常含义,而更多地依赖由精确、明确和形式化(或数学)定义支持的定义。形式化构建表示法和方法是大多数系统编程表示法的语义基础,其中准确性、时间行为和可测试性比映射到自然语言的容易程度更重要。形式化构造还使用精确定义的符号组合方式,避免了许多自然语言构造的歧义。</p>
<p><em>可视化表示法</em>较少依赖语言式和形式化构建的文本表示法,更多地依赖可视实体的直接视觉解释和放置。</p>
<h3 id="33-编码-1-c3-c5-c24-2-c7">3.3. 编码 [1-c3, c5, c24, 2-c7]</h3>
<p>以下是编码的主要考虑因素:</p>
<p>• 使用数据结构 • 设计和使用算法 • 理解现有代码库 •
使用软件构建技术(例如面向对象编程、结构化编程、基于组件的编程) •
组织源代码(例如到可重用的代码块中) •
利用代码重用机制(例如继承、参数化、模板) • 保证安全性的技术 •
使用和维护测试和调试基础设施 • 编写接受和文档惯例 •
命名变量、命名常量和其他类似实体 • 使用控制结构 •
处理错误条件—包括预期的和异常的(例如,输入错误数据) •
防止代码级安全漏洞(例如,缓冲区溢出或数组索引边界) •
通过使用排除机制和访问串行可重用资源的规则来使用资源,包括线程和数据库锁
• 将源代码组织成语句、例程、类、包或其他结构 • 代码文档</p>
<p>代表底层软件。可视化构建在一定程度上受到限制，因为仅通过在显示器上排列图标来完成”复杂”语句存在困难。然而，这些图标在某些情况下可以成为强大的工具，例如当主要编程任务是为程序构建和”调整”可视化界面时，程序的详细行为具有底层定义。</p>
<p>如今，领域特定语言(DSL)被广泛用于构建特定领域的应用程序。与通用编程语言(如C/C++或Java)不同，DSL是为特定领域的应用程序构建而设计的。因此，DSL通常可以基于目标领域更高级别的抽象来定义，并且可以针对特定类别的问题进行优化。此外，DSL通常可以通过由领域特定概念和规则定义的可视化符号来表达。</p>
<h3 id="33-编码">3.3. 编码</h3>
<p>以下考虑事项适用于软件构建的编码活动：</p>
<ul>
<li>创建可理解源代码的技术，包括命名约定和源代码布局</li>
<li>使用类、枚举类型、可视化代码调优</li>
</ul>
<h3 id="34-构建测试">3.4. 构建测试</h3>
<p>构建涉及两种形式的测试，通常由编写代码的软件工程师执行：单元测试和集成测试。</p>
<p>构建测试旨在缩小故障插入代码的时间与检测到这些故障的时间之间的差距，从而降低修复这些故障所产生的成本。在某些情况下，测试用例在编写代码后编写。在其他情况下，测试用例可能在编写代码之前创建。</p>
<p>构建测试通常涉及软件测试知识领域(KA)中描述的各种测试类型的子集。例如，构建测试通常不包括系统测试、Alpha测试、Beta测试、压力测试、配置测试、可用性测试或其他更专业的测试。</p>
<p>已发布两个关于构建测试的标准：IEEE标准829-2008”IEEE软件测试文档标准”和”IEEE软件单元测试标准”。</p>
<p>有关更专业的参考资料，请参见软件测试知识领域第2.1.1节和第2.1.2节。</p>
<h3 id="35-构建中的复用">3.5. 构建中的复用</h3>
<p>构建中的复用包括为复用而构建和使用复用进行构建。为复用而构建创建具有未来复用潜力的软件，可用于当前项目或其他项目，具有广泛的多系统视角。为复用而构建通常基于可变性分析和设计。为避免代码克隆问题，开发人员应将可复用的代码片段封装到结构良好的库或组件中。</p>
<p>在编码和测试期间与为复用而进行软件构建相关的任务如下：</p>
<ul>
<li>使用参数化、条件编译和设计模式等机制实现可变性</li>
<li>可变性封装以使软件资产易于配置和自定义</li>
<li>测试可复用软件资产提供的可变性</li>
<li>描述和发布可复用软件资产</li>
<li>报告新代码、测试程序或测试数据的复用信息</li>
</ul>
<p>可复用软件资产的形式不限于必须本地集成的软件工件。如今，通过在线接口(如RESTful应用程序编程接口(API))提供各种服务的云服务被广泛应用于应用程序中。在新的云服务模型BaaS(后端即服务)中，应用程序将其后端实现委托给云服务提供商——例如，身份验证、消息传递和存储等实用工具通常由云提供商提供。</p>
<p>复用最好系统地实践，遵循定义明确、可重复的流程。系统复用可以显著提高软件生产力、质量并降低成本。系统复用由软件产品线工程等方法论以及各种软件框架和平台支持。广泛使用的框架(如Spring)为企业应用程序提供可复用的基础设施，因此软件团队可以专注于特定于应用程序的业务逻辑。商业平台提供各种可复用的框架、库、组件和工具来支持应用程序开发以构建其生态系统。</p>
<p>使用复用进行构建意味着通过复用现有软件资产来创建新软件。最流行的复用方法是复用语言、平台、工具或组织存储库提供的库中的代码。除此之外，当今开发的许多应用程序使用第三方开源库。此外，复用和现成的软件通常与新开发的软件具有相同(或更好)的质量要求(例如，安全级别要求)。</p>
<p>在编码和测试期间与使用复用进行软件构建相关的任务如下：</p>
<ul>
<li>选择可复用的单元、数据库、测试程序或测试数据</li>
<li>评估代码或测试的可复用性</li>
</ul>
<h3 id="36-构建质量">3.6. 构建质量</h3>
<p>除了在需求和设计活动期间发生的故障之外，在构建期间引入的故障可能会导致严重的质量问题(例如，安全漏洞)。这些不仅包括安全功能中的故障，还包括允许绕过安全功能或产生其他安全弱点或违规的其他地方的故障。</p>
<p>存在许多技术来确保代码在构建时的质量。用于确保构建质量的主要技术包括：</p>
<h1 id="软件构建">软件构建</h1>
<h2 id="将可重用的软件资产集成到当前软件中">将可重用的软件资产集成到当前软件中</h2>
<h3 id="单元测试和集成测试见第34节构建测试">单元测试和集成测试（见第3.4节，构建测试）</h3>
<h2 id="测试驱动开发见软件测试知识域第612节">测试驱动开发（见软件测试知识域第6.1.2节）</h2>
<h2 id="使用断言和防御性编程">使用断言和防御性编程</h2>
<h2 id="调试">调试</h2>
<h2 id="检查">检查</h2>
<h2 id="技术评审包括面向安全的评审见软件质量知识域第23节">技术评审，包括面向安全的评审（见软件质量知识域第2.3节）</h2>
<h2 id="静态分析见软件质量知识域第221节">静态分析（见软件质量知识域第2.2.1节）</h2>
<p>选择特定的技术取决于所构建的软件以及执行构建活动的软件工程师的技能组合。程序员应该了解良好实践和常见漏洞（例如，来自广泛认可的常见漏洞列表）。针对安全弱点的自动化静态代码分析可用于几种常见编程语言。</p>
<p>构建质量活动通过其关注点与其他质量活动区分开来。这些活动关注与代码密切相关的工件——如详细设计——而不是与代码联系不太直接的其他工件，如需求、高层设计和计划。</p>
<h2 id="37-集成">3.7. 集成</h2>
<p>在构建过程中，一个关键活动是将单独构建的例程(routine)、类、组件和子系统集成到单个系统中。此外，特定软件系统可能需要与其他软件或硬件系统集成。</p>
<p>与构建集成相关的关注点包括规划组件集成的顺序、确定需要什么硬件、创建脚手架(scaffolding)以支持软件的临时版本、确定在组件集成之前对其执行的测试和质量工作程度，以及确定项目中测试软件临时版本的时间点。</p>
<p>程序可以通过阶段性方法或增量方法进行集成。阶段性集成，也称为大爆炸集成(big
bang
integration)，需要延迟组件软件部分的集成，直到所有计划在某个版本中发布的部分都完成。增量集成被认为比传统的阶段性集成具有许多优势（例如，更容易定位错误、改进进度监控、更早的产品交付和改善的客户关系）。在增量集成中，开发人员以小块方式编写和测试程序，然后一次组合一块。通常需要额外的测试基础设施，例如桩(stub)、驱动程序(driver)和模拟对象(mock
object)，以实现增量集成。此外，通过一次构建和集成一个单元（例如，一个类或组件），构建过程可以为开发人员和客户提供早期反馈。</p>
<p>如今，持续集成(CI, Continuous
Integration)已在实践中被广泛采用。使用CI的软件团队频繁集成其工作，导致每天进行多次集成。CI通常通过管道(pipeline)自动化，该管道构建并测试每次集成以检测错误并提供快速反馈。</p>
<h2 id="38-跨平台开发和迁移">3.8. 跨平台开发和迁移</h2>
<p>一些应用程序，如移动应用程序，严重依赖特定平台（例如，Apple、Android），这些平台通常包括操作系统、开发框架和API。为了支持多个平台，开发人员需要使用相应的编程语言和软件开发工具包(SDK)为每个目标平台单独开发和构建应用程序。然而，以这种方式进行多平台开发需要更多的时间和成本，并可能导致不同实现之间的用户体验不同。</p>
<p>跨平台开发允许开发人员使用通用语言开发应用程序并将其导出到各种平台。对于移动应用程序，这通常可以通过两种方式完成。一种方式是使用可以将通用语言编译成特定平台格式的工具生成原生应用程序。另一种是开发混合应用程序(hybrid
application)，将使用超文本标记语言第5版(HTML5)和层叠样式表(CSS)等语言开发的Web应用程序与用于各种操作系统的原生容器或包装器相结合。</p>
<p>对于不是以这种方式开发的应用程序，开发人员可以考虑将应用程序从一个平台迁移到另一个平台。迁移通常涉及不同编程语言和平台特定API的转换，并且可以通过工具部分自动化。</p>
<h2 id="4-构建技术">4. 构建技术</h2>
<h3 id="41-api设计和使用">4.1. API设计和使用</h3>
<p>API是一组导出和共享的签名，用于在软件组件之间进行通信。API优先方法(API-first
approach)已被广泛使用，该方法强调首先设计和构建应用程序的API。在实践中，API优先方法通常通过使用API描述语言(API
description
language)来建立关于API应该如何行为的契约(contract)来实现。</p>
<h3 id="42-面向对象的运行时问题">4.2. 面向对象的运行时问题</h3>
<p>面向对象语言支持运行时机制，包括多态性(polymorphism)和反射(reflection)。这些运行时机制增加了面向对象程序的灵活性和适应性。</p>
<p>多态性是语言支持通用操作的能力，而无需在运行时之前知道软件将包含什么类型的具体对象。因为程序事先不知道对象的类型，所以确切的行为在运行时确定（称为动态绑定，dynamic
binding）。</p>
<p>反射是程序在运行时观察和修改其结构和行为的能力。</p>
<p>并可供库或框架的用户用于编写他们的应用程序。除了签名之外，API
应该始终包含关于程序效果和/或行为（即其语义）的说明。</p>
<p>API 设计应使 API
易于学习和记忆，使代码可读性好，难以误用，易于扩展，功能完整，并保持向后兼容性。</p>
<p>由于 API 通常比广泛使用的库或框架的实现更持久，API
应该简单明了且稳定，以促进客户端应用程序的开发和维护。</p>
<p>API 使用涉及选择、学习、测试、集成以及可能扩展库或框架提供的
API（参见第 3.5 节，构建中的重用）。</p>
<p>对于 RESTful API 等在线接口，OpenAPI 等开放标准起着重要作用。OpenAPI
定义了一个标准的、与语言无关的 HTTP API
接口，支持服务器端和客户端代码的自动生成，涵盖 Java、JavaScript、Python
等流行语言。同时，API 优先的方法在现代软件开发中变得越来越重要。</p>
<p>例如，反射(reflection)允许在运行时检查类、接口、字段和方法，而无需在编译时知道它们的名称。它还允许在运行时实例化新对象并使用参数化的类和方法名称调用方法。</p>
<h2 id="43-参数化模板和泛型">4.3. 参数化、模板和泛型</h2>
<p>[6-c1]</p>
<p><strong>参数化类型(Parameterized
types)</strong>，也称为<strong>泛型(generics)</strong>（Ada、Java、Eiffel）和<strong>模板(templates)</strong>（C++），使类型或类定义无需指定所有使用的其他类型。未指定的类型在使用时作为参数提供。参数化类型提供了第三种方式（除了类继承和对象组合之外）来组合面向对象软件中的行为。</p>
<h2 id="44-断言契约式设计和防御性编程">4.4.
断言、契约式设计和防御性编程</h2>
<p>[1-c8, c9]</p>
<p><strong>断言(assertion)</strong>
是放置在程序中的可执行谓词——通常是例程或宏——用于执行程序的运行时检查。</p>
<p>[软件构建] 4-11</p>
<p>断言在高可靠性程序中特别有用。它们使程序员能够更快地发现不匹配的接口假设、代码修改时出现的错误以及其他问题。断言通常在开发时编译到代码中，之后从代码中编译出来，以免降低性能。</p>
<p><strong>契约式设计(Design by contract)</strong>
是一种开发方法，其中每个例程都包含前置条件和后置条件。当使用前置条件和后置条件时，每个例程或类都与程序的其余部分形成一个契约。契约精确地指定了例程的语义，从而有助于阐明其行为。契约式设计被认为可以提高软件构建的质量。</p>
<p><strong>防御性编程(Defensive programming)</strong>
意味着保护例程免受无效输入的破坏。处理无效输入的常见方法包括检查所有输入参数的值并决定如何处理错误的输入。防御性编程中经常使用断言来检查输入值。</p>
<h2 id="45-错误处理异常处理和容错">4.5. 错误处理、异常处理和容错</h2>
<p>[1-c8, c9]</p>
<p><strong>错误(errors)</strong>
的处理方式影响软件满足与正确性、健壮性和其他非功能属性相关的需求的能力。断言有时用于检查错误。其他错误处理技术——如返回中性值、替换下一个有效数据、记录警告消息、返回错误代码或关闭软件——也会使用。</p>
<p><strong>异常(Exceptions)</strong>
用于检测和处理错误或异常事件。异常的基本结构如下：例程使用
<em>throw</em> 抛出检测到的异常，异常处理块将在 <em>try-catch</em> 块中
<em>catch</em> 异常。try-catch
块可以处理错误条件或将控制权返回给调用例程。</p>
<p>导致异常的所有信息，避免空的 catch
块，了解库代码抛出的异常，也许构建一个集中的异常报告器，并标准化程序对异常的使用。</p>
<p><strong>容错(Fault tolerance)</strong>
是一组通过检测错误然后从错误中恢复或在无法恢复时控制其影响来提高软件可靠性的技术。</p>
<p>最常见的容错策略包括备份和重试，使用辅助代码和投票算法，以及用一个无害的虚假值替换错误值。</p>
<h2 id="46-可执行模型">4.6. 可执行模型</h2>
<p>[7]</p>
<p><strong>可执行模型(Executable models)</strong>
抽象掉特定编程语言的细节和关于软件组织的决策。</p>
<p>与传统软件模型不同，用可执行建模语言（如 xUML（可执行
UML））构建的规范可以在各种软件环境中部署而无需更改。此外，可执行模型编译器（转换器）可以使用一组关于目标硬件和软件环境的决策将可执行模型转换为实现。因此，构建可执行模型是构建可执行软件的一种方式。</p>
<p>可执行模型是支持 OMG 的模型驱动架构(model-driven architecture, MDA)
计划的基础之一。可执行模型是指定平台独立模型(platform-independent model,
PIM) 的一种方式；PIM
是问题解决方案的模型，不依赖于任何实现技术。然后可以通过将 PIM
与其所依赖的平台编织在一起来生成平台特定模型(platform-specific model,
PSM)，PSM 是包含实现细节的模型。</p>
<h2 id="47-基于状态和表驱动的构建技术">4.7. 基于状态和表驱动的构建技术</h2>
<p>[1-c18]</p>
<h1 id="47-基于状态的和基于表格的构造技术-1-c6-5">4.7.
基于状态的和基于表格的构造技术 [1-c6, 5]</h1>
<p>异常处理策略应该仔细设计，遵循通用原则，如在异常消息中包含相关信息。</p>
<p><strong>基于状态的编程</strong>或<strong>基于自动机的编程</strong>是一种使用有限状态机来描述程序行为的编程技术。状态机的转换图用于软件开发的所有阶段（规范说明、实现、调试和文档编制）。主要思想是以自动化技术流程的相同方式构造计算机程序。基于状态的编程通常与面向对象编程相结合，形成一种称为<strong>基于状态的面向对象编程</strong>的新型组合方法。</p>
<p><strong>表格驱动</strong>方法是一种使用表格来显示信息而非通过逻辑语句（如
<em>if</em> 和
<em>case</em>）传达信息的模式。在适当的情况下使用时，表格驱动的代码比复杂的逻辑更简单，也更容易修改。使用表格驱动方法时，程序员需要处理两个问题：在一个或多个表格中存储什么信息，以及如何高效地访问表格中的信息。</p>
<h2 id="48-运行时配置和国际化-1-c3-c10">4.8. 运行时配置和国际化 [1-c3,
c10]</h2>
<p>为了实现更高的灵活性，程序通常被构造为支持其变量的延迟绑定时间。例如，<strong>运行时配置</strong>在程序运行时绑定变量值和程序设置，通常通过即时模式更新和读取配置文件来实现。</p>
<p><strong>国际化</strong>是准备程序（通常是交互式软件）以支持多个语言环境的技术活动。相应的活动<strong>本地化</strong>则是修改程序以支持特定的本地语言。</p>
<p>交互式软件可能包含数十或数百条提示、状态显示、帮助消息、错误消息等。设计和构造过程应适应字符串和字符集问题，包括使用哪种字符集、使用什么类型的字符串、如何在不更改代码的情况下维护字符串，以及如何以最小的处理代码和用户界面影响将字符串翻译成不同的语言。</p>
<h2 id="49-基于文法的输入处理-1-8">4.9. 基于文法的输入处理 [1, 8]</h2>
<p><strong>基于文法的输入处理</strong>涉及对输入标记流的语法分析或<strong>解析(parsing)</strong>。它涉及创建一个表示输入数据的数据结构（称为<strong>解析树</strong>或<strong>语法树</strong>）。解析树的中序遍历通常给出刚刚解析的表达式。接下来，解析器检查符号表中填充树的程序员定义变量。构建解析树后，程序将其用作计算过程的输入。</p>
<h2 id="410-并发原语-9-c6">4.10. 并发原语 [9-c6]</h2>
<p><strong>同步原语(synchronization
primitive)</strong>是编程语言或操作系统提供的编程抽象，用于促进并发和同步。众所周知的并发原语包括信号量(semaphores)、监视器(monitors)和互斥锁(mutexes)。</p>
<p><strong>信号量</strong>是一个受保护的变量或抽象数据类型，为并发编程环境中多个进程或线程控制对公共资源的访问提供了一个简单但有用的抽象。</p>
<p><strong>监视器</strong>是一种抽象数据类型，它呈现一组以互斥方式执行的程序员定义操作。监视器包含共享变量的声明以及对这些变量进行操作的过程或函数。监视器构造确保一次只有一个进程在监视器中活动。</p>
<p><strong>互斥锁(mutex)</strong>（互斥）是一种同步原语，一次只授予一个进程或线程对共享资源的独占访问权。</p>
<h2 id="411-中间件-5-c1-8-c8">4.11. 中间件 [5-c1, 8-c8]</h2>
<p><strong>中间件(Middleware)</strong>是软件的广泛分类，它提供操作系统层之上但应用程序层之下的服务。中间件可以为软件组件提供运行时容器，以提供消息传递、持久化以及跨网络的透明位置。中间件可以被视为使用中间件的组件之间的连接器。现代面向消息的中间件通常提供企业服务总线(ESB)，支持多个软件应用程序之间面向服务的交互和通信。</p>
<h2 id="412-分布式和基于云的软件的构造方法-2-c17-c18-9-c2">4.12.
分布式和基于云的软件的构造方法 [2-c17, c18, 9-c2]</h2>
<p><strong>分布式系统</strong>是物理上分离的、可能是异构的计算机系统的集合，通过网络连接以向用户提供对系统维护的资源的访问。分布式软件的构造与传统软件构造的区别在于并行性、通信和容错等问题。</p>
<p>分布式编程通常分为几个基本的架构类别：</p>
<h2 id="413-异构系统的构造方法-2-c14">4.13. 异构系统的构造方法 [2-c14]</h2>
<p><strong>异构系统</strong>由多种计算单元组成，如中央处理器(CPUs)、图形处理单元(GPUs)、数字信号处理器(DSPs)、微控制器和外围处理器。这些计算单元是独立控制的并相互通信。嵌入式系统通常是异构系统。</p>
<p>异构系统的设计可能需要结合多种规范说明语言来设计不同的系统部分（硬件/软件协同设计）。关键问题包括多语言验证、协同仿真和接口。</p>
<p>在硬件/软件协同设计期间，软件和虚拟硬件开发通过逐步分解并行进行。硬件部分通常在现场可编程门阵列(FPGAs)或专用集成电路(ASICs)中模拟。软件部分被翻译成低级编程语言。</p>
<h1 id="客户端-服务器三层架构n层架构">客户端-服务器、三层架构、N层架构</h1>
<p><strong>4.14. 性能分析与调优</strong></p>
<p>分布式对象、松耦合或紧耦合(见计算基础知识领域第5.6节和软件架构知识领域第2.2节)。</p>
<p>[[1-c25, c26]]</p>
<p><strong>代码效率</strong> —
由架构、详细设计决策以及数据结构和算法选择决定 —
影响执行速度和大小。<strong>性能分析</strong>通过程序执行时收集的信息来调查程序的行为,以识别程序中可能需要改进的热点。</p>
<p>如今,越来越多的应用程序迁移到云端。<strong>基于云的软件</strong>通常采用微服务架构和基于容器的部署。除了传统的分布式软件问题外,基于云的软件开发人员还需要考虑云基础设施问题,如API网关的使用、服务注册和发现。</p>
<p><strong>代码调优</strong>在代码级别改进性能,修改代码使其运行更高效。代码调优通常只涉及影响单个类、单个例程或更常见的几行代码的小改动。有丰富的代码调优技术可用,包括用于调优逻辑表达式、循环、数据转换、表达式和例程的技术。使用低级语言是改进程序热点的另一种常见技术。</p>
<p>基于N层/面向服务架构的分布式系统通常依赖ACID分布式事务来实现涉及多个分布式组件的事务。相比之下,基于云的微服务无法强制执行分布式事务一致性,而是使用某种形式的基于SAGA的最终一致性,这最初是为长期运行的事务设计的。</p>
<p>[[8-c9]]</p>
<p><strong>4.15. 平台标准</strong> [[4-c, 8-c10, 9-c1]]</p>
<p><strong>4.13. 构建异构系统</strong> [[8-c9]]</p>
<p><strong>平台标准</strong>使程序员能够开发可移植的应用程序,这些应用程序可以在兼容环境中执行而无需更改。平台标准通常涉及兼容平台实现必须使用的标准服务和API。</p>
<p><strong>异构系统</strong>由不同类型的各种专用计算单元组成,如图形处理单元(GPU)和其他处理器。</p>
<p>平台标准的典型示例包括Jakarta企业版(JEE);操作系统的可移植操作系统接口(POSIX)标准,主要为基于Unix的操作系统实现的一组标准;以及HTML5,它定义了开发可在不同环境(如Apple
iOS、Android)上运行的Web应用程序的标准。</p>
<p><strong>4.16. 测试优先编程</strong> [[1-c22, 2-c8]]</p>
<p><strong>测试优先编程</strong>(也称为TDD -
测试驱动开发)是一种流行的开发风格,在编写任何代码之前先编写测试用例。这些测试用例应用于当前代码库时会失败。然后编写代码使测试用例通过。此时,可以对新代码和项目的相关部分进行重构和优化。测试优先编程通常能够比传统编程风格更早地检测缺陷并更容易地纠正它们。此外,先编写测试用例迫使程序员在编码前思考需求和设计,从而更早地暴露需求和设计问题。</p>
<p><strong>4.17. 构建的反馈循环</strong> [[3-c3, c16]]</p>
<p>对构建活动的早期和持续反馈是敏捷开发和DevOps最重要的优势之一。敏捷开发通过开发过程中的频繁迭代为构建提供早期反馈。DevOps从运营中提供更快的反馈,使开发人员能够了解他们的代码在生产环境中的表现如何。这种快速反馈是通过技术和实践实现的。</p>
<h2 id="5-软件构建工具">5. 软件构建工具</h2>
<p><strong>5.1. 开发环境</strong> [[1-c30]]</p>
<p><strong>开发环境</strong>或<strong>集成开发环境</strong>(IDE)通过集成一组开发工具,为程序员的软件构建提供全面的设施。程序员对开发环境的选择会影响软件构建的效率和质量。</p>
<p>除了基本的代码编辑功能外,现代IDE通常还提供其他特性,如编辑器内的编译和错误检测、与源代码控制的集成、构建/测试/调试工具、程序的压缩或大纲视图、自动化代码转换以及对重构的支持。</p>
<p>如今,基于云的开发环境可在公有云或私有云服务中使用。这些环境可以提供现代IDE的所有功能甚至更多(例如容器化构建和部署),由云提供支持。</p>
<p>此外,现代IDE通常配备了AI辅助编程功能,这得益于大语言模型(LLM)的最新进展。在这种支持下,程序员可以用伪代码注释定义函数,或概述其实现作为LLM生成或完成代码的提示。程序员让LLM完成许多细节,但仍然审查生成的代码并将其集成到项目中。</p>
<p><strong>5.2. 可视化编程和低代码/零代码平台</strong> [[1-c30]]</p>
<p><strong>可视化编程</strong>允许用户通过图形化操作可视化程序元素来创建程序。作为一种可视化编程工具,GUI(图形用户界面)构建器使开发人员能够以所见即所得(WYSIWYG)模式创建和维护GUI。GUI构建器通常</p>
<p>在DevOps流水线中，如自动化构建和测试、金丝雀发布(canary
release)和A/B测试，通常包含一个可视化编辑器，使开发者能够设计表单和窗口，并通过拖放和参数设置功能管理小部件的布局。</p>
<p><a href="#软件构建">软件构建</a> 4-15</p>
<p>一些GUI构建器可以自动生成与可视化GUI设计相对应的源代码。由于GUI应用程序通常遵循事件驱动风格(事件和事件处理决定程序流程)，GUI构建器工具通常提供代码生成助手，自动化事件处理所需的最重复性任务。支持代码将小部件与触发应用程序逻辑功能的传出和传入事件连接起来。一些现代IDE提供集成的GUI构建器或GUI构建器插件。也有许多独立的GUI构建器。</p>
<p>可视化编程和其他快速应用开发工具已经发展成为低代码/零代码平台(low-code/zero-code
platforms)。这些平台允许开发者通过拖放界面和最少的手工编码以可视化方式构建完整的应用程序。它们通常基于模型驱动设计、可视化编程和代码生成的原则。低代码开发和零代码开发之间的区别在于手工编码；前者需要少量手工编码，而后者几乎不需要。</p>
<h2 id="53-单元测试工具-1-c22-2-c8">5.3. 单元测试工具 [1-c22, 2-c8]</h2>
<p>单元测试(Unit
testing)验证软件模块与其他可独立测试的软件元素(例如类、例程、组件)隔离时的功能。单元测试通常是自动化的。开发者可以使用单元测试工具和框架来扩展和创建自动化测试环境。例如，开发者可以使用单元测试工具和框架将标准编码到测试中，以验证单元在各种数据集下的正确性。每个测试都实现为一个对象，测试运行器(test
runner)运行这些测试。失败的测试用例会在测试执行期间自动标记和报告。</p>
<h2 id="54-性能分析性能分析和切片工具-1-c25-c26">5.4.
性能分析、性能分析和切片工具 [1-c25, c26]</h2>
<p>性能分析工具(Performance analysis tools)通常用于支持代码调优(code
tuning)。最常见的性能分析工具是性能剖析工具(profiling
tools)。执行性能剖析工具在代码运行时监控代码，并记录每条语句执行的频率或程序在每条语句或执行路径上花费的时间。在代码运行时对其进行性能剖析可以深入了解程序的工作方式、热点在哪里以及开发者应该在哪里集中精力进行代码调优。</p>
<p>程序切片(Program
slicing)涉及计算可能影响某个关注点处指定变量值的程序语句集(即程序切片)，该关注点称为切片准则(slicing
criterion)。程序切片可用于定位错误源、程序理解和优化分析。程序切片工具使用静态或动态分析方法为各种编程语言计算程序切片。</p>
<h2 id="主题与参考资料对照表">主题与参考资料对照表</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 14%"/>
<col style="width: 14%"/>
<col style="width: 14%"/>
<col style="width: 14%"/>
<col style="width: 14%"/>
<col style="width: 14%"/>
<col style="width: 14%"/>
</colgroup>
<thead>
<tr>
<th></th>
<th>[1]</th>
<th>[4]</th>
<th>[5]</th>
<th>[6]</th>
<th>[9]</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 软件构建基础</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.1. 最小化复杂性</em></td>
<td>c2, c3, c7-c9, c24, c27, c28, c31, c32, c34</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.2. 预见和拥抱变化</em></td>
<td>c3-c5, c24, c31, c32, c34</td>
<td>c1, c3, c9</td>
<td>c1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.3. 为验证而构建</em></td>
<td>c8, c20-c23, c31, c34</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.4. 复用</em></td>
<td>c15</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.5. 构建中的标准</em></td>
<td>c4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2. 管理构建</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.1. 生命周期模型中的构建</em></td>
<td>c2, c3, c27, c29</td>
<td>c3, c7</td>
<td>c1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.2. 构建规划</em></td>
<td>c3, c4, c21, c27-c29</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.3. 构建度量</em></td>
<td>c25, c28</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.4. 管理依赖关系</em></td>
<td>c25</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3. 实践考虑</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.1. 构建设计</em></td>
<td>c3, c5, c24</td>
<td>c7</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.2. 构建语言</em></td>
<td>c4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.3. 编码</em></td>
<td>c5-c19, c25-c26</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.4. 构建测试</em></td>
<td>c22, c23</td>
<td>c8</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.5. 构建中的复用</em></td>
<td>c15, c16</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.6. 构建质量</em></td>
<td>c8, c20-c25</td>
<td>c8, c24</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.7. 集成</em></td>
<td>c29</td>
<td>c8</td>
<td>c11</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.8. 跨平台开发和迁移</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>4. 构建技术</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.1. API设计和使用</em></td>
<td></td>
<td>c7</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.2. 面向对象运行时问题</em></td>
<td>c6, c7</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><a href="#软件构建">软件构建</a> 4-17</p>
<div class="line-block"><em>4.3. 参数化、模板和泛型</em> | | c1 | | | |
|<br/>
<em>4.4. 断言、契约式设计和防御式编程</em> | c8, c9 | | | | | |<br/>
<em>4.5. 错误处理、异常处理和容错</em> | c3, c8 | | | | | |<br/>
<em>4.6. 可执行模型</em> | | | | | | |<br/>
<em>4.7. 基于状态和表驱动的构建技术</em> | c18 | | | | | |<br/>
<em>4.8. 运行时配置和国际化</em> | c3, c10 | | | | | |<br/>
<em>4.9. 基于语法的输入处理</em> | c5 | | c8 | | | |<br/>
<em>4.10. 并发原语</em> | c6 | | | | | |<br/>
<em>4.11. 中间件</em> | c1 | | c8 | | | |<br/>
<em>4.12. 分布式和基于云的软件的构建方法</em> | c17, c18 | c2 | | | |
|<br/>
<em>4.13. 构建异构系统</em> | c9 | | | | | |<br/>
<em>4.14. 性能分析和调优</em> | c25, c26 | | | | | |<br/>
<em>4.15. 平台标准</em> | | c10 | c1 | | | |<br/>
<em>4.16. 测试优先编程</em> | c22 | c8 | | | | |</div>
<h1 id="第5章-软件测试">第5章 软件测试</h1>
<h2 id="缩略语-1">缩略语</h2>
<ul>
<li><strong>AI</strong> - 人工智能(Artificial Intelligence)</li>
<li><strong>API</strong> - 应用程序接口(Application Program
Interface)</li>
<li><strong>ARINC</strong> - 航空无线电公司(Aeronautical Radio
Incorporated)</li>
<li><strong>ATDD</strong> - 验收测试驱动开发(Acceptance Test-Driven
Development)</li>
<li><strong>CMMI</strong> - 能力成熟度模型集成(Capability Maturity Model
Integration)</li>
<li><strong>CSS</strong> - 层叠样式表(Cascading Style Sheets)</li>
<li><strong>DICOM</strong> - 医学数字成像和通信(Digital Imaging and
Communications in Medicine)</li>
<li><strong>DL</strong> - 深度学习(Deep Learning)</li>
<li><strong>DU</strong> - 定义和使用(Definition and Use)</li>
<li><strong>EBSE</strong> - 循证软件工程(Evidence-Based Software
Engineering)</li>
<li><strong>ETSI</strong> - 欧洲电信标准协会(European Telecommunications
Standards Institute)</li>
<li><strong>FHIR</strong> - 快速医疗互操作性资源(Fast Healthcare
Interoperability Resources)</li>
<li><strong>GDPR</strong> - 通用数据保护条例(General Data Protection
Regulation)</li>
<li><strong>GPS</strong> - 全球定位系统(Global Positioning System)</li>
<li><strong>GUI</strong> - 图形用户界面(Graphical User Interface)</li>
<li><strong>HIL</strong> - 硬件在环(Hardware-In-the-Loop)</li>
<li><strong>HIPAA</strong> - 健康保险流通与责任法案(Health Insurance
Portability and Accountability Act)</li>
<li><strong>HL7</strong> - 健康七级协议(Health Level Seven)</li>
<li><strong>IoT</strong> - 物联网(Internet of Things)</li>
<li><strong>KPI</strong> - 关键绩效指标(Key Performance Indicator)</li>
<li><strong>MC/DC</strong> - 修正条件/判定覆盖(Modified
Condition/Decision Coverage)</li>
<li><strong>ML</strong> - 机器学习(Machine Learning)</li>
<li><strong>MTTR</strong> - 平均恢复时间(Mean Time to Recovery)</li>
<li><strong>OAT</strong> - 正交阵列测试(Orthogonal Array Testing)</li>
<li><strong>ODC</strong> - 正交缺陷分类(Orthogonal Defect
Classification)</li>
<li><strong>SoS</strong> - 系统之系统(System of Systems)</li>
<li><strong>SPI</strong> - 软件过程改进(Software Process
Improvement)</li>
<li><strong>SPICE</strong> - 软件过程改进和能力测定(Software Process
Improvement and Capability Determination)</li>
<li><strong>SUT</strong> - 被测系统(System Under Test)</li>
<li><strong>TDD</strong> - 测试驱动开发(Test-Driven Development)</li>
<li><strong>TMMi</strong> - 测试成熟度模型集成(Test Maturity Model
integration)</li>
<li><strong>UI</strong> - 用户界面(User Interface)</li>
<li><strong>UP</strong> - 统一过程(Unified Process)</li>
</ul>
<h2 id="引言-2">引言</h2>
<p>软件测试包括对<em>被测系统</em>(<em>SUT</em>)进行<em>动态</em>验证，通过从通常无限的执行域中适当<em>选择</em>的<em>有限</em>测试用例集来验证系统是否提供<em>预期</em>行为。</p>
<p>在上述声明中，斜体字对应于软件测试知识领域(KA)中的关键问题。这些术语将在下文中讨论。</p>
<p><strong>•
被测系统</strong>：该术语指被测试的对象，可以是程序、软件产品、应用程序、面向服务的应用程序(例如Web服务、微服务)、中间件(硬件/软件)、服务组合、系统、系统之系统(SoS)或生态系统。</p>
<p><strong>•
测试用例</strong>：测试用例是对执行所必需的所有实体的规范说明，例如输入值、执行和时序条件、测试过程以及预期结果(例如产生的值、状态变化、输出消息)。仅有输入值通常不足以指定测试用例，因为被测系统可能对相同的输入做出不同的行为反应，具体取决于例如被测系统的状态或环境条件。一组测试用例通常称为<em>测试套件</em>。</p>
<p><strong>•
动态</strong>：动态验证需要隐式需求或期望。(参见软件需求知识领域第4.3节，基于验收标准的需求规范。)</p>
<p>正如本讨论所反映的，软件测试是一项普遍而全面的活动，涉及任何过程开发生命周期(例如传统或左移开发)的所有步骤。本章的其余部分</p>
<p>4-18 <em>SWEBOK® GUIDE V4.0a</em></p>
<h2 id="延伸阅读-1">延伸阅读</h2>
<p><strong>IEEE Std. 1517-2010:
IEEE信息技术标准—软件生命周期过程—复用过程，IEEE，1999 [8]</strong></p>
<p>本标准规定了在软件生命周期的每个阶段应用的过程、活动和任务，以使软件产品能够从可复用资产构建。它涵盖了基于复用的开发概念以及为复用而构建和使用复用进行构建的过程。</p>
<p><strong>ISO/IEC 12207:2008：信息技术—软件生命周期过程，ISO/IEC，2008
[9]</strong></p>
<p>本标准定义了一系列软件开发过程，包括软件构建过程、软件集成过程和软件复用过程。</p>
<p><strong>Martin Fowler, Kent Beck.
重构：改善既有代码的设计(第2版)，Addison-Wesley签名系列(Fowler)</strong></p>
<p><strong>Robert C. Martin.
代码整洁之道：敏捷软件工艺手册，培生教育公司</strong></p>
<h2 id="参考文献-4">参考文献</h2>
<p>[1] S. McConnell,
<em>代码大全</em>，第2版，雷德蒙德，华盛顿州：微软出版社，2004年。</p>
<p>[2] I. Sommerville,
<em>软件工程</em>，第10版，Addison-Wesley，2016年。</p>
<p>[3] G. Kim等,
<em>DevOps手册：如何在技术组织中创造世界级的敏捷性、可靠性和安全性</em>，第2版，IT
Revolution，2021年。</p>
<p>[4] H. Heitkötter, S. Hanschke, 和 T.A. Majchrzak,
评估移动应用的跨平台开发方法，2013年，收录于Cordeiro, J., Krempels, K.H.
(编), <em>Web信息系统与技术</em>。WEBIST
2012。商业信息处理讲义，第140卷，Springer，柏林，海德堡。</p>
<p>[5] P. Clements等,
<em>软件架构文档化：视图与超越</em>，第2版，波士顿：培生教育，2010年。</p>
<p>[6] E. Gamma等,
<em>设计模式：可复用面向对象软件的基础</em>，第1版，雷丁，马萨诸塞州：Addison-Wesley专业版，1994年。</p>
<p>[7] S.J. Mellor和M.J. Balcer,
<em>可执行UML：模型驱动架构的基础</em>，第1版，波士顿：Addison-Wesley，2002年。</p>
<p>[8*] L. Null和J. Lobur,
<em>计算机组织与架构基础</em>，第5版，Jones和Bartlett出版社，2018年。</p>
<p>[9] A. Silberschatz等,
<em>操作系统概念</em>，第8版，霍博肯，新泽西州：Wiley，2008年。</p>
<h1 id="软件测试-2">软件测试</h1>
<p>对被测系统（SUT）执行测试套件。静态技术[介绍了软件测试的基础及其]</p>
<p>补充动态测试，[面临的挑战、问题和普遍接受的]</p>
<p>它们在软件质量知识领域中有所涵盖。[1]</p>
<p><em>• 有限性：</em> 即使在简单的SUT中，执行</p>
<p>所有可能的测试用例（即详尽测试）可能需要数月或数年时间。因此，在实践中，测试</p>
<p>针对由不同标准确定的所有可能测试用例的子集。测试</p>
<p>总是意味着在有限资源和时间表与固有无限测试需求之间进行权衡。</p>
<p><em>• 选择性：</em>
在给定条件下识别最合适的选择标准是一个复杂的问题。可以考虑并结合不同的技术来解决这个问题，例如风险分析、软件需求、成本降低、质量属性满足、优先级排序和故障检测。许多提出的测试技术在测试套件的选择方式上有所不同，软件工程师必须意识到不同的选择标准可能产生截然不同的有效性。</p>
<p><em>• 预期性：</em>
对于每个执行的测试用例，必须能够（尽管可能不容易）判断观察到的SUT结果是否与预期结果匹配。实际上，观察到的行为可以根据用户需求进行检查（通常称为验证测试），根据规范进行检查（验证测试），或者根据预期行为进行检查。</p>
<p>[1
值得注意的是，不同社区之间的术语并不统一，有些人使用术语<em>测试</em>来指代静态技术。]</p>
<p><strong>软件测试基础知识分解</strong></p>
<p>[图5.1展示了软件测试知识领域的主题分解。主题与参考资料矩阵在本知识领域末尾提供了更详细的分解。第一个主题，软件测试基础，涵盖了软件测试的基本定义、基本术语和关键问题，以及软件测试与其他活动的关系。]</p>
<p>[第二个主题，测试级别，包含两个（正交的）子主题。第一个子主题，测试目标，列出了大型软件测试传统上细分的级别，第二个子主题，测试目标，讨论了针对特定条件或属性的测试。并非所有类型的测试都适用于每个软件产品，也没有列出所有可能的类型。测试目标和测试目标共同决定了如何识别测试套件，包括其一致性（要达到既定目标需要多少测试？）和组成（应该选择哪些测试用例来达到既定目标？）。（然而，通常”为了达到既定目标”保持隐含，只提出上述两个问题的第一部分。）解决第一个问题的标准是<em>测试充分性标准</em>，而用于解决第二个问题的标准是<em>测试选择标准</em>。]</p>
<p>在过去几十年中开发了几种测试技术，新的技术仍在不断提出。因此，第三个主题涵盖了普遍接受和标准化的技术。</p>
<p>第四个主题涉及测试相关度量，而第五个主题涵盖与测试过程相关的问题。</p>
<p>第六个主题描述了开发过程和应用领域中的软件测试，第七个主题描述了新兴技术的测试和通过新兴技术进行的测试。最后，第八个主题介绍了软件测试工具。</p>
<figure>
<img alt="图5.1. 软件测试知识领域主题分解" src="images/000000.png"/>
<figcaption aria-hidden="true">图5.1.
软件测试知识领域主题分解</figcaption>
</figure>
<p><strong>软件测试</strong></p>
<ul>
<li><strong>基础知识</strong>
<ul>
<li>故障与失效</li>
<li>关键问题</li>
<li>测试与其他活动的关系</li>
</ul></li>
<li><strong>测试级别</strong>
<ul>
<li>测试目标</li>
<li>测试目标</li>
</ul></li>
<li><strong>测试技术</strong>
<ul>
<li>基于规范的技术</li>
<li>基于结构的测试技术</li>
<li>基于经验的技术</li>
<li>基于故障的和变异技术</li>
<li>基于应用性质的技术</li>
<li>选择和组合技术</li>
<li>基于派生知识的技术</li>
</ul></li>
<li><strong>测试过程</strong>
<ul>
<li>SUT的评估</li>
<li>执行的测试评估</li>
<li>人员配置和活动</li>
</ul></li>
<li><strong>开发过程和应用领域中的测试</strong>
<ul>
<li>实际考虑</li>
<li>开发过程中的测试</li>
<li>应用领域中的测试</li>
</ul></li>
<li><strong>测试相关度量</strong>
<ul>
<li>SUT内部评估</li>
<li>软件开发过程评估</li>
</ul></li>
<li><strong>新兴技术</strong>
<ul>
<li>新兴技术测试</li>
<li>通过新兴技术测试</li>
</ul></li>
<li><strong>测试工具</strong>
<ul>
<li>测试工具支持和选择</li>
<li>工具类别</li>
</ul></li>
</ul>
<h2 id="11-故障与失效">1.1 故障与失效</h2>
<p>[[1*, c1s5; 2*, c1; 14*, c1s3]]</p>
<p>[软件工程文献中使用许多术语来描述故障：特别是<em>故障</em>（参见软件质量知识领域第3.2节缺陷特征中的<em>缺陷</em>）、<em>失效</em>和<em>错误</em>。区分故障的<em>原因</em>（此处使用术语<em>故障</em>）和在系统交付服务中观察到的不良效果（<em>失效</em>）至关重要。实际上，软件中可能存在从未表现为失效的故障。（参见第1.2.8节测试的理论和实践局限性。）因此，测试旨在发现软件中的故障，而不是失效。]</p>
<p>引用的参考资料中可以找到软件测试相关术语。</p>
<h1 id="1-软件测试基础">1. 软件测试基础</h1>
<p><strong>[1<em>, c1, c2; 2</em>, c8; 14*, c7]</strong></p>
<p>本节概述了主要的测试问题以及测试与其他活动的关系。这里使用的大多数测试术语也有定义。Software
Quality KA 中提供了更全面的测试概述。</p>
<h2 id="12-关键问题">1.2. 关键问题</h2>
<p>本小节概述了主要的测试问题。</p>
<h3 id="121-测试用例创建">1.2.1. 测试用例创建</h3>
<p>[1<em>, c12s1, c12s3, 2</em>, c8]</p>
<p><em>测试用例创建</em>或<em>生成</em>创建用于测试
SUT（被测系统）的测试套件，以实现特定目的（例如，充分性、准确性或评估）。由于测试用例生成是最重要和最密集的软件测试活动之一，因此通常由方法、技术和工具支持以实现流程自动化。</p>
<h3 id="122-测试选择和充分性标准">1.2.2. 测试选择和充分性标准</h3>
<p>[1<em>, c1s14, c6s6, c12s7, 2</em>, c8]</p>
<p>测试选择标准是选择测试用例或确定测试套件是否足以满足特定目的的方法。测试用例选择旨在减少测试套件的基数，同时在覆盖率或故障检测率方面保持相同的有效性。测试充分性标准可用于决定何时完成了足够的测试。</p>
<h3 id="123-优先级排序最小化">1.2.3. 优先级排序/最小化</h3>
<p>[4, part 2, part 3, c5]</p>
<p>可以采用合适的测试用例选择或优先级排序策略来提高测试效能。测试用例<em>优先级排序</em>旨在根据某些标准（例如，覆盖率、故障检测率、相似性和风险）定义测试执行顺序，以便优先级较高的测试在优先级较低的测试之前执行。测试用例<em>最小化</em>通常旨在通过根据某些标准或目的删除冗余测试用例来减少测试套件。</p>
<p>测试可以揭示故障，但必须找出并消除导致故障的缺陷(faults)。然而，故障的原因并不总是能明确识别。不存在理论标准可以明确地确定导致观察到的故障的缺陷。可能必须修改缺陷以消除故障，但其他修改也可能有效。为了避免歧义，我们可以指<em>导致故障的输入</em>，而不是缺陷——即那些导致故障出现的输入集。</p>
<h3 id="124-测试目的">1.2.4. 测试目的</h3>
<p>[1<em>, c13s11, c11s4, 2</em>, c8]</p>
<p>不同的明确定义的目的可以指导测试活动；只有考虑特定目的，才能生成（选择）、执行和评估测试套件（详见第2节）。</p>
<h3 id="125-评估和认证">1.2.5. 评估和认证</h3>
<p>[4, part 1, c5; 2*, c7, c25; 8]</p>
<p>测试需要关注特定的（强制性的）测试规范，例如需求、法律和标准。应生成并执行测试用例，以提供有用的证据来评估和/或认证对所选规范的遵守情况。通常，测试结果的<em>评估</em>和<em>认证</em>包括验证测试用例是否使用基线需求派生和生成，采用配置控制流程，并使用可重复的流程。</p>
<h3 id="126-质量保证改进测试">1.2.6. 质量保证/改进测试</h3>
<p>[1*, c16s2; 4, part 1, c5; 9]</p>
<p>测试有许多方面，包括质量改进和保证。这些特征涉及计划的和系统的支持流程和活动，增强对
SUT
满足既定技术或质量要求的信心。因此，质量<em>改进</em>和<em>保证</em>涉及定义方法、工具、技能和实践，以实现特定的质量水平和目标。ISO/IEC
25010:2023 [9]
报告了测试可以测量或评估的主要质量特征列表。（另见软件质量 KA
中的第1.3.2节，软件产品质量。）</p>
<h3 id="127-预言机问题">1.2.7. 预言机问题</h3>
<p>[1*, c1s9, c9s7]</p>
<p>一个重要的测试组件是预言机(oracle)。实际上，只有在可以决定其观察到的结果时，测试才有意义。<em>预言机</em>可以是任何人工或机械代理，它决定
SUT
在每个测试中的行为是否正确，以及是否符合预期结果。因此，预言机提供”通过”或”失败”判决。预言机不能总是做出决定；在这些情况下，测试输出被归类为不确定。有许多类型的预言机——例如，明确的需求规范、行为模型和代码注释。预言机的自动化可能既困难又昂贵。</p>
<h3 id="128-理论和实际限制">1.2.8. 理论和实际限制</h3>
<p>[1*, c2s7]</p>
<p>测试理论警告不要对一系列成功的测试赋予不合理的信心。不幸的是，测试理论的大多数既定结果都是负面结果，因为它们陈述了没有实现什么，而不是实现了什么。关于这一点最著名的引用是
Dijkstra
的格言：“程序测试可以用来显示缺陷的存在，但永远无法显示它们的不存在。”</p>
<h3 id="129-测试有效性">1.2.9. 测试有效性</h3>
<p>[1*, c8s7]</p>
<p><em>测试有效性</em>是指测试套件检测故障的能力。有效性可以通过覆盖率或故障检测率来衡量。</p>
<h3 id="1210-可测试性">1.2.10. 可测试性</h3>
<p>可测试性一方面是指给定测试覆盖标准的易满足程度；另一方面，它被定义为测试套件在软件有缺陷时暴露故障的可能性，可能通过统计方法测量。这两种含义都很重要。</p>
<h3 id="1211-测试执行和自动化">1.2.11. 测试执行和自动化</h3>
<p>[4, part 1, c4]</p>
<p>测试的一个重要挑战是提高可实现的自动化，无论是通过开发用于生成测试输入的高级技术，还是通过寻找创新的支持程序来（完全）自动化不同的测试活动——例如，增加生成或执行的测试用例数量。</p>
<h3 id="1212-可扩展性">1.2.12. 可扩展性</h3>
<p>[1*, c8s7]</p>
<p><em>可扩展性</em>是软件增加其规模、复杂性或负载的能力。</p>
<p>出现的错误，但永远无法证明它们的不存在”
[3]。其明显原因是完全测试在真实软件中是不可行的。</p>
<h3 id="129-不可行路径问题">1.2.9 不可行路径问题</h3>
<p>[1*, c4s7]</p>
<p>不可行路径是指无法通过任何输入数据（即测试用例）执行的控制流路径。管理（即识别、解决或移除）不可行路径可以帮助减少测试投入的时间和资源。它们是基于路径测试中的一个重大问题，特别是在自动推导测试用例以执行控制流路径时。此外，检测不可行路径也可以在降低安全漏洞方面发挥作用。</p>
<h3 id="1210-可测试性-1">1.2.10 可测试性</h3>
<p>[1*, c17s2]</p>
<p>术语<em>软件可测试性</em>有两个相关但不同的含义。一方面，它</p>
<p>以及其非功能需求的规模扩展，例如负载、事务数量、和数据量。可扩展性也与程序运行的平台和环境的复杂性相关，例如分布式、无线网络和虚拟化环境、大规模集群和移动云。</p>
<h3 id="1213-测试有效性">1.2.13 测试有效性</h3>
<p>[1* c1s1; 2* c8s1; 8]</p>
<p>评估SUT、测量测试技术的效能、以及判断测试是否可以停止是软件测试的重要证据，它们可能需要定义和选择合适的测试有效性度量标准。</p>
<h3 id="1214-可控性可复现性和泛化性">1.2.14 可控性、可复现性和泛化性</h3>
<p>[1* c12s12; 4, part 2, c7]</p>
<p>测试的具体方面包括以下内容：</p>
<p><strong>5-6</strong> <em>SWEBOK® GUIDE V4.0a</em></p>
<ul>
<li><strong>可控性</strong>是指测试活动从实验室（即受控条件）向现实（即不受控条件）的过渡。</li>
<li><strong>可复现性</strong>是指不同人员执行相同测试活动的能力。其目的是验证给定的测试理论是否有效，至少在实验室中是这样。</li>
<li>测试的<strong>泛化性</strong>与外部效度相关——即测试方法可以应用于更广泛环境或目标群体的程度。软件测试的泛化性对于管理测试活动（在成本和工作量方面）以及提高对测试结果的信心可能很重要。</li>
</ul>
<h3 id="1215-离线测试与在线测试">1.2.15 离线测试与在线测试</h3>
<p>[10, c3]</p>
<p>测试过程可以在两种环境下执行：<em>离线</em>和<em>在线</em>。通常，在离线测试中，SUT在没有外部交互的环境中进行验证，而在在线测试中，SUT与真实应用环境进行交互。测试用例在两种情况下都是手动或自动推导的，预期结果用于评估SUT。</p>
<h3 id="13-测试与其他活动的关系">1.3 测试与其他活动的关系</h3>
<p>软件测试与静态软件质量管理技术、正确性证明、调试和程序构造相关但不同。然而，从软件质量分析师和认证者的角度来考虑测试是有益的。更多讨论请参见以下内容：</p>
<ul>
<li><p><strong>测试与静态软件质量管理技术</strong>：参见软件质量KA第2.2.1节，静态分析技术。</p></li>
<li><p><strong>测试与质量改进/保证</strong>：参见软件质量KA第1.3.2节，软件产品质量。</p></li>
<li><p><strong>测试与正确性证明和形式化验证</strong>：参见软件工程模型与方法KA。</p></li>
<li><p><strong>测试与调试</strong>：参见软件构造KA中的构造测试以及计算基础KA中的调试工具和技术。</p></li>
<li><p><strong>测试与程序构造</strong>：参见软件构造KA中的构造测试。</p></li>
<li><p><strong>测试与安全</strong>：参见新KA：软件安全。</p></li>
<li><p><strong>测试与工作量估算</strong>：参见软件工程管理KA。</p></li>
<li><p><strong>测试与法律问题</strong>：参见软件工程专业实践KA。</p></li>
</ul>
<h2 id="2-测试级别">2. 测试级别</h2>
<p><strong>[1<em>, c1s13; 2</em>, c8s1]</strong></p>
<p>软件测试通常在开发和维护过程中的不同<em>级别</em>执行。级别可以根据测试对象、<em>目标</em>或测试级别的目的或<em>目标</em>来区分。</p>
<h3 id="21-测试的目标">2.1 测试的目标</h3>
<p>[1<em>, c1s13, 2</em>, c8s1]</p>
<p>测试的目标可能因
SUT、环境条件以及测试活动投入的预算/时间而异。可以区分四个测试阶段：单元测试、集成测试、系统测试和验收测试。这四个测试阶段并不意味着任何特定的开发过程，也不假设其中任何一个比其他三个更重要。</p>
<h4 id="211-单元测试">2.1.1 单元测试</h4>
<p>[1<em>, c3, 2</em>, c8]</p>
<p>单元测试验证可单独测试的SUT元素在隔离状态下的功能。根据上下文，这些可以是单独的子程序或组件、子系统或SUT组件的组合。通常（但并非总是），编写代码的人员进行单元测试。</p>
<p><strong><a href="#软件测试">软件测试</a></strong> 5-7</p>
<h4 id="212-集成测试">2.1.2 集成测试</h4>
<p>[1<em>, c7, 2</em>, c8]</p>
<p><em>集成测试</em>验证SUT元素（例如组件、模块或子系统）之间的交互。</p>
<p>集成策略涉及考虑已识别的功能线程或架构规范的SUT元素的增量（和系统性）集成。典型的集成测试策略</p>
<p>软件构建的任务。例如，此测试活动可能针对可用性测试或操作验收。在实现相应功能之前定义验收测试是验收测试驱动开发（ATDD）的关键活动。（参见软件需求KA第4.3节。）</p>
<h3 id="22-测试的目标">2.2 测试的目标</h3>
<p>[1*, c1s7]</p>
<p>包括自顶向下、自底向上、混合（或夹层）以及大爆炸式集成方法。这些方法关注SUT元素集成层次的不同视角。集成测试是一项可以在每个开发阶段执行的持续性活动。它可能针对不同方面，如SUT元素之间或与外部环境的互操作性（例如，兼容性或配置）。与其他应用程序、实用工具、硬件设备或操作环境的外部接口也可以被考虑在内。</p>
<h2 id="213-系统测试">2.1.3. 系统测试</h2>
<p>[1<em>, c8, 2</em>, c8]</p>
<p><strong>系统测试</strong>关注被测系统（根据第1节的定义）行为的测试。有效的单元测试和集成测试应该已经识别出许多SUT缺陷。此外，系统测试通常被认为适合评估非功能性系统需求，如安全性、隐私性、速度、准确性和可靠性。（参见软件需求知识领域中的功能性和非功能性需求，以及软件质量知识领域中的软件质量需求。）</p>
<h2 id="214-验收测试">2.1.4. 验收测试</h2>
<p>[1<em>, c1s7, 2</em>, c8s4]</p>
<p><strong>验收测试</strong>针对SUT的部署。其主要目标是验证SUT满足需求和最终用户的期望。通常，它由最终用户运行或与最终用户一起运行，以执行那些功能。</p>
<p>测试是基于特定<strong>目标</strong>进行的，这些目标（或多或少）明确地陈述，并具有不同程度的精确性。以精确的、量化的术语陈述测试目标有助于测试过程的度量和控制。</p>
<p>测试可以旨在验证不同的属性。例如，可以设计测试用例来检查功能规范是否正确实现，这在文献中被称为一致性测试、正确性测试或功能测试。然而，也可能测试其他几个非功能性属性，包括性能、可靠性和可用性。（参见软件质量知识领域中的模型和质量特性。）</p>
<p>其他重要的测试目标包括但不限于可靠性度量、安全性和隐私漏洞识别以及可用性评估；根据目标的不同，需要采用不同的方法。请注意，一般来说，测试目标随测试目标而变化；在不同的测试级别处理不同的目的。</p>
<p>下面列出的子主题是文献中最常被引用的。</p>
<h3 id="221-一致性测试">2.2.1. 一致性测试</h3>
<p>[1*, c10s4]</p>
<p><strong>一致性测试</strong>旨在验证SUT是否符合标准、规则、规范、需求、设计、流程或实践。</p>
<p>5-8 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<h3 id="222-合规性测试">2.2.2 合规性测试</h3>
<p>[1*, c12s3]</p>
<p><strong>合规性测试</strong>旨在证明SUT遵守法律或法规。通常，合规性测试是由外部监管机构强制执行的。</p>
<h3 id="223-安装测试">2.2.3. 安装测试</h3>
<p>[1*, c12s2]</p>
<p>通常，在系统测试和验收测试完成后，并且SUT已安装在目标环境中之后，会对SUT进行验证。<strong>安装测试</strong>可以被视为在硬件配置和其他操作约束的操作环境中进行的系统测试。安装程序也可能被验证。</p>
<h3 id="224-alpha测试和beta测试">2.2.4. Alpha测试和Beta测试</h3>
<p>[1<em>, c13s7, c16s6, 2</em>, c8s4]</p>
<p>在SUT发布之前，有时会将其提供给一小群精选的潜在用户进行试用（<strong>alpha测试</strong>）和/或提供给更大范围的代表性用户（<strong>beta测试</strong>）。这些用户报告产品的问题。Alpha测试和Beta测试通常是不受控制的，并且不总是在测试计划中被提及。</p>
<h3 id="225-回归测试">2.2.5. 回归测试</h3>
<p>[1*, c8s11, c13s3; 4, part 1, c5]</p>
<p>根据[5]中报告的定义，<strong>回归测试</strong>是”对SUT的选择性重新测试，以验证修改没有造成意外影响，并且SUT仍然符合其规定的需求。“实际上，该方法旨在显示SUT仍然通过先前通过的测试。回归测试可以在第2.1节描述的每个测试级别进行。它可能涉及功能和非功能测试，如可靠性、可访问性、可用性、可维护性、转换、迁移和兼容性测试。回归测试可能涉及测试用例的选择（参见第1.2.2节）和最小化（参见第1.2.3节），以及对现有测试套件采用优先级排序方法（参见第2.2.6节）。</p>
<p>回归测试是敏捷、DevOps、测试驱动开发(TDD)和持续开发的基本活动。它通常在集成测试之后和部署到生产或运营之前执行。</p>
<h3 id="226-优先级测试">2.2.6. 优先级测试</h3>
<p>[1*, c12s7]</p>
<p><strong>测试用例优先级排序</strong>旨在调度测试用例以提高故障检测的速度和可能性、被测代码的覆盖率以及SUT的可靠性。通常，优先级测试依赖于启发式方法，其性能可能根据SUT、环境和可用测试用例而变化。在不同的优先级排序建议中，基于相似性的优先级排序是最常采用的方法之一。在这种优先级排序方法中，测试用例从根据预定义距离函数最不相似的开始进行优先级排序。</p>
<h3 id="227-非功能测试">2.2.7. 非功能测试</h3>
<p>[2*, c8]</p>
<p><strong>非功能测试</strong>针对非功能方面（如性能、可用性或可靠性）的验证，并在所有测试级别执行。在当前实践状态下，有数百种非功能测试</p>
<p>在测试套件中(实际上,它有时被称为<em>非回归测试</em>)。在某些情况下,必须在每次更改时进行回归测试所提供的保证和执行回归测试所需的资源之间进行权衡。这可能相当耗时,因为需要进行许多测试。</p>
<p><a href="#软件测试">软件测试</a> 5-9</p>
<p>包括但不限于以下技术:</p>
<p><strong>性能测试 [4, part 1]:</strong>
性能测试验证软件是否满足指定的性能要求,并评估性能特征(例如,容量和响应时间)。</p>
<p><strong>负载测试 [4, part 1]:</strong>
负载测试专注于验证被测系统(SUT)在负载压力条件下的行为,以发现问题(例如,死锁、竞态条件、缓冲区溢出和内存泄漏)或可靠性、稳定性或健壮性违规。它旨在评估向被测系统提交不同服务请求的速率。</p>
<p><strong>压力测试 [1*, c8s8]:</strong>
压力测试旨在通过生成大于系统预期处理能力的负载,使被测系统超越其能力。</p>
<p><strong>容量测试 [4, part 1]:</strong>
容量测试针对评估被测系统的内部存储限制及其交换数据和信息的能力,包括事务量和数据量。它可以整合或扩展负载测试、弹性测试和压力测试。</p>
<p><strong>弹性测试 [17]:</strong>
弹性测试评估被测系统(如云和分布式系统)快速扩展或收缩计算、内存和存储资源的能力,而不影响满足峰值利用率的容量。一些弹性测试目标是控制行为、识别要分配(或取消分配)的资源,以及并行协调事件。</p>
<p><strong>基础设施测试 [8, annex H]:</strong>
基础设施测试测试和验证基础设施组件,以减少停机机会并改善IT基础设施的性能。</p>
<p><strong>背对背测试 [5]:</strong> ISO/IEC/IEEE
24765将背对背测试定义为”使用相同的输入执行程序的两个或多个变体,比较输出,并在出现差异时分析错误”。</p>
<p><strong>恢复测试 [1*, c14s2]:</strong>
恢复测试旨在验证系统崩溃或其他灾难后软件的重启能力。</p>
<p><strong>故障转移测试 [1*, c17s2; 2*, c8]:</strong>
故障转移测试验证被测系统管理重负载或意外故障以继续典型操作的能力(例如,通过分配额外资源)。故障转移测试还与可恢复性验证相关。</p>
<p><strong>可靠性测试 [1*, c15; 2*, c11]:</strong>
可靠性测试通过识别和纠正故障来评估被测系统的可靠性。可靠性测试观察被测系统的运行或根据不同用户行为的统计模型(操作剖面,operational
profiles)使用测试用例来执行被测系统。通常,可靠性通过可靠性增长模型进行评估。持续开发过程(如DevOps)正在促进在各种迭代中采用可靠性测试,以提高最终被测系统的质量。</p>
<p><strong>兼容性测试 [4, part 1; 10, c3]:</strong>
兼容性测试用于验证软件是否可以与不同的硬件和软件设施或不同的版本或发行版协作。</p>
<p><strong>可扩展性测试 [1*, c8s7; 2* c17]:</strong>
可扩展性测试评估软件扩展非功能需求的能力,如负载、事务数量和数据量。</p>
<h2 id="228-安全测试">2.2.8. 安全测试</h2>
<p>[2*, c13; 4, part 4, annex A]</p>
<p><strong>安全测试</strong>专注于验证被测系统免受外部攻击的保护。更准确地说,它验证系统及其数据的机密性、完整性和可用性。通常,安全测试包括针对软件或系统的误用和滥用的验证(负面测试)。(请参阅软件安全知识域中的安全测试。)</p>
<h2 id="229-隐私测试">2.2.9. 隐私测试</h2>
<p>[2*, c13, c14]</p>
<p><strong>隐私测试</strong>致力于评估用户个人数据的安全性和隐私性,以防止攻击。它专门评估隐私</p>
<p>5-10 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<p>和信息共享策略,以及用户社交资料和数据存储解决方案的去中心化管理的验证。(请参阅软件工程专业实践知识域中的法律问题。)</p>
<h2 id="2210-接口和应用程序接口api测试">2.2.10.
接口和应用程序接口(API)测试</h2>
<p>[2*, c8s1; 14*, c7s12; 4, part 5, c4, c7]</p>
<p>接口缺陷在复杂系统中很常见。<strong>接口测试</strong>旨在验证组件的接口是否提供正确的数据和控制信息交换。通常,测试用例是从接口规范生成的。一个特定的接口测试目标是模拟终端用户应用程序对API的使用。</p>
<p>测试技术可以通过考虑不同的关键方面进行分类,如规格说明、结构和经验 [4,
part
4]。额外的分类来源可以是要发现的故障、预测的使用、模型、应用程序的性质或派生的知识。例如,基于模型的测试
[7; 4, part 1]
指的是所有使用模型概念的测试技术,这些模型表示行为规范、被测系统的结构或可用的知识和经验。然而,分类重叠是可能的,一个类别可能涉及组合两种或多种技术。</p>
<p>基于被测系统信息程度的替代分类在文献中可用。实际上,在基于规格说明的技术中,也称为</p>
<p>这些调用的参数、设置环境的条件，以及定义影响API的内部数据。</p>
<p><strong>2.2.11. 配置测试(Configuration Testing)</strong> [1*,
c8s5]</p>
<p>当被测系统(SUT)需要服务不同用户时，配置测试会在指定配置下验证软件。</p>
<p><strong>2.2.12. 可用性和人机交互测试</strong> [2* c8s4; 19*, c6; 4,
part 4, annex A]</p>
<p>可用性和人机交互测试的主要任务是评估最终用户学习使用软件的难易程度。这可能涉及测试支持用户任务的软件功能、帮助用户的文档，以及系统从用户错误中恢复的能力。(参见软件设计知识领域中的以用户为中心的设计。)</p>
<p><strong>3. 测试技术</strong> <strong>[1*, c1s15; 4, part
4]</strong></p>
<p>为了提高被测系统的整体质量[4, part
4]，现有技术提出了系统化的程序和方法。</p>
<p><a href="#软件测试">软件测试</a> 5-11</p>
<p>这些技术根据计算结果、控制流或数据流，或者被测系统接受和处理的有效输入以及无效输入来进行。例如可以是有效值和超出范围的值。后者可能生成错误消息或启动错误处理。通常从每个等价类中选取一个有代表性的测试套件(有时只包含一个测试用例)。</p>
<p>在黑盒(black-box)技术中，测试用例的生成仅基于被测系统的输入/输出行为，而在基于结构的，也称为白盒(white-box)(或玻璃盒(glass-box)或透明盒(clear-box))技术中，测试用例是使用关于被测系统如何设计或编码的信息来生成的。</p>
<p>由于某些测试技术比其他技术使用得更多，本节的其余部分介绍了标准测试技术和当前实践中常用的技术。</p>
<p><strong>3.1. 基于规格说明的技术</strong> [1*, c6s2; 4, part 4]</p>
<p>基于规格说明的技术(有时也称为域测试技术)的基本思想是从输入域中选择少量测试用例，这些测试用例可以检测特定类别的故障(也称为域错误)。这些技术检查被测系统是否能够管理某个范围内的输入并返回所需的输出。</p>
<p><strong>3.1.1. 等价类划分(Equivalence Partitioning)</strong> [1*,
c9s4]</p>
<p>等价类划分涉及根据指定的标准或关系将输入域划分为一组子集(或等价类)。</p>
<p><strong>3.1.2. 边界值分析(Boundary Value Analysis)</strong> [1*,
c9s5; 4, part 4]</p>
<p>测试用例选择在变量输入域的边界上或附近，其基本原理是许多故障往往集中在输入的极值附近。该技术的扩展是鲁棒性测试(robustness
testing)，其中测试用例也选择在变量输入域之外，以测试程序在处理意外或错误输入时的鲁棒性。</p>
<p><strong>3.1.3. 语法测试(Syntax Testing)</strong> [1<em>, c10s11,
2</em>, c5; 4, part 4]</p>
<p>语法测试技术，也称为基于形式化规格说明的技术，依赖于用形式化语言表示的被测系统规格说明。(参见软件工程模型和方法知识领域中的形式化方法。)这种表示允许自动派生功能测试用例，同时提供检查测试结果的预言机(oracle)。</p>
<p><strong>3.1.4. 组合测试技术(Combinatorial Test Techniques)</strong>
[1*, c9s3; 4, part 4]</p>
<p>组合测试技术系统地派生覆盖特定参数值或条件的测试用例。根据[4, part
4]，常用的组合测试技术包括全组合测试、两两测试、每选择测试和基选择测试。全组合测试关注所有可能的输入组合，而其子集，也称为t-wise测试，考虑每个t个输入的可能组合。在这种情况下，派生出多个配对(即，通过包含更高级别的组合)。两两测试(Pair-wise
testing)是一种特定的组合测试技术，其中测试用例通过组合输入集中每对值来派生。这些技术也称为正交阵列测试(OAT)。</p>
<p><strong>3.1.5. 决策表(Decision Table)</strong> [1<em>, c9s6; 1</em>,
c13s6; 4, part 4]</p>
<p>决策表(或决策树)表示条件(大致相当于输入)和动作(大致相当于输出)之间的逻辑关系。通常，它们被广泛用于知识表示(例如，机器学习(ML))。通过考虑条件的每个可能组合及其相应的结果动作，系统地派生测试用例。一个相关的技术是因果图(cause-effect
graphing)。左移开发流程(Shift-left development
processes)正在利用这种测试技术，因为这些技术对于记录测试结果和可能影响它们的因素很有用。</p>
<p><strong>3.1.6. 因果图(Cause-Effect Graphing)</strong> [1*, c1s6; 4,
part 3, part 4]</p>
<p>因果图技术依赖于逻辑网络，通过系统地探索输入条件的可能组合，将一组原因映射到一组结果。它们识别结果并通过模型图将结果与其原因联系起来。因果图技术用于测试，因为它们允许规格说明分析、识别相关输入条件或原因、相应的转换和输出条件。</p>
<p><strong>3.1.7. 状态转换测试(State Transition Testing)</strong> [1*,
c10; 4, part 4]</p>
<p>基于有限状态机(finite-state machine)的技术(在[4, part
4]中称为状态转换测试技术)专注于用有限状态机表示被测系统。在这种情况下，测试</p>
<p>5-12 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]]</p>
<p>套件是根据特定覆盖级别衍生出来以覆盖状态和转换的。输入选择标准指导随机输入采样。</p>
<p>在模糊测试的名义下，随机选择无效和意外的输入和数据被广泛用于网络安全，以发现可被攻击的软件漏洞、编码错误和安全漏洞。（另见2.2.8节安全测试和8.2节工具类别。）</p>
<p><strong>3.1.8. 基于场景的测试</strong> [2*, c8s3, c19s3; 4, part 4;
7]</p>
<p>在这种情况下，模型是被测系统(SUT)或其软件需求的抽象（形式化）表示。（参见软件工程模型和方法知识领域中的建模。）</p>
<p><strong>基于场景的测试</strong>用于验证需求、检查其一致性并生成专注于被测系统行为方面的测试用例。（参见软件工程模型和方法知识领域中的模型类型。）基于场景测试的关键组成部分是用于表示软件或其需求模型的符号、工作流模型或类似模型、用于测试用例生成的测试策略或算法、测试执行的支持基础设施，以及测试结果与预期结果的评估。由于技术的复杂性，基于场景的测试方法通常与测试自动化工具一起使用。</p>
<p>在基于场景的测试中，工作流模型也可用于图形化表示人类和/或软件应用程序执行的活动序列。在这种情况下，每个动作序列构成一个工作流（也称为场景）。通常，确保典型和备选工作流都得到测试是很重要的。例如，业务流程测试是这种基于场景技术的一部分。在这种情况下，特别关注的是工作流规范中的角色。</p>
<p><strong>3.1.9. 随机测试</strong> [1*, c9s7; 4, part 4]</p>
<p>在这种方法中，测试用例是纯粹随机生成的。这种测试属于输入域测试的范畴，因为必须知道输入域才能在其中随机选取点。<strong>随机测试</strong>为测试自动化提供了一种相对简单的方法。已经提出了增强形式的随机测试（例如自适应随机测试），其中其他输入选择标准指导随机输入采样。</p>
<p><strong>3.1.10. 基于证据的测试</strong> [10, c6s2]</p>
<p><strong>基于证据的软件工程</strong>(EBSE)遵循严格的研究方法，是实际问题的<strong>最佳</strong>解决方案。EBSE包括以下阶段：</p>
<p>• 识别证据并形成一个问题 • 追踪最佳证据以回答问题 •
根据证据应该帮助解决的问题批判性地分析证据</p>
<p>EBSE原则也可以应用于测试过程。为此，允许识别和汇总证据的广泛使用的方法是系统映射研究和系统综述。</p>
<p><strong>3.1.11. 强制异常测试</strong> [5]</p>
<p>测试用例是专门设计用于检查被测系统是否能够管理预定义的异常/错误集，例如数据异常、操作异常、溢出异常、保护异常或下溢异常。测试技术通常关注负面测试场景（即能够强制生成错误消息的测试用例）。</p>
<h2 id="32-基于结构的测试技术">3.2. 基于结构的测试技术</h2>
<p>[4, part 4]</p>
<p><strong>基于结构的测试技术</strong>（有时称为<strong>基于代码的测试技术</strong>）关注代码及其结构。基于结构的测试技术可以在不同级别执行（例如代码开发、代码检查或单元测试），并且可以包括静态测试（例如代码检查、代码走查和代码审查）、动态测试（如语句覆盖、分支覆盖和路径覆盖）或代码复杂度测量（例如使用循环复杂度[12]等技术）。</p>
<p><strong>3.2.1. 控制流测试</strong> [1*, c4; 4, part 4]</p>
<p><strong>控制流测试</strong>覆盖被测系统中的所有语句、分支、决策、分支条件、修正条件/决策覆盖(MC/DC)、语句块或特定语句组合。基于控制流标准中最强的是路径测试，其目标是执行被测系统控制流图中的所有入口到出口的控制流路径。由于循环的存在，穷尽路径测试通常不可行，因此其他不那么严格的标准专注于限制循环迭代的路径覆盖，例如语句覆盖、分支覆盖和条件/决策测试。此类测试的充分性以百分比衡量；例如，当所有分支都被测试至少执行一次时，就达到了100%的分支覆盖。</p>
<p><strong>3.2.2. 数据流测试</strong> [1*, c5s2]</p>
<p>在<strong>数据流测试</strong>中，控制流图被注释以显示变量在何处被定义和使用。测试覆盖特定定义和使用对之间的路径。与路径测试一样，数据流测试通常不可行，因此使用诸如全定义和全使用等标准来减少所需的路径数量。</p>
<p><strong>3.2.3. 基于结构测试技术的参考模型</strong> [1*, c4]</p>
<p>虽然不是一种技术，但被测系统的控制结构可以使用流图进行图形化表示，以可视化<strong>基于结构的测试技术</strong>。流图是一个有向图，其节点和弧对应于程序元素。（参见数学基础知识领域中的图和树。）例如，节点可以表示语句或不间断的语句序列，弧可以表示节点之间的控制转移。</p>
<h2 id="33-基于经验的技术">3.3. 基于经验的技术</h2>
<p>[4, part 1, part 4]</p>
<p>最合适的测试套件的生成可能取决于不同的因素，例如人类对被测系统及其上下文的知识以及测试人员的经验和直觉。在下一节中，将简要介绍常用的基于经验的技术。</p>
<p><strong>3.3.1. 错误猜测</strong> [1*, c9s8; 4, part 4]</p>
<p><em>3.2.2. 数据流测试</em></p>
<p>在<em>数据流测试</em>中，控制流图会添加关于变量如何被定义、使用和销毁(未定义)的信息注释。常用的数据流测试技术包括全定义测试、全C使用测试、全P使用测试、全使用测试和全DU路径测试。最强的数据流测试准则是全DU路径测试，其中需要覆盖所有的定义和使用(DU)路径。这是因为它要求对每个变量执行从该变量的定义到该定义的使用之间的每条控制流路径段。然而，较弱的策略</p>
<p><em>3.3.2. 探索性测试(Exploratory Testing)</em></p>
<p><em>探索性测试</em>被定义为同时进行学习、测试设计和测试执行。测试用例不是预先定义的，而是根据收集到的证据和测试结果动态设计、执行和修改的，这些结果包括观察到的产品行为、被测系统的特性、领域和环境、故障过程、可能的缺陷和失效类型，以及与特定产品相关的风险。通常，负责执行探索性测试的人员的直觉、知识和专业技能会影响测试的有效性。探索性测试在左移开发(如敏捷)中被广泛使用。(参见第5.4.2节)</p>
<p><em>3.3.3. 其他基于经验的技术</em></p>
<p>在实践中，<em>基于经验的技术</em>可能包括其他方法，如基于临时的、基于知识的和基于机器学习的测试技术。</p>
<p>临时测试是一种广泛使用的技术，其中测试用例的产生依赖于软件工程师的技能、直觉和类似程序的经验。它有助于识别那些通过更正式化技术不容易生成的测试用例。典型的临时方法包括以下几种：</p>
<p>• 猴子测试运行随机生成的测试用例来模拟随机活动并导致程序停止。</p>
<p>•
结对(伙伴)测试涉及两个人。一个生成并运行测试用例；另一个观察和分析测试过程。结对测试允许生成具有更广泛和更好测试覆盖率的测试用例。</p>
<p>•
游戏化旨在将测试任务转换为游戏玩法的组成部分。通过应用特定技术(如吸引从业者或众包复杂测试任务)，游戏化可以显著改善软件测试实践，从而提高被测系统的质量。</p>
<p>•
快速测试，其中选择并执行一个非常小的测试套件来快速识别被测系统中的关键问题。它旨在提高在开发过程早期检测缺陷的概率。</p>
<p>•
冒烟测试(也称为构建验证测试)确保被测系统的核心功能正常运行。它还保证在计划的测试开始之前被测系统是可运行的。此外，冒烟测试可以预防由于测试环境导致的失效(例如，由于制品或包未正确构建)。冒烟测试也被认为是快速测试的一种特殊情况。</p>
<p>基于知识的测试和基于机器学习的测试利用关于被测系统的(正式或非正式)知识，或从被测系统执行的观察中推导出知识，以定义其行为模型(如本体或决策表)(参见第3.6.1节)、规则和非功能属性。此外，基于知识的测试和基于机器学习的测试指定测试需求并确定生成测试用例的测试目标。</p>
<h2 id="34-基于缺陷和变异技术">3.4. 基于缺陷和变异技术</h2>
<p><em>基于缺陷</em>的测试技术专门设计测试用例来揭示可能的或预定义的缺陷类别。可以引入<em>缺陷模型</em>对不同的缺陷进行分类，以更好地聚焦测试用例的生成或选择。在这种情况下，各种平台和开发过程(例如瀑布、螺旋和敏捷)认为正交缺陷分类(ODC)是一种有效的方法，用于收集关于不同缺陷的语义信息并减少根本原因分析的时间和工作量。</p>
<p><em>变异测试(Mutation
Testing)</em>最初被构想为一种评估测试套件的技术(参见第4.2节，已执行测试的评估)，其中变异体是被测系统(也称为<em>gold</em>)的略微修改版本，通过小的语法更改与其不同。每个测试用例都会执行gold版本和所有生成的变异体。如果测试用例成功识别出gold版本和变异体之间的差异，则该变异体被称为”被杀死”。变异测试的基础假设，即耦合效应(coupling
effect)，是通过寻找简单的语法缺陷可以发现更复杂但真实的缺陷。为了使该技术有效，必须自动生成并系统地执行许多变异体。变异测试本身也是一种测试准则。随机生成测试用例直到足够多的变异体被杀死，或者专门设计测试来</p>
<p><em>3.5.2. 用户观察启发式</em></p>
<p>在<em>错误猜测</em>中，软件工程师设计测试用例专门用于预测每个被测系统中最可能出现的缺陷。良好的信息来源是早期项目中发现的缺陷历史和软件工程师的专业知识。</p>
<p>这种方法的挑战来自操作剖面(operational
profile)的推导。因此，一种可能的解决方案是根据输入在实际操作中出现的频率为其分配概率或剖面。</p>
<p>消灭存活的变异体。在后一种情况下，</p>
<p>变异测试也可以归类为<em>基于结构的</em>技术。变异测试已被有效地用于生成模糊测试。变异过程的一个更新的应用是变形测试(metamorphic
testing)。这特别适用于解决机器学习系统的测试挑战。在这种情况下，修改(也称为变形)应用于输入，以便建立一种关系，将先前的输入(及其输出)与新的变形输入(及其输出)连接起来。</p>
<p>[2* c16, c17, c18, c20, c21; 14*, c4s8; 8]</p>
<p><strong>3.5. 基于使用的技术</strong> [1*, c15s5]</p>
<p><em>基于使用的技术</em>通常依赖于使用模型或配置文件。在这种情况下，测试环境需要代表实际的运行环境，测试用例执行的序列应重现目标利益相关者对被测系统的使用。统计采样用于模拟许多测试用例的执行。因此，有时术语<em>随机测试</em>也与这些技术相关联。基于使用的统计测试更多地应用于验收测试阶段。</p>
<p><strong>3.5.1. 操作配置文件</strong> [1<em>, c15s5, 2</em>, c11]</p>
<p>基于<em>操作配置文件</em>的测试旨在生成测试用例，以估计被测系统或其部分的可靠性。因此，目标是从观察到的测试结果推断软件(在使用时)的未来可靠性。由于建立的可靠性严格依赖于操作配置文件，因此使用这种测试的主要难点(和成本)在于操作配置文件本身。</p>
<p><em>专用启发式方法</em>,也称为<em>可用性检查方法</em>,用于在受控条件下系统地观察系统使用,以确定人们使用系统及其界面的效果如何。可用性启发式方法包括认知走查(cognitive
walkthrough)、声明分析、现场观察、出声思考(thinking
aloud),甚至间接方法如用户问卷和访谈。</p>
<p><strong>3.6. 基于应用性质的技术</strong></p>
<p>上述技术适用于所有类型的软件。其他测试派生和执行技术基于被测软件的性质。例如:</p>
<p>• 面向对象软件 • 基于组件的软件 • 基于Web的软件 • 并发程序 •
基于协议的软件 • 通信系统 • 实时系统 • 安全关键系统 • 面向服务的软件 •
开源软件 • 嵌入式软件 • 基于云的软件 • 基于区块链的软件 •
基于大数据的软件 • 基于AI/ML/DL的软件 • 移动应用 •
安全和隐私保护软件</p>
<p>在某些情况下,ISO/IEC/IEEE 29119等标准[4, part 4, part
5]提供了指定测试用例、自动化执行和维护测试套件的示例和支持,例如关键字驱动测试[4,
part 5]。</p>
<p><strong>3.7. 选择和组合技术</strong> [14*, c7s12; 10; 4, part 5]</p>
<p>组合不同的测试技术一直是确保被测系统所需质量水平的有效手段。特别是在左移开发中,自适应组合测试技术的方法是实践中的常态。目标是通过从经验中学习,同时使技术选择适应当前测试会话,从而提高测试过程的有效性。</p>
<p><strong>3.7.1. 组合功能性和结构性测试</strong> [1*, c9; 4, part
5]</p>
<p>基于场景和基于结构的测试技术通常对比为<em>功能性</em>测试与<em>结构性</em>测试。这两种测试用例选择方法被视为互补的,因为它们使用不同的信息来源并突出不同的问题。根据不同的组织约束,如预算考虑,它们可以组合使用。</p>
<p><strong>3.7.2. 确定性与随机</strong> [1*, c9s6]</p>
<p>测试用例可以按照许多技术以确定性方式选择,或者从某些输入分布中随机抽取,如可靠性测试中通常所做的那样。已经进行了几项分析和实证比较来分析这些方法的效果。</p>
<p>使用方法和框架支持测试活动并提高其有效性。创新方法包括使用数字孪生或仿真方法和框架、利用机器学习和游戏化设施,以及使用(模拟的)神经网络。</p>
<p><strong>4. 测试相关度量</strong> <strong>[2<em>, c24s5; 14</em>, c10;
4, part 4]</strong></p>
<p>测试技术就像帮助实现特定测试目标的工具。要评估是否达到测试目标,需要明确定义的度量。度量通常被认为是质量分析的基础。度量也可用于优化测试计划和执行。测试管理可以使用几种不同的过程度量来监控进度。(有关度量程序的信息,请参阅软件工程管理知识域中的软件工程度量。有关度量的信息,请参阅软件工程过程知识域中的软件度量。)</p>
<p>根据[4, part
4]中的定义,测试技术可以根据它们能够达到的覆盖程度进行分类。覆盖率可以从0%到100%变化,不包括可能不可行的测试(即无法执行的测试)。因此,对于每种基于规范的、基于结构的和基于经验的测试技术,必须确定相关的覆盖度量和评估该覆盖率的程序。覆盖度量的示例可以是程序流图中覆盖的分支百分比,或规范文档中列出的功能需求中被测试的百分比。</p>
<p>使测一种方法比另一种更有效的条件。</p>
<h2 id="38-基于衍生知识的技术">3.8. 基于衍生知识的技术</h2>
<p>[2<em>, c19, c20; 14</em>, c7]</p>
<p>测试技术可以整合来自不同研究领域和背景的证据和知识。为此，需要考虑监控设施可以动态计算被覆盖元素与总数之间的比率。此外，特别是在基于结构的测试技术情况下，可能还需要对被测系统(SUT)进行适当的插桩。然而，所提出的测试度量集也可以从不同的角度进行分类——从提供者的角度和允许基于观察到的测试输出对SUT进行评估的角度，以及评估已执行测试套件的彻底性或有效性的角度。</p>
<h2 id="41-sut的评估">4.1. SUT的评估</h2>
<p>[2*, c24s5]</p>
<p>通常，指标(即可测量的信息)可用于确定SUT是否按预期执行并实现其预期结果。这些指标有时被称为关键绩效指标(KPI)，与所采用的评估度量、方法、数据分析和报告密切相关。</p>
<h3 id="411-有助于规划和设计测试的sut度量">4.1.1.
有助于规划和设计测试的SUT度量</h3>
<p>[14*, c10; 10, c6; 4, part 1, part 4]</p>
<p>[4, part
4]中提出的所有测试度量都可用于规划和指导测试活动。此外，在左移开发过程中，特定度量，如部署频率、前置时间、平均恢复时间(MTTR)和变更失败率，也通常被采用来规划和管理测试活动和结果。</p>
<h3 id="412-故障类型分类和统计">4.1.2. 故障类型、分类和统计</h3>
<p>[1* c13s4, c13s5, c13s6]</p>
<p>测试文献中有丰富的故障分类和分类法，可以是通用的，也可以特定于某个上下文或质量属性(如可用性缺陷分类、硬件/软件安全和隐私漏洞及攻击的分类法，以及网络安全风险的分类)。为了使测试更有效，重要的是要知道SUT中可能发现哪些类型的故障，以及这些故障过去发生的相对频率。此信息可用于质量预测和过程改进(见软件质量知识领域中的特征化)。</p>
<h3 id="413-故障密度">4.1.3. 故障密度</h3>
<p>[1<em>, c13s4; 14</em>, c10s1]</p>
<p>传统上，可以通过计算发现的故障数与SUT大小之间的比率来评估SUT。由于故障的语义定义，可以考虑其他度量，例如故障深度(使SUT正确所需的最小故障移除次数)和故障多重性(修复单个故障所需的原子更改次数)。</p>
<h3 id="414-寿命测试可靠性评估">4.1.4. 寿命测试、可靠性评估</h3>
<p>[1<em>, c15, 2</em>, c11; 14*, c1s3]</p>
<p>软件可靠性的统计估计可用于评估是否可以停止测试或SUT是否足够成熟以进行下一次发布。可靠性评估在云(和雾)环境中发挥着关键作用[18]。一方面，验证和确认提案专注于维护云(雾)服务所需的高水平可靠性和可用性。另一方面,测试活动正在利用云(雾)环境的计算能力来加速可靠性评估并大幅降低其成本。</p>
<h3 id="415-可靠性增长模型">4.1.5. 可靠性增长模型</h3>
<p>[1<em>, c15, 2</em> c11s5]</p>
<p><strong>可靠性增长模型</strong>基于观察到的失效来预测可靠性。一般来说，它们假设当导致观察到的失效的故障被修复后(尽管有些模型也接受不完美的修复)，产品的可靠性将会提高。已发表的可靠性增长模型有很多。值得注意的是，这些模型分为<strong>失效计数</strong>模型和<strong>失效间隔时间</strong>模型。</p>
<h2 id="42-已执行测试的评估">4.2. 已执行测试的评估</h2>
<p>[4, part 4, c6]</p>
<p>SUT的行为通常通过执行测试套件来验证，测试套件在发现缺陷方面至关重要。因此，从研究人员和实践者的角度来看，软件测试的一个基本部分是比较测试套件。通常，评估测试套件意味着比较生成测试用例的测试用例生成技术。为此目的使用不同的标准，例如覆盖标准或变异分析标准。已经进行了大量研究，根据定义的每个属性(或有效性)概念，分析和经验地比较不同的技术。</p>
<h3 id="421-故障注入">4.2.1. 故障注入</h3>
<p>[1*, c2s5]</p>
<p>在<strong>故障注入</strong>中，在测试之前人为地将一些故障引入SUT。当执行测试套件时，会暴露其中一些注入的故障，并可能暴露一些已经存在的故障。理论上，根据发现了哪些以及多少人工故障，可以评估测试有效性。</p>
<h2 id="5-测试过程">5. 测试过程</h2>
<p><strong>[4, part 1, part 2, part 3; 2* c8]</strong></p>
<p>测试概念、策略、技术和度量需要整合到一个定义明确且受控的测试规划过程中，以进行测试输出评估。测试过程支持测试，并为负责不同测试活动的人员提供指导，以确保以经济有效的方式实现测试目标。如[4,
part
2]中所述，测试过程是一个多层次的过程活动，包括组织、管理和动态级别的测试规范。组织测试过程定义了创建的步骤。</p>
<p>评估的，剩余的真实缺陷数量可以被估算出来。在实践中，统计学家质疑注入缺陷相对于真实缺陷的分布和代表性，以及任何外推基于的小样本量。一些人还认为这种技术应该谨慎使用，因为向被测系统中插入缺陷会带来将它们留在那里的明显风险。</p>
<h3 id="422-变异分数-1-c3s5-6">4.2.2. 变异分数 [1*, c3s5; 6]</h3>
<p>在变异测试中，测试套件有效性度量被计算为被杀死的变异体与生成的变异体数量的比率。测试套件有效性值越高越好，因为它表明发现最真实注入缺陷的能力更强。</p>
<h3 id="423-不同技术的比较和相对有效性-1-c1s7-5-9">4.2.3.
不同技术的比较和相对有效性 [1*, c1s7; 5; 9]</h3>
<p>相对有效性将不同的测试技术与特定属性进行比较，例如找到第一个故障所需的测试数量、通过测试发现的缺陷数量与测试期间和之后发现的所有缺陷的比率，以及可靠性提高了多少。一些研究已经对此进行了探讨。</p>
<h2 id="5-测试过程-1">5. 测试过程</h2>
<p>测试过程规范定义了用于评估和维护测试规范的步骤，例如组织测试策略、流程、程序和其他资产
[4, part 2]。</p>
<p>测试管理过程定义了管理所需的步骤：计划、监控和控制以及完成。</p>
<p>最后，动态测试过程规定了设计和实现、环境设置和维护、执行以及测试事件报告的步骤。</p>
<p>在本节的其余部分，将提供关于测试过程规范、管理和执行的一些实际考虑因素，以及按照
[4, part 2] 中包含的组织、管理和动态级别的测试子过程和活动的摘要。</p>
<h3 id="51-实际考虑因素-4-part-1">5.1. 实际考虑因素 [4, part 1]</h3>
<p>测试过程应该允许不同测试阶段的自动化，并且应该依赖于所执行活动的可控性、可追溯性、可复制性和风险/成本估算。在本节的其余部分，将描述常用的测试步骤，这些步骤与所有生命周期模型兼容并适用。（参见软件工程过程知识领域中的软件生命周期。）</p>
<h4 id="511-态度无我编程egoless-programming-1-c16-2-c3">5.1.1.
态度/无我编程(Egoless Programming) [1<em>, c16; 2</em>, c3]</h4>
<p>成功测试的一个重要因素是对测试和质量保证(QA)活动的协作态度。管理者在促进对软件开发和维护期间故障发现和纠正的积极接受方面发挥着关键作用。例如，在敏捷等左移开发中，测试人员和开发人员之间的沟通与协作被认为对实现成功的测试结果至关重要。</p>
<h4 id="512-测试指南和组织过程-1-c12s1-2-c8-4-part-2-part-3-14-c7s3">5.1.2.
测试指南和组织过程 [1<em>, c12s1, 2</em> c8; 4, part 2, part 3; 14*,
c7s3]</h4>
<p>各种目标可以指导测试阶段。例如，基于风险的测试使用产品风险来确定优先级和集中测试策略，基于场景的测试根据指定的软件场景和待办事项列表定义测试用例。通常，测试过程的组织包括定义测试策略（即指定测试的目的、目标和总体范围）和测试战略（即指定关于如何进行测试的指导方针）。例如，在左移开发中，测试战略应至少包括以下数据：目的（例如通过用户故事定义）、目标（例如测试套件）、范围（被测系统）以及环境和方法（例如如何以及在哪里运行测试套件）。</p>
<h4 id="513-测试管理和动态测试过程-1-c12-4-part-2-part-3-14-c7s3">5.1.3.
测试管理和动态测试过程 [1<em>, c12; 4, part 2, part 3, 14</em>,
c7s3]</h4>
<p>在不同级别（参见第2节，测试级别）进行的测试活动应该被组织起来——包括人员、工具、策略和度量——成为软件开发和维护过程的一个完整定义的过程。测试管理过程包括测试计划、监控和控制以及完成。动态测试过程包括设计和实现、测试环境设置和维护、测试执行以及测试事件报告。</p>
<h4 id="514-测试文档-1-c8s12-14-c7s8-4-part-3">5.1.4. 测试文档 [1<em>,
c8s12; 14</em>, c7s8; 4, part 3]</h4>
<p>根据 [4, part
3]，文档是测试过程形式化的组成部分。测试文档可以分为三个层次类别：组织测试文档、测试管理文档和动态测试文档。</p>
<p>组织测试文档包括记录测试策略和组织测试战略所需的信息。测试管理文档包括测试计划、测试状态报告和测试完成报告。最后，动态测试文档包括以下文档：测试规范（测试设计规范、测试用例规范和测试程序规范）、测试数据需求、测试环境需求、测试数据就绪报告、测试环境就绪报告以及测试执行文档（例如实际结果、测试结果、测试执行日志和事件报告）。</p>
<p>测试文档应该像其他软件工程文档一样以相同的质量生产和持续更新。测试文档也应该在软件配置管理的控制之下。（参见软件配置管理知识领域。）</p>
<h4 id="515-测试团队-1-c16-2-c23s5-4-part-2-part-3">5.1.5. 测试团队 [1<em>,
c16; 2</em> c23s5; 4, part 2, part 3]</h4>
<p>测试过程的形式化也可能涉及测试团队组织的形式化。成本、进度、相关组织的成熟度级别和应用的关键性的考虑可以指导决策。测试团队可以由不同角色和技能的人员组成。</p>
<p>生命周期。测试过程管理包括参与（或不参与）SUT开发的成员（即是否具有无偏见的独立视角）或内部（或外部）人员。左移开发不强烈区分测试团队成员，因为测试套件是根据SUT开发和交付的代码定义和更新的。</p>
<p>不同的子过程，如规划、监控、控制和完成，而动态测试过程包括测试设计。</p>
<p><strong>5.1.6. 测试过程度量</strong></p>
<p>[1<em>, c18s3, 14</em>, c10; 4, part 1, part 5.1.8. 测试完成 2, part
3]</p>
<p>管理者使用多种度量来衡量测试所花费的资源，以及各个测试阶段相对的缺陷发现有效性，以控制和改进测试过程，并为管理过程风险提供信息。因此，监控测试必须定义所需的数据和信息，并说明如何获取它们。测试度量可能涵盖已指定、已执行、已通过和未通过的测试用例数量等要素。这些度量还可以与特定的过程指标结合使用，如残余风险、累计打开和关闭的缺陷、测试用例进度和缺陷检测百分比。对测试阶段报告的评估可以与根本原因分析相结合，以评估测试过程在尽早发现缺陷方面的有效性。这种评估可以与风险分析相关联。此外，认为值得在测试上花费的资源应与应用程序的使用和关键性相称。不同的技术具有不同的成本，并产生不同的产品可靠性置信水平。</p>
<p><strong>5.1.7. 测试监控</strong></p>
<p>[4, part 1, part 2]</p>
<p>监控和控制是测试管理过程的一个重要子过程，如[4, part
2]所述，用于收集测试管理和评估期间所需的数据和信息。通常，监控活动与测试执行并行执行，有时收集的数据可能会促使修订整体过程规划。监控确保测试过程活动符合特定的测试计划，以跟踪需求满足情况并充分识别和缓解已识别的风险。在测试监控期间，可以定期生成特定的文档（测试报告），以帮助评估和记录测试活动。</p>
<p>[14*, c7s11; 4, part 3]</p>
<p>必须决定多少测试才算足够以及何时可以完成测试阶段。因此，测试完成作为[4,
part
2]中测试管理过程的子过程，其目的是确保满足并验证测试需求，完成测试报告，并将测试结果传达给相关利益相关者。彻底性度量，如已达到的代码覆盖率或功能覆盖率，以及缺陷密度或运行可靠性的估计，提供了有用的支持，但本身并不充分。该决策还涉及考虑可能剩余故障所带来的成本和风险，以及继续测试所产生的成本（参见第1.2节测试选择和充分性标准中的关键问题）。与其他活动一样，在此阶段生成特定文档（例如测试完成报告）并传达给相关利益相关者。</p>
<p><strong>5.1.9. 测试可重用性</strong></p>
<p>[14*, c3; 9]</p>
<p>为了实现测试工件（如测试用例或执行环境）的可重用性，需要增加测试规划和设计的复杂性和时间，当测试开发成本高、耗时且复杂时，这种可重用性是期望的。</p>
<p>测试可重用性收集和分类测试知识（测试用例和测试结果），使这些信息可搜索并可用于创建新测试或重新执行现有测试。应配置和管理合适的基于知识的存储库以实现测试可重用性，以便软件需求或设计的变更可以反映在测试的变更中。</p>
<p>测试用例的可重用性在基于特性的或产品线开发以及回归测试中至关重要。测试可重用性还与可维护性相关，因为可重用性可以降低所涉及的成本和工作量，并提高测试的有效性。</p>
<p><strong>5.2. 测试子过程和活动</strong></p>
<p>[1<em>, c1s12; 1</em>, c12s9; 4, part 2]</p>
<p>在本节的其余部分，将简要介绍主要的测试活动和子过程。</p>
<p><strong>5.2.1. 测试规划过程</strong></p>
<p>[1*, c12s1, c12s8; 11; 4, part 2]</p>
<p>像项目管理的所有其他方面一样，测试活动必须进行规划。根据[4, part
2]，测试规划的关键方面包括人员的识别和协调、测试专注于实现和执行测试用例。它通常与工具相关（即使用特定软件，也称为测试用例生成器）。该软件接受输入（如源代码、测试标准、规范或数据结构定义）并使用它们生成测试套件。有时，测试用例生成器可以通过使用特定的测试预言机(oracle)功能来确定预期结果。这有助于整个测试过程的完全自动化。</p>
<p><strong>5.2.3. 测试环境搭建和维护</strong></p>
<p>[1<em>, c12s6; 2</em> c8s1; 14* c13s2; 4, part 2; 11]</p>
<p>根据[4, part
2]中描述的动态测试过程，测试环境开发和搭建涉及识别测试基础设施。这包括选择或开发设施、硬件、软件、固件以及进行测试的程序。</p>
<p>测试目标和完成标准、测试设施和设备的定义、所有测试相关文档的创建和维护，以及针对可能出现的不良结果的风险规划和管理。</p>
<p>这些活动可以分为三个不同的层次进行组织：(1)
过程管理（即测试政策、策略、流程和程序的识别），(2)
组织管理（即测试阶段、测试类型和测试目标的定义），以及 (3)
设计和实现（即测试环境的定义、测试执行过程和监控、完成过程以及报告）。</p>
<p>测试活动。测试环境可以是模拟的、受控的，并且可以在体外或体内执行。开发测试环境还涉及建立监控和日志记录设施，这对于记录测试活动和评估获得的结果非常有用。测试环境应该与使用的其他软件工程工具兼容。</p>
<h2 id="524-受控实验和测试执行">5.2.4. 受控实验和测试执行</h2>
<p>[1<em>, c12s7, 14</em> c4s7, 14* c5s6; 4, part 2]</p>
<p>测试的执行应该体现科学受控实验的基本原则——在测试期间所做的一切都应该足够具体和清晰地执行和记录，以便其他人可以复制结果。因此，测试应该遵循记录的程序执行，使用清晰定义的
SUT（System Under Test，被测系统）版本。特别是在验收测试期间，像 A/B
测试这样的受控实验也可以用来统计评估用户对 SUT 不同版本的偏好。</p>
<h2 id="522-测试设计和实现">5.2.2. 测试设计和实现</h2>
<p>[1*, c12s1, c12s3; 11]</p>
<p>测试用例的生成基于要执行的测试级别和选择的测试技术。根据 [4, part 2]
中描述的动态测试过程，测试用例生成的前提条件是识别测试目标和选择适当的测试/演示技术。</p>
<h2 id="525-测试事件报告">5.2.5. 测试事件报告</h2>
<p>[1<em>, c13s4, c13s9, c13s11; 2</em>, c8s3; 14*, c7s8; 4, part 3;
12]</p>
<p>根据 [4, part 2]
中描述的动态测试过程，测试事件和报告侧重于明确定义的测试数据收集过程（即识别测试何时进行、谁执行了测试、使用了什么软件配置以及其他相关识别信息）。该过程和收集的证据可以用于问责目的。测试报告可能涉及适当的审计系统，以识别意外或不正确的测试结果，并将其记录在问题报告系统中。这些数据构成了后续调试和修复测试期间观察到的故障问题的基础。此外，如果异常情况后来变得比最初想象的更严重，即使未分类为故障的异常也可以被记录下来。测试报告也是变更管理请求过程的输入。（参见软件配置管理知识领域中的软件配置控制。）</p>
<p>因此，<em>测试事件报告</em>过程侧重于识别相关利益相关者的事件，这些事件可用于确定软件测试和其他过程的哪些方面需要改进以及先前方法的有效性。</p>
<p>事件报告的一部分也是评估测试结果以确定测试是否成功。在大多数情况下，“成功”意味着软件按预期执行，并且没有任何重大意外结果。并非所有意外结果都一定是故障；有时它们被确定为仅仅是噪声。在移除故障之前，需要进行分析和调试工作以隔离、识别和描述它。当测试结果特别重要时，可能会召集正式审查委员会来评估它们。</p>
<h2 id="53-人员配置">5.3. 人员配置</h2>
<p>[1*, c16; 4, part 3]</p>
<p>指定招聘需求和定义培训需求。人员配置影响项目风险，因为团队的专业知识可能会削弱发现故障、应对不断变化的需求、满足截止日期以及增加/减少维护成本的能力。</p>
<p>角色、活动和职责定义建立了以下角色和职责：活动负责人和支持人员、测试相关角色及其相应职责，以及负责提供测试项的人员。</p>
<p>根据采用的开发生命周期，典型的测试角色包括但不限于 Scrum
Master/测试负责人、QA/测试分析师、测试设计师、测试安全/性能工程师和顾问、测试环境专家、测试执行者和测试自动化顾问或架构师。</p>
<p>招聘需求需要识别完成测试过程需要额外测试人员的具体要求（以及何时需要该人员和所需的技能）。根据业务需求，人员配置可以采取不同形式，从内部调动到外部招聘，甚至顾问和/或外包资源。</p>
<p>最后，培训需求规范包括所需技能水平的定义。它还包括培训活动的规范（如课堂培训、自定进度培训、基于计算机的培训或指导），这些活动有助于为选定的员工提供必要的技能。</p>
<h2 id="6-开发过程和应用领域中的软件测试">6.
开发过程和应用领域中的软件测试</h2>
<p>[2<em>, c8, c15; 14</em>, c4s8, c7]</p>
<p>无论采用何种开发过程，测试仍然是一项基本活动。但是，在某些情况下可能会使用特定的测试活动或术语，例如</p>
<p>根据 [4, part
3]，人员配备包括采用的开发生命周期和/或定义角色、活动和职责以及应用领域。</p>
<p><a href="#软件测试">软件测试</a> 5-23</p>
<p><em>6.1. 软件开发过程中的测试</em> [验证质量。它还能够使用用例和]</p>
<p><em>流程</em> [2*, c8; 14*, c7]
[风险来驱动被测系统(SUT)的开发，并允许]</p>
<p>[战略变更管理。统一过程(UP)将]</p>
<p>在本节剩余部分，将介绍不同开发 [被测系统的增量和迭代分为四个]</p>
<p>过程中测试的特殊性。 [阶段：初始、细化、构建]</p>
<p>[和转换。]</p>
<p><em>6.1.1. 传统流程中的测试</em>
[统一过程既可以被认为是迭代的，也可以]</p>
<p>[1* c18; 14*, c7] [被认为是敏捷的——迭代是因为所有核心活动]</p>
<p>[在整个被测系统开发]</p>
<p>有多种传统流程， [项目中重复进行，敏捷是因为所选生命周期]</p>
<p>本质上基于被测系统开发 [的已定义阶段可以重复]</p>
<p>原则，可以在组织内采用。顺序模型、V模型、螺旋模型和
[直到被测系统满足需求（包括]</p>
<p>迭代模型只是一些常见 [功能性和非功能性需求），实现]</p>
<p>应用的流程。（软件工程过程知识领域中的软件生命周期提供
[定义的目标，并保证]</p>
<p>了每种模型的详细描述。）然而，在 [目标质量。]</p>
<p>所有这些流程中，测试只是一个被</p>
<p>感知的活动；有时在流程末尾执行，如果偏离 <em>6.1.2.
符合左移运动的测试</em></p>
<p>最终用户需求或评估 [[2*, c3, c8s2; 4, part 1; 10, c3, c5]]</p>
<p>问题，存在被测系统开发失败的明显风险。</p>
<p>近年来，为了评估和
[<em>左移测试运动</em>倡导在软件开发的早期阶段采用测试]</p>
<p>控制被测系统的整体质量， [以尽早检测和消除缺陷]</p>
<p>已经建立了测试成熟度模型集成 [从而提高整体被测系统]</p>
<p>(TMMi)和软件过程改进 [质量并降低测试活动的成本和风险。]</p>
<p>(SPI)等举措。因此， [不同的开发生命周期，]</p>
<p>不同的现有框架已经为此目的进行了更新
[如敏捷、DevOps和测试驱动开发(TDD)，都属于]</p>
<p>或改进，例如软件过程改进和能力
[左移运动。（参见软件工程过程知识领域中的敏捷方法。）]</p>
<p>确定(SPICE)、能力成熟度 [在基于左移的开发中，应考虑]</p>
<p>模型集成(CMMI)和统一过程 [不同的测试方面：]</p>
<p>(UP)。</p>
<p>例如，CMMI是最 A. 内部代码质量：回归测试、</p>
<p>受参考的模型之一；它可以指导关键被测系统
[优先级、安全性和隐私可能]</p>
<p>利益相关者控制他们的开发 [是内部代码质量的主要目标]</p>
<p>和维护流程。实际上，它 [（第2.2节）。通常，单元]</p>
<p>是软件测试中一套定义良好的最佳实践， [测试和集成测试是]</p>
<p>通过提高客户满意度来改进被测系统质量。 [目标级别（第2.1节），而]</p>
<p>[基于结构的是主要测试技术]</p>
<p>在2000年代初提出的统一过程 [（第3.2节）。]</p>
<p>模型可以被视为 [B. 业务需求：合规性和一致性、]</p>
<p>左移运动的前身。统一过程通过提供多种机制来鼓励早期测试，以便更紧密地将
[可用性、安全性和隐私]</p>
<p>测试与软件 [只是业务需求方面可能目标的]</p>
<p>开发工作集成，使测试成为一个独特的 [一个子集]</p>
<p>学科。此外，统一过程促进迭代 [（第2.2节）。关于这个方面，测试]</p>
<p>开发方法，以持续 [更多地关注系统和验收]</p>
<p>[测试级别以及最终用户期望]</p>
<p>[以及基于使用的技术（第]</p>
<p>[3.5节）和基于场景的技术]</p>
<p>（第3.1.8节）。</p>
<p>5-24 [<em>SWEBOK</em>] [<em>®</em>][ 指南 V4.0a]</p>
<p>C. 感知质量：Alpha、Beta、安装 [• 在自动化构建和持续]</p>
<p>、可用性、安全性和隐私 [集成测试中（例如DevOps），]</p>
<p>[可能是内部感知质量的主要目标] [被测系统被持续开发、集成]</p>
<p>[（第2.2节）。] [、交付和监控。在此]</p>
<p>[感知质量通常关注] [过程中，持续执行回归测试]</p>
<p>[验收测试级别，并通过应用] [以及时识别和纠正]</p>
<p>[基于软件工程直觉和经验] [开发和集成问题。]</p>
<p>[的技术（第3.3节）以及基于使用] [此外，快速测试技术，]</p>
<p>[和基于缺陷的技术，如变异] [如冒烟测试，通常]</p>
<p>[测试（第3.4节）来实现。] [在持续集成期间使用，以]</p>
<p>D. 质量保证：性能安装
[保证被测系统在发布到运营阶段之前是可测试的。]</p>
<p>、安全性和隐私一致性</p>
<p>和合规性是质量保证的一些主要 <em>6.2. 应用领域中的测试</em></p>
<p>目标（第2.2节）。这个方面可能涉及所有测试 [[2*, c15; 14*, c4s8]]</p>
<p>级别，测试</p>
<p>技术的选择取决于目标和 [通常，应用领域与]</p>
<p>选择的级别。 [特定现实紧密相关。因此，测试]</p>
<p>[方法可以根据]</p>
<p>不同左移运动实施中的测试示例包括：
[领域的需求进行定制，并根据采用的技术进行自定义。]</p>
<p>[每个特定领域的环境都有]</p>
<p>• 在敏捷流程开发中，测试 [软件测试的特定方面和解决方案，例如：]</p>
<p>活动涉及所有利益相关者（如</p>
<p>客户和团队人员）并针对识别未来交互中可以改进的地方。管理回归缺陷的风险、满足不断变化的需求以及管理它们对测试工件的影响也是敏捷测试过程的目标。通常，测试自动化用于管理回归风险，探索性测试可用于管理缺乏详细需求的情况。</p>
<p>•
在TDD(测试驱动开发)中，测试用例主要针对软件需求规格说明和验收，并且在编写代码之前生成。测试基于用户故事，并使用自动化组件测试工具实现。TDD是一种需要定义和维护单元测试的实践，可以帮助澄清用户需求和软件需求规格说明。</p>
<p>•
汽车领域测试：由于汽车系统的复杂性，此测试涉及几乎每个软件组件及其与硬件交互的方方面面。安全测试、仿真测试、可靠性/生命周期测试、集成系统测试、数据采集和信号分析测试、质量测试和检查以及应力/应变测试只是该领域执行的各种测试中的一部分。几个支持标准根据特性、组件或应评估的质量方面来指导和管理汽车测试。Autosar和Automotive
SPICE就是例子。</p>
<p>•
物联网(IoT)领域测试：此测试涉及应用程序开发、设备管理、系统管理、异构性管理、数据管理以及用于分析、部署、监控、可视化和研究的工具。此外，在质量评估中还应考虑安全性、隐私、通信和用户/组件交互。例如，欧洲电信标准协会(ETSI)标准中详细说明了针对IoT被测系统网络安全评估的指南和特定一致性测试套件。</p>
<p>•
法律领域测试：法律领域最重要的方面之一是高度敏感用户的管理；因此，安全性、隐私和信任是测试最常见的关注领域。此外，由于收集和交换的数据量大，数据存储库的性能测试、显示准确通信和集成测试以及一致性和合规性测试也应该进行。最后，由于法律领域具有特定的命名法和术语，让法律领域专家参与测试用例生成是确保关注所需特性和质量的常见做法。</p>
<p>•
移动领域测试：此测试通常用于可用性、功能、配置和一致性评估。在测试活动期间还应考虑移动特定方面，如屏幕分辨率、全球定位系统(GPS)、操作系统和设备制造商。最后，移动应用程序的类型（原生或Web应用）及其交互需要进行测试。例如，W3C
Web和移动兴趣小组提供了用于开发和测试基于Web的内容、应用程序和服务的设施、指南和专用测试套件。</p>
<p>•
航空电子领域测试：通常，航空电子系统包括几个独立或松散耦合的组件和商用现货产品。因此，测试需要包括适用于系统和流程级别的非常通用的流程和方法。功能和非功能、集成、通信操作、压力、安全和安全测试是可能方法的示例。与其他领域一样，可以参考航空无线电公司(ARINC)标准和ASTM
F3153-15等支持标准。</p>
<p>•
医疗保健领域测试：医疗保健领域测试应确保安全可靠的数据交换、稳定的性能、隐私和安全等领域的质量。互操作性、可用性、性能以及符合行业法规以及安全和安全标准（如Health
Level Seven
(HL7)、快速医疗互操作性资源(FHIR)、医学数字成像和通信(DICOM)、健康保险流通与责任法案(HIPAA)和通用数据保护条例(GDPR)）也应被考虑。</p>
<p>•
嵌入式领域测试：由于软件和硬件在嵌入式系统中紧密耦合，测试活动应评估软件和硬件的功能和非功能属性。</p>
<p>•
图形用户界面(GUI)测试：GUI测试涉及评估UI（用户界面）（即我们可以看到的用户对象的元素）。因此，GUI测试针对设计模式、图像、对齐、拼写以及UI的整体外观和感觉。测试方法应有效且高效。客户满意度、可用性、安全性、隐私、第三方组件和应用集成、实时问题和性能是</p>
<p>基于有限状态机的方法、目标驱动的方法、基于抽象的方法和基于模型的方法都可以考虑。</p>
<p>•
游戏：游戏应用程序和软件对新方法和确保其质量与安全性的新途径产生了越来越大的需求。在具体的测试技术中，游戏测试(playtesting)是最常采用的技术之一。在这种情况下，真实的游戏玩家(通常来自开发或测试团队)在游戏执行或设计过程的许多节点重复质量控制方法。GUI测试、功能测试、安全测试、控制台测试、合规性测试和性能测试也可以考虑。</p>
<p>•
实时领域测试：实时测试通常侧重于评估时间约束和确定性行为。可以采用单元测试、集成测试和系统测试方法。通信测试、交互测试和行为测试也可以执行。</p>
<p>• 面向服务架构(Service Oriented Architecture,
SOA)测试：此测试主要关注正确实现业务流程，涉及单元测试和集成测试方法。可以应用基于结构的测试、基于规约的测试和安全测试。测试活动根据环境、组织和应满足的需求集而变化。</p>
<p>•
金融领域测试：此测试涵盖广泛的方面，从管理金融需求到评估金融应用程序和软件程序。与其他领域一样，领域特定知识(例如银行、信用合作社、保险公司、信用卡公司、消费金融企业、投资基金和股票经纪公司所持有的知识)可能是应用测试过程所必需的。</p>
<h2 id="7-新兴技术的测试与通过新兴技术进行测试">7.
新兴技术的测试与通过新兴技术进行测试</h2>
<p>软件开发受到新兴趋势的驱动，如移动技术的广泛普及、云基础设施的采用、大数据分析和软件即服务范式，这些趋势为测试带来了新的约束和挑战。</p>
<h3 id="71-新兴技术的测试">7.1. 新兴技术的测试</h3>
<p>• 人工智能(AI)、机器学习(ML)/深度学习(DL)的测试
[13]：AI、ML和DL正在实践中得到应用。大多数业务应用程序将包含某种形式的AI、ML或DL。由于其特性(例如非确定性性质)，测试此类应用程序具有挑战性，并且可能非常昂贵。在此场景中定义错误和测试时应考虑三个主要方面：所需条件(正确性、鲁棒性、安全性和隐私性)；AI、ML或DL项目(例如，错误可能存在于数据、学习程序或使用的框架中)；以及涉及的测试活动(测试用例生成、测试预言识别和定义、测试用例充分性标准)。在所有这些应用中，首先基于历史数据生成原型模型。然后，进行离线测试，如交叉验证，以验证生成的模型满足所需条件。通常，在部署后，该模型通过生成新数据用于预测目的。最后，通过在线测试分析生成的数据，以评估模型如何与用户行为交互。</p>
<p>这个领域中一些最重要的挑战。</p>
<p>• 区块链测试
[15]：用于验证区块链及相关应用程序(如智能合约)的常用测试技术包括压力测试、渗透测试和属性测试。然而，根据具体情况，在测试基于区块链的被测系统(SUT)时应考虑不同方面，例如：</p>
<p>o
平台类型：验证级别取决于用于实现的平台类型——公有链或私有链。后者需要更大的测试工作量。</p>
<p>o
与其他应用程序的连接：当区块链与各种应用程序协同工作时，应执行集成测试以检查一致性。</p>
<p>o
性能：应构思处理大量交易的特定策略，以保证令人满意的性能水平。还应考虑定性和定量指标，如平均交易验证延迟和安全性。</p>
<p>• 云测试 [1<em>, c10s10, 2</em>,
c18]：云测试通过考虑功能性和非功能性方面来验证部署在云中的应用程序和基础设施的质量，涉及不同的操作系统和版本、不同类型的硬件以及众多用户。对于此类测试，很难使用基于组件或系统之间经典层次结构的测试方法；相反，基于输入/输出、依赖线程或动态关系的解决方案通常效果更好。此外，不同组件的持续集成和部署的可能性迫使测试过程包括根据时间、带宽使用、吞吐量和适应性约束管理持续测试操作、注入、监控和报告的方法。最后，仍然需要允许测试知识、架构和代码可重用性的解决方案，以使测试活动更有效且成本更低。</p>
<h3 id="72-通过新兴技术进行测试">7.2. 通过新兴技术进行测试</h3>
<p>• 通过ML进行测试
[13]：AI、ML或DL技术被成功用于减少软件工程中几项活动(如行为提取、测试或错误修复)所涉及的工作量。这些技术帮助研究人员和从业者为其期望的应用程序采用和识别适当的方法。在软件测试中采用ML技术的兴趣日益增长。</p>
<p>的功能性和非功能性属性。测试的重点是识别驻留在云中的系统所带来的问题。因此，测试活动使用技术来验证基于云的服务的性能、可扩展性、弹性(elasticity)和安全性。此外，当使用不同的部署模型(例如私有云、公有云或混合云)时，测试还应关注异构云资源之间的兼容性和互操作性。</p>
<p>• 测试并发和分布式应用[1*, c10s10, 2*,
c17]：测试动态、复杂、分布式或并发应用的一个主要方面是处理多个操作系统和更新、多个浏览器平台。大多数软件测试问题被表述为机器学习问题。实际上，AI、ML或DL几乎用于所有软件中，例如测试用例设计、预言问题(oracle
problem)、测试用例评估、测试用例优先级排序和细化，以及变异测试自动化。实际上，它们减少了维护工作并提高了整体SUT质量，因为它们能够分析大量数据以更有效地分类、分类和优先处理错误。从DevOps的角度来看，AI、ML和DL解决方案可用于测试用例的SUT自动化创建和执行阶段，以及执行后的测试分析，以识别趋势、模式和对SUT测试活动的影响。</p>
<p>•
通过区块链进行测试[15]：当不同的团队、领域专家和用户需要在协作的大规模系统和复杂软件系统中共同工作以实现共同目标时，测试变得复杂。这主要是因为时间限制、数据共享策略、验收标准以及测试过程中涉及的团队之间的可信协调。区块链技术可以用来提高软件测试效率，避免使用中心化权威来管理不同的测试活动。这有助于确保分布式数据管理、防篡改、可审计性和自动需求合规，以提高软件测试和开发的质量。基于区块链的可信测试用例库管理方法以及支持基于测试的软件和安全测试也被考虑在内。</p>
<p>•
通过云进行测试[17]：通过云进行测试是指利用可扩展的云技术执行的SUT测试。通常，云用于需要大规模仿真和弹性资源的测试目的。实际上，这可以影响成本降低、测试基础设施(脚手架)的开发和维护，以及系统的在线验证，例如基于ML的SUT。一种特殊情况是通过云本身测试云。这是测试与通过新兴技术进行测试之间交集的一个例子。部署在云中的应用和基础设施可以利用云的带宽进行测试。</p>
<p>• 通过仿真进行测试[1*,
c3s9]：仿真是测试活动的一项重要技术，因为它代表了一种在关键情况或灾难下评估SUT执行或评估特定行为或恢复活动的有效手段。测试方法可能根据所采用的仿真系统的复杂性而有所不同，可能涉及闭环测试；评估设备、通信和接口；以及使用实时数据(例如电压、电流和断路器状态)。仿真测试可以应用于每个开发级别，可能涉及真实系统、环境、网络条件和控制设备的数学、形式化表示。仿真测试目前在许多应用领域被采用。特别是在汽车和嵌入式领域，在不同的方案中，仿真测试的新兴解决方案之一是硬件在环(HIL)仿真测试。在这种情况下，发送到SUT的真实信号用于模拟现实并测试和设计迭代，在使用真实世界系统时不断执行。</p>
<p>•
通过众包进行测试[16]：众包测试(也称为crowdtesting)是一种让用户和专家参与测试活动的方法。因此，众包用户代表了由多个单独测试人员组成的分散的临时工作人员。通过众包进行测试主要用于测试移动应用程序，因为它确保了技术多样性和以客户为中心的验证。然而，众包测试并不能替代内部SUT验证。它代表了一种检测故障和问题的有效手段，因为它涉及不同地点的许多个人(测试人员)，他们在不同条件下使用不同的技术，并具有不同的技能和知识。</p>
<h2 id="8-软件测试工具">8. 软件测试工具</h2>
<p><strong>[1*, c12s11, 14*, c7]</strong></p>
<p>几种测试工具关注SUT的特性和需求。本节描述了与测试工具相关的主要问题和挑战，并对其进行了分类。</p>
<h3 id="81-测试工具支持和选择">8.1. 测试工具支持和选择</h3>
<p>[1*, c12s11, 14*, c7]</p>
<p>测试涉及许多劳动密集型任务，因为它涉及运行大量程序执行和处理大量信息。适当的工具可以自动化某些任务。分析可以通过SUT仪器化(instrumenter)来完成，该仪器化在代码中插入记录探针，以验证程序流程图中所选测试覆盖标准所要求的所有元素是否都已被执行。</p>
<p><em>• 跟踪器(Tracers)</em> [1*, c1s7]记录</p>
<p>可以减轻繁琐文书操作的负担，并使其不易出错。复杂的工具可以支持测试设计和生成，使其更加有效。</p>
<p>关于为管理者和测试人员选择测试工具的指导至关重要，因为正确的工具会显著影响测试效率和有效性。工具选择取决于多种因素，如开发选择、评估目标和执行设施。一般来说，可能没有唯一的工具能满足特定需求，因此一套精选的工具可能是合适的。</p>
<h2 id="82-工具类别">8.2. 工具类别</h2>
<p>[1*, c1, c3, c4, c7, c8, c9, c12]</p>
<p>测试工具的几种分类主要描述了它们的功能，例如：</p>
<ul>
<li><strong>测试框架</strong>（驱动程序、桩程序）[1*, c3s9]
提供一个受控环境，在其中可以启动测试并记录测试输出。提供驱动程序和桩程序来执行被测系统(SUT)的部分代码，以模拟调用模块和被调用模块。</li>
<li><strong>测试生成器</strong> [1*, c12s11]
协助生成测试用例。生成可以是随机的、基于路径的、基于模型的或它们的混合。</li>
<li><strong>捕获/回放工具</strong> [1*, c12s11]
自动重新执行或回放先前执行的测试，这些测试已记录输入和输出（例如屏幕）。</li>
<li><strong>预言机、文件比较器、断言检查工具</strong> [1*, c9s7]
协助判断测试结果是否成功。</li>
<li><strong>覆盖率分析器和插桩器</strong> [1*, c4]
协同工作。覆盖率分析器评估程序执行路径中哪些实体以及有多少实体被覆盖。</li>
<li><strong>回归测试工具</strong> [1*, c12s16]
支持在软件的某个部分被修改后重新执行测试套件。它们还可以根据所做的更改帮助选择测试子集。</li>
<li><strong>可靠性评估工具</strong> [1*, c8]
支持测试结果分析和图形可视化，以根据选定的模型评估与可靠性相关的度量。</li>
<li><strong>基于注入的工具</strong> [1*, c3, c7s7]
专注于引入或重现特定问题，以确认被测系统在相应条件下的行为是否合适。这可能涉及管理某些输入或触发事件。通常，基于注入的工具分为两类：攻击注入和故障注入。</li>
<li><strong>基于仿真的工具</strong> [1*, c3s9]
验证和确认选定的属性。通常，它们利用特定模型来实现场景的自动化执行，以评估被测系统是否按预期运行或预测被测系统如何响应定义的输入。典型的基于仿真的工具分为验证工具、协作工具、优化工具、自动化系统测试工具和软件概念评估工具。</li>
<li><strong>安全测试工具</strong> [1*, c8s3, c12s11]
专注于特定的安全漏洞。其中包括攻击注入工具、渗透测试工具和模糊测试工具。</li>
<li><strong>测试管理工具</strong> [1*, c12s11]
包括所有支持工具，以确保高效和有效的测试管理和数据收集。</li>
<li><strong>跨浏览器测试工具</strong> [1*, c8s3]
使测试人员能够快速构建和运行跨桌面、移动和Web应用程序的用户界面测试用例，以检查被测系统在每个设备和浏览器上的外观和工作是否符合预期。</li>
<li><strong>负载测试工具</strong> [1*, c3]
收集有价值的数据和证据，用于被测系统性能评估。</li>
<li><strong>缺陷跟踪工具</strong> [1*, c3]
帮助在被测系统开发项目期间跟踪检测到的故障。这些工具充当跟踪系统，并允许最终用户直接输入故障报告。</li>
<li><strong>移动测试工具</strong> [1*, c8s3]
通过允许在应用平台上进行多次重复的UI测试、在真实移动设备或模拟器上开发、在真实时间测试移动应用程序，来支持移动应用程序的实现和测试，以及收集特定质量保证(QA)度量的数据。</li>
<li><strong>API测试工具</strong> [1*, c7s2]
通过特定API测试的自动化，检查应用程序是否满足功能、性能、可靠性和安全性期望。</li>
<li><strong>Web应用测试工具</strong> [1*,
c8s3]，也称为Web测试工具，支持验证基于Web的被测系统的功能和性能。这些工具为不同的利益相关者（如开发人员、服务器管理员和基础设施管理员）提供相关见解和数据。这些工具在被测系统提供给最终用户之前解决问题或错误。</li>
</ul>
<div class="page-separator"></div>
<h2 id="主题与参考材料对照表">主题与参考材料对照表</h2>
<table>
<thead>
<tr>
<th></th>
<th>[<strong>1*</strong>]</th>
<th>[<strong>2*</strong>]</th>
<th>[<strong>14*</strong>]</th>
<th>[<strong>19*</strong>]</th>
</tr>
</thead>
<tbody>
<tr>
<td>[<strong>1. 软件测试基础</strong>]</td>
<td>[c1, c2]</td>
<td>[c8]</td>
<td>[c7]</td>
<td></td>
</tr>
<tr>
<td>[<em>1.1. 故障与失效</em>]</td>
<td>[c1s5]</td>
<td>[c1]</td>
<td>[<em>c1s3</em>]</td>
<td></td>
</tr>
<tr>
<td>[<em>1.2. 关键问题</em>]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.1. 测试用例创建</em>]</td>
<td>[c12s1, c12s3]</td>
<td>[c8]</td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.2. 测试选择和充分性准则</em>]</td>
<td>[c1s14, c6s6, c12s7]</td>
<td>[c8]</td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.3. 优先级排序/最小化</em>]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.4. 测试目的</em>]</td>
<td>[c13s11, c11s4]</td>
<td>[c8]</td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.5. 评估和认证</em>]</td>
<td>[c7, c25]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.6. 质量改进/保证测试</em>]</td>
<td>[c16s2]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.7. 预言机问题</em>]</td>
<td>[c1s9, c9s7]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.8. 理论和实践限制</em>]</td>
<td>[c2s7]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.9. 不可行路径问题</em>]</td>
<td>[c4s7]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.10. 可测试性</em>]</td>
<td>[c17s2]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.11. 测试执行和自动化</em>]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.12. 可扩展性</em>]</td>
<td>[c8s7]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.13. 测试有效性</em>]</td>
<td>[c1s1]</td>
<td>[c8s1]</td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.14. 可控性、可复制性和泛化性</em>]</td>
<td>[c12s12]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.2.15. 离线测试与在线测试</em>]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[<em>1.3. 测试与其他活动的关系</em>]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="2-测试级别-1">2. 测试级别</h1>
<h2 id="21-测试的目标-1">2.1. 测试的目标</h2>
<h3 id="211-单元测试-1">2.1.1. 单元测试</h3>
<h3 id="212-集成测试-1">2.1.2. 集成测试</h3>
<h3 id="213-系统测试-1">2.1.3. 系统测试</h3>
<h3 id="214-验收测试-1">2.1.4. 验收测试</h3>
<h2 id="22-测试的目的">2.2. 测试的目的</h2>
<h3 id="221-符合性测试">2.2.1. 符合性测试</h3>
<h3 id="222-合规性测试-1">2.2.2. 合规性测试</h3>
<h3 id="223-安装测试-1">2.2.3. 安装测试</h3>
<h3 id="224-alpha-和-beta-测试">2.2.4. Alpha 和 Beta 测试</h3>
<h3 id="225-回归测试-1">2.2.5. 回归测试</h3>
<h3 id="226-优先级测试-1">2.2.6. 优先级测试</h3>
<h3 id="227-非功能性测试">2.2.7. 非功能性测试</h3>
<h3 id="228-安全测试-1">2.2.8. 安全测试</h3>
<h3 id="229-隐私测试-1">2.2.9. 隐私测试</h3>
<h3 id="2210-接口和-api-测试">2.2.10. 接口和 API 测试</h3>
<h3 id="2211-配置测试">2.2.11. 配置测试</h3>
<h3 id="2212-可用性和人机交互测试">2.2.12. 可用性和人机交互测试</h3>
<h1 id="3-测试技术">3. 测试技术</h1>
<h2 id="31-基于规格说明的技术">3.1. 基于规格说明的技术</h2>
<h3 id="311-等价类划分">3.1.1. 等价类划分</h3>
<h3 id="312-边界值分析">3.1.2. 边界值分析</h3>
<h3 id="313-语法测试">3.1.3. 语法测试</h3>
<h3 id="314-组合测试技术">3.1.4. 组合测试技术</h3>
<h3 id="315-决策表">3.1.5. 决策表</h3>
<h3 id="316-因果图">3.1.6. 因果图</h3>
<h3 id="317-状态转换测试">3.1.7. 状态转换测试</h3>
<h3 id="318-场景测试">3.1.8. 场景测试</h3>
<h3 id="319-随机测试">3.1.9. 随机测试</h3>
<h3 id="3110-基于证据的测试">3.1.10. 基于证据的测试</h3>
<h3 id="3111-强制异常">3.1.11. 强制异常</h3>
<h2 id="32-基于结构的测试技术-1">3.2. 基于结构的测试技术</h2>
<h3 id="321-控制流测试">3.2.1. 控制流测试</h3>
<h3 id="322-数据流测试">3.2.2. 数据流测试</h3>
<p>5-32 SWEBOK® GUIDE V4.0a</p>
<h3 id="323-基于结构的测试技术参考模型">3.2.3.
基于结构的测试技术参考模型</h3>
<h2 id="33-基于经验的技术-1">3.3. 基于经验的技术</h2>
<h3 id="331-错误推测">3.3.1. 错误推测</h3>
<h3 id="332-探索性测试">3.3.2. 探索性测试</h3>
<h3 id="333-其他基于经验的技术">3.3.3. 其他基于经验的技术</h3>
<h2 id="34-基于故障的技术和变异技术">3.4. 基于故障的技术和变异技术</h2>
<h2 id="35-基于使用的技术">3.5. 基于使用的技术</h2>
<h3 id="351-操作剖面operational-profile">3.5.1. 操作剖面(Operational
Profile)</h3>
<h3 id="352-用户观察启发式方法">3.5.2. 用户观察启发式方法</h3>
<h2 id="36-基于应用特性的技术">3.6. 基于应用特性的技术</h2>
<h2 id="37-选择和组合技术">3.7. 选择和组合技术</h2>
<h3 id="371-组合功能性和结构性测试">3.7.1. 组合功能性和结构性测试</h3>
<h3 id="372-确定性测试与随机测试">3.7.2. 确定性测试与随机测试</h3>
<h2 id="38-基于衍生知识的技术-1">3.8. 基于衍生知识的技术</h2>
<h1 id="4-测试相关度量">4. 测试相关度量</h1>
<h2 id="41-被测系统的评估">4.1. 被测系统的评估</h2>
<h3 id="411-有助于测试规划和设计的被测系统度量">4.1.1.
有助于测试规划和设计的被测系统度量</h3>
<h3 id="412-故障类型分类和统计-1">4.1.2. 故障类型、分类和统计</h3>
<h3 id="413-故障密度-1">4.1.3. 故障密度</h3>
<h3 id="414-寿命测试可靠性评估-1">4.1.4. 寿命测试、可靠性评估</h3>
<h3 id="415-可靠性增长模型-1">4.1.5. 可靠性增长模型</h3>
<h2 id="42-已执行测试的评估-1">4.2. 已执行测试的评估</h2>
<h3 id="421-故障注入-1">4.2.1. 故障注入</h3>
<h3 id="422-变异分数">4.2.2. 变异分数</h3>
<h3 id="423-不同技术的比较和相对有效性">4.2.3.
不同技术的比较和相对有效性</h3>
<h1 id="5-测试过程-2">5. 测试过程</h1>
<h2 id="51-实践考虑因素">5.1. 实践考虑因素</h2>
<h3 id="511-态度无我编程egoless-programming">5.1.1. 态度/无我编程(Egoless
Programming)</h3>
<h3 id="512-测试指南和组织过程">5.1.2. 测试指南和组织过程</h3>
<h3 id="513-测试管理和动态测试过程">5.1.3. 测试管理和动态测试过程</h3>
<h3 id="514-测试文档">5.1.4. 测试文档</h3>
<h3 id="515-测试团队">5.1.5. 测试团队</h3>
<h3 id="516-测试过程度量">5.1.6. 测试过程度量</h3>
<h3 id="517-测试监控和控制">5.1.7. 测试监控和控制</h3>
<p>软件测试 5-33</p>
<h3 id="518-测试完成">5.1.8. 测试完成</h3>
<h3 id="519-测试可复用性">5.1.9. 测试可复用性</h3>
<h2 id="52-测试子过程和活动">5.2. 测试子过程和活动</h2>
<h3 id="521-测试规划过程">5.2.1. 测试规划过程</h3>
<h3 id="522-测试设计和实现-1">5.2.2. 测试设计和实现</h3>
<h3 id="523-测试环境设置和维护">5.2.3. 测试环境设置和维护</h3>
<h3 id="524-受控实验和测试执行-1">5.2.4. 受控实验和测试执行</h3>
<h3 id="525-测试事件报告-1">5.2.5. 测试事件报告</h3>
<h2 id="53-人员配备">5.3. 人员配备</h2>
<h1 id="6-开发过程和应用领域中的软件测试-1">6.
开发过程和应用领域中的软件测试</h1>
<h2 id="61-软件开发过程中的测试">6.1. 软件开发过程中的测试</h2>
<h3 id="611-传统过程中的测试">6.1.1. 传统过程中的测试</h3>
<h3 id="612-符合左移shift-left运动的测试">6.1.2.
符合左移(Shift-Left)运动的测试</h3>
<h2 id="62-应用领域中的测试">6.2. 应用领域中的测试</h2>
<h1 id="7-新兴技术的测试和通过新兴技术进行测试">7.
新兴技术的测试和通过新兴技术进行测试</h1>
<h2 id="71-新兴技术的测试-1">7.1. 新兴技术的测试</h2>
<h2 id="72-通过新兴技术进行测试-1">7.2. 通过新兴技术进行测试</h2>
<h1 id="8-软件测试工具-1">8. 软件测试工具</h1>
<h2 id="81-测试工具支持和选择-1">8.1. 测试工具支持和选择</h2>
<h2 id="82-工具类别-1">8.2. 工具类别</h2>
<p><strong>参考文献</strong></p>
<p>[1*] S. Naik and P. Tripathy, <em>Software Testing and Quality
Assurance: Theory and Practice</em>, 1st ed: Wiley, 2008.</p>
<p>[2*] I. Sommerville, <em>Software Engineering</em>, 10th ed.,
Addison-Wesley, 2016.</p>
<p>[3] E.W. Dijkstra, <em>Notes on Structured Programming</em>,
Technological University, Eindhoven, 1970.</p>
<p>[4] ISO/IEC/IEEE 29119 — System and software engineering — Software
testing, ed. 2022.</p>
<p>[5] “ISO/IEC/IEEE 24765:2017 Systems and Software Engineering —
Vocabulary,” 2nd ed. 2017.</p>
<p>[6] M. Papadakis, M. Kintis, J. Zhang, Y. Jia, Y. Le Traon, and M.
Harman, Chapter Six — Mutation Testing Advances: An Analysis and Survey,
<em>Advances in Computers,</em> 112, 2019: 275-378.</p>
<p>5-34 SWEBOK® GUIDE V4.0a</p>
<p>[7] M. Utting, B. Legeard, F. Bouquet, E. Fourneret, F. Peureux, and
A. Vernotte, Recent advances in model-based testing, <em>Advances in
Computers</em>, 101, 2016, pp. 53-120.</p>
<p>[8] IEEE Std 1012-2016, IEEE Standard for System, Software, and
Hardware Verification, and Validation, ed. 2016.</p>
<p>[9] ISO/IEC 25010:2011, Systems and Software Engineering Applications
Enabled by Blockchain Technology: A Systematic</p>
<p>[14*] C.Y. Laporte, and A. April, <em>Software Quality
Assurance</em>, IEEE Computer Society Press, 1st ed., 2018.</p>
<p>[15] S. Demi, R. Colomo-Palacios, and M. Sánchez-Gordón, Software
Engineering Applications Enabled by Blockchain Technology: A Systematic
<em>Software Engineering</em>, 25, 2020, pp. 5193-5254.</p>
<h1 id="第6章-软件工程运维">第6章 软件工程运维</h1>
<p><strong>缩略词表</strong></p>
<ul>
<li>API - 应用程序编程接口(Application Programming Interface)</li>
<li>ATDD - 验收测试驱动开发(Acceptance Test Driven Development)</li>
<li>CD - 持续交付(Continuous Delivery)</li>
<li>CPU - 中央处理器(Central Processing Unit)</li>
<li>CI - 持续集成(Continuous Integration)</li>
<li>CONOPS - 运维概念(Concepts of Operations)</li>
<li>DBMS - 数据库管理系统(Database Management System)</li>
<li>IaaS - 基础设施即服务(Infrastructure as a Service)</li>
<li>IaC - 基础设施即代码(Infrastructure as-Code)</li>
<li>IT - 信息技术(Information technology)</li>
<li>ITIL - IT基础设施库(IT Infrastructure Library)</li>
<li>MR - 修改请求(Modification request)</li>
<li>KPI - 关键绩效指标(Key Performance Indicator)</li>
<li>MVP - 最小可行产品(Minimum Viable Product)</li>
<li>PaaS - 平台即服务(Platform as a Service)</li>
<li>QA - 质量保证(Quality Assurance)</li>
<li>PR - 问题报告(Problem Report)</li>
<li>SaaS - 软件即服务(Software as a Service)</li>
<li>SLA - 服务级别协议(Service-Level Agreement)</li>
<li>TDD - 测试驱动开发(Test Driven Development)</li>
<li>SRE - 站点可靠性工程(Site Reliability Engineering)</li>
</ul>
<h2 id="引言-3">引言</h2>
<p><em>软件工程运维</em>是指在目标运维环境中部署、运行和支持软件应用或系统，同时保持其完整性和稳定性所需的一系列活动和任务。一旦应用投入运行，软件工程运维必须对使用过程中发现的任何缺陷、系统软件环境和硬件设备的变更，以及出现的任何新用户需求进行监控和管理(直到其退役)。</p>
<p>软件工程运维是系统和软件生命周期过程的重要组成部分[3]。软件工程运维知识领域(KA)与软件工程的所有其他方面相关。传统上，专门的软件和信息技术(IT)运维工程师提供和管理IT运维服务。软件工程运维的最佳实践最初由IT基础设施库(ITIL)发布，并迅速被行业接受。这些实践被总结并发布在IEEE
20000标准中[1]。</p>
<p>从历史上看，运维和计算中心通常位于与软件开发活动分离的组织孤岛中。现在，进步的组织将软件开发、软件维护和一些软件工程运维活动(通常作为服务提供，通常称为DevOps)放在一起。这种方法的好处是消除了分隔这些软件活动的组织孤岛，并共享通用流程和工具。DevOps实践日益流行和越来越被接受[2*]，以及相关标准[4]，包括不断演进的工具集，反映了这一趋势。</p>
<p>DevOps旨在自动化和持续演进软件工程活动，以确保高质量软件并满足要求软件工程师更快周转的用户需求。</p>
<h2 id="图61-软件工程运维知识领域主题分解">图6.1
软件工程运维知识领域主题分解</h2>
<p><strong>软件工程运维基础</strong> - 软件工程运维的定义 -
软件工程运维流程 - 开发与运维环境</p>
<p><strong>软件工程运维规划</strong> - 运维计划和供应商管理 - 变更管理 -
运维支持</p>
<p><strong>软件工程运维交付</strong> - 部署/发布工程 - 回滚和数据迁移 -
软件安装 - 脚本和自动化</p>
<p><strong>软件工程运维控制</strong> - 事件管理 - 监控、测量、跟踪和审查
- 运维服务报告</p>
<p><strong>软件工程运维实践考虑因素</strong> - 事件和问题预防 -
自动化部署 - 自动化测试 - 自动化监控和遥测 - 有效的测试和故障排除</p>
<p><strong>软件工程运维工具</strong> - 容器和可视化 - 运维风险管理 -
问题管理 - 软件可用性、连续性和服务级别 -
软件容量、性能、可靠性和负载均衡 - 安全、安保、完整性、数据保护和控制 -
极小型实体的软件工程运维</p>
<h2 id="参考文献-5">参考文献</h2>
<p>[10] ISO/IEC/IEEE 32675:2022 信息技术 - DevOps -
构建可靠和安全的系统，包括应用构建、打包和部署。</p>
<p>[11] 软件工程能力模型(SWECOM)，v1.0，2014。</p>
<p>[12] ISO/IEC 20246:2017，“软件和系统工程 - 工作产品评审”，2017。</p>
<p>[13] V. Riccio, G. Jahangirova, A.
Stocco等人，基于机器学习系统的测试：系统映射研究，<em>应用科学</em>，11(7)，2021，pp. 2960。</p>
<p>[16] K. Mao, L. Capra, M. Harman和Y.
Jia，软件工程中众包使用的调查，<em>系统与软件期刊</em>，126，2017，pp. 57-84。</p>
<p>[17] A. Bertolino, G.D. Angelis, M. Gallego, B. García, F. Gortázar,
F. Lonetti和E.
Marchetti，云测试的系统综述，<em>ACM计算调查(CSUR)</em>，52(5)，2019，pp. 1-42。</p>
<p>[18] R. Achary和P.
Raj，<em>云可靠性工程：技术和工具</em>，CRC出版社，2021。</p>
<p>[19*] J. Nielsen，<em>可用性工程</em>，第1版，波士顿：Morgan
Kaufmann，1993。</p>
<p>软件工程 - 系统和软件质量要求和评估(SQuaRE) -
系统和软件质量模型，ed. 2011。</p>
<p>一致性/标准化、已知的安全策略、自文档化(透明性)、单一真实来源、配置控制、</p>
<p>在这种背景下，从2015年到2025年，随着基础设施即代码(Infrastructure-as-Code,
IaC)、平台即代码(Platform-as-Code,
PaC)、敏捷基础设施、软件定义的架构/系统等实践的出现，以及基础设施即服务(IaaS)和平台即服务(PaaS)解决方案的普及，参与软件工程运维的软件工程师的角色发生了显著演变。传统上由IT基础设施工程师执行的任务越来越多地被自动化并作为服务提供，使应用程序开发人员能够在日常项目活动中独立执行软件工程运维任务。例如，许多组织中的应用程序开发人员现在可以直接使用IaaS和PaaS在生产环境中部署应用程序，并监控这些应用程序的不同方面，而无需直接涉及运维工程师。</p>
<p>使用IaC和PaC等实践，像管理代码一样管理端到端资源和期望的状态配置，以提高可重复性和可扩展性的形式提供价值。从工程角度来看，重要的一点是，几乎任何直接或间接影响软件产品的因素都应该被考虑以代码形式表示。</p>
<p>为了执行软件工程运维任务，一些组织使用平台工程(Platform
Engineering)和站点可靠性工程(Site Reliability Engineering,
SRE)[6]的概念来提高生产力和软件质量。平台工程的作用是构建和管理自助式平台能力，软件工程师可以使用这些能力来开发、部署和运营软件应用程序。另一方面，SRE的作用是监控、自动化和改进软件运维中的非功能性方面，包括可用性、性能、延迟和安全性。SRE还负责变更管理、应急响应、容量规划以及软件系统的整体效率。</p>
<p>尽管许多组织仍在使用传统的IT运维管理流程，但本知识领域主要关注软件工程师在DevOps、IaC、PaC和敏捷基础设施实践的新兴背景下在运维中的作用。</p>
<p><strong>软件工程运维</strong> 6-3</p>
<p>在这种背景下，我们识别出两个与运维相关的主要软件工程角色：</p>
<p><strong>运维工程师</strong>(operations
engineer)，负责开发作为服务提供并可通过应用程序编程接口(API)访问的运维服务，以及<strong>软件工程师</strong>(software
engineer)，可以使用生成的运维服务(作为服务提供)来独立部署和管理应用程序，而无需直接涉及IT运维专家。</p>
<p>在这个角色中，运维工程师与软件工程师密切合作，开发和提供运维服务，例如以下服务：</p>
<p>• 为容器和虚拟服务器提供配置、部署、配置和支持， •
设计和提供按需服务(例如，按需环境、版本控制、持续集成(CI)和测试、部署和监控)供软件工程使用，
•
通过运行诊断、记录问题和解决方案、优先处理问题以及评估问题影响来监控和排查系统和应用软件事件，
• 执行、自动化和实施适当的安全流程、数据保护和故障转移程序， •
监督容量、存储规划和数据库管理系统(DBMS)性能， •
为IT人员提供文档和技术规范，以规划和实施新的或升级的IT基础设施和系统软件。</p>
<p><strong>软件工程运维主题分解</strong></p>
<p>软件工程运维知识领域的主题分解如图6.1所示。</p>
<h2 id="1-软件工程运维基础">1. 软件工程运维基础</h2>
<p>第一部分介绍了构成理解软件工程运维角色和范围的基础概念和术语。</p>
<h3 id="11-软件工程运维的定义-1-c3s333-c6s6412">1.1. 软件工程运维的定义
[1, c3s3.3][3, c6s6.4.12]</h3>
<p>在本<em>指南</em>中，术语<em>软件工程运维</em>是指软件工程师或其组织使用的知识、技能、流程和工具，以确保软件产品(包括IT基础设施、系统软件和应用软件)在开发、维护和实际运营条件下良好运行。</p>
<p>在ISO/IEC/IEEE 12207
[3]中，<em>运营者</em>(operator)被定义为”执行系统运营的个人或组织”。<em>SWEBOK指南</em>修改了该定义为术语<em>运维工程师</em>(operations
engineer)，指执行软件工程运维流程的软件工程师。</p>
<p>ISO/IEC/IEEE
20000-1描述了开发和增强运维工程师专业能力的需要。为实现这一目标，软件组织应解决以下问题：</p>
<p>•
人员招聘：验证应聘者的资格和能力，包括他们的专业认证，并根据运维工程师职位描述、核心技术和掌握的计算机语言以及整体经验，识别他们的优势、劣势和潜在能力，
•
资源规划：为新的或扩展的工程运维服务配备人员，规划新技术的使用，规划将服务管理人员分配到开发项目团队，</p>
<p>6-4 <em>SWEBOK® GUIDE V4.0a</em></p>
<p>• 运维计划和供应商管理 • 开发和运维环境 •
软件可用性、连续性和服务级别 • 软件容量管理</p>
<p>[• 软件备份、灾难恢复和故障转移]</p>
<p>[• 软件和数据安全性、保障性、完整性、保护和控制]</p>
<p>[运营规划]</p>
<p>[流程]</p>
<p>[• 运营测试、验证和验收]</p>
<p>[运营交付] [• 部署/发布工程]</p>
<p>[流程] [• 回滚和数据迁移]</p>
<p>[运营控制] [• 问题解决]</p>
<p>[流程]</p>
<p>[• 事件和变更管理]</p>
<p>[• 监控、测量、跟踪和审查]</p>
<p>[• 运营支持]</p>
<p>[• 服务报告]</p>
<p>[<strong>图 6.2.</strong> ][软件工程运营流程和活动]</p>
<p>制定继任规划和其他服务交付流程、发布流程、填补员工流动造成的人员缺口、控制流程、解决流程和关系流程。这些运营流程在ISO/IEC/IEEE
12207
[3]中被进一步归类为技术流程。从软件工程师的角度来看，运营流程包含部署、配置、操作和支持现有软件系统或产品同时保持其完整性所需的活动和任务。该国际标准描述了四个主要的运营流程活动：1）为运营做准备：需要定义运营策略；2）执行运营：包括操作和监控；3）管理运营结果：记录和处理异常；最后4）支持客户：向运营服务的任何用户提供帮助和咨询。</p>
<p>•
资源培训和开发：识别培训和开发需求并制定满足这些需求的培训和开发计划；同时及时、有效地提供运营服务。运营工程师应接受服务管理相关方面的培训（例如，通过培训课程、自学、指导和在职培训），并应培养他们的团队合作和领导技能。应为每个人维护一份按时间顺序排列的培训记录，并附上所提供培训的描述。</p>
<p><em>1.2. 软件工程运营流程</em> [2*, s1][3, c6s6.4.12]</p>
<p>ISO/IEC/IEEE
20000-1是呈现运营流程概述的参考标准。它规定了运营服务的设计、过渡、交付和改进的要求。ISO/IEC/IEEE
20000-1描述了五个主要的运营流程组：</p>
<p>最后，ISO/IEC/IEEE 32675
[4]从敏捷和最小可行产品(MVP)的角度介绍了一些软件工程运营活动。该标准认可了DevOps作为一套原则和实践的影响，这些原则和实践使相关利益相关者之间能够更好地沟通和协作，以便指定、开发、持续改进和运营软件及系统产品和服务。这些流程和活动是运营工程师的职责。</p>
<p>[软件工程运营] 6-5</p>
<p>对于《SWEBOK指南》而言，工程运营活动可以分为三个主要的运营流程（见图6.2），每个流程包含许多运营活动，这些活动将在本章的以下部分中描述：</p>
<p>• 运营规划（第2节） • 运营交付（第3节） • 运营控制（第4节）</p>
<p>每个软件工程运营流程都包括在软件项目的交付前和交付后阶段执行的活动。软件工程运营规划活动发生在交付前阶段。本章涵盖这些活动。</p>
<p><em>1.3. 软件安装</em> [1, c3, c6s2][2*, c3s3.1]</p>
<p>在软件应用程序或更新可供用户使用（即在生产环境中发布并向用户开放）之前，运营工程师必须在部署过程中安装软件。为了安装软件，工程师可能需要卸载以前的版本，为目标环境配置软件，并在目标环境上创建必要的目录、注册表文件和环境变量。这通常使用脚本语言完成。软件安装到</p>
<p>延迟、提高质量并确保一致且稳定的运营环境。这通常使用脚本语言来实现，脚本语言是基本的编程语言。自动化运营能够在发生故障时做出更快的反应，因此导致更少的停机时间和更少的严重事件，因为警报会立即发送。自动化此类任务也是确保组织内运营标准化的好方法。它也构成了作为服务提供的运营开发的基础。有关运营工具的进一步讨论，请参阅第6节。</p>
<p><em>1.5. 有效的测试和故障排除</em> [2*, c3]</p>
<p>软件工程运营负责确保系统的稳定性。为此，软件必须在发布之前（在生产环境中部署并向用户开放）进行彻底测试。由于手动测试效率低下、容易出错且不可扩展，因此必须在整个软件过程中尽可能实现测试自动化。此外，由于可用于测试的时间有限，回归测试和测试覆盖率策略（选择性地重新测试软件应用程序或组件，以验证要部署的软件不会导致意外影响）在软件工程运营中发挥着重要作用。</p>
<p>当发现错误时（在软件发布后的生产环境中或在内部测试阶段），软件工程师和软件运营工程师需要进行故障排除</p>
<p>进行硬件和软件事件诊断，记录问题和解决方案，对问题进行优先级排序，并评估问题的影响。在重要软件上重复完整测试的成本（包括时间和金钱）是巨大的。</p>
<p>为确保请求的问题报告（Problem
Reports，PR）有效，运维工程师应通过运行适当的测试来复现和验证问题。在生产环境中测试软件的某些方面可能特别具有挑战性。例如，当软件执行关键功能时，将其下线测试可能很困难。通常，在生产系统环境中测试软件具有挑战性（有时甚至不可能），可能需要使用金丝雀测试（canary
testing）和暗启动（dark
launch）等测试技术。软件测试知识领域（KA）提供了有关测试的更多信息和参考。</p>
<h2 id="16-性能可靠性和负载均衡">1.6. 性能、可靠性和负载均衡</h2>
<p>软件运维工程师在软件项目早期就要规划性能、可靠性和负载均衡，以确保满足项目需求（参见软件需求知识领域第1.2到1.7节）。当前的趋势是软件工程师设计和使用基础设施/运维服务来根据需求动态调整（例如可扩展性）基础设施。使用DevOps实践使运维工程师能够提前预测这些需求，并提供软件工程师可以在项目开发阶段使用和测试的基础设施服务。</p>
<h1 id="2-软件工程运维规划">2. 软件工程运维规划</h1>
<p>本主题介绍了软件工程运维规划中一些普遍接受的技术。运维工程师必须处理许多关键问题以确保软件有效运行。运维工程师应记录其软件工程运维步骤和工具，使用任何适合目的的类型、形式或媒介（例如Wiki、文档等）。以下主题通常被认为适合作为良好记录运维的证据：</p>
<p>• 策略和计划， • 服务文档， • 程序， • 流程，以及 •
流程控制记录。</p>
<h2 id="21-运维计划和供应商管理">2.1. 运维计划和供应商管理</h2>
<p>软件工程运维规划应成为将项目需求和开发人员及维护人员的需求转化为服务的过程的一部分，它应该为指导和进度提供路线图。这个过程通常涉及供应商的产品和服务，必须协调好以确保服务质量。ISO/IEC/IEEE
20000-1描述了规划活动，ISO/IEC/IEEE
12207也列出了运维工程师从人员、技术和系统角度考虑的活动。</p>
<h3 id="211-运维计划">2.1.1. 运维计划</h3>
<p>虽然软件开发通常持续几个月到几年，但运维阶段通常持续多年。因此，资源估算是运维规划的关键要素。软件工程运维规划应从决定开发新软件产品时开始，并应尽早考虑其维护和运维需求。应制定概念文档，然后制定运维和维护计划，两者都应涉及以下内容：</p>
<p>• 运维和软件维护的范围， • 软件工程运维流程和工具的适配， •
软件工程运维组织的识别， • 软件工程运维和维护成本的估算。</p>
<p>下一个规划步骤建议制定软件工程运维计划，或运维概念（Concept of
Operations，CONOPS）。该计划应在软件开发期间准备，并应说明软件投入运营后用户将如何请求软件修改并报告问题或故障。</p>
<p>软件工程运维规划在ISO/IEC/IEEE 12207和ISO/IEC/IEEE
32675中有所说明。这些标准为规划、实施、维护、自动化和支持生产软件提供了指南。最后，在最高规划层面，运维组织必须进行业务规划活动（例如预算、财务和人力资源），就像组织的所有其他部门一样（参见软件工程管理知识领域）。ISO/IEC/IEEE
20000-1建议运维计划应处理与多个规划视角相关的问题，包括以下内容：</p>
<p>• 实施、运行和维护新服务或变更服务的角色和职责，</p>
<p>需要进行修改请求（Modification
Request，MR）规划。一旦收到并验证了单个请求，发布或版本规划活动要求运维工程师执行以下任务：</p>
<p>• 确定单个请求的目标可用日期， • 就后续发布或版本的内容达成一致， •
识别潜在冲突并制定替代方案， •
评估给定发布的风险并制定回滚和数据迁移计划（参见第3.3节），以防出现问题，
• 通知所有利益相关者。</p>
<h3 id="212-供应商管理">2.1.2. 供应商管理</h3>
<h2 id="客户和供应商需要执行的活动">客户和供应商需要执行的活动</h2>
<p>[供应商管理确保组织的供应商及其绩效得到适当管理，以支持无缝提供优质产品和服务。]</p>
<h2 id="对现有服务管理框架和服务的变更">对现有服务管理框架和服务的变更</h2>
<p>[ISO/IEC/IEEE
12207列出了运维工程师为建立获取供应商产品和/或服务的协议而执行的活动。]</p>
<h2 id="与相关方的沟通">与相关方的沟通</h2>
<p>[从运维工程师的角度来看，与供应商关系的性质和方法应由项目所需产品和服务的性质决定。]</p>
<h2 id="新的或变更的合同和协议以适应业务需求的变化">新的或变更的合同和协议，以适应业务需求的变化</h2>
<p>[管理与运维软件相关服务的供应商包括管理外包服务和云服务，如IaaS和PaaS。]</p>
<h2 id="人员配备和招聘需求">人员配备和招聘需求</h2>
<h2 id="技能和培训需求">技能和培训需求</h2>
<p>（例如用户、技术支持）</p>
<h2 id="与新服务或变更服务相关的流程度量方法和工具">与新服务或变更服务相关的流程、度量、方法和工具</h2>
<h2 id="容量管理">容量管理</h2>
<h2 id="财务管理">财务管理</h2>
<h2 id="预算和时间表">预算和时间表</h2>
<h2 id="服务验收标准">服务验收标准</h2>
<h2 id="运营新服务的预期成果以可衡量的术语表示">运营新服务的预期成果，以可衡量的术语表示</h2>
<p><strong>2.2. 开发和运维环境</strong> [2*, c9]</p>
<p>[整个软件过程需要在不同阶段使用不同的环境。这些环境通常定义为开发环境、测试或质量保证(QA)环境、预生产环境和生产环境。]</p>
<p>该计划确保定义运维策略，识别和评估正确运维的条件，在预期环境中大规模测试软件，并提供监控以确保软件的响应性和可用性，从而确保持续支持。在单个请求级别（例如问题报告(PR)或修改请求），</p>
<p>[为了在产品中构建质量并降低与在生产环境中发布软件相关的风险（无论发布是与新功能还是软件缺陷相关），工程师必须确保不同环境都与生产环境保持一致和同步。]</p>
<p>[因此，DevOps建议所有不同环境的创建都应自动化，并从单一代码仓库构建。]</p>
<p>[在成熟的DevOps组织中，不同环境的创建是完全自动化的，并作为服务提供。]</p>
<p>[此外，所有环境都需要从相同的代码源（单一真实来源）构建，以确保所有环境都与发布软件的生产环境同步。]</p>
<p>这引出了基础设施即代码(IaC)的概念。</p>
<p><strong>2.3. 软件可用性、连续性和服务级别</strong> [1, c6s6.3]</p>
<p>[必须管理服务可用性和连续性，以确保满足客户承诺。]</p>
<p>[由于服务可用性和连续性在项目早期被定义为非功能性需求（见软件质量知识领域），运维工程师将确保规划、设计、实施和测试适当的基础设施。]</p>
<p>[软件可用性被测量和记录，未计划的不可用性被调查并采取适当的措施。]</p>
<p>[服务报告根据服务级别目标生成运维服务的可用性和连续性指标。]</p>
<p>[服务级别管理流程监控约定的软件服务级别，包括工作负载特征、性能和可用性趋势信息以及客户满意度分析。]</p>
<p>[定义、同意和记录服务级别协议(SLA)可以帮助明确所提供的全方位运维服务义务。]</p>
<p>软件维护知识领域提供了额外信息。</p>
<p><strong>2.5. 软件备份、灾难恢复和故障转移</strong> [1, c6s6.3.4]</p>
<p>[ISO/IEC/IEEE
20000-1还提出，在重大服务故障或灾难发生后，应快速提供以下内容：]</p>
<p>[在任何时候都有足够的容量来满足由客户业务需求创建的当前和未来约定的需求。]</p>
<p>[应该从业务需要向其客户交付产品或服务的角度理解当前和预期的服务业务需求。]</p>
<p>[业务预测和工作负载估计应转化为具体需求并记录下来。]</p>
<p>[对工作负载或环境变化的反应应该是可预测的；应该在适当级别捕获和分析当前和以前组件的数据以及资源利用率，以支持该流程。]</p>
<p>[容量管理是所有性能和容量问题的焦点。]</p>
<p>[该流程应通过调整和建模这些服务来直接支持新服务和变更服务的开发。]</p>
<p>[应以适当的频率（至少每年一次）制作记录基础设施实际性能和预期需求的容量计划，考虑服务和服务量的变化率、变更管理报告中的信息以及不断变化的客户业务需求。]</p>
<p>[容量计划应记录满足业务需求的成本化选项，并推荐解决方案以确保实现SLA中定义的约定服务级别目标。]</p>
<p>[应充分了解技术基础设施及其当前和预计容量，以确保最佳软件运维。]</p>
<h2 id="24-软件容量管理">2.4. 软件容量管理</h2>
<h3 id="备份与恢复规划">备份与恢复规划</h3>
<p>ISO/IEC/IEEE 20000-1
描述了确保软件产品具有持续性规划和测试所需的容量，包括数据、文档和软件的备份，以及服务恢复所需的任何设备或人员。备份和数据恢复是重要的活动；成功恢复尤为关键。成功恢复的需求应影响使用哪种备份和恢复方法（完全或增量）、恢复点建立的频率、存储位置以及保留时长。</p>
<p>准备工作和定期测试备份、灾难恢复和故障转移应随着生产环境的变化不断演练。这是在进行中断评估时触发的另一项基本活动。测试灾难恢复需要停止服务、识别检查点状态并触发故障转移过程。软件工程师应该理解故障是不可避免的，自动化故障转移守护进程可以大幅减少恢复时间。为实现这一点，软件应用程序应包含故障处理逻辑；这必须在开发期间规划。DevOps可以帮助希望减少故障转移和灾难的组织，通过尽可能频繁地自动化和启动测试，确保在发生故障或灾难性事件时的准备状态。</p>
<h2 id="26-软件和数据安全安全性完整性保护和控制">2.6.
软件和数据安全、安全性、完整性、保护和控制</h2>
<p>ISO/IEC/IEEE 20000-1
描述了在所有服务活动中有效管理信息安全的需求。这通过对信息的安全性和可用性进行软件风险评估来完成。运维工程师应努力执行以下控制措施：</p>
<ol type="a">
<li><p>高层管理人员应定义其信息安全策略，将其传达给员工和客户，并采取行动确保其有效实施，</p></li>
<li><p>应定义信息安全管理角色和职责，并分配给岗位持有者，</p></li>
<li><p>应指派管理团队的代表监督和维护信息安全策略的有效性，</p></li>
<li><p>担任重要安全角色的员工应接受信息安全培训，</p></li>
<li><p>所有员工都应了解信息安全策略，</p></li>
<li><p>应提供有关风险评估和控制实施的专家帮助，</p></li>
<li><p>变更不应损害控制措施的有效运行，以及</p></li>
<li><p>信息安全事件应遵循事件管理程序报告，并应启动响应。</p></li>
</ol>
<p>随着DevOps的演进，DevSecOps正在推动将安全性早期整合到整个软件过程中，这包括在运维层面整合不同的安全机制和工具。其目标是在整个过程中尽早自动检测和纠正安全问题。</p>
<h2 id="3-软件工程运维交付">3. 软件工程运维交付</h2>
<p>本主题介绍了软件工程运维交付（ISO/IEC/IEEE
20000-1）中一些普遍接受的流程：SLA、服务报告、服务连续性、可用性管理、IT服务的预算和核算、容量管理以及信息安全管理。</p>
<h3 id="31-运维测试验证和验收">3.1. 运维测试、验证和验收</h3>
<p>软件工程师尽早规划和执行软件验证，使用测试驱动开发(TDD)和验收测试驱动开发(ATDD)技术和工具，确保运维测试在软件开发过程中持续进行，而不仅仅在项目结束时进行。DevOps在开发和自动化软件测试服务以及集成不同工具以提高软件生产力和质量方面发挥着重要作用。（参见软件测试知识领域中的TDD和ATDD。）</p>
<h3 id="32-部署发布工程">3.2. 部署/发布工程</h3>
<p>软件运维工程师的主要职责与软件的部署和发布有关，以确保其持续性能。如[2*]中所定义，“部署是将指定版本的软件安装到给定环境（例如，将代码部署到集成测试环境或在生产环境中部署代码），而发布是指我们向所有客户或某一部分客户提供一个功能（或一组功能）（例如，我们让5%的客户群使用该功能）。”发布流程包括与发布管理相关的所有活动。</p>
<p>ISO/IEC/IEEE 12207
[3]列出了发布控制活动，并解释了需要识别暂存环境以支持应用程序新版本发布的必要性。换句话说，基本策略涉及将应用程序的新版本部署到暂存环境。基于应用程序的发布策略基于使用开关（例如，特性开关(feature
toggles)）的使用，这使得可以使用配置参数启用或禁用代码的特定部分（例如，一个功能）。</p>
<p>部署和发布由自动化技术和工具支持。金丝雀发布测试技术(canary release
testing)是服务中变更的部分和限时部署以及对该变更的评估。此评估帮助运维工程师决定是否继续进行完整部署。类似地，管理新软件安装的工具通常会观察新启动的软件一段时间，确保</p>
<p>识别并记录发布请求，识别发布中的软件系统元素，然后批准，并在指定的环境中跟踪发布。</p>
<p>DevOps
倡导在同一团队中集成开发和运维，以提高软件工程运维效率(efficiency)。在传统软件过程中，当应用程序准备好部署时，它从开发团队转移到负责部署的运维团队，这主要是手动完成的。这导致从时间和质量角度来看效率都很低的过程。为了提高部署过程的效率，DevOps
要求自动化不同的部署步骤，包括打包代码、生成配置文件、重启服务器、配置服务器和数据库、在不同服务器上安装软件、启动应用程序执行以及执行冒烟测试(smoke
testing)。</p>
<p>可以使用不同的发布工程策略来降低与软件发布相关的风险。这些策略可以分为两大类：基于环境的发布策略和基于应用的发布策略。基于环境的发布策略使用软件不会崩溃或出现其他异常行为。同样的技术对于观察最近的更改也很有用；如果它们没有通过验证期，可以自动回滚。软件配置管理(Software
Configuration
Management)知识领域提供了有关发布过程的更多信息。一旦应用平台在目标生产环境中部署，使其对用户可用(发布它)的决定就成为一项业务决策。</p>
<h2 id="33-回滚和数据迁移">3.3. 回滚和数据迁移</h2>
<p><strong>回滚(Rollback)</strong>和<strong>数据迁移(data
migration)</strong>是用来描述将软件及其数据库返回到正常工作状态的过程的术语。软件工程师确保当软件的新版本及其数据库被修改并部署到生产环境时，如果新版本在生产中导致缺陷或产品降级，可以轻松快速地回滚。这意味着在软件的新版本部署到生产环境之前，要进行计划好的和预演过的回滚。DevOps
流程自动化了这个过程以使其更快；事实上，自动化监控可以触发回滚和数据迁移到之前的状态，速度快到最终用户不会注意到出现了问题。这两种发布策略类别(在第3.2节中描述)——基于环境的发布和基于应用的发布——都可以用来支持回滚。</p>
<h2 id="34-问题解决">3.4. 问题解决</h2>
<p>这个运维过程的目标是通过识别和分析软件和系统事件及问题的原因，最大限度地减少对业务的干扰。这种方法可能需要多学科团队的参与，其软件工程师和运维工程师调查，例如，可能在软件基础设施和系统组件中有根本原因的反复出现的生产问题。这可能需要监控、记录和分析软件及其基础设施行为。</p>
<h2 id="4-软件工程运维控制">4. 软件工程运维控制</h2>
<p>本主题介绍了软件工程运维控制中一些普遍接受的技术。</p>
<h2 id="41-事件管理">4.1. 事件管理</h2>
<p>事件管理是记录、优先级排序和评估业务影响、解决、升级和关闭软件事件的过程。现代
DevOps
方法使用警报和日志自动化软件监控，以防止小事件变成大事件。当事件发生时，必须进行适当的分析和/或事后分析(post
mortems)，以找到事件的根源，并且必须实施适当的解决方案以防止将来再次发生类似事件。</p>
<h2 id="42-变更管理">4.2. 变更管理</h2>
<p>所有变更请求都以受控的方式记录、分类和审查。所有变更请求都被记录并分类(例如，紧急、urgent、重大和次要)。此过程评估变更的风险以及在失败情况下回滚策略的需求。大型系统可能需要与产品经理和最终用户一起规划变更计划。</p>
<p>而在传统的软件交付过程(或软件生命周期模型)中，所有变更都作为新软件发布的一部分交付(包含与应用程序或系统不同方面相关的多个变更)，在固定的时间间隔(例如，每三个月)发布，DevOps
旨在按需交付小的变更单元(单个新功能或服务，或缺陷修复，而不是包含多个变更的应用程序新版本)，并且彼此独立。为此，软件应用程序(或服务)必须架构为支持小型、独立的软件部署。</p>
<h2 id="43-监控测量跟踪和审查">4.3. 监控、测量、跟踪和审查</h2>
<p>软件工程运维活动监控容量、连续性和可用性。在 DevOps
思维方式中，希望不应该是一种策略；相反，工程师应该通过证据了解系统质量和运维健康状况，例如以下关键绩效指标(KPI)，这些指标实时提供给利益相关者：</p>
<p>• 生产系统的监控和产品遥测(telemetry)， •
发布到生产环境前后的可操作验证和确认结果， • 最终用户活动和资源使用， •
影响分析结果， • 系统运行所需的相互关联和内部关联依赖关系， •
与配置更改无关的配置更改</p>
<p>经过批准的部署任务，以及</p>
<p>此运维流程确保所有变更都经过评估、批准、实施。</p>
<ul>
<li>安全性和韧性性能能力</li>
</ul>
<p>6-12 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<h2 id="44-运维支持-1-c6-c14s5">4.4. 运维支持 [1, c6, c14s5]</h2>
<h3 id="51-事件和问题预防-2-c7">5.1. 事件和问题预防 [2*, c7]</h3>
<p>ISO/IEC/IEEE 12207 [3]、ISO/IEC/IEEE 20000-1 [1] 和 ISO/IEC/IEEE
32675 [4]
确定了支持运维流程的主要软件工程运维活动——在预期环境中运行软件产品的活动——以及为软件产品客户提供支持的主要活动。运维支持活动在项目规划阶段启动，然后执行，这通常需要技术和工具来主动监控产品和服务并快速响应事件和意外情况。支持活动通常在
SLA(服务级别协议)中描述。</p>
<p>整体运维流程需要尽可能自动化，以预防事件和问题，并且自动化测试需要在整个流程中集成。此外，应该实施产品遥测(telemetry)并采用适当的分析技术，以尽早检测问题从而预防事件。为此，必须收集和分析产品堆栈所有层(包括应用层、操作系统层和基础设施层)收集的数据。使用产品遥测不仅允许工程师检测潜在问题，还为识别问题根源提供了基础。</p>
<h2 id="45-服务报告-1c6s62">4.5. 服务报告 [1,c6s6.2]</h2>
<h3 id="52-运维风险管理-3-c6s64123c4">5.2. 运维风险管理 [3,
c6s6.4.12.3c4]</h3>
<p>服务报告旨在为决策提供商定的、及时的、可靠的和准确的信息。每个服务报告都有助于展示运维服务的执行情况以及是否满足某些既定和商定的最终用户目标。典型的服务报告涉及针对服务级别目标的性能，以及安全漏洞、交易量和资源使用、事件和故障、趋势信息和满意度分析。运维工程师需要建立用于测量的自动化系统和工具，以执行以下操作:</p>
<p>运维工程师必须管理许多风险。IEEE 2675 [4]
将持续风险管理定义为一个可以自动化的持续过程，用于持续监控可能影响软件可用性、可扩展性和安全性的运维风险。运维工程师可以采取措施自动化警报。为了决定哪些事件将触发警报，他们需要与产品负责人和软件工程师沟通，以建立商定的风险容忍度水平。其他视角是选择适合给定服务风险概况的部署流程以及暴露私有数据的风险。</p>
<ul>
<li>确定测量是否已经可用，或者是否需要额外的仪器来收集、分析和报告</li>
<li>选择或开发一个框架和工具，以便协调用于分析、报告和控制的测量收集</li>
</ul>
<h2 id="5-实践考虑">5. 实践考虑</h2>
<h3 id="53-软件工程运维自动化-2-c8">5.3. 软件工程运维自动化 [2*, c8]</h3>
<p>本主题介绍了软件工程运维的实践考虑。</p>
<p>自动化在现代软件运维中发挥着重要作用。软件工程师在结合应用和运维自动化时取得最佳结果。尽管自动化主要关注管理系统或基础设施的生命周期(例如，用户账户创建、环境和服务器配置、运行时</p>
<p>[SOFTWARE ENGINEERING OPERATIONS] 6-13</p>
<p>配置变更)，但在其他用例中也很有用，在这些用例中，可以开发服务来帮助软件工程师在开发过程中部署、测试和调试。运维自动化的趋势旨在降低复杂性，加速基础设施配置，向开发人员提供运维服务脚本，定义应用程序，自动化部署和测试工作流。</p>
<p><em>持续交付</em>(CD)是一种软件工程实践，它使用自动化工具频繁发布新系统(包括软件)到暂存或各种测试环境。CD
持续将最新代码和配置从主干组装成发布候选版本。</p>
<p><em>持续测试</em>是一种软件测试实践，涉及在软件开发生命周期的每个阶段测试软件。持续测试旨在通过早期和频繁的测试来评估
CD 流程每一步的软件质量。持续测试涉及各种利益相关者，如开发人员、DevOps
人员、QA 和最终用户。</p>
<h3 id="54-小型组织的软件工程运维">5.4. 小型组织的软件工程运维</h3>
<p><em>持续部署</em>(也称为
CD)是一个自动化流程，通过验证预期功能和验证来将变更部署到生产环境，以降低风险。Jez
Humble 和 David Farley [8]
指出”对任何软件工作最大的风险是你最终构建了一些无用的东西。越早、越频繁地将可工作的软件展示给真实用户，你就能越快获得</p>
<p>非常小的组织(最多 25
人的组织)难以应用由大型组织为大型组织开发的标准，因为这些要求可能会超出小型组织的能力。这就是
ISO/IEC 29110
系列标准有用的地方，因为它提供了适应非常小的组织的标准和指南，以确保其软件工程运维的质量
[7]。软件工程师应该意识到，运维流程可以适应小型组织。</p>
<h1 id="软件工程运维-1">软件工程运维</h1>
<p>ISO/IEC CD 29110-5-5 的反馈，以了解它的实际价值。</p>
<h2 id="6-软件工程运维工具">6. 软件工程运维工具</h2>
<p>本主题涵盖在软件工程运维中特别重要的工具，旨在最大化人员的高效使用。自动化开发、维护和运维相关任务可以节省工程资源并提高质量和周转时间。当适当实施时，这些自动化任务通常比软件工程师和运维工程师手动尝试完成时更快、更容易、更可靠。DevOps
支持这种自动化，用于集成、构建、打包、配置和部署可靠且安全的系统。它结合了开发、维护和运维资源及流程，以执行持续集成、交付、测试和部署。</p>
<h3 id="61-容器和虚拟化">6.1. 容器和虚拟化</h3>
<p><strong>[1, c5s5g][2*, c12]</strong></p>
<p>不同的容器/虚拟化技术和管理工具（也称为编排器(orchestrators)）可供运维工程师使用，以提高应用程序的可扩展性并标准化跨多个计算机和服务器供应商的软件部署。[4,
c6s6.4.12]
运维工程师利用他们对每个项目规模和复杂性的了解，确定灵活性、安全性和监控的最佳工具。</p>
<h3 id="62-部署-2-c12">6.2. 部署 [2*, c12]</h3>
<p>不同的技术和工具可用于管理不同环境中的软件部署。[4, c5s5.1]
此外，通常会组合使用不同的工具来覆盖软件部署的不同阶段和方面，从使用描述符文件指定部署和配置，到自动化部署和管理生产环境资源。</p>
<p>6-14 [<em>SWEBOK</em>][<em>®</em>][GUIDE V4.0a]</p>
<h3 id="63-自动化测试-2-c10">6.3. 自动化测试 [2*, c10]</h3>
<p>为了向开发人员提供快速和持续的反馈，必须在整个软件交付过程中尽可能自动化测试，包括整个开发和运维过程。为此，必须定义涵盖不同类型测试（单元测试、集成测试、系统测试、用户验收测试）的测试策略，并且必须选择支持和自动化不同测试阶段的工具。测试自动化对于向开发代码的软件工程师提供持续反馈至关重要，从而提高软件质量。</p>
<h3 id="64-监控和遥测-2-c14-15">6.4. 监控和遥测 [2*, c14-15]</h3>
<p>监控和遥测是软件工程运维的关键方面。它们在软件系统的所有层（包括应用程序、操作系统和服务器）收集数据，并提取可用于分析和监控系统不同方面的信息，以检测问题并跟踪各种属性的演变。James
Turnbull [9]
描述了许多技术组织中工程运维使用的通用监控框架架构。实施监控解决方案需要结合不同的技术和工具在不同层收集数据。这包括应用程序级别的日志、操作系统级别的执行跟踪以及服务器级别的资源使用信息（如
CPU
和内存使用）。然后，基于收集的数据，可以使用不同的分析技术（例如，统计分析和机器学习技术）来提取相关信息。最后，可以使用仪表板来可视化提取的信息；可以开发不同的仪表板向不同的利益相关者显示相关信息。</p>
<h2 id="主题与参考资料矩阵">主题与参考资料矩阵</h2>
<table>
<colgroup>
<col style="width: 20%"/>
<col style="width: 20%"/>
<col style="width: 20%"/>
<col style="width: 20%"/>
<col style="width: 20%"/>
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>ISO 20000-1</strong></th>
<th><strong>The DevOps Handbook [2*]</strong></th>
<th><strong>[1]</strong></th>
<th><strong>ISO 12207 [3]</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 软件工程运维基础</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.1. 软件工程运维的定义</em></td>
<td></td>
<td>c3s3.3</td>
<td>c6s6.4.12</td>
<td></td>
</tr>
<tr>
<td><em>1.2. 软件工程运维过程</em></td>
<td>s1</td>
<td></td>
<td>c6s6.4.12</td>
<td></td>
</tr>
<tr>
<td><em>1.3. 软件安装</em></td>
<td></td>
<td>c3, c6s6.2</td>
<td>c3s3.1</td>
<td></td>
</tr>
<tr>
<td><em>1.4. 脚本和自动化</em></td>
<td></td>
<td>c9</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.5. 有效的测试和故障排除</em></td>
<td></td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.6. 性能、可靠性和负载均衡</em></td>
<td></td>
<td>c6s6.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2. 软件工程运维规划</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.1. 运维计划和供应商管理</em></td>
<td>c4s4.1</td>
<td></td>
<td>c6s6.1</td>
<td></td>
</tr>
<tr>
<td><em>2.2. 开发和运维环境</em></td>
<td></td>
<td>c9</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.3. 软件可用性、连续性和服务级别</em></td>
<td></td>
<td>c6s6.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.4. 软件容量管理</em></td>
<td>c6s6.5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.5. 软件备份、灾难恢复和故障转移</em></td>
<td></td>
<td>c6s6.3.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.6. 软件和数据安全、安全性、完整性、保护和控制</em></td>
<td></td>
<td>c6s6.6</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3. 软件工程运维交付</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.1. 运维测试、验证和验收</em></td>
<td></td>
<td>c10</td>
<td>c6s6.3.5.3d</td>
<td></td>
</tr>
<tr>
<td><em>3.2. 部署/发布工程</em></td>
<td></td>
<td>c12</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.3. 回滚和数据迁移</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.4. 变更管理</em></td>
<td></td>
<td>c9s9.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.5. 问题管理</em></td>
<td>c8s8.3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>4. 软件工程运维控制</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.1. 事件管理</em></td>
<td>c8s8.2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.2. 监控、测量、跟踪和审查</em></td>
<td></td>
<td>c14-15</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.3. 运维支持</em></td>
<td></td>
<td>c6, c14s5</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.4. 运维服务报告</em></td>
<td></td>
<td>c6s6.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>5. 实践考虑</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.1. 事件和问题预防</em></td>
<td></td>
<td>c7</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.2. 运维风险管理</em></td>
<td></td>
<td>c6s6.4.12.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.3. 软件工程运维自动化</em></td>
<td></td>
<td>c8</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.4. 小型组织的软件工程运维</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>6. 软件工程运维工具</strong></td>
<td>c5s5g</td>
<td>c12</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.1. 容器和虚拟化</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.2. 部署</em></td>
<td></td>
<td>c12</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.3. 自动化测试</em></td>
<td></td>
<td>c10</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.4. 监控和遥测</em></td>
<td></td>
<td>c14-15</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="参考文献-6">参考文献</h2>
<p><em>management — Part 1: Service management systems
requirements,</em> ed. IEEE, 2013.</p>
<h1 id="第七章-1">第七章</h1>
<h1 id="软件维护-2">软件维护</h1>
<p><strong>缩略词</strong></p>
<p>API 应用程序编程接口 CI 持续集成 IEC 国际电工委员会 IEEE
电气和电子工程师学会 ISO 国际标准化组织 KA 知识领域 LOC 代码行数 PR
问题报告 MR 修改请求 SCM 软件配置管理 SEE 软件工程环境 SLI 服务级别指标
SLA 服务级别协议 SLO 服务级别目标 SQA 软件质量保证 XaaS 万物即服务
V&amp;V 验证与确认</p>
<h2 id="引言-4">引言</h2>
<p>成功的软件开发工作会产生满足用户需求的软件产品。随着这些需求和其他因素的变化,软件产品必须演进:一旦软件投入运行,就会发现缺陷,运行环境会发生变化,新的用户需求会不断涌现。生命周期的维护阶段在保修期后或实施后支持交付后开始,但维护活动发生得更早。</p>
<p>软件维护是软件生命周期不可分割的一部分。然而,它并没有像其他软件工程活动那样受到同等程度的关注。历史上,软件开发比软件维护更受关注。随着组织努力通过确保持续开发、维护和运行来优化其软件工程投资,这种情况正在发生变化,逐步消除这些领域之间的组织隔阂。DevOps实践和工具的日益普及进一步引起了人们对在确保软件平稳运行的同时持续演进软件的需求的关注,以满足比过去要求更快周转时间的用户。</p>
<p>在本《SWEBOK指南》中,软件维护被定义为为运行中的软件提供经济有效支持所需的全部活动。支持软件运行和维护的活动在交付前阶段和交付后阶段执行。交付前活动包括规划交付后运行、可维护性以及确定过渡从开发到维护所需的后勤支持。交付后活动包括软件监控、修改、培训以及操作或与帮助台对接。</p>
<p>软件维护知识领域(KA)与软件工程的所有其他方面相关。因此,本KA描述与《指南》中的所有其他软件工程KA都有关联。</p>
<h2 id="软件维护主题分解">软件维护主题分解</h2>
<p>软件维护KA的主题分解如图7.1所示。</p>
<figure>
<img alt="图7.1. 软件维护KA的主题分解" src="media/image-001.png"/>
<figcaption aria-hidden="true">图7.1. 软件维护KA的主题分解</figcaption>
</figure>
<p><strong>图7.1 主题结构包括:</strong> - 软件维护基础 - 定义和术语 -
软件维护的必要性 - 软件维护的演进 - 软件维护的类别 -
软件维护中的关键问题 - 技术问题 - 管理问题 - 软件维护成本 - 软件维护测量
- 软件维护过程 - 维护活动和任务 - 软件维护过程 - 软件维护技术 - 程序理解
- 软件重构 - 逆向工程 - CI/CD、测试和部署 - 软件维护工具</p>
<h3 id="1-软件维护基础">1. 软件维护基础</h3>
<p>本节介绍构成理解软件维护作用和范围基础的概念和术语。这些概念包括不同的类别,国际标准还强调在软件最终交付之前执行某些维护活动(交付前活动)的重要性。软件维护与软件开发和软件运行共享知识和工具,也有自己的过程和技术。</p>
<p><strong>1.2. 软件维护的性质</strong> [2*, c1s1.3]</p>
<p>软件维护维持软件</p>
<h1 id="软件维护的一系列定义这些定义对于理解这一知识领域至关重要">软件维护的一系列定义，这些定义对于理解这一知识领域至关重要。</h1>
<p>在软件产品的整个生命周期（从开发到运营，直至最终退役）中对软件进行监控。软件需要监控其容量、连续性和可用性。</p>
<h2 id="11-定义和术语">1.1. 定义和术语</h2>
<p>修改请求（MRs）和事件或问题报告（PRs）被记录和跟踪，确定提议变更的影响，修改代码和其他软件制品，进行测试，并将新版本的软件产品发布到运营环境中。此外，还为用户提供培训和日常持续支持。</p>
<p>软件维护的目的在国际软件维护标准ISO/IEC/IEEE
14764中有明确定义。在软件工程的背景下，软件维护本质上是众多技术过程之一。软件维护的目标是在保持其完整性的同时修改现有软件。</p>
<p><strong>软件维护人员</strong>被定义为执行软件维护活动的角色或组织。在本知识领域中，该术语有时指执行这些活动的个人，以将他们的角色与软件开发人员的角色区分开来。</p>
<p>维护人员可以从开发人员和操作人员对软件的了解中学习。与开发人员的早期接触和维护人员的早期参与可以降低整体维护成本和工作量。当维护人员在最初的开发人员离开或不再可用后加入项目时，会产生额外的挑战。</p>
<p>维护人员必须理解并使用开发过程中产生的软件制品（例如代码、测试或文档），立即支持它们，并随着时间的推移逐步演进和维护它们。</p>
<h2 id="13-软件维护的必要性">1.3. 软件维护的必要性</h2>
<p>软件维护是必要的，以确保软件在其整个生命周期内继续满足用户需求。无论使用何种软件生命周期模型（例如瀑布模型或敏捷模型）来开发软件，维护都是必要的。软件产品会因纠正性和非纠正性操作而发生变化。软件维护通常用于执行以下操作：</p>
<ul>
<li>纠正故障和潜在缺陷</li>
<li>改进运营软件的设计或性能</li>
<li>实现增强功能</li>
<li>帮助用户理解软件的功能</li>
<li>适应接口系统或基础设施的变化</li>
<li>防止安全威胁</li>
<li>修复系统或软件元素的技术过时问题</li>
<li>退役软件</li>
</ul>
<h2 id="14-维护成本占大部分">1.4. 维护成本占大部分</h2>
<p>人们普遍认为，错误修复的相对成本在软件生命周期的后期阶段会增加。维护也使用了软件整个生命周期中大部分财务资源。人们对软件维护的普遍看法是它仅仅修复故障。然而，多年来的研究和调查表明，大多数软件维护——超过80%——用于增强和调整软件。在管理报告中将增强和更正归为一类，导致了更正成本高于实际成本的误解。了解软件维护的类别有助于我们理解软件维护成本的结构——也就是说，大部分支出流向了哪里。此外，了解影响软件可维护性的因素可以帮助组织控制成本。影响软件维护成本的环境因素包括：</p>
<ul>
<li>运营环境（硬件和软件）</li>
<li>组织环境（政策、竞争、流程、产品和人员）</li>
</ul>
<h2 id="15-软件的演进">1.5. 软件的演进</h2>
<p>软件维护作为支持软件演进的活动最早在20世纪60年代末被提出。Lehman等人在二十年间的研究导致了软件演进八大定律的形成：</p>
<ul>
<li><strong>持续变化</strong> ——
软件必须持续适应，否则会逐渐变得不令人满意。</li>
<li><strong>复杂性增加</strong> ——
随着软件的演进，其复杂性会增加，除非采取措施来维持或降低该复杂性。</li>
<li><strong>自我调节</strong> ——
程序演进过程是自我调节的，产品和过程属性的度量值接近正态分布。</li>
<li><strong>不变的工作速率</strong> ——
演进软件包中的平均有效全局活动速率在产品的生命周期内保持不变。</li>
<li><strong>熟悉度守恒</strong> ——
随着软件的演进，所有与之相关的人员（例如开发人员、销售人员和用户）必须保持对其内容和行为的掌握，以实现令人满意的演进。过度增长会削弱这种掌握。因此，随着系统的演进，平均增量增长保持不变。</li>
<li><strong>持续增长</strong> ——
功能内容必须持续增长以满足用户需求。</li>
</ul>
<p>程序永远不会完成并会继续演进。随着它们的演进，它们会变得更加复杂，除非采取措施来降低该复杂性。</p>
<h2 id="16-软件维护的类别">1.6. 软件维护的类别</h2>
<p>五类（类型）软件维护已被标准化以对维护请求进行分类：纠正性、预防性、适应性、添加性和完善性。ISO/IEC/IEEE
14764将这些维护类别重新归类为更正或增强。</p>
<figure>
<img alt="图7.2. 软件维护类别" src="media/image-001.png"/>
<figcaption aria-hidden="true">图7.2. 软件维护类别</figcaption>
</figure>
<p>修改请求可以分为：更正（包括纠正性和预防性）和增强（包括适应性、添加性和完善性）。</p>
<h1 id="软件维护-3">软件维护</h1>
<p>软件产品的内容必须在其生命周期内不断增加以维持用户满意度。ISO/IEC/IEEE
14764 [1] 还定义了第六类——紧急维护(emergency maintenance)：</p>
<h2 id="质量下降">质量下降</h2>
<p>除非对软件进行严格的维护并使其适应运行环境的变化，否则软件的质量将呈现下降趋势。</p>
<h2 id="反馈系统">反馈系统</h2>
<p>软件演进过程构成多级、多循环、多代理的反馈系统，必须将其作为这样的系统来对待，才能在任何合理基础上实现显著改进。</p>
<p>Lehman研究的关键发现包括：维护是演进式开发，通过理解软件随时间发生的变化可以辅助维护决策。另一种看待维护的方式是将其视为适应额外输入（或约束）的持续开发——换句话说，大型软件</p>
<ul>
<li><strong>纠正性维护(Corrective
maintenance)</strong>：交付后对软件产品执行的被动修改（或修复），用于纠正发现的问题。</li>
<li><strong>预防性维护(Preventive
maintenance)</strong>：交付后对软件产品进行的修改，用于在潜在故障在实际系统中发生之前纠正软件产品中的潜在缺陷。</li>
<li><strong>适应性维护(Adaptive
maintenance)</strong>：交付后对软件产品执行的修改，使软件产品在不断演进的环境中保持可用（例如，操作系统升级导致应用程序的变更）。</li>
<li><strong>增补性维护(Additive
maintenance)</strong>：交付后对软件产品执行的修改，用于添加功能或特性以增强产品的使用性。</li>
</ul>
<p>增补性维护与完善性维护的不同之处在于：a)
它提供额外的新功能或特性来改进软件的可用性、性能、可维护性或其他软件质量属性，b)
它通过相对较大的添加或更改来增加功能或特性，以在交付后改进软件属性。</p>
<ul>
<li><strong>完善性维护(Perfective
maintenance)</strong>：交付后对软件产品的修改，为用户提供增强功能、改进程序文档，以及重新编码以改进软件性能、可维护性或其他软件属性。</li>
<li><strong>紧急维护(Emergency
maintenance)</strong>：为临时保持系统运行而执行的非计划修改，等待纠正性维护。</li>
</ul>
<h2 id="2-软件维护的关键问题">2. 软件维护的关键问题</h2>
<p>必须处理许多关键问题以确保软件的有效维护。软件维护为软件工程师提供了独特的技术和管理挑战（例如，在他人开发的大型复杂软件中查找故障的挑战）。</p>
<p>同样，在敏捷环境中，维护人员和开发人员不断努力确保客户在每次迭代结束时看到价值，因此维护活动必须与新功能的开发竞争以获得客户认可；为未来版本做计划（通常包括在发送当前版本的紧急补丁时编写下一个版本的代码）也给平衡维护和开发工作带来了挑战。以下部分介绍与软件维护相关的技术和管理问题。它们按以下主题分组：</p>
<ul>
<li>技术问题</li>
<li>管理问题</li>
<li>软件维护成本</li>
<li>软件维护度量</li>
</ul>
<h3 id="21-技术问题">2.1. 技术问题</h3>
<h3 id="211-有限理解">2.1.1 有限理解</h3>
<p>[2*, c6s6.9]</p>
<p>有限理解(Limited
understanding)描述的是软件工程师对他人开发的软件的初步理解。这反映在软件工程师理解在哪里更改或纠正软件的速度上。研究表明，总维护工作量的很大一部分用于理解要修改的软件。因此，软件理解(software
comprehension)主题引起了软件工程师的极大关注。已经确定了许多理解因素：1)
领域知识；2) 编程实践（例如，实现问题）；3) 文档；4)
组织和呈现问题。在面向文本的表示（例如，在源代码中）中理解更加困难，如果更改没有被记录且开发人员无法解释它们，通常很难追踪软件通过其发布或版本的演进。因此，软件工程师最初可能对软件的理解有限，必须做大量工作来弥补这一点。各种技术可以帮助工程师理解现有软件，例如可视化和使用基于工具的代码图形表示的逆向工程。</p>
<h3 id="212-测试">2.1.2 测试</h3>
<p>[1, s6.2][2*, c9, c13s13.4.4]</p>
<p>测试计划和活动发生在MR和PR处理过程中。对大型软件进行完整重复测试的成本在时间和精力上都很显著。为了确保软件修改得到验证，维护人员应该通过计划和执行适当的测试来复制或验证更改——例如，回归测试在维护中很重要。回归测试是对软件或组件的选择性重测，以验证修改没有引起意外影响。另一个挑战是找到时间进行尽可能多的测试。对于同时处理不同问题的维护团队成员来说，协调测试可能具有挑战性。如果软件执行关键</p>
<ul>
<li>通过跟踪变通方法(work-around)直至移除</li>
<li>确定将向用户提供什么后续反馈</li>
</ul>
<p>软件维护人员经常使用严重性(severity)</p>
<h2 id="213-影响分析">2.1.3 影响分析</h2>
<p>[1, s5.1.6][2*, c13s13.3]</p>
<p>影响分析评估所提议的变更对现有软件的详细影响。软件工程师应尽可能高效地进行分析。维护人员需要详细了解软件的结构和内容。他们利用这些知识进行影响分析,识别所有会受到软件变更请求影响的系统和软件产品,并估算完成变更所需的资源。分析还确定进行变更所涉及的风险。变更请求(源自MR或PR)必须首先被分析并转换为软件术语。影响分析在变更请求进入软件配置管理(SCM)流程后执行。ISO/IEC/IEEE
14764 [1]指出影响分析任务执行以下工作:</p>
<p>• 为MR/PR开发识别方案。 • 开发MR/PR的分类和优先级方案。 •
确定操作员提交MR/PR的程序。 •
识别必须跟踪并报告给用户的信息需求和问题,并确定能够对这些信息需求和问题提供反馈的度量指标。
• 确定如何向操作员提供临时解决方案(work-around)。</p>
<p>维护人员使用PR作为决定如何以及何时修复问题的指南。维护人员进行影响分析,识别受影响的组件,开发几个潜在解决方案,并最终推荐行动方案。</p>
<p>所提议的维护变更的影响分析通常考虑各种因素,如维护类别、修改规模、涉及的成本、进行修改所需的测试,以及对性能、安全和安保的任何影响。在设计软件时考虑可维护性将大大有助于影响分析。更多信息可在软件配置管理知识领域中找到。</p>
<h2 id="214-可维护性">2.1.4 可维护性</h2>
<p>[1, s8.8][2*, c12s12.5.5]</p>
<p>ISO/IEC/IEEE 14764
[1]将可维护性定义为软件产品可被修改的能力。修改可以包括纠正、改进或使软件适应环境变化,以及需求和功能规范的变化。</p>
<p>作为一个重要的软件质量特性,可维护性应在软件开发活动期间被指定、审查和控制,以降低维护成本。当这些活动成功实施时,软件的可维护性将受益。可维护性通常难以实现,因为它往往不是软件开发期间的主要关注点。开发人员通常更专注于其他活动,可能没有对可维护性需求给予足够的关注。这可能导致糟糕的架构、缺失的软件文档或测试环境,这是程序理解和后续维护期间影响分析困难的主要原因。系统化和成熟的软件开发过程、技术和工具的存在有助于增强软件的可维护性。软件质量知识领域提供了关于软件可维护性的更多信息和参考。</p>
<p>受损的软件可维护性通常会增加未来维护软件的软件工程师的负担;换句话说,它会产生技术债务(technical
debt)。当快速处理纠正性、紧急性和添加性维护任务的需要,受限于有限的时间和对软件的理解,导致妥协时,技术债务往往会积累。这些即时但可能考虑不足的解决方案,通常未经同行评审,会导致技术债务的积累。这种做法通常会产生技术债务,需要在维护期间花费额外的时间和精力来解决。具体而言,软件工程师在处理技术债务时必须深入研究三个领域:</p>
<ol type="1">
<li>代码质量与相关性:并非所有技术债务都是紧急的。</li>
<li>与组织目标的一致性:软件架构应反映组织的目标。</li>
<li>流程损失:确保涉及的软件工程师具有互补技能。</li>
</ol>
<p>软件工程、测试知识领域提供了关于软件测试及其回归测试子主题的更多信息和参考。</p>
<h2 id="215-软件维护经济学">2.1.5 软件维护经济学</h2>
<p>软件维护可能由纠正软件缺陷并使其在需要的时间内保持运行的需要驱动。此外,它可能由满足用户对软件更新和增强的需求所驱动。</p>
<p>在这两种情况下,软件维护的经济性不如软件开发的经济性那么明显。在组织层面,它可能被视为一项消耗大量资源但对组织没有明确、可量化收益的活动。因此,添加新功能通常比其他维护活动(如重构、安全或性能改进)获得更高的优先级,以满足软件客户的目标和目的,以及时间和预算等约束。然而,这些组织目标和约束必须与软件可维护性和工程标准相平衡,以避免代码退化和技术债务。</p>
<p>将产品管理方法应用于软件开发和维护的管理可以帮助组织:</p>
<p>• 理解运营软件在其整个生命周期内的总成本。 •
比较开发新软件与增强现有软件的成本和收益。 •
解决人员配备和技能问题,因为同一团队可以负责维护和开发。</p>
<h2 id="22-管理问题">2.2. 管理问题</h2>
<h3 id="221-与组织目标的一致性">2.2.1. 与组织目标的一致性</h3>
<p>[1, s9.1.8][2*, c2s2.3.1.2, c3s3.4]</p>
<p>本节描述如何优化软件维护活动和经济效益，使其与组织目标以及业务、客户和用户的优先级保持一致。</p>
<p>在许多组织中，初始软件开发是基于项目的，具有明确的时间表和预算。主要目标是按时在预算内交付满足用户需求的产品。相比之下，软件维护旨在延长软件的生命周期。</p>
<ul>
<li>从一开始就更加关注可维护性需求，因为同一团队同时负责开发和维护。</li>
</ul>
<h3 id="222-人员配置">2.2.2. 人员配置</h3>
<p>[1*, s6.4.13.3c][2*, c2s2.3.1.5, c10s10.4]</p>
<p>尽管维护工作有时被认为不太吸引人，但这种观点忽视了软件维护人员的关键重要性。鉴于维护构成了软件生命周期活动的重要部分，认可和重视维护人员的贡献对于提升士气、性能和减少员工流失至关重要。</p>
<p>组织需要仔细设计开发和维护团队及角色，并为员工提供专业发展机会。</p>
<h3 id="223-流程">2.2.3. 流程</h3>
<p>[1*, s6][2*, c5]</p>
<p>软件生命周期流程是一组活动、方法、实践和转换，人们用它来开发和维护软件及其相关产品。在流程层面，软件维护活动与软件开发有很多共同之处(例如，SCM(软件配置管理)在两者中都是关键活动)。维护还需要一些软件开发中没有的活动。(参见第3.2节。)</p>
<h3 id="224-供应商管理">2.2.4. 供应商管理</h3>
<p>[1*, s6.1.2, s8.3, s8.8.2]</p>
<p>供应商管理确保组织的供应商及其绩效得到适当管理，以支持在将维护外包给供应商时无缝提供高质量的产品和服务。组织与供应商关系的性质及其供应商管理方法应由这些产品和服务的性质决定。可以聘请承包商来执行维护任务，外包或离岸软件维护是一个主要产业。外包维护意味着用外部供应商的能力替代内部能力。外包维护的方法包括以下几种：</p>
<ul>
<li>单一来源或合作伙伴关系：单一供应商提供所有服务，或者外部服务集成商管理组织与所有供应商的关系。</li>
<li>多源外包(Multi-sourcing)：产品和服务由多个独立供应商提供。这些被整合成单一的(软件支持的)服务。软件服务中的多源外包越来越普遍，这得益于”一切即服务”(XaaS)的增长、应用程序编程接口(API)和数据源。</li>
</ul>
<p>许多组织外包整个软件组合。通常，这些组合包括非关键任务的软件，因为组织不想失去对其核心业务中使用的软件的控制。外包商面临的一个主要挑战是确定所需维护服务的范围、服务级别协议(SLA)的条款以及合同细节。外包商需要投资于良好的通信基础设施和高效的帮助台，配备能够与客户和用户有效沟通的人员[3]。外包需要大量的初始投资以及需要自动化的软件维护流程的设置和审查。</p>
<h3 id="225-维护的组织方面">2.2.5. 维护的组织方面</h3>
<p>[1, s9.1.8][2*, c10]</p>
<p>维护的组织方面包括确定哪些团队将负责软件维护。当使用敏捷生命周期模型时，开发人员也执行维护任务，同时充当开发人员和维护人员。其他组织更倾向于开发软件的团队不一定在软件投入运营后维护它。在决定软件维护功能的位置时，软件工程组织必须考虑每种替代方案的优缺点。让开发人员在软件投入生产后也维护软件有许多缺点，例如当开发人员需要处理故障时新开发将被中断的风险，以及当开发人员离开组织时可能失去知识的风险，因为熟悉软件的人较少；这也可能导致文档质量降低，因为参与的人较少。</p>
<p>然而，设立独立的维护职能也有其挑战，因为许多软件工程师不喜欢将工作限制在维护上，可能更有可能离开去做更有趣的工作。此外，必须在开发人员和维护人员之间建立交接流程，这有时会导致团队之间的摩擦[3]。</p>
<p>产品管理流程的引入鼓励了单一团队方法，特别是对于需要快速响应客户和用户需求变化的软件的开发和维护。</p>
<p>软件产品需要通过添加新特性和功能来演进，其代码库必须保持可维护性，易于理解和进一步演进。解决技术债务(technical
debt)的一个常见障碍——或者说，白空格、消除语言弱点和依赖编译器的构造、促进错误跟踪、确保代码到设计的可追溯性、进行检查和代码审查。</p>
<p>由于每个选项都有许多优缺点，因此应该逐案做出决策。重要的是组织将维护任务委派给经验丰富的团队或个人，并对维护任务和所有软件更改保持高质量的文档记录，无论组织结构如何。</p>
<p>实施任何潜在增强的不确定回报。这就是为什么组织确定以下内容如此重要：</p>
<ul>
<li>当前软件的质量</li>
<li>技术债务的程度</li>
<li>投资于质量增强的潜在节省</li>
<li>当前质量问题对业务的影响</li>
</ul>
<h2 id="23-软件维护成本">2.3. 软件维护成本</h2>
<p>软件工程师必须理解1.6中描述的软件维护的不同类别。按维护类别展示成本趋势可以向客户展示每个支持系统的维护工作分配情况。按类别划分的维护工作数据也可用于准确估算软件维护成本。成本估算是规划软件维护的一个重要方面。</p>
<p>此外，技术债务只是导致过多计划外工作的几个因素之一；团队或流程问题也可能需要理解和解决。现代工具可以帮助检测此类问题，这意味着技术债务不应孤立处理，而应通过检查其根本原因来处理。</p>
<h3 id="231-技术债务成本估算">2.3.1. 技术债务成本估算</h3>
<p>技术债务通常使代码的维护成本高于必要水平。技术债务代表当应用程序由开发团队首次发布时，修复代码中遗留问题所需的工作量。一些技术和指标可以帮助工程师衡量技术债务，包括规模、复杂性以及源代码中工程缺陷和违反良好架构设计和编码实践的数量。ISO/IEC/IEEE
14764提供了改进可维护性的建议，包括：确保可读性、追求结构化代码、降低代码复杂性、提供准确的代码注释、使用缩进和</p>
<h3 id="232-维护成本估算">2.3.2. 维护成本估算</h3>
<p>软件维护成本的估算应在软件规划过程的早期准备。成本应该是维护活动范围的函数。ISO/IEC/IEEE
14764识别了应包括的各种因素，例如以下内容：</p>
<ul>
<li>前往用户所在地的差旅费</li>
<li>维护人员和用户的培训</li>
<li>软件工程环境(SEE)和软件测试的成本和年度维护费用</li>
<li>人员成本（例如，工资、福利）</li>
<li>其他资源成本，如耗材</li>
<li>软件许可证维护成本</li>
</ul>
<p>对一个组件的更改对其他组件的影响最小。</p>
<ul>
<li><p>可重用性衡量组件被重用的程度</p></li>
<li><p>可分析性衡量维护人员为诊断缺陷或故障原因或识别要修改的组件而必须花费的工作量或资源</p></li>
<li><p>可修改性衡量维护人员在实施指定修改而不引入缺陷或降低现有产品质量时的工作量</p></li>
<li><p>可测试性衡量维护人员和用户测试修改后软件所花费的工作量</p></li>
<li><p>可支持性衡量为软件提供支持的难易程度，包括文档、工具和协助解决问题的可用性和可访问性，促进有效的维护和故障排除</p></li>
<li><p>项目变更、项目管理</p></li>
<li><p>现场服务工程师</p></li>
<li><p>维护设施租赁</p></li>
</ul>
<p>此外，随着维护和开发工作的进展，估算应进行修正。历史测量数据应作为估算维护成本的输入。此外，在单个MR或PR的影响分析期间也需要成本估算。应描述成本估算方法（例如，参数模型、与类似系统的比较、使用经验和历史数据）。单个MR或PR的估算通常包括与执行变更相关的估计工作量、资源估算和实施变更的估计时间表。</p>
<h2 id="24-软件维护度量">2.4. 软件维护度量</h2>
<p>可度量的软件维护工件包括维护过程、资源和产品。度量包括规模、复杂性、质量、可理解性、可维护性和工作量。一个有用的度量是用于纠正性、预防性、适应性、增量性和完善性维护的工作量（以资源计）。</p>
<p>软件的复杂性和技术债务度量也可以使用可用工具获得。这些度量构成了软件质量度量的良好起点。维护人员应根据特定组织的需求确定哪些度量适合该组织。软件度量程序在软件工程管理知识领域中讨论。</p>
<p>软件维护人员使用的其他度量包括以下内容：</p>
<ul>
<li>可靠性：系统或软件在指定条件下在指定时间内执行特定功能的程度，包括以下特征：
<ul>
<li>成熟度：系统或软件能够满足可靠性需求的程度</li>
<li>可用性：系统或软件是否可操作和可访问</li>
<li>容错性：系统或软件尽管存在硬件或</li>
</ul></li>
</ul>
<p>软件质量模型在软件故障中进行了描述。</p>
<p>软件质量知识领域描述了软件的可恢复性(Recoverability)：系统或产品以及特定于软件维护的过程度量。可维护性的可度量特征包括以下内容：</p>
<p>• 软件规模（例如，功能规模、代码行数）。 •
按时间段统计的维护请求数量。</p>
<p>软件维护 7-11</p>
<p><strong>软件维护过程</strong></p>
<p>[运行] [处置]</p>
<p>[准备维护] [执行维护]</p>
<p>[开发] [后勤支持] [维护转换] [支持] [执行] [管理结果和后勤]</p>
<p><strong>图7.3.</strong> 软件维护过程（ISO/IEC/IEEE 14764）[1]</p>
<p>• 每个维护请求的工作量。 •
软件特征（例如，平台、硬件、编程语言、框架）。</p>
<p>可以按类别收集、分析和跟踪维护度量，以促进改进并深入了解维护成本的支出情况。针对不同应用按类别列出的软件维护工作量程度，对用户及其组织来说是有价值的业务信息。它还可以使组织对软件维护概况进行内部比较[7]。</p>
<p><strong>3. 软件维护过程</strong></p>
<p>除了ISO/IEC/IEEE 14764
[1]中描述的标准软件工程过程和活动外，还有许多维护人员特有的活动（参见第3.2节）。</p>
<p><em>3.1. 软件维护过程</em> [1, s5.2][2*, c5]</p>
<p>维护过程提供所需的活动以及这些活动的详细输入和输出，如ISO/IEC/IEEE
14764 [1]所述。维护是ISO/IEC/IEEE 12207
[10]中介绍的技术生命周期过程之一。图7.3展示了维护过程如何连接到其他软件工程过程，这些过程相互作用以支持运行中的软件。软件维护过程包括以下内容：</p>
<p>• 准备维护。 • 执行维护。 • 执行后勤支持。 •
管理维护和后勤的结果。</p>
<p>最近，提倡轻量级过程的敏捷方法论(Agile
methodologies)也被应用于维护。这一需求源于对快速维护服务周转日益增长的需求。对软件维护过程的改进由软件维护成熟度模型(maturity
models)支持[3]。</p>
<p><em>3.2. 软件维护活动和任务</em> [1, s6.1][2*, c6, c7]</p>
<p>维护过程包含运行和修改现有软件系统同时保持其完整性所需的活动和任务。这些活动和任务是操作员和维护人员的责任。如前所述，许多维护活动与软件开发活动相似。维护人员执行分析、设计、编码、测试和文档编制。他们必须在活动中跟踪需求——就像在开发中一样——并在基线变更时更新文档。</p>
<p>7-12 <em>SWEBOK® GUIDE V4.0a</em></p>
<p>ISO/IEC/IEEE
14764建议，当维护人员使用开发过程时，该过程必须进行裁剪以满足特定需求。</p>
<p>然而，有许多专门用于软件维护的过程、活动和实践：</p>
<p>• 程序理解(Program
understanding)：这包括获取软件产品功能以及各部分如何协同工作的总体知识所需的活动。</p>
<p>•
转换(Transition)：这是一个受控且协调的活动序列，在此期间软件逐步从开发人员转移到运维和维护团队。</p>
<p>•
维护请求接受/拒绝：超过约定规模、工作量水平或复杂度水平的修改请求可能会被维护人员拒绝并转回给开发人员。</p>
<p>• 维护服务台(Maintenance help
desk)：服务台是一个最终用户和维护协调的支持功能，触发维护请求和事件的评估、优先级排序和成本核算。</p>
<p>• 影响分析(Impact analysis)：影响分析识别受潜在变更影响的区域。</p>
<p>•
维护服务级别指标(SLIs)、服务级别目标(SLOs)、服务级别协议(SLAs)，以及维护软件和硬件许可证和合同：这些是描述第三方服务和质量目标的合同协议。</p>
<p><em>3.2.2. 规划活动</em> [1, s6.1.3, s8.7.2][2*, c10]</p>
<p>软件维护的一个重要活动是规划，该过程必须解决与多个规划视角相关的问题，包括以下内容：</p>
<p>• 业务规划（组织级别） • 维护规划（转换级别） •
发布/版本规划（软件级别） • 维护请求规划（在单个请求级别）</p>
<p>在单个请求级别，规划在影响分析期间进行。（参见第2.1.3节，影响分析。）发布/版本规划活动要求维护人员执行以下操作：</p>
<p>• 收集各个请求的可用日期。 • 与用户就后续发布/版本的内容达成一致。 •
识别潜在冲突并制定替代方案。 •
评估给定发布的风险并制定后备计划以防出现问题。 •
通知所有利益相关者。</p>
<p>软件开发项目的典型持续时间为几个月到几年，而维护阶段通常持续到软件被处置过程退役为止。资源估算是维护规划的关键要素。软件维护计划——</p>
<h1 id="软件维护-4">软件维护</h1>
<p>ning should begin with the decision to develop</p>
<h2 id="321-支持和监控活动">3.2.1. 支持和监控活动</h2>
<p>[s6.4.13.3d5, s6.1.8][2*, c3s3.4]</p>
<p>a new software product and should consider quality objectives. A
concept document should be developed, followed by a maintenance plan,
and these should address the following:</p>
<p>维护人员还可能执行持续的支持活动，例如文档编制、软件配置管理(SCM)、验证和确认(V&amp;V)、问题解决、软件质量保证(SQA)、评审、漏洞评估和审计。另一项重要的维护结果管理活动是监控客户满意度。</p>
<p>• 软件维护范围。 • 软件维护过程和工具的调整。 • 软件维护组织的识别。
• 软件维护成本估算。</p>
<p>[SOFTWARE MAINTENANCE] 7-13</p>
<h2 id="322-软件维护计划">3.2.2. 软件维护计划</h2>
<p>应在软件开发期间准备软件维护计划，并应说明用户如何请求修改和报告问题或事项。ISO/IEC/IEEE
14764 [1]
中阐述了软件维护计划。最后，在最高管理层级，维护组织必须开展软件维护业务规划活动(例如，沟通、预算、财务和人力资源活动)。[2*,
c10]</p>
<h2 id="323-配置管理">3.2.3. 配置管理</h2>
<p>[1, s6.1.3c, s6.4.13.3d4][2*, c11s11.3]</p>
<p>ISO/IEC/IEEE 14764 [1]
将软件配置管理(SCM)描述为支持维护过程的使能系统或服务。软件配置管理程序应提供对识别、授权、实施和发布正在进行变更的软件产品及其IT资产所需的每个步骤的验证、确认和审计。</p>
<p>仅跟踪维护请求(MR)或问题报告(PR)是不够的。必须控制对软件产品及其底层基础设施所做的任何更改。通过实施和执行已批准的软件配置管理流程来建立这种控制。软件配置管理知识领域(KA)更详细地讨论了软件配置管理以及提交、评估和批准变更请求的过程。软件维护的软件配置管理与软件开发的软件配置管理不同之处在于，必须在操作环境中控制的小变更数量。</p>
<p>软件配置管理流程通过制定和遵循软件配置管理计划及操作程序来实施。维护人员参与配置控制委员会，以确定生产环境中下一个发布版本的内容。</p>
<h2 id="324-软件质量">3.2.4. 软件质量</h2>
<p>[1, s6.1.6, s8.7.2][2*, c13s13.4]</p>
<p>仅仅希望软件维护能产生更高质量的软件是不够的。维护人员应该有一个有效的质量计划。他们必须实施流程以支持软件维护流程的持续改进。必须与所有其他流程协调选择软件质量保证(SQA)、验证和确认(V&amp;V)、评审和审计的活动和技术，以达到期望的质量水平。还建议软件运维和维护调整和使用软件开发过程的输出、其技术和交付物(例如，测试工具和文档)以及测试结果。有关软件质量的更多详细信息，请参阅软件质量知识领域。</p>
<h2 id="4-软件维护技术">4. 软件维护技术</h2>
<p>本主题介绍软件维护中普遍接受的技术。</p>
<h3 id="41-程序理解">4.1. 程序理解</h3>
<p>[2*, c6, c14s14.5]</p>
<p>维护人员花费大量时间阅读和理解程序以实施变更。代码浏览器是程序理解的关键工具，用于组织和呈现源代码。清晰简洁的文档也有助于程序理解。</p>
<h3 id="42-软件再工程">4.2. 软件再工程</h3>
<p>[2*, c7]</p>
<p>软件再工程(reengineering)是指对软件进行检查和修改，以新形式重构它。它包括新形式的后续实施。通常进行再工程不是为了改善可维护性，而是为了替换老化的遗留软件。</p>
<p>重构(refactoring)是一种再工程技术，旨在在不改变程序行为的情况下重组程序。重构旨在改进内部结构和软件的可维护性。重构技术可以在维护活动期间使用，以在代码变更前后减少代码库的技术债务(technical
debt)。</p>
<p>在敏捷软件开发的背景下，持续集成(CI)的增量特性通常需要持续重构代码以增强其质量和可靠性。因此，持续重构通过提供更好的方法来减少和管理软件系统日益增长的复杂性，同时提高开发人员生产力，从而支持易变的软件生命周期。</p>
<p>7-14 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<h3 id="43-逆向工程">4.3. 逆向工程</h3>
<p>[2*, c7, c14s14.5]</p>
<p>逆向工程(reverse
engineering)是分析软件以识别其组件及其相互关系，以及创建的过程。</p>
<h3 id="44-持续集成交付测试和部署">4.4. 持续集成、交付、测试和部署</h3>
<p>[1, s6.4.13.3 Note 1]</p>
<p>自动化开发、运维和维护相关任务可以节省工程资源。如果实施得当，这些自动化任务通常比手动执行更快、更容易且更可靠。ISO/IEC/IEEE
14764 指出，自动化包括软件的分发和安装。[1, s6.4.13.3 Note
1]。DevOps支持这种自动化，同时构建、打包和部署可靠和安全的系统。DevOps结合了开发、运维和维护资源。</p>
<h1 id="软件维护-5">软件维护</h1>
<p>将软件以另一种形式或在更高抽象级别上表示的过程。逆向工程是被动的；它不改变软件或产生新软件。逆向工程工作通常生成不同软件制品的图形表示，例如从源代码生成的调用图和控制流图。逆向工程的类型包括以下几种：</p>
<p>• 重新文档化 • 设计恢复 •
数据逆向工程——从物理数据库中恢复逻辑模式</p>
<p>工具是逆向工程和相关任务（如重新文档化和设计恢复）的关键。软件可视化是一种常见的逆向工程技术，帮助维护人员探索、分析和理解软件系统的结构及其演变。软件可视化包括使用信息可视化、计算机图形学和人机交互技术对软件系统进行视觉编码和分析，包括软件维护实践、演变、结构和软件运行时行为。通常，软件可视化工具配备各种质量保证功能，例如质量指标计算、技术债务估算以及不良设计和编码实践（代码异味）检测。</p>
<p>执行CI、交付、测试和部署的过程。[9]</p>
<p>CI是一种软件工程实践，持续将制品（包括来自团队所有成员的源代码更新）合并到共享主线中，以演化和测试开发的系统。使用CI，团队成员可以频繁集成他们的更改，每次集成都可以通过自动化构建（包括测试）进行验证，以尽快检测集成错误。CI的基本目标是自动尽早捕获有问题的更改。CI有助于保证软件系统从构建到发布的各个阶段的工作状态，从而提高对软件产品的信心和质量，并提高团队的生产力。具体来说，CI通过持续构建、持续交付、持续测试和持续部署来自动化构建和发布过程。[6,
c23, c24]</p>
<p><strong>持续交付</strong>是一种软件工程实践，通过使用自动化工具，能够频繁地将新系统（包括软件）发布到暂存环境或各种测试环境。持续交付持续组装最新的代码和配置以创建候选发布版本。</p>
<p><strong>持续测试</strong>是一种软件测试实践，涉及在软件开发生命周期的每个阶段测试软件。持续测试的目标是通过早期和频繁的测试来评估持续交付过程中每一步的软件质量。持续测试涉及各种利益相关者，例如开发人员、维护人员、DevOps、SQA和运营系统团队。</p>
<p><strong>持续部署</strong>是一个自动化过程，通过验证预期功能和验证来将更改部署到生产环境以降低风险。正如Martin
Fowler在《持续交付》一书中指出的，“任何软件工作的最大风险是你最终构建了无用的东西。你越早、越频繁地让真实用户看到可工作的软件，你就能越快获得反馈以了解它的真正价值。”</p>
<h2 id="45-维护可视化">4.5. 维护可视化</h2>
<p>保持对软件系统不断演变的结构和依赖关系的清晰理解是一项挑战。可视化是软件维护管理的宝贵支持工具，它提供软件组件的可视化表示，帮助做出明智的决策。随着软件系统规模和复杂性的增加，可视化表示可以通过支持依赖性分析、跟踪软件演变历史、可视化软件运行时动态以及提供补充文档来支持软件维护。可视化代表了一个活跃的研究领域，它将计算能力与人类模式检测能力相结合。它生成旨在增强维护团队在面对复杂数据分析时认知性能的可视化表示。</p>
<h2 id="5-软件维护工具">5. 软件维护工具</h2>
<p><strong>[1, c6s4][2*, c14]</strong></p>
<p>在修改现有软件时。</p>
<p>维护工具与开发和运维工具紧密相连。它们共同构成了软件工程环境（SEE）的一部分。</p>
<p>以下是维护工具的示例：</p>
<p>• 配置管理、代码版本控制和代码审查工具 • 软件测试工具 •
软件质量评估工具（用于评估技术债务和代码质量） •
程序切片器，仅选择受更改影响的程序部分 •
静态分析器，允许对程序内容进行一般查看和汇总 •
动态分析器，允许维护人员跟踪程序的执行路径 •
数据流分析器，允许维护人员跟踪程序的所有可能数据流 •
交叉引用工具，生成程序组件的索引 •
依赖性分析器，帮助维护人员分析和理解程序组件之间的相互关系 •
远程访问工具，使维护人员能够远程诊断和修改用户系统，这对于实时问题解决和跨环境的无缝修改至关重要</p>
<p>逆向工程工具通过从现有产品向后工作来支持该过程，以创建诸如规范和设计描述之类的制品，然后可以对其进行转换以从旧产品生成新产品。维护人员还使用软件</p>
<p>本主题涵盖在软件维护中特别重要的工具，包括软件测试、SCM（软件配置管理）、软件文档和软件度量工具。</p>
<p>7-16 <em>SWEBOK® GUIDE V4.0a</em></p>
<p><strong>主题与参考资料矩阵</strong></p>
<p><strong>Grubb and Takang 2003 [2*]</strong></p>
<p><strong>1. 软件维护基础</strong></p>
<p><em>1.1. 定义和术语</em> [c1s1.2, c2s2.2] <em>1.2.
软件维护的性质</em> [c1s1.3] <em>1.3. 软件维护的需求</em> [c1s1.5]
<em>1.4. 维护成本的主要部分</em> [c4s4.3, c5s5.2] <em>1.5.
软件的演化</em> [c3s3.5] <em>1.6. 软件维护的类别</em> [c1s1.8,
c3s3.3]</p>
<p><strong>2. 软件维护中的关键问题</strong></p>
<p><em>2.1. 技术问题</em></p>
<p><em>2.1.1. 理解受限</em> [c6s6.9] <em>2.1.2. 测试</em> [c9,
c13s13.4.4] <em>2.1.3. 影响分析</em> [c13s13.3] <em>2.1.4. 可维护性</em>
[c12s12.5.5]</p>
<p><em>2.2. 管理问题</em></p>
<p><em>2.2.1. 与组织目标的一致性</em> [c2s2.3.1.2, c3s3.4] <em>2.2.2.
人员配备</em> [c2s2.3.1.5, c10s10.4] <em>2.2.3. 过程</em> [c5]
<em>2.2.4. 供应商管理</em> <em>2.2.5. 维护的组织方面</em> [c10]</p>
<p><em>2.3. 维护成本</em></p>
<p><em>2.3.1. 技术债务成本估算</em> [c12s12.5] <em>2.3.2.
维护成本估算</em> [c12s12.5.6]</p>
<p><em>2.4. 软件维护度量</em> [c12]</p>
<p><strong>3. 软件维护过程</strong></p>
<p><em>3.1. 软件维护过程</em> [c5] <em>3.2. 软件维护活动和任务</em> [c6,
c7] <em>3.2.1. 支持和监控活动</em> [c3s3.4] <em>3.2.2. 规划活动</em>
[c10] <em>3.2.3. 软件配置管理</em> [c11s11.3] <em>3.2.4. 软件质量</em>
[c13s13.4]</p>
<p><strong>4. 软件维护技术</strong></p>
<p><em>4.1. 程序理解</em> [c6,c14s14.5] <em>4.2. 软件再工程</em>
[c7]</p>
<p>软件维护 7-17</p>
<p><em>4.3. 逆向工程</em> [c7, c14s14.5] <em>4.4.
持续集成、交付、测试和部署</em> <em>4.5. 维护可视化</em></p>
<p><strong>5. 软件维护工具</strong> [c14]</p>
<p><strong>扩展阅读</strong> <strong>参考文献</strong></p>
<p>A. April 和 A. Abran, <em>软件维护管理：评估和持续改进</em> [3]。</p>
<p>本书探讨了持续软件维护过程领域。它提供了改进组织中软件维护过程的路线图。它描述了按成熟度级别组织的软件维护实践，允许进行基准测试和持续改进。为每个关键实践领域提供了目标，并且所呈现的过程模型完全符合国际标准
ISO/IEC/IEEE 12207、ISO/IEC/IEEE 14764 和 ISO/IEC/IEEE 15504
的架构和框架，以及 ITIL 和 CoBIT 等模型。</p>
<p>IEEE Std 2675-2021，IEEE DevOps
标准：<em>构建可靠和安全的系统，包括应用程序构建、打包和部署</em>
[5]。</p>
<p>规定了以可靠和安全的方式构建、打包和部署系统和应用程序的技术原则和过程。重点是建立有效的合规性和信息技术(IT)控制。提出的
DevOps
原则包括使命优先、客户关注、左移(shift-left)、持续一切和系统思维。描述了包括开发人员和运维人员在内的利益相关者如何有效协作和沟通。此处的过程结果和活动与
ISO/IEC/IEEE 12207:2017 和 ISO/IEC/IEEE 15288:2015
中规定的过程模型保持一致。</p>
<p>[1] IEEE Std, <em>ISO/IEC/IEEE 14764:2022, 软件工程 —
软件生命周期过程 — 维护</em>, 第三版。</p>
<p>[2*] P. Grubb 和 A.A. Takang, <em>软件维护：概念与实践</em>, 第2版.
River Edge, NJ: World Scientific Publishing, 2003.</p>
<p>[3] A. April 和 A. Abran, <em>软件维护管理：评估和持续改进</em>.
Wiley-IEEE Computer Society Press, 2008.</p>
<p>[4] C. Seybold 和 R. Keller, <em>将软件维护与离岸现实对齐</em>,
第12届欧洲软件维护和再工程会议. 2008年4月1-4日, 希腊雅典,
DOI:10.1109/CSMR.2008.4493298.</p>
<p>[5] IEEE DevOps
标准：<em>构建可靠和安全的系统，包括应用程序构建、打包和部署</em>, IEEE
Std 2675-2021, 2021年4月。</p>
<p>[6] W. Titus, T. Manshreck, 和 H. Wright.
<em>谷歌的软件工程：从长期编程中学到的经验教训</em>. O’Reilly Media,
2020.</p>
<p>[7] A. Abran 和 H. Nguyenkim, 从需求角度衡量维护过程,
<em>软件维护期刊：研究与实践</em>, 第5卷第2期: 63-90, 1993.</p>
<p>7-18 <em>SWEBOK® GUIDE V4.0a</em></p>
<p>[8] M.M. Lehman, “软件演化定律重审.” <em>欧洲软件过程技术研讨会</em>.
Berlin, Heidelberg: Springer Berlin Heidelberg, 1996.</p>
<p>[9] J. Humble 和 D. Fairley,
<em>持续交付：通过构建、测试和部署自动化实现可靠的软件发布</em>,
Addison-Wesley, 2010.</p>
<p>[10] ISO/IEC/IEEE 12207:2017 <em>系统和软件工程 —
软件生命周期过程</em>, 2017.</p>
<h2 id="第08章"><strong>第08章</strong></h2>
<p>软件配置管理</p>
<p><strong>缩略词</strong></p>
<p>CR 变更请求(Change Request) CCB 配置控制委员会(Configuration Control
Board)</p>
<p>在软件生命周期中确保配置项(CIs)的完整性和正确性，CM
被定义为”一门应用技术和管理指导的学科</p>
<h1 id="软件配置管理-2">软件配置管理</h1>
<p><strong>软件配置管理的定义和特点</strong></p>
<p>[CMDB 配置管理数据库] [CMMI 软件工程研究所的能力成熟度模型集成] [FCA
功能配置审计] [CM 配置管理] [CI 配置项] [MBX 基于模型的经验] [QA
质量保证] [PCA 物理配置审计] [SBOM 软件物料清单] [SCCB
软件配置控制委员会] [SCR 软件变更请求] [SCMP 软件配置管理计划] [SCSA
软件配置状态记账] [SLCP 软件生命周期过程] [SCM 软件配置管理] [SCI
软件配置项] [V&amp;V 验证与确认] [SQA 软件质量保证] [VDD
版本描述文档]</p>
<p><strong>引言</strong></p>
<p>软件配置管理(Software Configuration Management,
SCM)的正式定义是”在整个过程中应用配置管理[CM]的过程，记录和报告变更处理和实施状态的特征，并验证是否符合规定要求”[1]。</p>
<p>SCM是一个支持项目管理、开发和维护活动、质量保证(QA)活动以及最终产品的客户和用户的软件生命周期过程(SLCP)。</p>
<p>CM的概念适用于所有受控项目，尽管硬件CM实施和软件CM实施之间存在一些差异。CM同样适用于迭代和增量软件开发方法。</p>
<p>SCM与软件质量保证(SQA)密切相关。如软件质量知识领域所定义，SQA过程通过要求软件工程师规划、制定和执行一系列活动来确保项目生命周期中的软件产品和过程符合其规定要求，这些活动证明这些规范已内置到软件中。SCM活动通过软件配置活动(本章后面介绍)支持这些SQA目标。配置审计活动可以描述为对配置项的审查，与质量计划中定义的审查密切相关。</p>
<p>SCM活动应该将SCM过程管理和规划、软件配置识别、软件配置变更控制、软件配置状态记账(SCSA)、</p>
<p>8-1</p>
<p>8-2 <em>SWEBOK®</em> <em>GUIDE V4.0a</em></p>
<p><strong>软件配置管理</strong></p>
<p><strong>SCM过程管理</strong> | <strong>软件配置识别</strong> |
<strong>软件配置变更控制</strong> | <strong>软件配置状态记账</strong> |
<strong>软件配置审计</strong> | <strong>软件发布管理与交付</strong> |
<strong>软件配置管理工具</strong></p>
<p>组织环境 | 识别受控项目 | 请求、评估和批准软件变更 | 软件配置状态信息
| 软件功能配置审计 | 软件构建 |</p>
<p>SCM的约束和指导 | 软件配置项标识符和属性 | 软件变更请求过程 |
软件配置状态报告 | 软件物理配置审计 | 软件发布管理 |</p>
<p>SCM规划 | 基线 | 软件变更请求表单 | | 软件配置项的过程审计 | |</p>
<p>组织和职责 | 基线属性 | 实施软件变更 | | | |</p>
<p>SCM资源和进度 | 识别关系方案 | 偏差和豁免 | | | |</p>
<p>SCM组织和配置控制委员会 | 软件库 | | | | |</p>
<p>工具选择和实施 | | 接口控制 | | | |</p>
<p>供应商/分包商控制 | | | | | |</p>
<p>SCM计划 | | | | | |</p>
<p>软件配置管理的监督 | | | | | |</p>
<p>SCM度量和测量 | | | | | |</p>
<p>SCM的过程审计 | | | | | |</p>
<p><strong>图8.1.</strong> 软件配置管理知识领域的主题分解。</p>
<p>软件配置审计和软件发布管理与交付付诸实施。这种实施可以：</p>
<ol type="1">
<li>确定在项目开发期间预期受控的内容</li>
<li>识别和记录谁开发了什么配置项以及何时何地分配</li>
<li>允许受控变更</li>
<li>跟踪配置项的关系，以显示影响一个配置项的变更如何可能影响其他配置项</li>
<li>使配置项版本受控</li>
<li>确保交付的配置项质量满足预期用途的要求</li>
</ol>
<p>SCM知识领域与所有其他知识领域相关，因为SCM的对象是整个软件工程过程中产生和使用的工件。</p>
<p><strong>软件配置管理主题分解</strong></p>
<h2 id="1-scm过程管理">1. SCM过程管理</h2>
<p><strong>[2, c6, c7]</strong></p>
<p>SCM通过识别产品的元素(称为配置项)、管理和控制变更、验证、记录和报告配置信息来控制产品的演变和完整性。从软件工程师的角度来看，SCM促进了开发和变更实施活动。成功实施SCM需要仔细的规划和管理，这需要深入理解SCM过程设计和实施的组织环境以及施加的约束。SCM计划可以为组织开发一次，然后根据单个项目的需要进行调整。</p>
<h3 id="11-scm的组织环境">1.1 SCM的组织环境</h3>
<p>[2, c6, ann. D] [3*, Introduction] [4*, c25]</p>
<p>要为项目规划SCM过程，必须理解组织</p>
<p>图8.1展示了SCM知识领域的主题细分以及组织元素之间的关系。SCM不仅与特定项目交互，还与组织的其他几个领域交互。</p>
<p>负责软件工程支持过程的组织元素可以以多种方式构建。SCM的总体责任通常由组织的不同部分或指定的个人承担。但是，某些SCM任务的责任可能会分配给组织的其他部分(例如开发部门)。</p>
<p>软件通常作为包含硬件和固件元素的更大系统的一部分进行开发。在这种情况下，SCM活动与硬件和固件CM活动并行进行，并且必须与系统级CM保持一致。请注意，固件包含硬件和软件；因此，硬件和软件CM概念都适用。</p>
<p>SCM可能在记录管理和不合格项等问题上与组织的QA活动对接。关于前者，受组织QA程序规定约束的项目记录也可能处于SCM控制之下。QA团队通常负责管理不合格项。但是，SCM可能协助跟踪和报告此类别中的软件配置项(SCI)。</p>
<p>也许最密切的关系是与软件开发和维护组织的关系。正是在这种背景下，执行许多软件配置控制任务。通常，相同的工具支持开发、维护和SCM目的。</p>
<h2 id="12-scm过程的约束和指导">1.2 SCM过程的约束和指导</h2>
<p>[2, c6, ann. D, ann. E] [3*, c2, c5] [5, c19s2.2]</p>
<p>影响和指导SCM过程的约束来自许多来源。在企业或其他组织层面制定的政策和程序可能会影响或规定项目的SCM过程的设计和实施。此外，采购方和供应商之间的合同可能包含影响SCM过程的条款(例如，可能需要某些配置审计，或者合同可能指定某些项目置于CM之下)。当要开发的软件可能影响公共安全时，外部监管机构可能会施加约束。最后，为软件项目选择的SLCP和为实施选择的形式化级别也将影响SLCP的设计和实施。</p>
<p>软件工程师还可以在各种标准组织发布的软件工程标准中反映的”最佳实践”中找到设计和实施SCM过程的指导。(有关这些标准的更多信息，请参见附录B。)</p>
<h2 id="13-scm规划">1.3 SCM规划</h2>
<p>[2, c6, ann. D, ann. E] [3*, c23] [4*, c25]</p>
<p>项目的SCM过程规划应与组织背景、适用约束、普遍接受的指导以及项目的性质(例如规模、安全关键性和安全性)保持一致。计划中涵盖的主要活动是软件配置标识、软件配置控制、SCSA、软件配置审计以及软件发布管理和交付。此外，通常还会考虑组织和职责、资源和进度、工具选择和实施、供应商和分包商控制以及接口控制等问题。规划活动的结果记录在SCM计划(SCMP)中，该计划需接受SQA审查和审计。</p>
<p>应仔细规划和沟通分支和合并策略，因为它们影响许多SCM活动。SCM将分支定义为一组演进的源文件版本[1]。合并包括将对同一文件的不同更改组合在一起[1]。当多个人更改一个CI时，通常会发生这种情况。有许多常用的分支和合并策略。(有关其他讨论，请参见延伸阅读部分。)</p>
<p>选择的软件开发生命周期模型(请参见软件工程过程知识领域中的软件生命周期模型)也会影响SCM活动，SCM规划应考虑这一点。例如，许多软件开发方法使用持续集成(continuous
integration)，其特点是频繁的构建-测试-部署周期。显然，必须相应地规划SCM活动。</p>
<h3 id="131-scm组织和职责">1.3.1 SCM组织和职责</h3>
<p>[2, ann. Ds5-6] [3*, c10-11] [4*, c25]</p>
<p>必须明确确定组织角色，以防止混淆谁将执行特定的SCM活动或任务。这些职责还必须分配给组织实体；这可以通过责任人的职位或通过指定明确表示。</p>
<h3 id="132-scm资源和进度">1.3.2 SCM资源和进度</h3>
<p>应仔细规划工具获取。应考虑以下问题：</p>
<ul>
<li>组织：从组织角度来看，什么推动了工具获取？</li>
<li>工具：我们可以使用商业工具，还是需要专门为此项目开发自己的工具？</li>
<li>环境：组织及其技术背景施加了哪些约束？</li>
<li>遗留：项目将如何使用(或不使用)新工具？</li>
<li>资金：谁将支付工具的获取、维护、培训和定制费用？</li>
<li>范围：新工具将如何部署—例如，在整个组织中还是仅在特定项目上？</li>
<li>所有权：谁负责引入新工具？</li>
<li>未来：工具使用的计划是什么？</li>
</ul>
<h2 id="132-软件配置管理资源和进度">1.3.2 软件配置管理资源和进度</h2>
<p>[2, ann. Ds8] [3*, c23]</p>
<p>软件配置管理规划确定执行软件配置管理活动和任务所需的资源——包括人员和工具。它还确定软件配置管理任务的必要顺序，并在项目进度中确定每项任务的位置及其相对于项目管理规划阶段确定的里程碑的位置。还需要说明实施计划和培训新员工所需的任何培训要求。</p>
<h2 id="133-工具选择和实施">1.3.3 工具选择和实施</h2>
<p>[3*, c26s2, c26s6]</p>
<p>与软件工程的任何领域一样，软件配置管理工具的选择和实施需要考虑以下几点：</p>
<ul>
<li>互操作性(Interoperability)：这些工具如何与其他工具集成？它们如何与当前组织环境中的其他工具一起工作？它们如何与未来可能使用的工具一起工作？</li>
<li>变更(Change)：这些工具的适应性如何？</li>
<li>分支和合并(Branching and
merging)：这些工具的功能是否与计划的分支和合并策略兼容？</li>
<li>集成(Integration)：各种软件配置管理工具之间是否集成？它们是否与组织中使用的其他工具集成？</li>
<li>迁移(Migration)：版本控制工具维护的仓库是否可以移植到另一个版本控制工具，同时保持其包含的配置项的完整历史记录？</li>
</ul>
<p>软件配置管理需要一组工具而不是单一工具。这样的工具集有时被称为工作台(workbenches)。作为工具选择规划工作的一部分，团队必须确定软件配置管理工作台是开放式的(不同软件配置管理过程活动将使用来自不同供应商的工具)还是集成式的(工作台的元素设计为协同工作)。</p>
<p>组织规模和涉及的项目类型也可能影响工具选择。(参见本文档第7节软件配置管理工具)</p>
<h2 id="134-供应商分包商控制">1.3.4 供应商/分包商控制</h2>
<p>[2, c13] [3*, c13s9-c14s2]</p>
<p>软件项目可能会获取或使用购买的软件产品，例如编译器或其他工具。软件配置管理规划考虑这些项目是否以及如何通过配置控制进行管理(例如，集成到项目库中)，以及如何评估和管理变更或更新。</p>
<p>类似的考虑也适用于分包软件。当项目使用分包软件时，需要确定对分包商软件配置管理过程施加的软件配置管理要求以及监控合规性的方法。后者包括确定哪些软件配置管理信息必须可用才能进行有效的合规性监控。</p>
<h2 id="135-接口控制">1.3.5 接口控制</h2>
<p>[2, c12] [3*, c23s4]</p>
<p>当一个软件项与另一个软件或硬件项接口时，对任一项的更改都可能影响另一项。软件配置管理过程的规划考虑如何识别接口项以及如何管理和传达对这些项的更改。软件配置管理角色可能是更大的系统级接口规范和控制过程的一部分,涉及接口规范、接口控制计划和接口控制文档。在这种情况下，接口控制的软件配置管理规划在系统级过程的背景下进行。</p>
<h2 id="14-软件配置管理计划">1.4 软件配置管理计划</h2>
<p>[2, ann. D] [3*, c23]</p>
<p>给定项目的软件配置管理规划结果记录在软件配置管理计划(SCMP)中,这是一个”活文档”，作为软件配置管理过程的参考。软件配置管理计划在软件生命周期期间根据需要维护(更新和批准)。为了让团队实施软件配置管理计划,他们通常需要开发许多更详细的下级程序,以定义在日常活动中如何满足特定要求(例如,将使用哪些分支策略,构建发生的频率,各种自动化测试运行的频率)。</p>
<p>基于规划活动产生的信息创建和维护软件配置管理计划的指南可从多个来源获得,例如[2]。该参考文献提供了软件配置管理计划中应包含的信息要求。软件配置管理计划应包括以下部分：</p>
<ul>
<li>引言(目的、范围、使用的术语)</li>
<li>软件配置管理管理(组织、职责、权限、适用的政策、指令、程序)</li>
<li>软件配置管理活动(配置识别、配置控制等)</li>
<li>软件配置管理进度(与其他项目活动的协调)</li>
<li>软件配置管理资源(工具、物理资源和人力资源)</li>
<li>软件配置管理计划维护</li>
</ul>
<h2 id="15-软件配置管理监控">1.5 软件配置管理监控</h2>
<p>[3*, c11s3]</p>
<p>在软件配置管理过程实施后,可能需要进行一些监督以确保软件配置管理计划的规定得到正确执行。该计划可能包括特定的软件质量保证要求,以确保符合指定的软件配置管理过程和程序。负责软件配置管理的人员确保那些被分配职责的人员正确执行定义的软件配置管理任务。作为合规性审计活动的一部分,软件质量保证机构也可能执行此监督。</p>
<p>使用具有过程控制能力的集成软件配置管理工具可以使监督任务更容易。一些工具在为软件工程师提供适应程序的灵活性的同时促进过程合规性。其他工具则强制执行特定过程,使软件工程师的灵活性降低。监督要求和提供给软件工程师的灵活性水平是工具选择中的重要考虑因素。</p>
<h2 id="151-软件配置管理度量和测量">1.5.1 软件配置管理度量和测量</h2>
<p>[3*, c9s2, c25s2-s3]</p>
<p><strong>2. 软件配置识别</strong></p>
<p><strong>[2, c8]</strong></p>
<h1 id="软件配置管理-3">软件配置管理</h1>
<p>软件配置管理(SCM)的度量可以设计用于提供软件配置识别，识别需要控制的项目，为项目及其版本建立标识方案，以及建立用于获取和管理受控项目的工具和技术。这些活动为其他SCM活动提供了基础。</p>
<p>度量还可以提供关于SCM过程功能的洞察，并识别过程改进的机会。SCM过程度量使团队能够持续监控SCM活动的有效性。这些度量对于描述过程的当前状态和提供随时间比较的基础非常有用。度量分析可能产生导致过程变更和相应SCMP更新的洞察。</p>
<p>软件库和各种SCM工具能力使团队能够提取关于SCM过程特征的有用信息(以及项目和管理信息)。例如，关于完成各种类型变更所需时间的信息将有助于评估确定授权某些变更的最佳权限级别的标准，以及估算进行未来变更所需的资源。</p>
<p>必须注意保持监控重点放在可以从度量中获得的洞察上，而不是度量本身。软件过程和产品度量在软件工程过程知识领域中进一步讨论。软件度量程序在软件工程管理知识领域中描述。</p>
<h2 id="152-scm的过程中审计">1.5.2 SCM的过程中审计</h2>
<p>审计可以在软件工程过程中进行，以调查特定配置元素的状态或评估SCM过程实施情况。过程中审计为监控过程的选定方面提供了更正式的机制，并可以与软件质量保证(SQA)功能协调。(参见软件配置审计。)</p>
<h2 id="2-软件配置识别">2. 软件配置识别</h2>
<p>软件配置识别活动识别要控制的项目，为项目及其版本建立标识方案，并建立用于获取和管理受控项目的工具和技术。这些活动为其他SCM活动提供了基础。</p>
<h3 id="21-识别要控制的项目">2.1 识别要控制的项目</h3>
<p>控制变更的第一步是识别要控制的软件项目。这涉及在系统配置的上下文中理解软件配置，选择软件配置项(SCI)并制定标记软件项目的策略。</p>
<h4 id="211-软件配置">2.1.1 软件配置</h4>
<p>软件配置是在技术文档中规定的或在产品中实现的硬件或软件的功能和物理特性。它可以被视为整体系统配置的一部分。</p>
<h4 id="212-软件配置项">2.1.2 软件配置项</h4>
<p>配置项(CI)是设计为作为单一实体管理的硬件、软件或两者的项目或集合。软件配置项(SCI)是已被确立为配置项的软件实体。</p>
<p>SCM除了代码本身之外还控制各种项目。具有成为SCI潜力的软件项目包括计划、规格说明和设计文档、测试材料、软件工具、源代码和可执行代码、代码库、数据和数据字典，以及用于安装、维护、操作和软件使用的文档。</p>
<p>选择SCI是一个重要过程，在这个过程中必须在为项目控制目的提供足够的可见性和提供可管理数量的受控项目之间取得平衡。</p>
<h3 id="22-配置项标识符和属性">2.2 配置项标识符和属性</h3>
<p>状态记账(Status
Accounting)活动(稍后解释)在CI开发时收集关于它们的信息。定义CI方案是为了确定必须为每个CI收集和跟踪什么信息。跟踪唯一标识符和版本。</p>
<p>一个示例方案可能包括以下内容：</p>
<ul>
<li>CI名称</li>
<li>CI唯一标识符</li>
<li>CI描述</li>
<li>CI日期</li>
<li>CI类型</li>
<li>CI所有者</li>
</ul>
<p>CI的唯一标识符可以使用有意义或无意义的编码。有意义编码的一个例子可以是XX-YY，其中XX是迭代缩写(在使用迭代开发方法的情况下)，YY是CI缩写。</p>
<h3 id="23-基线识别">2.3 基线识别</h3>
<p>软件基线是CI(无论媒体类型如何)的正式批准版本，在CI生命周期中的特定时间正式指定并固定。该术语还指约定的SCI的特定版本。基线只能通过正式的变更控制程序进行更改。</p>
<p>示例基线属性可能包括以下内容：</p>
<ul>
<li>基线名称</li>
<li>基线唯一标识符</li>
<li>基线描述</li>
<li>基线创建日期</li>
<li>基线CI</li>
</ul>
<h3 id="25-关系方案定义">2.5 关系方案定义</h3>
<p>关系提供创建和维持结构所需的连接。当有效的关系(结构化)到位时(例如，基于模型的体验(MBX)平台)，传达意图和管理结果的能力会显著增强。需要关系信息交换和互操作性来支持适用的关系类型。状态记账活动负责收集关于CI之间关系的信息。</p>
<p>常见的关系类型可以根据以下方案描述：</p>
<p><strong>依赖关系</strong>：CI-1和CI-2相互依赖。</p>
<p>示例：CI-1依赖于CI-2，反之亦然，例如类模型依赖于序列图，因为对任一类型模型的任何更改都会影响另一个。</p>
<div class="line-block">CI-1代码 | CI-2代码 | 日期 |</div>
<p><strong>派生关系</strong>：一个CI从另一个派生，通常是顺序关系，不是因为缺乏资源来处理两者。</p>
<p>通过正式的变更控制程序。配置项(CI)是因为一个约束条件要求</p>
<p>基线，以及基线的所有已批准变更，表示当前已批准的配置。基线由一个或多个相关的配置项组成。例如，CI-1
必须在 CI-2 开发之前完成。</p>
<p>示例：CI-1 派生自 CI-2。</p>
<p>[CI-1 代码] [CI-2 代码] [日期]</p>
<h2 id="24-基线属性">2.4 基线属性</h2>
<p>[2, c8s2.5.4]
[<em>继承</em>：软件项随着软件项目的进展而演化。软件项版本是项的一个已标识实例。它可以被认为是演化项的一个状态。这就是继承关系
8-8 [<em>SWEBOK</em>] [<em>®</em>][ 指南 V4.0a]]</p>
<p>[继承] [继承]</p>
<p>[依赖]</p>
<p>[CI-1] [CI-2] [CI-3]</p>
<p>[继承]</p>
<p>[派生]</p>
<p>基线属性用于状态记录活动，并指定关于已建立基线的信息。</p>
<p>继承记录：根据为继承关系定义的方案，下表给出了每个 CI
创建的日期（前三行），第四行表示在 2021 年 10 月 5 日对 CI-1
进行的更改，当时的当前版本为 1，创建的新版本为 2。</p>
<p>[CI-1] [–] [1] [10/01/2021] [CI-2] [–] [1] [10/04/2021] [CI-3] [–]
[1] [10/03/2021] [CI-1] [1] [2] [10/05/2021]</p>
<p>依赖记录：根据为依赖关系定义的方案，CI-1 和 CI-2 具有在 CI-2
开发当天创建的依赖关系。</p>
<p>[CI-1] [CI-2] [10/04/2021]</p>
<p>派生记录：根据为派生定义的方案，CI-3 派生自 CI-1，此关系在 CI-3
创建当天产生。</p>
<p>[CI-3] [CI-1] [10/03/2021]</p>
<p><strong>图 8.2.</strong> 报告关系示例</p>
<p>反映，并且它是自反的，即每个 CI 与自身都有这种关系。第一次继承在 CI
首次创建时产生。每次更改时，都会产生新的继承，跟踪这些继承就是跟踪 CI
版本的方法。</p>
<p>示例：时间线上的 CI 版本。</p>
<p><em>组件</em>。组件可以是源代码、库、模块和其他工件；它们可以是开源或专有的，免费或付费的；数据可以是广泛可用的或访问受限的。</p>
<p>图 8.2 展示了软件物料清单(SBOM)中三个 CI（称为 CI-1、CI-2 和
CI-3）之间关系的简单示例。</p>
<p>[CI 代码 当前版本] [下一版本] [日期]</p>
<h2 id="26-软件库">2.6 软件库</h2>
<p>变体是由工程化替代选项产生的程序版本。这种类型的关系不如上述关系类型常见，因为维护成本更高。</p>
<p>决定在整个项目中跟踪哪些关系很重要，因为跟踪某些关系可能需要额外的工作。另一方面，跟踪此类关系可以促进对
CI 的变更请求(CR)做出决策。</p>
<p>配置项之间的关系可以在软件物料清单(SBOM)中跟踪。SBOM
是一种正式记录，包含用于构建软件的配置项的详细信息和供应链关系。SBOM
中的配置项通常被称为</p>
<p>[2, c8s2.5] [3*, c1s3]</p>
<p>软件库是源代码、脚本、目标代码、文档和相关工件的受控集合。需求和测试用例存储在存储库中，应与开发的代码基线链接。源代码存储在版本控制系统中，该系统为开发的基线提供可追溯性和安全性。版本控制系统支持多个开发流，并链接到构建过程中派生的二进制对象（例如，目标代码）。这些二进制对象通常存储在应包含用于执行物理配置审计(PCA)的加密哈希的存储库中。</p>
<p><a href="#软件配置管理">软件配置管理</a> 8-9</p>
<p>[需要] [初步] [变更] [调查]</p>
<p>[受控项] [识别为] [拒绝] [CCB] [通知] [变更] [评审] [请求者]</p>
<p>[生成或升级 SCR] [批准] [“紧急路径”] [分配给软件] [通常也存在]</p>
<p>[不完整] [可以实施变更] [工程师]</p>
<p>[SCR] [变更过程] [之后执行]</p>
<p>[已评估] [进度、] [设计、测试，]</p>
<p>[完成变更]</p>
<p>[完成]</p>
<p><strong>图 8.3.</strong> 变更控制流程</p>
<p>确定性媒体库包含可以部署到测试、阶段和生产系统的工件的发布基线。</p>
<p>发布管理流程依赖这些软件库来管理部署的工件。在访问控制和备份设施方面，安全性是库管理的关键方面。</p>
<p>根据这些规则。当软件项目所在的公司或行业部门不存在关于变更控制的特定规则时，本节的其余部分可能很有用。</p>
<h2 id="3-软件配置变更控制">3. 软件配置变更控制</h2>
<h3 id="31-请求评估和批准软件变更">3.1 请求、评估和批准软件变更</h3>
<p>[2, c9] [3*,c8] [4*, c25s3] [5, c11.s3.3]</p>
<p>[2, c9s2.4] [3*, c11s1] [4*, c25s3]</p>
<p>软件配置变更控制涉及软件生命周期中对配置项所需的变更。它涵盖了确定要进行哪些变更的流程、批准某些变更的权限、支持实施这些变更，以及接受、修改、推迟或拒绝提议的变更。</p>
<p>管理受控项变更的第一步是确定要进行哪些变更。软件变更请求(SCR)流程（图
8.3）提供了提交和记录变更请求的正式程序；评估提议变更的潜在成本和影响；以及接受、修改、推迟或拒绝提议的变更。变更请求是扩大或缩小</p>
<p>以及正式偏离项目范围的概念；修改政策、流程、</p>
<p>项目需求以及计划或程序的豁免；修改成本或预算；</p>
<p>修改已实现的代码；或修订进度计划。来自这些活动的信息对于衡量变更流量和</p>
<p>故障以及返工方面非常有用。请求更改配置项(SCI)的请求可能由</p>
<p>任何人在软件生命周期的任何阶段发起，并可能包括建议的解决方案</p>
<p>鉴于配置项(CI)的变更可能遵循特定的规则，这取决于工业部门、和请求的优先级。变更请求(CR)的一个来源是</p>
<p>领域、公司等，因此在为其开发软件配置管理(SCM)流程的响应问题报告而启动的纠正措施。无论来源如何，</p>
<p>软件项目的上下文中识别这些规则并严格遵守变更类型(例如，缺陷或增强)</p>
<p>这些规则是非常重要的。通常会记录在软件变更请求(SCR)上。</p>
<p>记录软件变更请求(SCR)使软件工程师能够跟踪缺陷并按变更类型收集变更发起变更请求、执行变更流程流程、捕获配置控制委员会(CCB)决策和报告</p>
<p>活动测量。一旦收到软件变更请求(SCR)，变更流程信息。将此工具功能与问题报告系统链接</p>
<p>将执行技术评估(也称为影响分析)，以确定如果接受变更请求所需修改的范围。可以促进问题解决跟踪</p>
<p>以及解决方案的开发速度。</p>
<p>充分理解软件(可能还有硬件)项之间的关系对于此任务非常重要。关于配置项关系的记录信息可能对影响任何配置项的决策有用，因为可能对其他配置项产生影响。最后，一个既定的权威机构——与受影响的基线、涉及的软件配置项(SCI)和变更性质相称——将评估变更请求的技术和管理方面，并接受、修改、拒绝或推迟提议的变更。</p>
<h2 id="311-软件配置控制委员会">3.1.1 软件配置控制委员会</h2>
<p>接受或拒绝提议变更的权威属于一个称为配置控制委员会(CCB)的实体。在较小的项目中，这种权威可能属于领导者或指定的个人，而不是多人委员会。根据各种标准——例如涉及项目的关键性、变更的性质(例如，对预算和进度的影响)，或项目在生命周期中的位置——可能存在多个级别的变更权威。用于系统的配置控制委员会的组成因这些标准而异(但软件配置管理代表始终在场)。所有适合配置控制委员会级别的利益相关者都有代表。当配置控制委员会的权限范围仅限于软件时，该委员会称为软件配置控制委员会(SCCB)。</p>
<p>配置控制委员会的活动受软件质量审计或评审的约束。</p>
<h2 id="312-软件变更请求流程">3.1.2 软件变更请求流程</h2>
<p>有效的软件变更请求流程需要使用支持工具和程序来</p>
<h2 id="313-软件变更请求表单定义">3.1.3 软件变更请求表单定义</h2>
<p>变更请求申请必须包括以下内容：</p>
<p>• 一个变更请求表单，必须描述请求并给出其理由 •
一个变更认证表单(如果批准变更请求则需要)</p>
<p>这些表单可以通过相应的支持工具进行管理，但人类负责设计表单。</p>
<h2 id="32-实施软件变更">3.2 实施软件变更</h2>
<p>批准的软件变更请求使用已定义的软件程序按照适用的进度要求实施。因为可能同时实施多个已批准的软件变更请求，所以必须提供一种跟踪哪些软件变更请求被纳入特定软件版本和基线的方法。在变更过程结束时，已完成的变更可能会经历配置审计和软件质量验证，其中包括确保只进行了已批准的变更。软件变更请求流程通常记录变更的软件配置管理和其他批准信息。</p>
<p>变更可以由源代码版本控制工具支持。这些工具允许软件工程师团队或单个软件工程师跟踪和记录对源代码的更改。这些工具提供了一个用于存储源代码的单一存储库，因此它们可以防止多个软件工程师同时编辑同一模块，并记录对源代码所做的所有更改。软件工程师从存储库中检出模块，进行更改，记录更改，然后将编辑后的模块保存到存储库中。如果需要，也可以放弃更改，恢复到以前的基线。更强大的工具可以支持并行开发和地理分布式环境。这些工具可能表现为独立的软件配置管理组控制下的独立专用应用程序。它们也可能作为软件工程环境的集成部分出现。最后，它们可能只是一个基本的工具。</p>
<h1 id="4-软件配置状态核算">4. 软件配置状态核算</h1>
<p>在配置识别活动中为配置项、基线和关系定义的逻辑方案用于收集信息。</p>
<h2 id="41-软件配置状态信息">4.1 软件配置状态信息</h2>
<p>软件配置状态核算(SCSA)活动设计并操作一个系统，用于在生命周期进行时捕获、验证、确认和报告必要的信息。与任何信息系统一样，需要为不断演变的配置管理的配置状态信息</p>
<p>必须识别、收集和维护变更控制系统。此外，信息本身也应在相关情况下得到保护。SCSA信息和测量数据需要支持SCM过程，并满足管理层、软件工程、安全、性能和其他相关活动的配置状态报告需求。</p>
<p>可用的信息类型包括但不限于以下内容：</p>
<p>• 正在进行和已批准的配置识别 • 变更的当前实施状态 •
受影响的配置项和相关系统 • 偏离和豁免 • 验证和确认（V&amp;V）活动</p>
<p>自动化工具在执行任务时支持SCSA，并以用户友好的格式提供报告。</p>
<p><strong>3.3 偏离和豁免</strong></p>
<p>对软件工程工作施加的约束或在开发活动期间产生的规格说明可能包含项目工作人员在生命周期的指定阶段无法满足的条款。<strong>偏离(Deviation)</strong>是在制造某个项目之前授予的书面授权，允许在特定数量的单元或特定时间段内偏离特定的性能或设计要求。<strong>豁免(Waiver)</strong>是书面授权，允许配置项或其他指定项在生产过程中或项目提交检查后发现问题时偏离规定要求，但该配置项或项目仍被认为适合使用，无论是原样使用还是通过批准的方法进行返工后使用。在这些情况下，使用正式流程来获得对条款的偏离或豁免批准。</p>
<p><strong>4. 软件配置状态记录</strong></p>
<p>SCSA是配置管理的一项活动，包括记录和报告有效管理配置所需的信息，涉及配置项、基线以及配置项之间的关系。此活动必须在整个生命周期中遵循配置识别活动中识别的配置项，并执行以下操作：</p>
<p><strong>4.2 软件配置状态报告</strong></p>
<p>报告的信息可供各种组织和项目元素使用，包括开发团队、运营、安全、维护团队、项目管理、软件质量活动团队等。报告可以采用多种形式：自动化报告、用于回答特定问题的即席查询，以及定期生成的预先设计的报告，包括为满足安全、法律或法规要求而开发的报告。</p>
<p>换句话说，SCSA活动在整个生命周期中产生的信息可用于满足质量保证和安全要求，并提供符合法规和治理要求等的证据。</p>
<p>除了报告配置的当前状态外，SCSA获得的信息还可以作为各种测量的基础。</p>
<p>现代SCM包括更广泛的信息范围，包括但不限于以下内容：</p>
<p>• 完整性指标（例如MAC消息认证码、SHA1安全散列算法、MD5消息摘要） •
安全状态指标（例如治理风险和合规性） •
V&amp;V活动的证据（例如需求完成情况） • 基线状态 •
每个软件配置项的变更请求数量 • 实施变更请求所需的平均时间</p>
<p><strong>5. 软件配置审计</strong></p>
<p>软件审计是对工作产品或一组工作产品进行独立检查，以评估技术、安全、法律和法规对规格说明、标准、合同协议或其他标准的符合性。审计根据包含各种审计员角色和职责的明确定义的流程进行。由于这种复杂性，每次审计都必须经过精心计划。审计可能需要多人在相当短的时间内执行各种任务。支持审计计划和实施的工具可以极大地促进这一过程。</p>
<p>软件配置审计可能需要按照管辖合同要求进行正式审计（例如涵盖关键软件的合同）：功能配置审计(FCA)和物理配置审计(PCA)。成功完成这些审计可能是建立产品基线的先决条件。</p>
<p><strong>5.1 软件功能配置审计</strong></p>
<p>软件FCA确保被审计的软件项与其管辖规格说明一致。软件V&amp;V活动的输出（参见软件质量知识领域中的验证和确认）是此审计的关键输入。</p>
<p><strong>5.2 软件物理配置审计</strong></p>
<p>软件PCA确保设计和参考文档与已构建的软件产品一致。</p>
<p><strong>5.3 软件基线的过程中审计</strong></p>
<p>可以在开发过程中进行审计，以调查特定配置元素的状态。过程中审计可应用于所有基线项，以确保性能与规格说明一致，或确保不断演变的文档继续与正在开发的基线项保持一致。此任务适用于要作为基线一部分批准的每个配置项。审计包括审查配置项以确定其是否满足要求。如何进行审查以及预期结果必须在质量计划中描述，或者如果没有质量计划，则为软件配置审计活动定义。</p>
<p>对配置识别活动中识别的配置项进行持续审查有助于验证是否符合治理和法规要求。</p>
<p><strong>6. 软件发布管理与交付</strong> <strong>[2, c14] [3*, c8s2]
[4*, c25s4]</strong></p>
<p>在此上下文中，<em>发布</em>是指在开发活动之外分发软件及相关工件，包括内部发布和向客户分发。当软件项有不同版本可供交付时(如针对不同平台的版本或具有不同功能的版本)，通常需要重新创建特定版本并为版本交付打包正确的材料。软件库是完成发布和交付任务的关键要素。</p>
<p><em>6.1 软件构建</em> [4*, c25s2]</p>
<p>软件构建使用适当的配置数据，将SCI的正确版本构造成软件包，以交付给客户或其他接收方(如执行测试的团队)。对于带有硬件或固件的系统，可执行程序会交付给系统构建活动。构建指令有助于确保按正确顺序执行适当的构建步骤。除了为新发布构建软件外，SCM通常还必须能够重现以前的版本，用于恢复、测试、维护或额外发布目的。</p>
<p>软件使用支持工具(如编译器)进行构建。例如，如果需要重新构建先前构建的SCI的精确副本，则支持工具和相关构建指令必须处于SCM控制之下，以确保工具正确版本的可用性。</p>
<p>工具能力对于为目标环境选择软件项的正确版本以及从选定版本和配置数据自动化构建软件的过程非常有用。这种工具能力对于具有并行或分布式开发环境的项目是必需的。大多数软件工程环境都提供此功能。然而，这些工具的复杂程度各不相同；一些工具要求软件工程师学习专门的脚本语言，而另一些则使用更面向图形的方法，隐藏了”智能”构建工具的大部分复杂性。</p>
<p>构建过程和产品通常需要接受软件质量验证。构建过程的输出可能需要供将来参考。它们可能成为质量、安全性或符合组织或监管要求的记录。列出构建中包含的工件的SBOM(软件物料清单)是重要的CM输出。</p>
<p>在持续集成中，当对CI的更改提交到源代码控制存储库时，会自动执行软件构建。在本地或基于云的服务器上运行的工具会监控项目的源代码控制系统，并在每次更改提交到源代码存储库的特定分支或区域时启动一系列步骤。该工具被配置为检索项目完整源代码的全新副本，并执行必要的命令来编译和链接代码。此配置通常与通过自动化静态分析验证编码标准、执行单元测试和确定代码覆盖率指标、或从源代码中提取文档的步骤相结合。生成的工件随后通过发布管理流程进行部署。</p>
<p><em>6.2 软件发布管理</em> [4*, c25s2]</p>
<p>软件发布管理包括产品元素(例如可执行程序、文档、发布说明或配置数据)的识别、打包和交付。鉴于产品变更可能持续发生，发布管理的一个关注点是确定何时发布。发布解决的问题的严重性以及先前发布的故障密度测量会影响此决策。打包任务识别要交付的产品项，然后根据产品的预期应用选择这些项的正确变体。记录发布物理内容的信息称为版本描述文档(VDD)。发布说明描述了新功能、已知问题以及产品正常运行所需的平台要求。要发布的包还包含安装或升级说明。后者可能很复杂，因为某些用户可能拥有旧几个版本的版本。在某些情况下，可能需要发布管理来跟踪产品向各个客户或目标系统的分发(例如，当供应商需要通知客户新报告的问题时)。最后，可以使用一种机制来帮助确保发布项的完整性。</p>
<p><a href="#软件配置管理">软件配置管理</a> 8-13</p>
<p>配置审计会在整个项目开发过程中进行，只要CI必须被审查时就会进行。</p>
<p><strong>7. 配置管理工具</strong></p>
<p>• 配置管理系统(CMS)提供支持技术和逻辑以促进CM活动。 •
版本控制存储源代码、配置文件和相关工件。 •
建立构建自动化(管道)以实现持续交付。 •
存储库存储在构建过程中创建的二进制文件，以提取最新的构建工件并根据需要重新部署它们——用于发布验证过程。
• 配置管理数据库(CMDB)或类似的持久化存储。 • 变更控制工具。 •
发布/部署工具。</p>
<p>CMS支持唯一标识。</p>
<h2 id="7-软件配置管理工具">7. 软件配置管理工具</h2>
<p><strong>[3*, c26s1]</strong></p>
<p>许多工具可以在多个层面上辅助配置管理。这些工具的范围因使用者而异。当配置管理与其他过程集成时，以及扩展到与其他现有工具集成时，最为有效。配置管理工具的选择取决于工具的应用范围。</p>
<p>工具概述：</p>
<p><em>单个支持工具</em>通常足以满足小型组织或开发团队的需求，这些团队不需要发布软件产品的变体或面对其他复杂的配置管理需求。以下是这些工具的示例：</p>
<p>•
版本控制工具：这些工具跟踪、记录和存储单个配置项，如源代码和外部文档。</p>
<p>•
构建处理工具：在最简单的形式下，这些工具编译和链接软件的可执行版本。更高级的构建工具从版本控制软件中提取最新版本，执行质量检查，运行回归测试，并生成各种形式的报告等任务。</p>
<p>•
变更控制工具：这些工具主要支持配置请求的控制和事件通知（例如，配置请求状态变更、达到里程碑）。</p>
<p><em>项目相关支持工具</em>主要支持开发团队和集成人员的工作空间管理。此外，它们还可以支持分布式开发环境。这类工具适用于使用软件产品变体和并行开发且没有认证要求的中大型组织。</p>
<p><em>全公司流程支持工具</em>可以自动化全公司流程的部分功能，为工作流管理、角色和职责提供支持。它们可以处理多个项目、大量数据和众多生命周期。此外，这类工具通过支持更正式的开发流程（包括认证要求），增强了项目相关支持。</p>
<p><strong>主题与参考资料对照表</strong></p>
<table>
<thead>
<tr>
<th><strong>主题</strong></th>
<th><strong>[1*]</strong></th>
<th><strong>[2*]</strong></th>
<th><strong>[3*]</strong></th>
<th><strong>[4*]</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 配置管理流程的管理</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.1. 配置管理的组织背景</em></td>
<td>引言</td>
<td>c25</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.2. 配置管理流程的约束和指导</em></td>
<td>c2,c5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.3. 配置管理规划</em></td>
<td>c23</td>
<td>c25</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.3.1. 配置管理组织与职责</em></td>
<td>c10-11</td>
<td>c25</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.3.2. 配置管理资源与进度</em></td>
<td>c23</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.3.3. 工具选择与实施</em></td>
<td>c26s2, s6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.3.4. 供应商/分包商控制</em></td>
<td>c13s9-c14s2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.3.5. 接口控制</em></td>
<td>c23s4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.4. 配置管理计划</em></td>
<td>c23</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.5. 软件配置管理监督</em></td>
<td>c11s3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.5.1. 配置管理度量与测量</em></td>
<td>c9s2; c25s2-s3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.5.2. 配置管理过程审计</em></td>
<td>c1s1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2. 软件配置识别</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.1. 识别待控制项</em></td>
<td>c1s2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.1.1. 软件配置</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.1.2. 软件配置项</em></td>
<td>c9</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.2. 配置项标识符和属性</em></td>
<td>c9</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.3. 基线识别</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.4. 基线属性</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.5. 关系方案定义</em></td>
<td>c7s4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.6. 软件库</em></td>
<td>c1s3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3. 软件配置变更控制</strong></td>
<td>c8</td>
<td>c25s3</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.1. 请求、评估和批准软件变更</em></td>
<td>c11s1</td>
<td>c25s3</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.1.1. 软件配置控制委员会</em></td>
<td>c11s1</td>
<td>c25s3</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.1.2. 软件变更请求流程</em></td>
<td>c1s4, c8s4</td>
<td>c25s3</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.1.3. 软件变更请求表单定义</em></td>
<td>c8s4</td>
<td>c25s3</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.2. 实施软件变更</em></td>
<td>c25s3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.3. 偏离和豁免</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>4. 软件配置状态记录</strong></td>
<td>c9</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.1. 软件配置状态信息</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.2. 软件配置状态报告</em></td>
<td>c1s5; c9s1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>5. 软件配置审计</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.1. 软件功能配置审计</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.2. 软件物理配置审计</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.3. 软件基线过程审计</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>6. 软件发布管理与交付</strong></td>
<td>c8s2</td>
<td>c25s4</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.1. 软件构建</em></td>
<td>c25s2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.2. 软件发布管理</em></td>
<td>c25s2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>7. 软件配置管理工具</strong></td>
<td>c26s1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>扩展阅读</strong></p>
<p>[<em>CMMI for Development,</em> Version 2.0 - 2.1, pp. 66–80
[7]。]</p>
<p>[该模型提供了一套最佳实践集合，帮助软]
[件开发组织改进其过程。在成熟度第2级，] [它建议采用配置管理活动。]</p>
<p>S.P. Berczuk 和 B.
Appleton，《软件配置管理模式：有效的团队协作》，实用集成 [6]。</p>
<p>本书将有效的软件配置管理实践和策略以模式形式表达。这些模式可以使用各种工具实现，但它们以工具无关的方式表达。</p>
<p>[B. Aiello 和 L. A.
Sachs，《配置管理最佳实践：在真实世界中有效的实用方法》（第1版），2011
[8]。]</p>
<p><a href="#软件配置管理">软件配置管理</a> 8-17</p>
<p>本书介绍了七种变更控制类型（第4章第3节）。</p>
<p>[[5] J.W. Moore，《软件工程路线图：基于标准的指南》，]
[第1版。霍博肯，新泽西州：Wiley-IEEE] [计算机学会出版社，2006年。]</p>
<p><strong>参考文献</strong></p>
<p>[1] ISO/IEC/IEEE，“ISO/IEC/IEEE 24765:2017
系统与软件工程——词汇表”，第2版，2017年。</p>
<p>[[6] S.P. Berczuk 和 B. Appleton，]
[《软件配置管理模式：有效的团队协作，] [实用集成》：Addison-Wesley]
[专业出版社，2003年。]</p>
<p>[2] IEEE. IEEE 标准
828-2012，系统与软件工程中的配置管理标准，2012年。</p>
<p>[[7] 《CMMI 开发模型》，版本2.0，] [CMMI 研究所，2018年。]</p>
<p>[3*] A.M.J.
Hass.《配置管理原则与实践》，第1版。波士顿：Addison-Wesley，2003年。</p>
<p>[[8] B. Aiello 和 L.A. Sachs，《配置管理]
[最佳实践：在真实世界中有效的实用方法] [（第1版）》，2011年。]</p>
<p>[4*] I.
Sommerville，《软件工程》，第10版。全球版。培生出版社，2016年。</p>
<h2 id="第09章"><strong>第09章</strong></h2>
<p><a href="#软件工程管理">软件工程管理</a></p>
<p><strong>缩略语</strong></p>
<p>[MBSE] [基于模型的系统工程] [PMBOK® Guide] [项目管理知识体系指南]
[PSM] [实用软件和系统测量] [SDLC] [软件开发生命周期] [SEM] <a href="#软件工程管理">软件工程管理</a> [SQA] [软件质量保证] [SWX] [PMBOK®
Guide 软件扩展] [WBS] [工作分解结构]</p>
<p><strong>引言</strong></p>
<p>软件工程管理（SEM）可以定义为一系列工作活动的集合，涉及软件项目的规划、估算、测量、控制、协调、领导和风险管理，以帮助确保软件产品和软件工程服务能够高效、有效地交付，并符合利益相关者的利益
[3]。虽然项目管理和测量管理通常被视为独立的领域，且各自具有许多独特属性，但两者之间的紧密关系促使它们在本知识领域（KA）中被合并处理。</p>
<p>从某种意义上说，应该可以像管理其他复杂项目一样管理软件工程项目，使用与其他工程项目相同的模型、技术过程和问题解决方式。然而，软件工程师在使用不同的过程模型、技术过程时，会基于他们的教育背景和经验以及物理属性与软件属性之间的差异，做出与其他工程师不同的选择。软件系统元素是以算法形式表达的逻辑构造，而物理系统元素则通过机械、电气、化学、生物和其他物理介质实现。软件是无形的，因为它没有物理属性；软件是可塑的，因为相对而言代码修改比较容易。通过修改软件代码来获得期望的效果可能并不容易，但与修改已经构建完成的物理元素相比，代码修改本身是相对直接的
[12]。</p>
<p>随着软件和嵌入软件的系统变得越来越大、越来越复杂、越来越相互交织，软件工程管理和工程角色正在相应演变
[10]，因为有技能的人员必须积极开发和维护这些系统。考虑以下几点：硬件与软件不同（并非所有软件都相同）。硬件可以以线性方式开发、采购和维护。软件是一种持久的能力，必须在其整个生命周期中得到支持和持续改进
[13]。此外，软件的可塑性允许开发阶段之间进行迭代和交织（其程度远超开发物理产品时的可能性）。软件由人开发并为人服务，因此数字人才至关重要。软件项目日益重要，其持续成功在很大程度上取决于具有正确技能、知识和能力的人员。这一事实本质上是实际的、必要的，但还不够充分。其他人为因素也可能影响项目的成功。在软件开发生命周期中，不可能将人为因素与技术因素分离开来。</p>
<p>人员管理活动，如团队和团队协作、领导力、沟通和协调活动，对项目成功至关重要。</p>
<p>软件复用可能是维护的关键因素。</p>
<p>[不同过程模型、技术过程之间取得] [适当的平衡有时很困难 [5]。]</p>
<p>[• 软件能力的开发通常涉及高度的新] [颖性和复杂性。]</p>
<p>[• 通常，底层技术具有很高的变化率。]</p>
<p>[• 计算机软件已成为大多数现代系统]
[的关键组成部分。软件已被提升到高度]</p>
<p>9-1</p>
<p>9-2 [<em>SWEBOK® GUIDE V4.0a</em>]</p>
<p>持和提高生产力以及竞争力方面发挥着突出作用，因为其灵活性和相对于硬件较低的复制成本。</p>
<p>文化差异和多样化态度等因素可能会影响开发团队。大量软件项目因社会问题而失败。如果提供的需求或沟通质量差，“高质量”的开发人员也可能会生产出不合适或质量差的产品，需要返工。</p>
<p>其他问题也会使软件项目和软件生命周期过程的有效管理变得复杂，包括以下几点：</p>
<ul>
<li>客户通常不知道需要什么或什么是可行的。</li>
<li>对项目理解的加深和条件的变化可能会产生新的或变更的软件需求。</li>
<li>客户通常不理解软件工程固有的复杂性，特别是需求变更的影响。</li>
<li>由于需求变更和软件的可塑性，软件通常是迭代构建的，而不是线性的阶段序列。</li>
<li>软件本质上是一种持久的能力，必须在其整个生命周期中得到支持和持续改进。</li>
<li>软件构造与硬件实现不同，设计通常是软件构造的一部分，而在面向硬件的系统中，设计先于硬件实现，以便在采购或制造硬件之前”做对”
[12]。</li>
<li>软件工程必然包含创造力和纪律性。在保持生产力和竞争力方面，软件发挥着突出作用，因为其灵活性和相对于硬件较低的复制成本。</li>
<li>大量软件项目由于人为问题而失败。物理度量单位（如长度和重量度量）很难应用于软件。这种困难影响了如何规划、监控和控制软件开发项目。</li>
<li>软件返工以消除缺陷并响应变更。</li>
<li>速度和周期时间是管理软件的重要指标。软件能力通常以越来越快的速度交付，以满足业务和任务需求
[13]。</li>
</ul>
<p>软件工程管理(SEM)活动发生在三个层面：组织和基础设施管理、项目管理以及度量项目的管理。后两者在本知识领域(KA)描述中有详细介绍。这一事实并不削弱组织和基础设施管理问题的重要性，而是指出软件组织工程管理者应该精通本知识领域中描述的项目管理和软件度量知识。他们还应该具备一些目标领域知识。同样，对于软件是系统架构一部分的复杂项目和计划的管理者来说，了解软件工程过程（相对于其他类型的工程过程）给项目管理和项目度量带来的问题也有帮助。</p>
<p>组织管理的其他方面也会影响软件工程——例如，为软件工程项目提供框架的组织政策和程序。这些政策和程序可能需要针对有效的软件开发和维护需求进行调整。此外，可能需要制定几项专门针对软件工程的政策，以便在组织层面有效管理软件工程。例如，通常需要制定政策来建立组织范围内的特定流程或程序，用于软件工程任务，如软件设计、软件构造、估算、监控和报告。这些政策对于在整个组织中有效长期管理软件工程项目非常重要（例如，一项这样的政策可以建立一致的基础来分析过去的项目绩效并实施改进）。</p>
<p>组织管理的另一个重要方面是使用人事管理政策和程序进行招聘、培训和指导——这不仅对项目的成功很重要，而且对组织的长期成功也很重要。鉴于预计会出现熟练软件工程师短缺的情况，提供一个能够吸引和留住优秀人才的环境非常重要。软件工程人员可能会带来独特的培训或人事管理挑战（例如，在不断变化的环境中保持知识的时效性）。</p>
<p>另一个重要考虑是重用软件。为此，需要建立流程来支持适当的软件重用，以及反映重用优势和劣势的软件产品开发方法。</p>
<p>软件工程师应该对软件项目管理的独特方面有深入的理解，他们还应该对本知识领域中讨论的更一般的管理方面有一些了解（即使在毕业后的最初几年）。</p>
<p>组织文化和行为的某些属性，以及直接软件工程领域之外的企业职能领域的管理，可以间接影响组织的软件工程过程。软件项目通常旨在改变人们的工作方式——但文化变革是困难的、复杂的，如果没有重大努力就不太可能成功。因此，领导力是计划管理者的重要属性，因为他们通常需要领导数字化转型。他们可能需要激励他们的团队和其他利益相关者，在追求重大变革的每个项目中发挥最佳水平。</p>
<p>关于项目管理的大量信息可以在《项目管理知识体系指南》(PMBOK®
Guide第五版)和《项目管理知识体系指南的软件扩展》(SWX) [1,
2]中找到。这些指南中的每一个都包括10个项目管理知识领域：项目整合管理</p>
<p>其中底层技术经历快速和持续变化）作为职业发展的一部分。</p>
<p>沟通管理也经常被提及，这是一个被忽视但却很重要的成功因素，因为在这个领域中，对用户需求、软件需求和软件设计的精确理解是必要的。此外，组合管理(portfolio
management)是可取的，它提供了一个整体视图，包括各种项目和程序（集成项目）中正在开发的软件、已计划的软件，以及组织中已经在使用的软件。同时，软件复用可以成为维持和提高生产力和竞争力的关键因素。有效的复用需要战略愿景</p>
<p>和范围管理、项目时间/进度管理、项目成本管理、项目质量管理、项目资源/人力管理、项目沟通管理、项目风险管理、项目采购管理和项目干系人管理。每个知识领域都与本软件工程管理知识领域直接相关。本知识领域的参考文献和延伸阅读列表中也提供了额外信息。</p>
<p>本软件工程管理知识领域讨论了图9-1中前五个主题所示的软件项目管理过程（启动和范围定义、软件项目规划、软件项目实施、评审和评估、收尾），以及软件工程度量（图中第六个主题）9-4
<em>SWEBOK® GUIDE V4.0a</em></p>
<p><strong>软件工程管理</strong></p>
<p><strong>启动和范围定义</strong> | <strong>软件项目规划</strong> |
<strong>软件项目实施</strong> | <strong>软件评审和评估</strong> |
<strong>收尾</strong> | <strong>软件工程度量</strong> |
<strong>软件工程管理工具</strong></p>
<p>需求的确定和协商 | 规划过程 | 实施规划 | 确定满意度 | 确定并维持收尾
| 建立度量过程 | 收尾活动</p>
<p>可行性分析 | 承诺确定 | 软件获取和供应商合同管理 |
交付物评审和评估绩效 | 度量过程的实施和修订 | 度量过程</p>
<p>工作量、进度和成本估算 | 执行度量过程 | 过程监控 | 评估度量 |
过程控制 | 度量报告</p>
<p><strong>图9.1.</strong> 软件工程管理知识领域主题分解</p>
<p>和软件工程管理工具（第七个主题）。</p>
<p>不幸的是，软件行业的一个普遍认知是，软件产品经常延期交付、超出预算、质量差和功能不完整。基于度量的管理——任何真正工程学科的基本原则（参见工程基础知识领域中的度量）——可以帮助改善认知和现实。本质上，没有度量（定性和定量）的管理意味着缺乏纪律，而没有管理的度量意味着缺乏目的或背景。为了有效，软件工程师必须同时使用度量和管理。</p>
<p>这里采用以下工作定义：</p>
<p><em>• 管理</em>是实现组织设定的战略目标所需的过程和控制系统。</p>
<p><em>•
度量</em>是指为软件工程工作产品、过程和资源分配值和标签，以及从中派生的模型，无论这些模型是使用统计学还是其他技术开发的[3*,
c7, c8]。</p>
<p>本知识领域中的软件工程项目管理部分广泛使用了软件工程度量部分的内容。</p>
<p>本知识领域与<em>SWEBOK指南</em>中的其他知识领域密切相关；阅读以下知识领域描述将对理解本知识领域特别有帮助：</p>
<p>•
工程基础知识领域描述了一些直接应用于本知识领域软件工程度量部分的通用度量概念。此外，工程基础知识领域统计分析部分中介绍的概念和技术直接应用于本知识领域的许多主题。</p>
<p>• 软件需求知识领域描述了在项目启动和范围定义阶段应执行的活动。</p>
<p>•
软件配置管理知识领域处理软件配置的识别、控制、状态记录和审计，以及软件发布管理和交付和软件配置管理工具。</p>
<p>•
软件工程过程知识领域描述了软件生命周期模型以及过程和工作产品之间的关系。</p>
<p><a href="#软件工程管理">软件工程管理</a> 9-5</p>
<p>• 软件质量知识领域强调质量作为管理目标和许多软件工程活动的目标。</p>
<p>•
软件工程经济学知识领域讨论如何在业务环境中做出与软件相关的决策。</p>
<h2 id="软件工程管理主题分解">软件工程管理主题分解</h2>
<p>团队层面的领导力和协作，而高度预测性方法的管理风格更加正式（自上而下）。许多敏捷方法整合了不同的管理方法。</p>
<p>例如，Dev/Sec/Ops是一种文化和敏捷方法，用于现代软件交付，它将开发(Dev)、安全(Sec)和运维(Ops)团队整合成一个专注于持续、增量交付能力的集成团队。Dev/Sec/Ops的主要特征是这种方法</p>
<p>由于大多数软件开发生命周期(SDLC)模型需要类似的活动，这些活动可能以不同方式执行，因此图9-1所示的主题分解是基于活动的。图中显示的顶层元素是在管理软件开发项目时通常执行的活动，无论使用哪种SDLC模型(参见软件工程过程知识领域中的软件生命周期模型)。这种分解不推荐特定的生命周期模型。然而，重要的是要注意SDLC的选择会对程序活动产生影响，以适应不断变化的需求。</p>
<p>交付速度、持续适应和频繁的模块化升级以交付新功能通常是关键的业务差异化因素和项目管理的必要条件[11,
13]。这些必要条件应该与风险管理活动保持平衡。</p>
<p>已经开发和正在开发几种软件生命周期过程模型，以缩短开发周期来响应不断变化的业务需求，特别是不断变化的软件需求。这些过程中的大多数涉及敏捷(Agile)SDLC方法[14]。敏捷方法假设团队可以使用持续设计改进原则和基于快速反馈和变更的测试来开发高质量、适应性强的软件。相比之下，传统方法假设软件密集型系统是完全可指定和可预测的，可以通过细致而广泛的规划来构建。与敏捷方法相关的管理风格强调可行性研究报告、详细设计文档或工作原型。一些可交付成果对应于项目管理过程的一部分，而其他可交付成果则是构思项目所需的最终产品或最终产品的组件。可交付成果以及因此的阶段是通常顺序过程的一部分，旨在确保对项目的适当控制并获得所需的产品或服务，这是项目的目标。从项目管理的角度来看，阶段有助于完成项目目标并保持对项目的控制。</p>
<p>在DevSecOps中，自动化、持续监控并在软件生命周期的所有阶段应用安全：计划、开发、构建、测试、发布、交付、部署、运营和监控。在DevSecOps中，测试和安全通过自动化单元、功能、集成和安全测试向左移动。这是DevSecOps的一个关键差异化因素；安全/质量保证(QA)和其他非功能和功能能力同时进行测试和构建[11,
14]。DevSecOps包含能够快速、持续交付具有网络弹性的系统的文化和流程，而复杂的软件嵌入式系统可能有额外的需求，这些需求也必须集成到DevSecOps文化和流程中，例如安全性。将这些需求提升到与DevSecOps同等重要的位置，突出了将质量纳入所有程序方面的重要性。端到端DevSecOps工具的复杂性以及使用人工智能(AI)和机器学习(ML)等新兴技术来利用这些工具增加了另一个维度[15]。例如，敏捷和DevOps方法已经相当成熟，但在基于AI的软件情况下，可能需要新的SLDC来管理AI给软件带来的复杂性。</p>
<p>重要的是要理解阶段(phases)和活动(activities)之间的区别以及为什么使用活动分解。项目管理协会(PMI)这样描述阶段：“一个或多个可交付成果的完成和批准是项目阶段的特征。”可交付成果(deliverable)是可衡量的、可验证的工作产品，例如规范、</p>
<p>图9-1中基于活动的分解显示了发生了什么，但并不意味着每个活动何时、如何或发生多少次。七个主题如下：</p>
<ul>
<li>启动和范围定义，处理着手进行软件工程项目的决定</li>
<li>软件项目规划，涉及从管理角度为成功的软件工程项目做准备而进行的活动</li>
<li>软件项目实施，处理在软件工程项目执行期间发生的普遍接受的软件工程管理(SEM)活动</li>
<li>审查和评估，处理</li>
</ul>
<p><em>9-6 SWEBOK® GUIDE V4.0a</em></p>
<p>需求、范围、可行性和软件项目的授权。一旦确定了项目可行性，本节中的其余任务是指定软件需求并选择需求修订和审查的流程。</p>
<h2 id="11-需求的确定和协商-3-c3">1.1. 需求的确定和协商 [3*, c3]</h2>
<p>确定和协商项目需求是此阶段所进行任务的首要目标(参见软件架构知识领域和软件需求知识领域)。活动应包括软件需求审查(例如，启发、分析、规范和验证)。应考虑各个利益相关者的观点来选择和应用方法和技术。需求为软件项目的所有后续工作提供基础，并记录在项目章程或其他高层项目启动文档中。</p>
<h2 id="12-可行性分析-4-c5">1.2. 可行性分析 [4*, c5]</h2>
<p>可行性分析的目的是对项目目标进行清晰描述，并评估替代方法以确定拟议的项目解决方案是否</p>
<h1 id="软件工程管理-2">软件工程管理</h1>
<p>确保技术、进度、成本和质量工程活动令人满意[考虑到伦理、环境和社会技术因素]，这是在技术、资源、财务限制和变更条件下的最佳方法。</p>
<p>•
收尾(Closure)，解决为完成项目而完成的活动[项目范围说明、项目可交付成果、项目持续时间约束，以及所需资源的估算应该准备好]</p>
<p>• 软件工程度量(Software Engineering
Measurement)，处理软件工程组织中度量程序的有效开发和实施[资源(可以是组织内部或外部的)包括基础设施、支持，以及具备必要核心能力的人员]</p>
<p>• 软件工程管理工具(Software Engineering Management
Tools)，描述用于管理软件工程项目的工具的选择和使用。可行性分析通常[需要基于适当方法的工作量和成本估算]。(参见第2.3节，工作量、进度和成本估算)</p>
<p>初始工作分解结构(WBS)和上下文图可能在项目的启动和范围定义阶段活动中开发。</p>
<h2 id="1-启动和范围定义">1. 启动和范围定义</h2>
<p>项目启动侧重于审查软件需求并确定将工作分解为较小任务是一种常见的生产力技术，它使工作更易于管理和处理。</p>
<p><a href="#软件工程管理">软件工程管理</a> 9-7</p>
<p>作为使用此技术的项目工具，WBS是一个重要的项目管理文档。虽然WBS可用于组织成本和进度跟踪，但WBS本身不包括成本和进度基线。进度安排作为下一个活动(项目规划)(第2节)的一部分而开发。</p>
<p>工程上下文图定义了系统(或系统的一部分)与其环境之间的边界，显示与之交互的实体。本文档对于定义必须考虑的管理和技术接口以及权衡非常重要[1]。当工程师开发WBS时，他们应该将所有配置项视为需要控制的任务。</p>
<h3 id="13-需求审查和修订流程-3-c3">1.3. 需求审查和修订流程 [3*, c3]</h3>
<p>鉴于变更的不可避免性，利益相关者应就如何审查和修订需求和范围达成一致(例如，变更管理和权衡程序、迭代周期回顾)。(参见需求知识领域)这表明范围和需求不会”一成不变”，而是可以并且应该在项目展开时的预定点重新审视[基于一路发生的变更]。(参见主题5，收尾)。</p>
<p>(例如，在创建待办事项优先级或里程碑审查时)。如果接受变更，则应使用前向或后向可追溯性分析和风险分析来确定这些变更的影响。例如，后向可追溯性可能将测试脚本链接到其关联的需求和设计。此链接有助于监控需求满足的状态，并有助于做出停止测试的决策。它还有助于在需求和设计方面进行权衡。(参见第2.5节，风险管理，以及软件配置管理知识领域中的软件配置控制)</p>
<p>管理变更方法还可以作为在增量周期或整个项目收尾期间评估成功的基础。</p>
<h2 id="2-软件项目规划">2. 软件项目规划</h2>
<p>软件项目规划的关键步骤应该是选择适当的SDLC模型，并可能[基于项目范围、软件需求和风险评估对其进行裁剪]。<em>SWX</em>
[2]
指出，项目生命周期[占据从预测性到自适应的连续统一体]。[表征软件项目生命周期在连续统一体中位置的因素]包括(但不限于)需求和计划的各种处理方式[、风险和成本的管理方式]，以及关键利益相关者的参与。[高度预测性的软件项目生命周期强调]需求规范和详细计划[在项目的启动和规划阶段]。[基于已知架构、需求和约束的详细计划用于降低风险和成本。里程碑是计划好的，而不是持续的关键利益相关者参与]。[另一方面，高度自适应的软件项目生命周期的特征是]基于短迭代开发周期的渐进式需求规范。[通过初始计划的渐进演化来降低风险和成本，关键利益相关者持续参与][2]。</p>
<p>[要考虑的其他因素包括应用领域的性质]、功能和技术复杂性，以及软件[质量要求]。(参见软件质量知识领域中的软件质量要求)</p>
<p>[在所有SDLC中，风险评估应该是初始项目规划的一个要素]，并且[项目的”风险概况”应该由所有相关利益相关者讨论和接受]。<a href="参见软件质量知识领域中的软件质量管理流程">软件质量管理流程</a>[应该与项目规划一起规划。此规划应该为软件质量保证(SQA)、验证和确认、审查和审计建立程序和职责]。(参见软件质量知识领域)[持续审查和修订项目计划及相关计划的流程和职责也应该明确说明并达成一致]。</p>
<p>9-8 [<em>SWEBOK</em>][<em>®</em>][指南 V4.0a]</p>
<h3 id="21-流程规划">2.1. 流程规划</h3>
<h3 id="22-确定可交付成果-3-c4-c5-c6">2.2. 确定可交付成果 [3*, c4, c5,
c6]</h3>
<p>每个项目活动的工作产品(例如，[软件架构设计文档]</p>
<p>[3*, c3, c4, c5], [5*, c1] [检查报告、测试过的软件)应被]</p>
<p>识别和描述。评估从以前项目中</p>
<p>SDLC模型跨越从预测性到适应性的连续谱
[复用软件组件或使用现成软件产品]</p>
<p>系。(参见软件工程过程 [的机会。应规划软件采购]</p>
<p>KA中的软件生命周期 [和使用第三方开发交付物]</p>
<p>模型。)预测性SDLC的特点是 [并选择供应商。]</p>
<p>开发详细的软件架构 (参见第3.2节,软件获取和</p>
<p>和软件需求,详细的 供应商合同管理。)</p>
<p>项目规划,以及最少的</p>
<p>开发阶段之间的迭代规划。</p>
<p>适应性SDLC旨在适应 <strong>2.3. 工作量、进度和成本估算</strong></p>
<p>新出现的软件需求和</p>
<p>计划的迭代调整。高度预测性的 [估算这一主题在软件工程经济学KA中]</p>
<p>SDLC按照线性顺序执行 [进行了总体论述。]</p>
<p>图9-1中列出的前五个流程, [“什么是估算?”和]</p>
<p>仅在必要时才修订早期阶段。
[“为什么我们要估算?”等问题在那里得到解答。]</p>
<p>适应性SDLC的特点是 本节讨论与管理相关的</p>
<p>迭代开发周期。处于SDLC连续谱 估算主题。</p>
<p>中间范围的SDLC产生 [估算软件项目的成本是一个]</p>
<p>功能增量,要么按照 [易出错的过程。任何特定软件项目所需的工作量]</p>
<p>预先计划的进度(在连续谱的预测性一侧)
[几乎完全取决于人的因素:个人的经验]</p>
<p>或作为频繁更新的开发周期的产品 [和能力、团队成员的互动]</p>
<p>(在连续谱的适应性一侧)。 [以及软件开发环境的文化。]</p>
<p>知名的SDLC包括瀑布式、 [动态环境因素,]</p>
<p>增量式和螺旋式模型,以及各种 [如快速的技术演进、变化]</p>
<p>敏捷软件开发方法 [和新出现的需求,以及产品的无形]</p>
<p>[2, 11] [3*, c2]。 [性质,也显著影响]</p>
<p>相关方法(参见软件 成本管理。当存在如此多的</p>
<p>工程模型和方法KA)和 可变性时,估算成本是困难的,即使</p>
<p>工具应作为规划的一部分进行选择。 [有大量历史数据存在。软件]</p>
<p>应规划和获取将在整个 [项目经理应使用多种估算]</p>
<p>项目中使用的自动化工具。 方法,然后协调估算之间的差异[3, 10, 11]。</p>
<p>工具可能包括用于 [当数据可用时,可以使用基于历史规模和]</p>
<p>项目进度、软件需求、 [工作量数据的校准估算模型来确定项目]</p>
<p>软件设计、软件构建、软件 [或项目部分所需工作量的估算范围。]</p>
<p>维护、软件配置 [最好同时使用自下而上的]</p>
<p>管理、软件工程过程 [估算技术,该技术基于将完成工作的人员的估算和]</p>
<p>和软件质量等的工具。许多 基于类似项目的历史数据[2]。</p>
<p>这些工具应主要基于 [可以建立任务依赖关系,并]</p>
<p>其他KA中讨论的技术考虑因素 [识别和记录并发和顺序完成任务的]</p>
<p>进行选择,但其中一些问题 潜在机会,</p>
<p>与本章讨论的管理考虑因素 例如使用甘特图。</p>
<p>密切相关。 在预测性SDLC项目中,</p>
<p><a href="#软件工程管理">软件工程管理</a> 9-9</p>
<p>带有预计开始时间、持续时间和结束时间的</p>
<p>预期任务进度通常在规划期间 [使用,以及与人员相关的问题(例如,]</p>
<p>产生。在适应性 个人和团队的生产力、团队</p>
<p>SDLC项目中,通常根据 动态和团队结构)。</p>
<p>对需求的初步理解开发</p>
<p>工作量和进度的总体估算,或者 <strong>2.5. 风险管理</strong> [3*, c9]
[5*, c5]</p>
<p>可以指定总体工作量和</p>
<p>进度的约束条件,并用于确定 [风险和不确定性是相关但不同的]</p>
<p>初始迭代周期数的估算 [概念。不确定性源于缺乏]</p>
<p>以及分配给每个周期的工作量和其他 [信息。风险是不确定性对]</p>
<p>资源的估算。 [目标的影响,对目标具有负面(威胁)或正面]</p>
<p>资源需求(例如, [(机会)后果。]</p>
<p>所需人员和工具)通常可以 [风险管理包括识别风险]</p>
<p>转换为成本估算。工作量、 [因素、分析每个风险因素的概率和潜在]</p>
<p>进度和成本的估算是一个迭代
[影响、对风险因素进行优先级排序,以及制定风险缓解策略]</p>
<p>活动,应在受影响的利益相关者之间 略以降低负面</p>
<p>进行协商和修订,直到 [事件的概率并最小化风险因素]</p>
<p>就项目完成所需的资源和时间 成为问题时的负面影响。风险管理</p>
<p>达成共识。程序 数据可用于表示</p>
<p>经理经常使用一个将四种 项目风险概况(profile);该数据通常是</p>
<p>关联角色类型联系起来的模型:负责人、责任人、
风险登记册的一部分。风险登记册是一个</p>
<p>用作风险管理工具的文档。它可以用于</p>
<p>[满足监管合规性,作为]</p>
<p>[所有已识别风险及其他风险的存储库]</p>
<p>可以参考、咨询和告知(即
RACI)来促进这个过程。负责角色生产可交付成果;问责角色检查可交付成果;咨询角色就任务提供建议;告知角色在整个过程中保持知情状态。项目经理应持续监控利益相关者需求及其演变变化,以分析其对项目成本和进度的影响。这在敏捷软件开发项目中通常更为重要,因为利益相关者需求是动态的,随着项目推进可能会快速发生变化。</p>
<h3 id="24-资源分配-3-c5-c10-c11">2.4. 资源分配 [3*, c5, c10, c11]</h3>
<p>设备、设施和人员应分配给已识别的任务,包括分配完成各种项目要素和整个项目的责任。可以使用矩阵来显示谁对每项任务负责、问责、咨询和告知。资源分配基于资源的可用性及其最优组织,并受其约束。</p>
<h3 id="26-质量管理-3-c4-4-c2">2.6. 质量管理 [3*, c4] [4*, c2]</h3>
<p>根据《PMBOK®指南》,项目质量管理包括执行组织的过程和活动,这些过程和活动确定质量政策、目标和职责,使项目能够满足其启动所需的需求。本节讨论管理软件项目质量的其他注意事项[1]。</p>
<p>软件项目的软件质量需求及相关工作产品应被识别,可能包括定量和定性两方面。软件的质量属性包括但不限于安全性、保密性、可靠性、可用性、性能、易用性和易修改性。《SWEBOK指南》第1.9节列出了对软件用户重要的质量属性(例如效率、安全性、保密性、可靠性、可用性)以及对软件开发人员和维护人员重要的质量属性(例如可维护性对提供维持服务的人员很重要)[1]。ISO/IEC
25000系列标准提供了与不同利益相关者需求相符的软件质量属性的详细列表[2]。这种一致性符合ISO/IEC/IEEE
15939和实用软件与系统度量(PSM)[2, 9.11]。</p>
<p>系统功能的大部分正从硬件转向软件,以利用软件可以提供的更高灵活性和更快的组件交付速度。然而,这些好处也带来了其他挑战——例如,需要在整个软件开发生命周期(SDLC)中加强软件质量需求(如网络安全)的管理[11]。应根据利益相关者的需求和期望,为每个软件质量需求设定可接受的质量度量阈值。在整个开发过程中与持续软件质量保证(SQA)和质量改进有关的程序,以及验证和确认可交付软件的程序都应被建立。</p>
<h3 id="27-计划管理-3-c4">2.7. 计划管理 [3*, c4]</h3>
<p>除了较早的预测型项目外,在管理大多数软件项目时,记录和管理正式计划的重要性正在降低(例如,文档计划很少使用,特别是当使用基于模型的系统工程(MBSE)进行产品数据管理时)。话虽如此,在使用这些计划的地方,当预期会发生变化时,应为软件项目制定和管理计划。计划工作的规模和计划的内容应部分由不制定计划的风险来决定。项目计划的管理本身应该被规划。为软件开发选择的计划和流程应系统地进行监控、审查、报告,并在适当时进行修订。与支持流程相关的计划(例如文档编制、软件配置管理和问题解决)也应该被管理。报告、监控和控制项目应适应所选的SDLC和项目的实际情况。计划应考虑将用于管理项目的各种工件。</p>
<p>预测型生命周期软件项目的项目经理会在项目计划的前期开发以及整合来自其他组织单位支持人员开发的辅助计划(例如,项目管理办公室(PMO)中的估算专家)方面投入大量精力。</p>
<p>在其他类型的项目(例如适应型项目)中,通常不使用正式计划,重点应放在选择和保留对项目控制和未来项目有用的项目信息,以及建立战略、政策和程序上。例如,在适应型项目中,管理者通常在前期花费较少精力来制定详细的范围、成本和进度计划。但通常会在其他方面投入大量精力。</p>
<p>关于每个风险的附加信息[2]。风险评估方法(例如专家判断、历史数据、决策树和流程模拟)有时可以用于识别和评估风险因素。</p>
<p>项目放弃条件也可以与所有相关利益相关者一起确定。软件特有的风险方面,如软件工程师倾向于添加不需要的功能或与软件无形性质相关的风险,可以影响软件项目的风险管理。应特别注意管理与软件质量需求相关的风险,如安全性或保密性[11]。(参见软件质量知识领域。)风险管理不仅应在项目开始时进行,而且应在整个项目生命周期的定期间隔进行。</p>
<p>软件产品也应该在质量规划期间明确说明监控和控制的方式(例如，技术过程，如需求追溯、评审和检查或已完成功能的演示)。(参见软件质量知识领域。)[以确保项目成员或团队之间的协调，因为新兴的计划正在实施][2]。</p>
<p><a href="#软件工程管理">软件工程管理</a> 9-11</p>
<p><strong>3. 软件项目执行</strong></p>
<p>[不同的软件获取类别包括商业现货(COTS)软件——从其他软件供应商处”按原样”获取的现有产品，具有适用的许可条款；专门为组织开发的软件——通常是由另一方承包开发的，有时是COTS软件的定制版本；开源软件——名义上是免费的，尽管组织可能会购买增强的支持或维护，并且必须审查许可证以了解使用限制；客户租借的软件——通常用于提供与其他系统元素的仿真或集成；软件即服务(SaaS)——可能包括组织租用以满足特定需求的软件(例如，基于云的托管、源代码控制或开发环境)。]</p>
<p>在软件项目实施(也称为<em>项目执行</em>)期间，计划得以执行，计划中体现的过程得以实施。在整个过程中，应重点关注对所选软件开发生命周期(SDLC)过程的遵守，并且应该期望遵守这些过程将满足利益相关者的需求并实现项目目标。</p>
<p>实施的基础是持续的管理活动，包括监控、控制和报告。</p>
<p><em>3.1. 计划的实施</em> [4*, c2]</p>
<p>项目活动应遵循项目计划和支持计划。项目活动使用资源(人员、技术和资金)并生成工作产品(软件设计、软件代码和软件测试用例)。</p>
<p><em>3.2. 软件获取和供应商合同管理</em> [3*, c3, c4]</p>
<p>软件获取和供应商合同管理涉及与软件开发组织的客户(他们获取可交付工作产品)以及向软件工程组织提供产品或服务的供应商签订合同的问题。</p>
<p>[软件项目通常使用不同的获取方法来获得必要的软件组件。然而，无论如何获得软件组件，都应执行以下活动：验证每个组件在架构设计和该组件的软件需求方面是完整、正确和一致的；集成这些组件；验证集成的组件在架构设计和软件需求方面是正确、完整和一致的；以及验证集成的组件在其预期的操作环境中使用时将满足其预期目的。]</p>
<p>软件获取是软件开发项目中的常见做法，集成开发环境(IDEs)和包库允许软件工程师通过最少的步骤获取第三方库，从而便于评估风险、合法性和适用性。</p>
<p>然而，软件不再仅仅通过复杂的供应链流程和采购路线作为收缩包装产品获取。获取软件的便利性导致了常见的攻击面，并引发了安全漏洞。组织应考虑引入技术或程序控制措施，以最小化对外部库存储库的未过滤访问可能带来的风险。</p>
<p>[不同的获取方法(用于获取软件组件)需要不同的项目管理方法。例如，定制开发需要详细规划软件开发人员的数量和技能、组织开发团队、向团队分配需求、指定要收集的项目指标、监控进度，以及在实际进度与计划进度不符时采取纠正措施。许可组件涉及评估候选组件；选择合适的组件；以及为所选组件协商条款、条件和交付日期。]</p>
<p>9-12 [<em>SWEBOK</em>][<em>®</em>][指南 V4.0a]</p>
<p>这可能涉及选择合适的合同，例如固定价格、工时和材料、成本加固定费用以及成本加激励费用。与客户和供应商的协议通常会规定工作范围和可交付成果。协议还可以包括特殊条款，例如规定延迟交付或未交付的罚款条款，以及规定供应商提供什么、采购方支付什么以及将交付给采购方并由采购方拥有什么的知识产权协议。</p>
<p>对于由供应商开发的软件(包括软件工程组织内部和外部的供应商)，应确保所需特性(例如，通过检查或演示工作功能)。应分析工作量支出、进度遵守情况、迄今为止的成本和资源使用情况。应重新审视项目风险概况(参见第2.5节，风险管理)，并应评估对软件质量需求的遵守情况(参见软件质量知识领域中的软件质量需求)。</p>
<p>[应分析测量数据。(参见工程基础知识领域中的统计分析。)应进行方差分析以确定实际]</p>
<p>development organization），协议通常会确定软件质量要求。</p>
<p>在与供应商的软件合同中，数据集获取通常很重要。它包括从外部供应商或合作伙伴获取特定数据集的过程，作为软件开发项目或服务协议的一部分。这可能发生在各种场景中，例如：数据许可协议、数据提供、定制数据获取和数据集成服务。</p>
<p>协议签订后，应管理项目执行，使其符合协议条款。（有关此主题的更多信息，请参阅第12章，<em>PMBOK®
指南的软件扩展</em>（<em>SWX</em>），软件采购管理 [2]。）</p>
<p><em>3.3. 测量过程的实施</em> [3*, c7]</p>
<p>应在软件项目期间执行测量过程，以确保收集相关和有用的数据。（参见6.2节，计划测量过程，和6.3节，执行测量过程。）</p>
<p><em>3.4. 监控过程</em> [3*, c8]</p>
<p>应持续评估对范围、项目计划和相关计划的遵守情况，并在预定的时间间隔进行评估。还应评估每项任务的输出和完成标准。应评估可交付成果与预期结果和价值的偏差。此分析可能会检查成本超支、进度延误或其他指标。应执行异常值识别和质量及其他测量数据的分析（例如，缺陷分析）。（参见软件质量知识领域中的软件质量测量。）应重新计算风险暴露。（参见2.5节，风险管理。）这些活动可以基于超出的阈值进行问题检测和异常识别。应根据需要或当阈值超出时报告结果。例如，及时识别、缓解和解决超出预期的软件安全漏洞和弱点可能会影响系统的安全态势
[11]。</p>
<p><em>3.5. 控制过程</em> [3*, c7, c8]</p>
<p>项目监控活动为制定决策提供基础。在适当的情况下，当风险因素的概率和影响被理解时，可以对项目进行更改。这可能采取纠正措施的形式（例如，重新测试某些软件组件）。它可能涉及合并额外的行动（例如，决定使用原型设计来协助软件需求验证；参见软件需求知识领域中的原型设计）。它还可能需要修订项目计划和其他项目文档（例如，软件需求规格说明），以适应未预料的事件及其影响。</p>
<p><a href="#软件工程管理">软件工程管理</a> 9-13</p>
<p>在某些情况下，控制过程可能导致项目放弃。在所有情况下，软件开发团队应遵守软件配置控制和软件配置管理程序。（参见软件配置管理知识领域。）应记录决策并传达给所有相关方，必要时应重新审视和修订计划，并应记录相关数据。（参见6.3节，执行测量过程。）</p>
<p><em>3.6. 报告</em> [3*, c11]</p>
<p>应在组织内部（例如，向项目指导委员会）和外部利益相关者（例如，客户或用户）指定和商定的时间报告迄今为止的进展。报告应关注目标受众的信息需求，而不是项目团队内部的详细状态报告。</p>
<p><strong>4. 软件审查和评估</strong></p>
<p>在预先指定的时间和需要时，应评估朝着既定目标的总体进展以及利益相关者（用户和客户）需求的满意度。同样，也应定期并根据情况需要对软件过程、相关人员以及所使用的工具和方法的有效性进行评估。</p>
<p><em>4.1. 确定需求满意度</em> [4*, c8]</p>
<p>实现利益相关者满意是软件工程经理的主要目标。应定期评估朝向此目标的进展。应识别需求的满足情况和偏离预期结果的情况，并应采取适当的行动。</p>
<p>如同上述控制过程活动（参见3.5节，控制过程），应遵循软件配置控制和软件配置管理程序（参见软件配置管理知识领域）。应记录决策并传达给所有相关方；必要时应重新审视和修订计划；应记录相关数据（参见6.3节，执行测量过程）。</p>
<p><em>4.2. 审查和评估绩效</em> [3*, c8, c10]</p>
<p>项目人员的定期绩效审查可以提供对计划和流程遵守可能性以及可能的困难领域（例如，团队成员冲突）的洞察。应评估各种项目方法、工具和技术的有效性和适当性。还应系统地定期评估项目过程的相关性、实用性和效力。在适当的情况下，应进行和管理项目变更。</p>
<p><strong>5. 收尾</strong></p>
<p>当所有计划和流程已被执行和完成时，整个项目、主要项目阶段或迭代开发周期即达到收尾。然后应评估项目、阶段或迭代成功的标准。一旦确定收尾，就可以执行归档、回顾和过程改进活动。</p>
<p><em>5.1. 确定收尾</em> [1, s3.7, s4.6]</p>
<p>当指定的任务完成时即发生收尾。</p>
<p>在实现项目、阶段或迭代的主要里程碑时（例如，完成软件设计架构或完成软件技术评审），或在完成产生产品增量的迭代开发周期时进行评估。软件过程的偏差应涉及相关利益相关者，并记录相关利益相关者的接受情况；任何已知问题都应记录在案。</p>
<p>已经完成，并且已确认完成标准的令人满意的实现。软件需求可以确认为已满足或未满足，并且可以确定实现目标的程度。关闭活动</p>
<p>本节遵循 ISO/IEC/IEEE 15939 标准
[6]，该标准描述了定义实施软件测量过程所需的活动和任务的过程。该标准还包括一个测量信息模型。PSM
持续迭代开发测量框架报告中的这个模型也针对 SDLC 方法进行了详细阐述
[9]。</p>
<p><strong>5.2. 关闭活动</strong> [2, s3.7, s4.8]</p>
<p>在确认关闭后，项目材料应根据利益相关者商定的归档规则进行归档，这些规则涉及归档方法、位置和持续时间——可能包括销毁敏感信息、软件以及副本所在的介质。例如，这些规则可能要求在关闭期间，在物理处置设备之前，从包含相关信息的任何设备中删除和销毁所有数据（例如，个人计算机、服务器、大型机、个人数字助理
(PDA)、路由器、防火墙、交换机、磁带、软盘、CD、DVD、手机、打印机、通用串行总线
(USB) 数据存储设备的硬盘驱动器）。</p>
<p>组织的测量数据库应使用相关项目数据进行更新。应进行项目、阶段或迭代回顾分析，以便分析遇到的问题、问题、风险和机会。（参见主题
4，评审和评估。）应从项目中吸取经验教训，并将其纳入组织学习和改进工作中。</p>
<h2 id="6-软件工程测量">6. 软件工程测量</h2>
<p>软件工程测量对于良好的管理和工程实践的重要性已得到广泛认可。（参见工程基础知识领域中的测量。）有效的软件工程测量已成为组织成熟度的基石之一。</p>
<p>测量可以应用于组织、项目、过程和工作产品。本节重点介绍在项目、过程和工作产品级别应用测量。</p>
<p><strong>6.1. 建立和维持测量承诺</strong> [7*, c1, c2][1]</p>
<p>•
建立测量需求。每项测量工作都应以组织目标为指导，并由组织和项目建立的一组测量需求驱动（例如，组织目标可能是率先进入市场）。</p>
<p>•
建立测量范围。项目团队应建立每个测量需求要应用到的组织单元。这可能是一个职能领域、一个单独的项目、一个单独的站点或整个企业。还应考虑测量工作的时间范围，因为可能需要某些测量的时间序列（例如，校准估算模型）。（参见第
2.3 节，工作量、进度和成本估算。）</p>
<p>• 建立团队对测量的承诺。承诺应正式建立、传达并由资源支持。</p>
<p>•
投入测量资源。组织对测量的承诺是成功的关键因素，这体现在为实施测量过程分配资源上。分配资源包括分配测量过程各项任务的责任（例如分析师和管理员）。还应分配足够的资金、培训、工具和支持来执行该过程。</p>
<p><strong>6.2. 规划测量过程</strong> [7*, c1, c2][1]</p>
<p>•
描述组织单元的特征。组织单元为测量提供了背景，因此组织背景应该是明确的，包括组织对测量过程的约束。特征描述可以用组织过程、应用领域、技术、组织接口和组织结构来表述。</p>
<p>•
识别信息需求。信息需求基于组织单元的目标、约束、风险和问题，可能来自业务、</p>
<p>影响评估标准。信息产品包括与生产的产品相关的产品以及与用于管理和测量项目的过程相关的产品。</p>
<p>•
为测量任务提供资源。适当的利益相关者应审查和批准测量计划，包括所有数据收集程序；存储、分析和报告程序；评估标准；时间表；和责任。审查这些工件的标准应在组织单元级别或更高级别建立，并应作为这些审查的基础。此类标准应考虑经验、资源可用性以及当提出与当前实践不同的变更时对项目的潜在干扰。批准表明了承诺。</p>
<p>[1] 这两章可以从 http://www.psmsc.com/PSMBook.asp 免费下载。</p>
<p>组织、监管和/或产品目标。利益相关者应识别、优先排序、记录、沟通并审查这些需求。</p>
<p>o
确定可用于实施计划和批准的测量任务的资源。在试点部署之前进行广泛部署的情况下,资源可用性可能是分阶段的。考虑成功部署新程序或测量所需的资源。</p>
<p>•
选择测量指标。选择候选测量指标,并明确与信息需求的关联。基于信息需求的优先级和其他标准选择测量指标,例如收集成本、收集期间对流程的干扰程度、获取准确一致数据的难易程度,以及分析和报告的难易程度。</p>
<p>o
获取并部署支持技术。这包括评估可用的支持技术、选择最合适的技术、获取这些技术并部署这些技术。</p>
<p>内部质量特征(参见软件质量KA中的模型和质量特征)通常不包含在合同约束的软件需求中。因此,考虑测量软件的内部质量,以提供可能影响外部利益相关者的潜在问题的早期指标。</p>
<p><em>6.3. 执行测量过程</em> [7*, c1, c2]</p>
<p>•
定义数据收集、分析和报告程序。这包括收集程序和计划、存储、验证、分析、报告和数据配置管理。</p>
<p>将测量程序与相关软件过程集成。测量程序(如数据收集)应与它们测量的软件过程集成。这可能涉及更改当前软件过程以适应数据收集或生成活动。它还可能涉及分析当前软件过程以最小化额外工作,并评估对员工的影响以确保测量程序的接受度。考虑士气问题和其他人为因素。此外,将测量程序传达给提供数据的人员。可能还需要培训和支持。数据分析和报告程序通常以类似方式集成到组织和项目过程中。</p>
<p>•
选择评估信息产品的标准。组织单元的技术和业务目标以及收益,并报告适当的改进措施。</p>
<p>收集数据。应收集和分析测量数据。应收集、验证和存储数据。收集有时可以通过使用SEM工具(参见主题7,软件工程管理工具)来自动化,以分析数据和生成报告。作为分析的一部分,数据可能被聚合、转换或记录,使用与数据性质和信息需求相适应的严格程度。该分析通常生成图表、数字或其他指标,为向利益相关者呈现的结论和建议提供信息。(参见工程基础KA中的统计分析。)使用组织的正式或非正式流程审查结果和结论。数据提供者和测量用户应参与审查数据,以确保数据有意义、准确,并可导致合理的行动。</p>
<p>将建议的改进措施传达给测量过程所有者和利益相关者进行审查和批准。此外,如果分析未能识别任何改进措施,则传达缺乏潜在改进的情况。</p>
<p>传达结果。记录信息产品并将其传达给用户和利益相关者。</p>
<p><strong><em>7.</em></strong> <strong>软件工程管理工具</strong> [3*,
c5, c6, c7]</p>
<p><em>6.4. 评估测量</em> [7*, c1, c2]</p>
<p>SEM工具通常用于提供SEM过程的可见性和控制。一些工具是自动化的,而另一些是手动实现的。此外,最近出现了一种趋势,即在整个项目中使用集成的软件工程工具套件来计划、收集和记录、监控和控制以及报告项目和产品信息。工具可以分为以下几类:</p>
<p>根据指定的评估标准评估信息产品和测量过程,并确定信息产品或过程的优势和劣势。内部过程或外部审计可用于执行评估,包括来自测量用户的反馈。在适当的数据库中记录经验教训。</p>
<p><em>项目规划和跟踪工具</em>。项目规划和跟踪工具可用于估算项目工作量和成本,并准备项目进度表。例如,一些项目使用自动化估算工具,该工具使用软件产品的估算大小和其他特征作为输入,然后估算所需的总工作量、进度和成本。规划工具还包括自动化调度工具,该工具分析WBS任务、它们的估算持续时间、它们的优先关系以及分配给每个任务的资源,以生成甘特图。</p>
<p>识别潜在改进。此类改进应通过使用适当的数据库来记录。</p>
<p>跟踪工具可用于跟踪项目里程碑、定期安排的项目状态会议、计划的迭代周期、产品演示和行动项。</p>
<p><em>风险管理工具</em>。风险管理工具(参见第2.5节,风险管理)可用于跟踪风险识别、分析和监控。这些工具包括模拟或决策树,用于分析成本与收益的影响以及风险事件概率的主观估计。例如,蒙特卡洛模拟工具可以</p>
<p>改进可能包括指标格式的变化、测量单位的变化或测量类别的重新分类。确定潜在改进的成本。</p>
<p><strong>沟通工具。</strong>
沟通工具可以帮助向项目相关的利益相关者提供及时且一致的信息。此类工具的示例包括向团队成员和利益相关者发送电子邮件通知和广播；定期传达会议纪要；以及显示进度、待办事项和维护请求解决情况的图表。</p>
<p><strong>测量工具。</strong>
测量工具支持与软件测量计划相关的活动。（参见主题6，软件工程测量。）此类别中几乎没有完全自动化的工具。用于收集、分析和报告项目测量数据的测量工具可能基于项目团队成员或组织员工开发的电子表格。</p>
<h2 id="主题与参考资料对照表-1">主题与参考资料对照表</h2>
<table>
<colgroup>
<col style="width: 20%"/>
<col style="width: 20%"/>
<col style="width: 20%"/>
<col style="width: 20%"/>
<col style="width: 20%"/>
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Fairley 2009 [3*]</strong></th>
<th><strong>Sommerville 2016 [4*]</strong></th>
<th><strong>Boehm and Turner 2003 [5*]</strong></th>
<th><strong>McGarry et al. 2001 [7*]</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 启动和范围定义</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.1. 需求的确定和协商</em></td>
<td>c3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.2. 可行性分析</em></td>
<td>c4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.3. 需求审查和修订过程</em></td>
<td>c3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2. 软件项目规划</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.1. 过程规划</em></td>
<td>c2, c3, c4, c5</td>
<td>c1</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.2. 确定可交付成果</em></td>
<td>c4, c5, c6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.3. 工作量、进度和成本估算</em></td>
<td>c6</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.4. 资源分配</em></td>
<td>c5, c10, c11</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.5. 风险管理</em></td>
<td>c9</td>
<td>c5</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.6. 质量管理</em></td>
<td>c4</td>
<td>c24</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.7. 计划管理</em></td>
<td>c4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3. 软件项目执行</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.1. 计划实施</em></td>
<td>c2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.2. 软件采购和供应商合同管理</em></td>
<td>c3, c4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.3. 测量过程实施</em></td>
<td>c7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.4. 过程监控</em></td>
<td>c8</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.5. 过程控制</em></td>
<td>c7, c8</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.6. 报告</em></td>
<td>c11</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>4. 审查和评估</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.1. 确定需求满足情况</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.2. 审查和评估绩效</em></td>
<td>c8, c10</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>5. 收尾</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.1. 确定收尾</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.2. 收尾活动</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>6. 软件工程测量</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.1. 建立和维持测量承诺</em></td>
<td></td>
<td></td>
<td></td>
<td>c1, c2</td>
</tr>
<tr>
<td><em>6.2. 规划测量过程</em></td>
<td></td>
<td></td>
<td></td>
<td>c1, c2</td>
</tr>
<tr>
<td><em>6.3. 执行测量过程</em></td>
<td></td>
<td></td>
<td></td>
<td>c1, c2</td>
</tr>
<tr>
<td><em>6.4. 评估测量</em></td>
<td></td>
<td></td>
<td></td>
<td>c1, c2</td>
</tr>
<tr>
<td><strong>7. 软件工程管理工具</strong></td>
<td>c5, c6, c7</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="延伸阅读-2">延伸阅读</h2>
<p><em>A Guide to the Project Management Body of Knowledge</em>
(<em>PMBOK</em>® <em>Guide</em>) [1]。</p>
<p><em>PMBOK</em>® <em>Guide</em>
为管理单个项目提供指南，并定义了项目管理相关概念。它还描述了项目管理生命周期及其相关过程，以及项目生命周期。它是全球公认的项目管理专业指南。</p>
<p><em>Software Extension to the Project Management Body of
Knowledge</em> (<em>PMBOK</em>®) <em>Guide</em> [2]。</p>
<p><em>SWX</em> 为 <em>PMBOK</em>® <em>Guide</em>
中记录的项目管理通用实践提供了针对软件项目管理的改编和扩展。该扩展对
<em>PMBOK</em>® <em>Guide</em>
的主要贡献是描述了管理自适应生命周期软件项目的过程。</p>
<p><em>IEEE Standard Adoption of ISO/IEC 15939</em> [6]。</p>
<p>该国际标准定义了一个过程，支持定义合适的测量来满足特定的信息需求。它确定了在整体项目或组织测量结构中成功识别、定义、选择、应用和改进测量所需的活动和任务。</p>
<p>J. McDonald, <em>Managing the Development of Software Intensive
Systems</em>, Wiley, 2010 [8]。</p>
<p>本教材为初学者介绍软件和硬件开发的项目管理，还为经验丰富的项目管理者提供了独特的高级材料。书中包含了规划和管理大型软件项目以及复杂软件和硬件系统的验证和确认的案例研究，以及用于监控项目状态的检查结果和测试指标。</p>
<h2 id="参考文献-7">参考文献</h2>
<p>[1] Project Management Institute, <em>A Guide to the Project
Management Body of Knowledge (PMBOK® Guide)</em>, 6th ed., Newton
Square, PA: Project Management Institute, 2017.</p>
<p>[2] <em>Software Extension to the Project Management Body of
Knowledge (PMBOK® Guide)</em>, Fifth Edition, Project Management
Institute, 2013.</p>
<p>[3*] R. E. Fairley, <em>Managing and Leading Software Projects</em>.
Hoboken, NJ: Wiley IEEE Computer Society Press, 2009.</p>
<p>[4*] I. Sommerville, <em>Software Engineering</em>, 10th ed., New
York: Addison-Wesley, 2016.</p>
<p>[5*] B. Boehm and R. Turner, <em>Balancing Agility and Discipline: A
Guide for the Perplexed</em>. Boston: Addison-Wesley, 2003.</p>
<p>[6] IEEE, <em>IEEE Standard Adoption of ISO/IEC 15939: 2007 Systems
and Software Engineering Measurement Process</em>, ed:</p>
<p>[7*] McGarry et al., <em>Principles, and Measures</em>, Version 2.1,
15 April 2021.</p>
<p>[10] S. Sheard, M. Bouyaud, M. Osaisai, J. Siviy, and K. Nidiffer,
<em>“Book Club” Guides a Working Group to Create INCOSE System-Software
Interface Products</em>, <em>INSIGHT</em>, Volume 24, Issue 2, 2021.</p>
<p>[11] K. Nidiffer, C. Woody, and T.A. Chick, <em>Program Manager’s
Guidebook for Software Assurance, Special Report</em>,
CMU/SEI-2018-SR-025, Software Solutions and CERT Divisions, Software
Engineering Institute/Carnegie Mellon University, August 2018.</p>
<p>[12] R.E. Fairley, <em>Systems Engineering of Software-Enabled
Systems</em>, ISBN 978-1-</p>
<p>IEEE, 2017. 119-53501-0, 2019.</p>
<p>[7] J. McGarry et al., <em>Practical Software</em> [13] Defense
Innovation Board, <em>Software Is</em></p>
<p><em>Measurement: Objective Information</em> <em>Never Done:
Refactoring the Acquisition</em></p>
<p><em>for Decision Makers</em>, Addison-Wesley <em>Code for Competitive
Advantage Defense</em>,</p>
<p>Professional, 2001. v3.3, March 12, 2019.</p>
<p>[8] J. McDonald, <em>Managing the</em> [14] “DevOps: Building
Reliable and Secure</p>
<p><em>Development of Software-Intensive</em> Systems Including
Application Build,</p>
<p><em>Systems</em>. Hoboken, NJ: John Wiley and Package, and
Deployment,” <em>IEEE</em></p>
<p>Sons, Inc., 2010. <em>Standard</em>, 2675-2021, 2021.</p>
<p>[9] <em>Practical Software and Systems</em> [15] M. Chemuturi and T.
Cagley, <em>Mastering</em></p>
<p><em>Measurement Continuous Iterative</em> *Software Project
Management: Best</p>
<p>Development Measurement Framework* <em>Practices, Tools and
Techniques</em>, J. Ross</p>
<p><em>Parts 1-3: Concepts, Definitions,</em> Publishing, July 2010.</p>
<h2 id="第10章"><strong>第10章</strong></h2>
<p>软件工程过程</p>
<p><strong>缩略语</strong></p>
<p>BPMN 业务流程建模符号(Business Process Modeling Notation)</p>
<p>CASE 计算机辅助软件工程(Computer-Aided Software Engineering)</p>
<p>CMM 能力成熟度模型(Capability Maturity Model)</p>
<p>CMMI 能力成熟度模型集成(Capability Maturity Model Integration)</p>
<p>GQM 目标-问题-度量(Goal-Question-Metric)</p>
<p>IDEF0 集成定义0(Integration Definition 0)</p>
<p>PDCA 计划-执行-检查-行动(Plan-Do-Check-Act)</p>
<p>SLCM 软件生命周期模型(Software Life Cycle Model)</p>
<p>SLCP 软件生命周期过程(Software Life Cycle Process)</p>
<p>UML 统一建模语言(Unified Modeling Language)</p>
<p><strong>引言</strong></p>
<p>本章从几个角度探讨软件工程过程：概念、生命周期和软件工程过程评估。软件工程社区在软件工程过程的许多方面的标准化工作中非常活跃。</p>
<p><strong>软件工程过程的主题分解</strong></p>
<p>软件工程过程知识领域的主题分解如图10.1所示。</p>
<p><strong>1. 软件工程过程基础</strong></p>
<h3 id="11-引言-1c513">1.1 引言 [1,c5],[13]</h3>
<p>软件工程过程涉及软件工程师为构建和操作软件而进行的工作活动。当软件工程学科出现时,科学家、工程师和技术人员必须审视现有学科以理解软件工程过程的范围。工程过程由一组相互关联的活动组成,这些活动在消耗资源完成转换的同时,将一个或多个输入转换为输出。作为工程的一部分,软件工程使用与其他类型工程相似的过程。当工程师创建设备或其他产品时,他们会经历各个步骤,投入大量的设计工作,依赖大量的知识储备,同时在执行过程和创建产品时获得知识,即学习。</p>
<p>从20世纪60年代开始并持续到70年代,工程设计和制造提供了基线——一个基础——为后来成为新学科的发展奠定了基础。在那些年里,人们认同构建软件的过程应该被分解为可以包括设计和制造,以及后来的操作的过程。构建软件系统所需的一些过程属于设计类别,其他则属于制造类别。如今,软件工程社区仍在学习,因此仍在改进软件工程过程。目前,关于构建软件系统需要大量设计和学习工作,这些工作聚焦于正在构建的产品和过程本身,已经形成了广泛共识。正如下文所述,</p>
<p><strong>软件工程过程</strong></p>
<figure>
<img alt="软件工程过程" src="media/image-001.png"/>
<figcaption aria-hidden="true">软件工程过程</figcaption>
</figure>
<p><strong>软件工程过程基础</strong> | <strong>生命周期</strong> |
<strong>软件过程评估和改进</strong></p>
<p>引言 | 生命周期的基本原理 | 评估和改进</p>
<p>过程定义 | 生命周期定义、过程 | 全局问题度量(GQM)方法</p>
<p>过程和生命周期模型的概念 | 框架基础方法 | 类别和术语</p>
<p>开发范式的一些模式 | 敏捷中的改进 | 软件过程概述</p>
<p>生命周期模型 | 过程评估和改进</p>
<p>开发生命周期模型及其工程维度 |</p>
<p>SLCP的管理 |</p>
<p>软件工程过程管理 |</p>
<p>软件生命周期适应 |</p>
<p>实践考虑 |</p>
<p>软件过程基础设施、工具、方法 |</p>
<p>软件工程过程监控及其与软件产品的关系 |</p>
<p><strong>图10.1.</strong> 软件工程过程知识领域的主题分解</p>
<p>不存在理想的过程或过程集合：软件过程必须根据每个项目和每个组织环境适当地选择、调整和应用。软件工程过程管理必须得到实证度量的支持,这一点至关重要。</p>
<p>项目的概念作为”具有明确开始和完成标准的工作,旨在创建产品或服务”而出现。在软件系统的情况下不会生产多个单元,尽管制造对于描述构建组成软件系统的众多软件单元的需求是有用的,并且你有一个可以建模和管理的单元流；同样,在制造中你有一个材料流。在电气或化学工程中,工程系统的运行将(原)材料、能量和物理实体转换为其他形式的材料、</p>
<p>根据指定的资源和/或能量。对于软件工程学科，这个操作的类比是执行一个软件单元（软件工程过程集的输出），将一种数据转换为另一种数据。</p>
<p>在本节的其余部分，术语<em>过程(process)</em>将表示工作活动，而不是软件的执行。</p>
<p>软件工程过程通常在项目背景下执行。软件工程过程KA与大多数SWEBOK
KA密切相关；特别是软件工程管理、软件工程模型和方法、软件质量、软件架构和软件测试KA。</p>
<p>许多传统工程学科（如电气或化学）的过程包括设计和制造，其中制造生产系统的多个单元（如化学反应器）。</p>
<p>软件工程过程 10-3</p>
<p>工程基础KA中的测量和根本原因分析章节也密切相关。</p>
<p>对于主要利益相关者关注软件的系统，生命周期的概念被提出，因为仅仅识别和定义生产软件所需的过程不足以充分描述软件系统的所有复杂性。还需要定义生命周期，其中包括许多过程和约束。</p>
<p><em>1.2 软件工程过程定义</em></p>
<p>过程是”一组将输入转换为输出的相互关联或相互作用的活动”，其中活动是”过程的一组内聚任务”，任务是”旨在促进实现过程一个或多个结果的必需、推荐或允许的行动”。根据文献，过程是”由其目的或在给定条件下实现的效果所定义的预定事件过程”。第三个定义是”一个使用资源将输入转换为输出的活动系统”。第四个定义是”一组将输入转换为输出以产生预期结果的相互关联或相互作用的活动”。也就是说，过程的描述包括所需的输入、转换活动和生成的输出。这些定义涉及应用于软件系统的软件部分的任何过程。软件系统还包括硬件，并且还涉及人员和手动程序。一个过程的输出可以是另一个过程的输入。过程可能包括与过程相关的控制（如指令和约束）和使能机制(enabling
mechanisms)（如工具、技术或资源，如劳动力和基础设施）。</p>
<p><strong>2. 生命周期</strong></p>
<p><em>2.1. 生命周期定义、过程类别和术语</em></p>
<p>根据文献，<em>生命周期(life
cycle)</em>是”系统、产品、服务、项目或其他人造实体从概念到退役的演变”。在软件工程中，生命周期帮助传达有关软件系统的信息，即”软件对利益相关者至关重要的系统”。之所以引入生命周期的概念，是因为仅仅识别和定义生产软件所需的过程不足以充分描述软件系统的所有复杂性。还需要定义生命周期，其中包括许多过程和约束。</p>
<p>在软件工程中，<em>开发(development)</em>是指系统、产品、服务或项目生命周期的一个关键阶段：根据利益相关者的需求构建（或更改）软件系统。从生产/工业管理的角度来看，软件系统被称为产品。在这种情况下，术语<em>软件产品开发生命周期</em>是有意义的。</p>
<p><em>产品生命周期(product life
cycle)</em>可以定义为”代表产品演变的一系列阶段，从概念到交付、增长、成熟，直到退役”。这个定义不是针对软件系统的，而是更普遍地适用于所有产品。同样，与产品概念相关的生命周期概念也不是软件工程特有的。</p>
<p>软件系统包含软件单元，这些软件单元是”软件架构的原子级软件组件，可以进行独立测试”（参见测试KA）。软件系统的生命周期（只要软件工程使用跨学科方法），包括从软件系统构思到系统退役的所有过程、活动和任务，包括生产、操作和演进，以及在需要时的采购和供应。同样，我们可以看看软件系统元素（软件单元）的生命周期。软件系统生命周期将考虑利益相关者的业务和技术需求，以及系统通过团队执行的不同软件生命周期过程(SLCPs)产生满足利益相关者需求的产品的能力，并为其用户和所有不同的利益相关者提供所需的质量水平。</p>
<p>以下段落列举了过程类别。这些过程类别反映了生产软件系统所涉及的多个视角：</p>
<ol start="7" type="a">
<li>测量过程</li>
<li>质量保证过程</li>
</ol>
<ol start="3" type="1">
<li>组织项目使能过程
<ol type="a">
<li>生命周期模型管理过程</li>
<li>基础设施管理过程</li>
</ol></li>
</ol>
<p>10-4 SWEBOK® GUIDE V4.0a</p>
<p>技术过程，包括工程 c) 组合管理过程实践，用于构建、制造、演进、运营和
[d) 人力资源管理过程]</p>
<p>淘汰软件产品；(2) 技术管理 e) 质量管理过程 过程，涵盖规划和 f)
知识管理过程 控制，以及配置管理、</p>
<p>风险管理、信息管理 4. 协议过程 和质量保证；(3) 组织 a) 采购过程
项目支持过程，支持 b) 供应过程 生命周期模型和基础设施管理、</p>
<p>组合管理、人力 <em>2.2. 生命周期的理论基础</em> [[8*,c2-3][12]]</p>
<p>资源、知识和质量管理；最后是 (4) 协议过程，[创建、运营和淘汰软件]</p>
<p>对于支持集体决策以及采购和供应 [产品需要许多过程，包括]</p>
<p>过程至关重要。[它们的活动和任务，以及许多]</p>
<p>这些过程的分解如下：[约束。如上所述，软件系统]</p>
<p>[涉及人员和手动程序，以及]</p>
<p>1. 技术过程 [软件和硬件。定义软件]</p>
<ol type="a">
<li><p>业务或任务分析过程 过程，遵循 [12]，需要指定</p></li>
<li><p>利益相关者需求和需求 [输入和输出。来自过程的输入]</p></li>
</ol>
<p>定义过程 [通常是来自其他过程的输出。]</p>
<ol start="3" type="a">
<li>系统/软件需求定义 因此，生命周期过程是相互关联的</li>
</ol>
<p>过程 [过程；也就是说，每个独立过程]</p>
<ol start="4" type="a">
<li><p>架构定义过程 [(其输入和输出)可能依赖于]</p></li>
<li><p>设计定义过程 [其他过程。所涉及过程的相互关联特性]</p></li>
<li><p>系统分析过程 [使整体软件]</p></li>
<li><p>实现过程 [工程过程高度复杂。]</p></li>
<li><p>集成过程 [生命周期的规范是一个强大的]</p></li>
<li><p>验证过程 [工具，用于实施工程]</p></li>
<li><p>过渡过程 [方法来创建、运营和淘汰]</p></li>
<li><p>确认过程 [软件系统。生命周期应该]</p></li>
<li><p>运营过程 [遵循指导工程作为一门学科的工程原则]</p></li>
<li><p>维护过程 [来定义 [8]。]</p></li>
<li><p>处置过程 [生命周期的规范包括]</p></li>
</ol>
<p>[每个过程和相关的规范]</p>
<p>2. 技术管理过程 [约束。过程规范应该]</p>
<ol type="a">
<li><p>项目规划过程 对人类有用，以便他们能够使用这个规范</p></li>
<li><p>项目评估和控制过程 [相互沟通。]</p></li>
<li><p>决策管理过程 [规范应该易于]</p></li>
<li><p>风险管理过程 [理解和正确，因为生命周期规范]</p></li>
<li><p>配置管理过程 [是技术和工程]</p></li>
<li><p>信息管理过程 [管理的基础，包括协调]</p></li>
</ol>
<p>[和协议、测量、评估和]</p>
<p>改进以及质量管理。</p>
<p><a href="#软件工程过程">软件工程过程</a> 10-5</p>
<p><em>2.3. 过程模型和生命</em> [而增量则依次添加到]</p>
<p><em>周期模型的概念</em> [3*,c2][10*,c2][c2] [产品的功能” [3, 8,
13]。迭代]</p>
<p>持续时间为每个项目定义。选择的</p>
<p>第 2.1 节提供了许多软件 方法(参见软件工程</p>
<p>生命周期定义。在参考文献 [2] 中，一个新的 [模型和方法 KA)会规定]</p>
<p>定义引入了<em>标准</em>的概念，作为一个普遍接受的指导文档
迭代的角色和规模。</p>
<p>，指出”项目特定的活动序列 [在<em>演进</em>生命周期中，产品]</p>
<p>… 是通过将标准的活动 [或服务在其生命周期内发生变化。这可能]</p>
<p>映射到选定的软件 [发生是因为需求和客户]</p>
<p>生命周期模型 (SLCM) 上创建的。“也就是说，生命
[需求发生变化，但也可能发生是因为]</p>
<p>周期是按照生命 [需求被引入产品]</p>
<p>周期模型创建的。[以连续的步骤而不是完整和]</p>
<p>产品开发的知名生命周期模型 [原子集 [3, 8]。“连续步骤”是]</p>
<p>示例包括瀑布模型、V 模型、增量 “迭代”的同义词。</p>
<p>模型、螺旋模型和敏捷 [<em>增量</em>生命周期是”一个自适应]</p>
<p>模型 [2, 3, 10]。[项目生命周期，其中可交付成果]</p>
<p>[通过一系列迭代产生，这些迭代]</p>
<p><em>2.4. 开发生命</em>
[在预定的时间框架内依次添加功能。可交付成果]</p>
<p><em>周期模型的一些范式</em> [3*,c2-3][8*,c2-3]
[包含必要且充分的能力]</p>
<p>[9*,c1][10*,c1][2][11][12] 仅在 [9*,c1][10*,c1][2][11][12]
[最终迭代后才被视为完整” [3, 8, 13]。增量]</p>
<p>生命周期并不总是可预测的，但它们</p>
<p>每个软件系统都有自己的特征 可以是。<em>增量开发</em>是”一种软件</p>
<p>反映利益相关者的需求，包括业务 [开发技术，其中需求]</p>
<p>和技术需求。合适的生命周期将 [定义、设计、实现]</p>
<p>考虑所有这些需求。如第 [和测试以重叠、迭代的方式发生]</p>
<p>2.3 节所述，软件生命周期将 (而不是顺序方式)，导致</p>
<p>按照(部分或完全 [整体软件产品的增量完成]</p>
<p>符合) SLCM 定义。一些作者使用 ” [2]。</p>
<p>术语”开发”来指代 SLCM，[<em>持续</em>开发是指软件]</p>
<p>例如”迭代开发”而不是”迭代 [工程实践，允许频繁]</p>
<p>(软件)生命周期模型”。生命周期的类型 [发布新系统(包括软件]</p>
<p>下面描述了周期。[ware)到暂存环境或各种测试环境]</p>
<p><em>预测型</em>生命周期是”项目生命周期的一种形式[通过使用自动化工具[8,
9, 11]。]</p>
<p>生命周期，其中项目范围、时间、[生命周期可以强制执行一个规则，即]</p>
<p>和成本在生命周期的早期阶段确定”[13]。预测型生命周期[需求规范在]</p>
<p>假设将要[需求过程最终完成后就不能更改]</p>
<p>实现的需求集是一个封闭集合，不会[并且客户已同意]</p>
<p>经历实质性变化，除非发生不可抗力。[规范。例如，这发生在]</p>
<p>预测型生命周期中。另一方面，</p>
<p><em>迭代型</em>生命周期是”一种项目生命周期[当生命周期不排除变更时]</p>
<p>其中项目范围通常在[需求规范中的变更，即使在]</p>
<p>项目生命周期早期确定，但[客户已同意并签署]</p>
<p>时间和成本估算会随着项目团队对[批准后，但允许它们在任何时候变更]</p>
<p>产品理解的加深而定期修改。[时间点[经利益相关方协商]，]</p>
<p>迭代通过一系列重复周期开发产品，[那么该生命周期被称为<em>开放变更</em>。]</p>
<p>[开放变更是]</p>
<p>敏捷开发的主张之一[9, 10]。</p>
<p>10-6 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<h2 id="25-开发生命周期模型及其工程维度-1"><em>2.5.
开发生命周期模型及其工程维度</em></h2>
<p>[3*,c2][8*,c2-3] [螺旋模型作为”软件的模型]</p>
<p>[9*,c1][10*,c1][2][11][16] [开发过程，其中组成]</p>
<p>[17][18][19][25][26][27]
[活动，通常是需求分析、初步和详细设计、编码、]</p>
<p>[集成和测试，以迭代方式执行]</p>
<p>自软件工程诞生以来，[直到软件完成。“另一个]</p>
<p>随着其发展，几种生命周期模型已经[流行的模型是快速原型法，一种”原型法的类型]</p>
<p>广为人知。一个模型，[其中重点放在]</p>
<p>在学科历史早期流行起来的是瀑布模型[3]，[在开发过程早期开发原型上]</p>
<p>它属于前面描述的<em>预测型</em>类别。[以便在支持开发过程中进行早期反馈和]</p>
<p>瀑布模型方法用于[分析”[2]。统一过程，也称为统一]</p>
<p>产品开发使用多个阶段，[软件开发过程，是一种迭代]</p>
<p>包括需求、初步设计、[和增量式软件开发过程框架[25]。从统一过程]</p>
<p>详细设计、编码和测试。它实现[中，理性统一过程(RUP®)]</p>
<p>了一个非常严格的流程，其中一个阶段[在[26]中有文档记录，OpenUP由]</p>
<p>在前一个阶段完成之前不能开始。[Eclipse基金会管理[27]。]</p>
<p>瀑布模型很有用，因为[敏捷宣言[16]在]</p>
<p>它在软件系统开发中引入了系统化，[软件工程社区中产生了颠覆性影响]</p>
<p>因此，[通过创造思维方式的突然转变。]</p>
<p>可以称之为软件产品开发的工程方法。[区别在于敏捷宣言签署者]</p>
<p>许多变体或扩展，如V模型[3]，[声称过程应该对]</p>
<p>有许多不同的名称和细微差别，[变更开放—如果用户]</p>
<p>在软件工程历史上被引入。[需求改变，需求可以在开发过程的任何阶段修改。]</p>
<p>瀑布模型是早期[团队/客户之间的沟通和相互]</p>
<p>解决所谓软件危机的尝试[3]。[信任至关重要。]</p>
<p>瀑布模型是文档驱动的。[签署者声称团队沟通，]</p>
<p>参考文献[2]将瀑布模型定义为[通常是面对面的，以及与]</p>
<p>“软件开发过程的模型[客户的沟通是关键。然而，敏捷]</p>
<p>其中组成活动，通常[宣言并没有说不需要文档(例如]</p>
<p>是概念阶段、需求阶段、设计[定义需求)，文档是需要的[9, 10]。]</p>
<p>阶段、实现阶段、测试阶段和[签署者还倡导]</p>
<p>安装和检出阶段，按此顺序执行，[小型软件增量交付，]</p>
<p>可能有重叠但很少或没有[与应用瀑布模型的项目相反]</p>
<p>迭代。“瀑布模型显然[在项目结束时经过数月或数年的工作后只有一次软件交付。]</p>
<p>是预测型生命周期的一个例子。[敏捷明确区分了，一方面，]</p>
<p>其他一些范式，如增量[价值观和原则(例如，始终]</p>
<p>生命周期，也试图解决[向客户交付价值或]</p>
<p>“软件危机”。在这个模型中(见[对技术卓越的承诺)，另一方面，]</p>
<p>第2.4节)，不同阶段以重叠[实践(结对编程、冲刺计划]</p>
<p>而非顺序方式发生。[或回顾)。敏捷思维方式[10]与]</p>
<p>增量生命周期也可以是预测型[预测型思维方式不同。敏捷]</p>
<p>生命周期。这意味着[思维方式基于一系列价值观和]</p>
<p>需求在任何其他开发阶段开始之前[原则(例如，沟通的重要性、]</p>
<p>被定义和关闭。[对变更开放或承诺]</p>
<p>螺旋模型由Boehm引入，是进化的[技术卓越并始终交付]</p>
<p>和风险驱动的，而不是文档驱动的。</p>
<h2 id="软件工程过程-10-7">软件工程过程 10-7</h2>
<p>敏捷开发帮助应对复杂性 [8, 10]。</p>
<p>围绕敏捷出现了一些误解，其中一些至今仍然存在。一个误解是敏捷本身就是一种方法，但事实并非如此。另一个误解是敏捷比瀑布模型”更快”，因为不需要编写任何文档。第三个误解是敏捷只有有限或非结构化的方法/实践集合；例如，在
[18]
中可以找到一个列举了几种常用敏捷方法和实践的图表。一些敏捷方法变得流行起来，比如用于产品开发的极限编程(Extreme
Programming)、用于项目管理的Scrum等。尽管敏捷生命周期模型在处理复杂项目方面越来越受欢迎，但将敏捷扩展到大型项目和项目组合仍然具有挑战性。今天的看法是，敏捷宣言意味着一次重大的颠覆；然而，它已经有20年的历史了，一些作者认为，根据开发人员在过去20年中获得的经验，其某些原则可能需要更新
[17]。</p>
<p>敏捷实践的应用已经超越了软件工程过程，<strong>业务敏捷性</strong>(business
agility)和<strong>敏捷组织</strong>(Agile
organizations)这些术语现在非常常见
[19]。从软件工程的角度来看，敏捷为行业创造了一个机会，可以实现软件工程过程的重新设计，并更好地将软件工程过程与组织的业务战略过程相协调。业务流程使用敏捷方法是一种常见的场景；这体现在DevOps
[11]
的原则中,例如，本节后面将进行解释，以及第3节中的过程评估和改进。</p>
<p>需要提供更频繁的发布版本，用户需求和技术生命周期变化更加频繁，再加上组织战略计划与组织IT运营之间所需的协调，这些因素导致了DevOps的诞生。DevOps被定义为”一套原则和实践，能够在相关利益相关者之间实现更好的沟通和协作，目的是为客户提供价值；这一关注点使敏捷区别于预测性思维模式，后者更专注于对需求规范的实现进行承诺。敏捷有助于应对复杂性
[8, 10]。</p>
<p>需要提供更频繁的发布版本，事实上用户需求和技术生命周期变化更加频繁，再加上组织的战略计划与组织的IT运营之间所需的协调，这些因素导致了DevOps的诞生，它被定义为”一套原则和实践，能够在相关利益相关者之间实现更好的沟通和协作，目的是规范、开发和运营软件以及系统产品和服务，并在生命周期的各个方面持续改进”
[11]。一旦定义了足够的过程管理，能够更频繁地提供更多发布版本的能力已经成为使公司更具竞争力的优势。</p>
<p>在软件工程的历史中，围绕软件生命周期模型一直存在很多争议——例如，关于瀑布模型与敏捷软件开发模型优点的辩论(参见第2节)。应该从历史的角度来理解这种争议；新方法具有颠覆性或被认为具有颠覆性，并且缺乏经验性度量来支持关于软件工程的基于证据的讨论。这种情况一直在缓慢但稳步地改变。使用经验性度量作为决策基础是软件工程的一个基本要素
[4, 8]。另见KA 9，软件工程管理，以及KA 12，软件质量。</p>
<h3 id="26-slcp的管理-14">2.6. SLCP的管理 [14]</h3>
<p>任何软件系统的生命周期都包含多个阶段。根据 [14]，这些阶段如下：</p>
<ol type="1">
<li><strong>概念阶段</strong>：在此阶段，识别利益相关者的需求，探索概念，并提出解决方案。</li>
<li><strong>开发阶段</strong>：在此阶段，代表用户需求的需求将被细化，创建解决方案，构建系统，并进行所需的验证和确认过程。</li>
<li><strong>生产阶段</strong>：此阶段的范围将取决于所关注软件系统的特性。一般来说，它将包括系统的生产和测试。</li>
<li><strong>使用阶段</strong>：在此阶段，系统运行以满足用户的需求。</li>
<li><strong>支持阶段</strong>：在此阶段，开发人员提供所需的行动以实现满意的操作。</li>
</ol>
<p>10-8 <em>SWEBOK® GUIDE V4.0a</em></p>
<ol start="6" type="1">
<li><strong>退役阶段</strong>：在此阶段，团队遵循既定程序处置系统。</li>
</ol>
<p>这些阶段绝不应该是顺序的。实际上，软件系统生命周期的规范将包括这些阶段之间的转换。应该明确的是，这些阶段是为通用生命周期确定的。特定的生命周期将有特定的阶段，对特定项目的利益相关者有意义；这些阶段将融入这些通用阶段。</p>
<h3 id="27-软件工程过程管理-1c52">2.7. 软件工程过程管理 [1*,c5][2]</h3>
<p>过程管理被定义为”对执行工作的指导、控制和协调</p>
<h3 id="29-实际考虑因素-8c2-3">2.9. 实际考虑因素 [8*,c2-3]</h3>
<p>定义生命周期过程包括规范第2节中介绍的四个类别。这意味着要处理技术过程(定义所需的过程)、组织过程(包括人力资源等其他过程)、技术管理过程(过程如何关联、如何监控和管理)以及协议过程。</p>
<p>软件工程学科自其诞生以来一直在演进，原因有几个。社区从未停止学习，而产品的复杂性一直在不断增加。定义一个生命周期过程不仅涉及技术方面，还需要考虑实际因素。</p>
<p>软件工程过程管理涵盖了对软件开发和维护活动的计划、监控和控制。ISO/IEC/IEEE
12207的一个派生系列，即针对极小型实体(VSEs)的标准
[29]，就是从ISO/IEC/IEEE 12207派生的一个系列示例。</p>
<p>软件工程过程的开发”[2]。软件开发产品的软件生命周期需要考虑产品的特征（例如利益相关者的需求、产品规模或复杂性）以及产品外部的其他因素，如利益相关者的特征。社区已经认识到，估算和度量(Measurements)是必不可少的。在生命周期背景下错误或不确定的估算将导致失败。准确的估算并不容易产生。[8]</p>
<p>多个管理层级管理着软件工程过程，如参考文献[1]所述，见知识领域(KA)
9，软件工程管理。最低层级是技术过程；第二层级是技术管理层级，包括项目管理过程。第三层级是（执行）管理层级，侧重于组织使能过程，如知识管理、生命周期模型管理或组合管理。</p>
<h2 id="28-软件生命周期适配-1">2.8. 软件生命周期适配</h2>
<p>[5] [14] [23][29]</p>
<p>每个软件系统都有其差异化特征。这些差异化特征与利益相关者的需求一起，形成了特定的生命周期。这种适配将包括识别所有相关特征，选择适当的标准或组织内部文档，选择开发策略/生命周期模型、阶段和过程，并记录决策和理由。适配不需要保留第2节中提供的名称，也不必包括所有这些名称[5,
14, 23]。ISO/IEC 29110系列《超小型组织的系统和软件工程标准和指南》</p>
<p>当前软件工程的一个趋势是专注于持续交付(Continuous
Delivery)，由现实的过程和产品估算及度量支持。工程师们学到的一个有用经验是，使用大型过程而不在过程中产生任何交付物会增加不确定性。（见第2.5节DevOps。）敏捷思维方式(Agile
Mindset)对此做出了贡献，并帮助工程师们认识到沟通在过程中的重要性。[8]</p>
<p>当项目过程按照生命周期定义时，重要的是要确保能够有度量/测量定义，这将在整个项目定义或执行过程中产生现实的过程（和产品）估算和测量，并定义精度和不确定性水平；项目过程（和产品）测量应始终提供关于正在发生什么（过程和产品的状态）的准确信息</p>
<p>【软件工程过程】10-9</p>
<p>在生命周期过程执行期间。如果估算和测量的准确性不确定，项目可能不会成功。在这种情况下，应该对整体方法进行反思。从历史上看，关于预测性生命周期与敏捷生命周期之间产生了很多争论。在软件工程中，讨论应该始终由现实的过程和产品估算和测量支持，这可以准确降低不确定性水平。</p>
<h2 id="210-软件过程基础设施工具和方法">2.10.
软件过程基础设施、工具和方法</h2>
<p>[3*,c2][8*,c2-3][2]</p>
<p>已经使用了几种符号来定义软件过程，包括自然语言、指定组成活动和任务的文本列表、数据流图、状态图、集成定义(IDEF0)[30]、Petri网、统一建模语言(UML)活动图和业务流程模型和表示法(BPMN)[2,
3]。软件过程基础设施包括支持这些过程定义的工具（例如BPMN工具包），但主要是支持所有特定过程（测试或配置管理）。过程定义通常包括方法和形式化表示（例如Rational
Unified
Process或极限编程）[3]。理想情况下，工具必须支持这些方法，同样重要的是，与它们集成。因此，工具支持测试是不够的。例如，一旦代码单元成功测试，这就成为应该记录的有用信息，以便团队其他成员能够了解这一事实。这意味着配置管理工具和测试工具必须集成。因此，与开发过程相关的工具基础设施（例如配置管理；测试；工单管理）被视为成功实施生命周期的关键。另见知识领域11，软件工程模型和方法。</p>
<h2 id="211-软件工程过程监控及其与软件产品的关系-1">2.11.
软件工程过程监控及其与软件产品的关系</h2>
<p>[1,c5-6][3*,c2][4*c4-10][8*c2-3]</p>
<p>开发人员必须监控软件工程过程执行，评估过程目标是否实现，并评估风险。这种过程监控是软件工程过程评估的一部分（见第3节），也是软件工程管理知识领域的一部分[1,
3, 4, 8]。</p>
<p>经验方法支持过程评估和改进以及产品评估和改进。过程执行的目标是获得满足利益相关者需求的产品。虽然这个领域侧重于软件工程过程，但过程监控需要同时评估过程和产品，使用一种联合的、更全面的方法。</p>
<h1 id="3-软件过程评估和改进-1">3. 软件过程评估和改进</h1>
<h2 id="31-软件过程评估和改进概述-1">3.1. 软件过程评估和改进概述</h2>
<p>[4*,c4][15][24]</p>
<p>任何执行的过程都可以改进的想法出现在经典的Shewhart-Deming计划-执行-检查-行动(PDCA)范式中[15,
24]，这在1950年代就已经被讨论和应用，其基础可以追溯到几个世纪之前。对于软件工程过程，已经开发了几种方法。</p>
<p>integrated [3, 8]. The term <em>software engineering</em>
[PDCA范式是一个满足广泛认可需求的机会——这个需求]</p>
<p><em>environment</em>，代表一组集成工具，有时会用到。术语
<em>CASE</em>（computer-aided software
engineering，计算机辅助软件工程）在20世纪80年代和90年代很流行。然而，80年代和90年代的强大工具被过度宣传为软件危机的解决方案。无论如何，今天，一些过程的自动化（例如，配置管理，或至少是版本控制；[就是获取经验证据来做决策。]</p>
<p>[这些决策包括选择生命周期、]</p>
<p>[决定如何评估过程或决定]</p>
<p>[如何改进过程等。]</p>
<p>[在软件工程过程执行中获取经验证据]</p>
<p>[对于过程执行的成功至关重要。] 10-10 [<em>SWEBOK</em>] [<em>®</em>][
GUIDE V4.0a]</p>
<p><em>3.2. Goal Question Metric (GQM，目标-问题-度量)</em> [21]
[执行过程评估的基本要求]</p>
<p>GQM方法 [21] 基于Basili的质量改进范式(Quality Improvement
Paradigm)。两者都基于设定可测量的目标，改变某些东西，然后评估变化的效果。当评估结果是正面的，就发生了改进。</p>
<p><em>3.3 基于框架的方法</em> [4*,c4-10][6][22]
[过程度量框架；关于如何]</p>
<p>[执行评估的指导；用于评估过程能力的度量框架]</p>
<p>[和组织成熟度；针对特殊情况的过程参考]</p>
<p>[模型，如安全或]</p>
<p>[高成熟度；针对以下方面的过程评估模型：]</p>
<p>[SLCP、系统生命周期过程、IT服务]</p>
<p>[管理、安全和高成熟度；以及]</p>
<p>[组织成熟度模型。]</p>
<p>一些评估方法基于使用过程参考模型和评估参考模型的框架——例如，CMM®（capability
maturity model，能力成熟度模型）、CMMI® [4, 22]，以及ISO/IEC 33000 [4,
6] 系列，也称为SPICE。</p>
<p>过程参考模型被定义为[“一个模型，包含应用领域中过程的定义，这些定义用过程目的和成果来描述，以及描述过程之间关系的架构。”]</p>
<p>ISO/IEC 33000框架包括过程参考框架和过程评估模型。ISO/IEC
33000框架修订了ISO/IEC
15504系列国际标准，提供了一个用于评估以下方面的框架：(1)
过程质量特征，其中之一是过程能力，以及 (2)
组织成熟度。该框架涵盖了信息技术领域内系统开发、维护和使用的过程，以及服务设计、转换、交付和改进的过程。寻求持续改进的概念是评估的基础。</p>
<p>过程评估模型被定义为[“适合于评估特定过程质量特征的模型，基于一个或多个过程参考模型。”]
[6]</p>
<p><em>3.4. 敏捷中的过程评估和改进</em> [9*,c11][28]</p>
<p>该系列标准已经开发了几组标准，除了核心要素外，还涉及：</p>
<p>敏捷方法（例如，scrum项目管理方法）引入了他们称之为<em>回顾会议(retrospectives)</em>的实践，在每次迭代结束时进行。回顾会议的目标是分析什么做得好，什么做得不好，理解原因，并设定一些学习和改进的行动。最终，团队处于持续学习循环中
[9]。这种实践，在软件工程中以不同的名称和范围存在已久 [28]。</p>
<p><strong>主题与参考资料矩阵</strong></p>
<p>[<strong>/</strong>] [ <strong>[1]</strong>]
[**]<strong>][<strong>9</strong>*] [<strong>07</strong>]
[<strong>lle</strong> ][**]</strong>][<strong>l [**] [**]</strong>]
[<strong>vi</strong>] [<strong>22</strong>] [<strong>8</strong>*]
[<strong>t a</strong>][<strong>0</strong>*] [<strong>EC</strong>]
[<strong>er</strong>] [<strong>te</strong>] [**4*]<strong>] [</strong>y
[**] [<strong>/I</strong>] [<strong>E 1</strong>] [<strong>m</strong>]
[<strong>or</strong>] [<strong>re e</strong>][<strong>I [1**]
[<strong>l. [**] [<strong>O</strong>] [<strong>E</strong>]
[<strong>m</strong>] [<strong>rle</strong>] [***]</strong>][
<strong>a</strong>] [<strong>IS</strong>] [<strong>IE</strong>]
[<strong>So</strong>] [</strong>[3**] [<strong>Lap</strong>]
[<strong>et</strong>] [<strong>Fa</strong>]
[<strong>Sho</strong>][<strong>PM</strong>]
[<strong>Others</strong>]</p>
<p>[<strong>1. 软件工程过程基础</strong> ]</p>
<p>[<em>1.1 引言</em>] [c5] [[13]]</p>
<p>[<em>1.2 软件工程过程定义</em>] [c5] [[2] [7][14][20]]</p>
<p><a href="#软件工程过程">软件工程过程</a> 10-11</p>
<p>[<strong>2. 生命周期</strong>]</p>
<p>[<em>2.1 生命周期定义、过程类别和术语</em>] [c5-6] [c2] [c1-3]
[[13]]</p>
<p>[<em>2.2 生命周期的基本原理</em>] [c2-3] [[12]]</p>
<p>[<em>2.3 过程模型和生命周期模型的概念</em>] [c2] [c2] [[2]]</p>
<p>[<em>2.4 开发生命周期模型的一些范式</em>] [c2-3] [c2-3] [c1] [c1]
[[2] [11] [13]]</p>
<p>[<em>2.5 开发生命周期模型及其工程维度</em>] [c2] [c2-3] [c1] [c1]
[[2] [11] [16] [17] [18] [19] [25] [26] [27]]</p>
<p>[<em>2.6 SLCP的管理</em>] [[14]]</p>
<p>[<em>2.7 软件工程过程管理</em>] [c5] [[2]]</p>
<p>[<em>2.8 软件生命周期适配</em>] [[5] [14] [23] [29]]</p>
<p>[<em>2.9 实际考虑因素</em>]</p>
<p>[<em>2.10 软件过程基础设施、工具、方法</em>] [c2] [c2-3] [[2]]</p>
<p>[<em>2.11 软件工程过程监控</em>] [c5-6] [c2] [c4-10 c2-3]</p>
<p>[<strong>3. 软件过程评估和改进</strong>] [<strong>c4-10</strong>]</p>
<p>[<em>3.1 软件过程评估和改进概述</em>] [c4] [[15] [24]]</p>
<p>[<em>3.2 目标-问题-度量(GQM)</em>] [[21]]</p>
<p>[<em>3.3 基于框架的方法</em>] [c4-10] [[6] [22]]</p>
<p>[<em>3.4 敏捷中的过程评估和改进</em>] [c11] [[28]]</p>
<p><strong>参考文献</strong></p>
<p>[1] ISO/IEC/IEEE 12207:2017 Systems and software engineering —
Software life cycle processes.</p>
<p>[5] Project Management Institute, <em>Software Extension to the
PMBOK® Guide — Fifth Edition</em>, 2013.</p>
<p>[6] ISO/IEC 33001:2015 Information technology — Process assessment
—</p>
<h2 id="参考文献-8">参考文献</h2>
<p>[2] “ISO/IEC/IEEE 24765:2017 概念和术语。</p>
<p>系统和软件工程 —</p>
<p>词汇表，” 第2版，2017年。</p>
<p>[3] I. Sommerville，《软件工程》。第10版，2016年。</p>
<p>[4] C. Y. Laporte 和 A.
April，《软件质量保证》，IEEE计算机协会出版社，第1版，2018年。</p>
<p>[7] ISO/IEC 25000:2014 系统和软件工程 —
系统和软件产品质量需求和评估(SQuaRE) — SQuaRE指南。</p>
<p>[8] D.
Farley，《现代软件工程：用有效方法更快地构建更好的软件》。Addison-Wesley专业出版社，2021年。</p>
<p>10-12 《SWEBOK® 指南 V4.0a》</p>
<p>《空间与社会组织治理：在颠覆中生存与繁荣》，2021年。</p>
<p>[9] J. Shore 和 S. Warden，《敏捷开发的艺术》，O’Reilly
Media，第2版，2021年。</p>
<p>[10]
项目管理协会，《敏捷实践指南》。项目管理协会和敏捷联盟。2017年。</p>
<p>[11] ISO/IEC/IEEE 32675:2022 信息技术 — DevOps —
构建可靠和安全的系统，包括应用构建、打包和部署。</p>
<p>[12] ISO/IEC/IEEE 24774:2021 系统和软件工程 — 生命周期管理 —
过程描述规范。</p>
<p>[13] 项目管理协会，《项目管理知识体系指南(PMBOK®指南)— 第六版》。</p>
<p>[14] ISO/IEC/IEEE 24748-1:2018(E) 系统和软件工程 — 生命周期管理 —
第1部分：生命周期管理指南。</p>
<p>[15] W.A. Shewhart 和 W.E.
Deming，《从质量控制角度看统计方法》。Dover，纽约，1986年。</p>
<p>[16] “敏捷宣言。”
https://agilemanifesto.org。[访问时间：2022年3月5日]。</p>
<p>[17] S. McConnell，《更高效的敏捷：软件领导者路线图》，2019年。</p>
<p>[18] “敏捷实践地铁图。”
敏捷联盟。https://www.agilealliance.org/agile101/subway-map-to-agile-practices/
[访问时间：2022年3月5日]。</p>
<p>[19] J. Eckstein 和 J.
Buck，《超越预算的全公司敏捷、开放空间与社会组织治理：在颠覆中生存与繁荣》，2021年。</p>
<p>[20] ISO/IEC TR 29110-5-3:2018 系统和软件工程 —
极小型实体(VSE)的生命周期概况 — 第5-3部分：服务交付指南。</p>
<p>[21] N. Fenton 和 J.
Bieman，《软件度量》，第3版。CRC出版社，2014年。</p>
<p>[22] CMMI研究所 — CMMI
V2.0。https://cmmiinstitute.com/cmmi。[访问时间：2022年3月5日]。</p>
<p>[23] ISO/IEC/IEEE 24748-3:2020。第3部分：ISO/IEC/IEEE
12207(软件生命周期过程)应用指南。</p>
<p>[24] D.R. Kiran，《全面质量管理》。Elsevier，2017年。</p>
<p>[25] J. Rumbaugh，G. Booch，I.
Jacobson。《统一软件开发过程》，1999年。</p>
<p>[26] P. Kruchten。《理性统一过程：导论》。第3版，2004年。</p>
<p>[27] Eclipse基金会。https://www.eclipse.org/org/foundation/
[访问时间：2024年4月25日]。</p>
<p>[28] T. Dingsøyr，事后审查(Postmortem
reviews)：软件工程中的目的和方法，《信息与软件技术》，第47卷，第5期，2005年，第293-303页。</p>
<p>[29] ISO/IEC 29110-1-1:2024 系统和软件工程 —
极小型实体(VSE)的生命周期概况，第1-1部分：概述。</p>
<p>[30] ISO/IEC/IEEE 31320-1:2012 信息技术 —
建模语言，第1部分：IDEF0的语法和语义</p>
<p>11-2 《SWEBOK® 指南 V4.0a》</p>
<h2 id="第11章-1">第11章</h2>
<h2 id="软件工程模型和方法-2">软件工程模型和方法</h2>
<h3 id="缩略语-2">缩略语</h3>
<p>3GL - 第三代语言(3rd Generation Language) BNF -
巴科斯-诺尔范式(Backus-Naur Form) FDD - 特性驱动开发(Feature-Driven
Development) IDE - 集成开发环境(Integrated Development Environment) RAD
- 快速应用开发(Rapid Application Development) XP - 极限编程(eXtreme
Programming) UML - 统一建模语言(Unified Modeling Language)</p>
<h3 id="软件工程模型和方法主题分类">软件工程模型和方法主题分类</h3>
<p>本章关于软件工程模型和方法的内容分为四个主要主题领域：</p>
<ol type="1">
<li><p><strong>建模</strong>
讨论建模的一般实践，介绍建模原则、属性和表达、建模的语法、语义和语用学，以及前置条件、后置条件和不变式等主题。</p></li>
<li><p><strong>模型类型</strong>
简要讨论模型和子模型的聚合，提供软件工程实践中常见模型类型的一般特征。</p></li>
<li><p><strong>模型分析</strong>
介绍建模中常用的分析技术，用于验证完整性、一致性、正确性、可追溯性和交互性。</p></li>
<li><p><strong>软件工程方法</strong>
概述常用的软件工程方法，如启发式方法(heuristic
methods)、形式化方法(formal methods)、原型法和敏捷方法。</p></li>
</ol>
<h3 id="简介">简介</h3>
<p>软件工程模型和方法为软件工程提供了结构化框架，使其更加系统化、可重复，并最终更加面向成功。模型提供了一种问题解决方法、模型构造和分析的符号表示和过程。方法提供了一种对最终软件产品和相关工作产品进行系统化规范、设计、构造、测试和验证的方法。</p>
<p>软件工程模型和方法的范围差异很大 —
从针对单个软件生命周期阶段到覆盖完整软件生命周期。本知识领域(KA)关注涵盖多个软件生命周期的模型和方法。</p>
<p>软件工程模型和方法知识领域的主题分类如图11.1所示。</p>
<h3 id="1-建模-1">1. 建模</h3>
<p>软件建模是一种普遍的技术</p>
<h2 id="111-建模原则">11.1 建模原则</h2>
<p>[1*, c2s2, c5s1, c5s2, 2*, c2s2, 3*, c5s0]</p>
<p>建模为软件工程师提供了一种有组织和系统化的方法，用于表示所研究软件的重要方面，促进关于软件或元素的决策制定，并将这些重要决策传达给利益相关者社区中的其他人。三个一般原则指导这些建模活动：</p>
<p>•
<strong>对本质进行建模</strong>：好的模型不会在所有可能的条件下表示软件的每个方面或特性。建模只涉及那些提出特定问题的方面或特性，抽象掉任何非必要信息。这种方法使模型保持可管理和有用。</p>
<p>•
<strong>提供视角</strong>：建模使用定义的规则在每个视图中表达模型，提供所研究软件的视图。这种视角驱动的方法为模型提供了维度（例如，提供结构视图、行为视图、时间视图、组织视图和/或其他相关视图）。将信息组织到视图中，使软件建模工作使用适当的符号、词汇、方法和工具集中在与该视图相关的特定关注点上。</p>
<p>•
<strong>实现有效沟通</strong>：建模使用软件的应用领域词汇、建模语言和语义表达（换句话说，上下文中的含义）。当严格和系统地使用时，建模产生一种报告方法，促进向项目利益相关者有效传达软件信息。</p>
<p>模型是系统的<strong>抽象</strong>或简化。使用抽象的结果是，因为没有单一的抽象能完全描述软件组件，所以软件模型包含抽象的聚合，这些抽象放在一起时，描述选定的方面、视角或视图——只有那些做出明智决策和响应创建模型的原因所需的方面。这种简化指向模型所处上下文的假设，这些假设也应该在模型中被捕获。然后，当模型被重用时，可以首先验证这些假设，以确定重用模型在其新用途和上下文中的相关性。</p>
<h2 id="112-模型的属性和表达">11.2 模型的属性和表达</h2>
<p>[1*, c5s2, c5s3, 3*, c4s1.1p7, c4s6p3, c5s0p3]</p>
<p><strong>模型的属性</strong>是特定模型的区别特征，这些特征在所选建模符号和工具中表征其完整性(completeness)、一致性(consistency)和正确性(correctness)。模型的属性包括以下内容：</p>
<p>• <strong>完整性</strong> -
所有需求已在模型中实现和验证的程度，可以适当处理需求、设计和/或实现。</p>
<p>模型的主要表达元素是<strong>实体</strong>(entity)。实体可以表示具体的工件（例如，处理器、传感器或机器人）或抽象工件（例如，软件模块或通信协议）。模型实体使用关系（目标实体上的线条或文本操作符）连接到其他实体。模型实体的表达可以使用文本或图形建模语言来完成；两种建模语言类型都通过特定的语言结构连接模型实体。实体的含义可以通过其形状、文本属性或两者来表示。一般来说，文本信息遵循特定于语言的句法结构。使用这些实体和关系对上下文、结构或行为进行建模的精确含义取决于所使用的建模语言、应用于建模工作的设计严格性、正在构建的特定视图以及特定符号元素可能附加到的实体。可能需要模型的多个视图来捕获软件所需的语义。当使用自动化支持的模型时，可以检查模型的完整性和一致性。这些检查的有用性在很大程度上取决于应用于建模工作的语义和句法严格性水平以及明确的工具支持。正确性可以</p>
<p><em>• 一致性（Consistency）</em> —
模型中不包含相互冲突的需求、断言、约束、功能或组件描述的程度，可以通过模型模拟、执行或评审来检验。</p>
<p><em>• 正确性（Correctness）</em> —
模型满足其需求和设计规范且无缺陷的程度</p>
<p><em>1.3. 语法、语义和语用</em> [[2*, c2s2.2.2p6, 3*, c5s0]]</p>
<p>模型可能具有欺骗性。模型作为一种缺少信息的抽象，可能会让人产生一种错觉，以为研究单个模型后就完全理解了软件。一个<em>完整模型</em>（“完整”是相对于建模工作而言的）可能是多个子模型和任何特殊功能模型的集合。对这些子模型集合中的单个模型进行检查和决策可能会产生问题。</p>
<p>构建模型是为了表示目标领域所需的对象及其行为，以回答关于软件预期如何运行的具体问题。通过探索、模拟或评审来审查模型，可能会暴露模型和模型所指软件中的不确定性领域。这些不确定性或关于</p>
<p>11-4 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<p>理解建模构造的精确含义也很困难。语法和语义规则定义了建模语言。对于文本语言，<em>语法</em>使用定义有效语言构造的符号文法（如巴科斯-诺尔范式（Backus-Naur
form,
BNF））来定义。对于图形语言，语法使用称为<em>元模型</em>的图形模型来定义。与BNF一样，元模型定义了图形建模语言的有效语法构造。此外，元模型还定义了如何组合这些构造以生成有效模型。</p>
<p>建模语言的<em>语义</em>指定附加到模型中捕获的实体和关系的含义。例如，由一条线连接的两个方框的简单图表可以有多种解释。了解放置和连接这些方框的图表是对象图还是活动图有助于解释该模型。</p>
<p>作为实际问题，特定软件模型的语义通常相当明确，这是由于模型使用了建模语言、该建模语言在模型中表达实体和关系的方式、建模者的经验和技能，以及进行建模和表示的上下文。即使在通过抽象缺少信息的情况下，意义也能通过模型传达。<em>语用</em>解释了意义如何体现在模型及其上下文中，以及如何有效地传达给其他软件工程师。</p>
<p>然而，在建模和语义方面仍有需要谨慎的情况。例如，从另一个模型或库导入的任何模型部分都必须检查与新建模环境冲突的语义假设；这些冲突可能并不明显。应检查模型的文档化假设。尽管导入的建模语法可能相同，但在新环境（不同上下文）中可能意味着完全不同的东西。此外，还要考虑随着软件的成熟和变化以及工具更新和可能的新需求，模型的部分可能会表示与原作者意图和初始模型上下文不同的内容，从而引入语义不一致，导致错误。随着许多软件工程师长期参与模型的部分工作，</p>
<p><em>1.4. 前置条件、后置条件和不变量</em> [[2*, c4s4, 4*, c10s4p2,
c10s5p2p4]]</p>
<p>在对函数或方法建模时，软件工程师通常从关于函数或方法执行前、执行期间和执行后软件状态的假设开始。这些假设对于函数或方法的正确运行至关重要，并作为一组前置条件、后置条件和不变量进行讨论。</p>
<p><em>•
前置条件</em>是在函数或方法执行前必须满足的条件。如果这些前置条件在函数或方法执行前不成立，函数或方法可能会产生错误结果。</p>
<p><em>•
后置条件</em>是在函数或方法成功执行后保证为真的条件。通常，后置条件表示软件状态如何改变、传递给函数或方法的参数如何改变、数据值如何改变或返回值如何受到影响。</p>
<p><em>•
不变量</em>是在函数或方法执行前后在操作环境中持续存在（换句话说，不改变）的条件。这些不变量与软件以及函数或方法的正确运行相关且必要。</p>
<p><strong>2. 模型类型</strong></p>
<p>典型的模型由子模型的聚合组成。每个子模型都是部分描述，为特定目的而创建。一个子模型可能包含一个或多个</p>
<p>[SOFTWARE ENGINEERING MODELS AND METHODS] 11-5</p>
<p>图表。子模型集合可以使用多种建模语言或单一建模语言。统一建模语言（Unified
Modeling Language,
UML）识别了丰富的建模图表集合。这些图表与建模语言构造一起用于两种常见的模型类型：结构</p>
<p>信息。语义或概念信息模型的后续转换成为软件中实现的逻辑和物理数据模型。</p>
<p><em>2.2. 行为建模</em> [[1*, c7s2.1, c7s2.3, c7s2.4, 2*, c9s2,
3*,]</p>
<p>tural models和behavioral models。（参见[c5s4, 8, c1s5.4]</p>
<p>第1.1节。）根据建模语言的不同，还可能存在其他类型的模型。<em>行为模型</em>识别并定义软件功能。行为模型通常采用三种基本形式：状态机、控制流模型和数据流模型。状态机提供了一个将软件表示为一组定义的状态、事件和转换的模型。软件通过建模环境中发生的有保护或无保护的触发事件从一个状态转换到下一个状态。</p>
<p>例如，系统建模语言(SysML)提供了另外两种类型的模型：需求模型和参数模型。</p>
<p><strong>2.1. 结构建模</strong> [1<em>, c7s2.2, c7s2.5, c7s3.1,
c7s3.2, 3</em>, c5s3, c8s1, 4*, c4, 17]</p>
<p><em>结构模型</em>展示了软件从其各个组成部分进行的物理或逻辑组合。<em>结构建模</em>在正在实现或建模的软件与其运行环境之间建立了明确的边界。结构建模中使用的一些常见结构构造包括实体的组合、分解、泛化和特化；识别实体之间的相关关系和基数；以及定义过程或功能接口。UML为结构建模提供的结构图包括类图、组件图、对象图、部署图和包图。</p>
<p>控制流模型描述了事件序列如何导致进程被激活或停用。数据流模型将数据流行为表示为一系列步骤，其中数据通过进程移动到数据存储或数据汇。这些模型以事件触发、时间概念（即逻辑、物理、离散、连续、相对或绝对时间）或其组合的方式来描述。UML为行为建模提供的行为图包括用例图、活动图、状态机图和交互图（序列图、通信图、时序图和交互概览图）。</p>
<p>信息建模是一种结构建模，关注数据和其他信息。<em>信息模型</em>是一种抽象表示，用于识别和定义一组关于数据实体的概念、属性、关系和约束。语义或概念信息模型通常用于从问题角度为软件提供一些形式化和上下文，而不关心该模型如何映射到软件的实现。语义或概念信息模型是一种抽象，因此只包含概念化真实世界视图所需的概念、属性、关系和约束。</p>
<p><strong>3. 模型分析</strong></p>
<p>模型的开发使软件工程师能够研究、推理和理解软件结构、功能、操作使用和组装考虑因素。需要对构建的模型进行分析，以确保模型足够完整、一致和正确，从而为利益相关者实现其预期目的。</p>
<p>以下各节简要描述了通常用于确保软件工程师和其他相关利益相关者从模型的开发和使用中获得适当价值的分析技术。11-6
[<em>SWEBOK</em>] [<em>®</em>] [GUIDE V4.0a]</p>
<p><strong>3.1. 完整性分析</strong> [3<em>, c4s1.1p7, c4s6, 5</em>,
pp8-11]</p>
<p>为确保软件完全满足利益相关者的需求，从需求获取过程到代码实现的完整性至关重要。<em>完整性</em>是所有指定需求已被实现和验证的程度。工程师可以使用建模工具检查模型的完整性，该工具使用结构分析和状态空间可达性分析（确保某些正确输入集到达状态模型中的所有路径）。也可以通过使用检查或其他评审技术手动检查模型的完整性。（参见软件质量KA。）这些分析工具生成的错误和警告以及通过检查或评审发现的问题表明可能需要采取纠正措施以确保模型完整性。</p>
<p><strong>3.2. 一致性分析</strong> [3<em>, c4s1.1p7, c4s6, 5</em>,
pp8-11]</p>
<p><em>一致性</em>是模型不包含冲突的需求、断言、约束、功能或组件描述的程度。通常，一致性检查是使用建模工具完成的，该工具使用语法和语义分析来检查被建模的内容。为了分析模型的语法和语义正确性，可以自动分析（例如，使用建模工具检查模型语法正确性）或手动分析（使用检查或其他评审技术）——搜索可能的缺陷，然后在软件发布使用之前移除或修复确认的缺陷。</p>
<p><strong>3.3. 正确性分析</strong></p>
<p>软件工程师通过检查模型是否准确表示了预期的系统或组件来分析模型的正确性。</p>
<p><strong>3.4. 可追溯性分析</strong> [3*, c4s7.1, c4s7.2]</p>
<p>开发软件通常涉及使用、创建和修改许多工作产品，例如规划文档、过程规范、软件需求、图表、设计和伪代码、手写和工具生成的代码、手动和自动化测试用例和报告，以及文件和数据。这些工作产品可能共享各种依赖关系（例如，使用、实现和测试）。随着软件的开发、管理、维护或扩展，必须映射和控制这些可追溯性关系，以证明软件需求与软件模型的一致性（参见软件需求KA中的需求追踪）以及众多工作产品。可追溯性的使用通常可以改善软件工作的管理。</p>
<p>自动分析功能。模型也可以使用检查或其他评审技术进行人工检查以验证一致性。（参见软件质量知识领域。）与完整性分析类似，这些分析工具生成的错误和警告以及通过检查或评审发现的问题都表明需要采取纠正措施。</p>
<p>产品和软件过程质量向利益相关者保证所有需求都得到满足。可追溯性使得在软件开发和发布后能够进行变更分析，因为可以轻松遍历与软件工作产品的关系来评估变更影响。建模工具通常能够帮助自动或手动指定和管理需求、设计、代码和/或测试实体之间的可追溯性链接，这些实体可能在模型和其他软件工作产品中表示。（有关可追溯性的更多信息，请参见软件配置管理知识领域。）</p>
<h3 id="33-正确性分析-5-pp8-11">3.3. 正确性分析 [5*, pp8-11]</h3>
<p><strong>正确性</strong>是指模型满足其软件需求和软件设计规范的程度，无缺陷，并最终满足利益相关者需求的程度。正确性分析包括验证模型的语法正确性（即正确使用建模语言的语法和构造）和语义正确性（即使用建模语言构造正确表示其所代表内容的含义）。</p>
<h3 id="35-交互分析-2-c10-c11-3-c29s11-c29s5-4-c5">3.5. 交互分析 [2<em>,
c10, c11, 3</em>, c29s1.1, c29s5, 4*, c5]</h3>
<p><strong>交互分析</strong>关注软件模型中用于完成特定任务或功能的实体之间的通信或控制流关系。此分析检查软件模型不同部分之间交互的动态行为，包括其他软件层（如操作系统、中间件和应用程序）。对于某些软件应用程序，检查计算机软件应用程序与用户界面软件之间的交互也很重要。一些软件建模环境提供仿真设施来研究建模软件的动态行为方面。逐步执行仿真允许软件工程师审查交互设计并验证软件的不同部分是否协同工作以提供预期功能。</p>
<h2 id="4-软件工程方法-1">4. 软件工程方法</h2>
<p>软件工程方法为目标计算机的软件开发提供了有组织和系统的途径。有众多方法可供选择，软件工程师需要为手头的软件开发任务选择合适的方法。这种选择可能会极大地影响项目的成功。当具备正确技能和正确工具的软件工程师使用这些软件工程方法时，他们可以可视化软件的细节，并最终将表示转换为一组可工作的代码和数据。</p>
<p>下面将讨论选定的软件工程方法。主题领域组织为启发式方法、形式化方法、原型方法和敏捷方法的讨论。</p>
<h3 id="41-启发式方法-1-c13-c15-c16-3-c2s22-c7s1-c5-8-ppxiii-xvii-9-c2s2-11-c1-12-c1s1-19-pp220-242">4.1.
启发式方法 [1<em>, c13, c15, c16, 3</em>, c2s2.2, c7s1, c5, 8,
pp.xiii-xvii 9, c2s2, 11, c1, 12, c1s1, 19, pp.220-242]</h3>
<p><strong>启发式方法</strong>是基于经验的软件工程方法，在软件行业中被广泛实践。本主题领域包含五个广泛的讨论类别：结构化分析和设计方法、数据建模方法、面向对象分析和设计方法、面向方面开发方法以及模型驱动和基于模型的开发方法。</p>
<ul>
<li><p><strong>结构化分析和设计方法</strong>：这些方法主要从功能或行为视角开发软件模型。它们从软件的高层视图（包括数据和控制元素）开始，然后通过越来越详细的设计逐步分解或细化模型组件。详细设计最终收敛到必须编码（手工、自动生成或两者结合）、构建、测试和验证的特定软件细节或规范。</p></li>
<li><p><strong>数据建模方法</strong>：数据模型从使用的数据或信息的视角构建。数据表和关系定义数据模型。这种数据建模方法主要用于定义和分析支持数据库设计或数据仓库的数据需求，这些数据库或数据仓库通常存在于业务软件中，其中数据作为业务系统资源或资产被主动管理。</p></li>
<li><p><strong>面向对象分析和设计方法</strong>：面向对象模型表示为封装数据和关系的对象集合，这些对象通过方法与其他对象交互。对象可以是真实世界的项目或虚拟项目。这些方法使用图表构建模型，以构成软件的选定视图。模型的逐步细化导致详细设计。然后详细设计通过连续迭代演化或（使用某种机制）转换为模型的实现视图，在该视图中表达最终软件产品发布和部署的代码和打包。流行的面向对象方法包括统一过程(Unified
Process, UP)和UP的特定实现，如Rational统一过程(Rational Unified Process,
RUP)。（参见软件设计知识领域中的基于模型的需求部分和软件需求知识领域。）</p></li>
<li><p><strong>面向方面开发方法</strong>：使用规范语言，软件</p></li>
</ul>
<p>面向方面的方法旨在将横切关注点(crosscutting
concerns)与非横切关注点分离开来，并在整个生命周期中保持它们的封装性，以解决它们的分散和纠缠问题。方面(Aspect)是封装横切关注点的模块化单元。在软件层面，有一个”织入器(weaver)“负责根据良好定义的谓词(pointcuts)，在基础行为的某些点(join
points)连接封装在关注点中的功能部分(advices)。</p>
<p><em>• 模型驱动和基于模型的开发方法</em>：模型驱动开发(Model-Driven
Development,
MDD)是一种使用模型作为开发过程主要产物的方法。在MDD中，通常从模型(半)自动转换实现或其他模型。基于模型的开发(Model-Based
Development,
MBD)使用模型来分析系统，其中模型不一定是主要产物。一些文献将MBD称为基于模型的设计。基于模型的设计是一种以模型为中心的方法，用于开发控制、信号处理、通信和其他动态系统，专注于可执行规范和仿真。请参阅软件设计知识领域。模型驱动需求和基于模型的需求将相同的思维方式应用于软件需求规范，请参阅软件需求知识领域。MDD/MBD是基于模型的架构的前提条件，请参阅软件架构知识领域。有时，测试用例是从模型生成的，请参阅软件测试知识领域。</p>
<h2 id="42-形式化方法-1">4.2. 形式化方法</h2>
<p>[1*, c18, 3*, c27, 5*, pp8-24, 10, pp.xi-xiv]</p>
<p>形式化方法(Formal
methods)是应用严格的、基于数学的符号和语言来规范、开发和验证软件的软件工程方法。模型可以系统地检查一致性(或消除歧义)、完整性和正确性，无论是自动还是半自动。这个主题与软件需求知识领域中的形式化分析部分相关。</p>
<p>本节讨论规范语言、程序精化和派生、形式化验证、逻辑推理和轻量级形式化方法。</p>
<p><em>•
规范语言</em>：规范语言为形式化方法提供数学基础。规范语言是形式化的、更高级的计算机语言(不是经典的第三代语言(3GL)编程语言)，在软件规范、需求分析和/或设计阶段使用，用于描述特定的输入/输出行为。规范语言不是直接可执行的语言。相反，它们通常包括符号和语法、符号使用的语义以及对象允许的关系集。</p>
<p><em>• 程序精化和派生</em>：程序精化(Program
refinement)通过一系列转换创建更低级别(或更详细)的规范。通过连续的转换，软件工程师派生出程序的可执行表示。规范可以被精化，添加细节直到模型可以用3GL编程语言或所选规范语言的可执行部分表述。这种规范精化是通过定义具有精确语义属性的规范来实现的。例如，规范不仅必须设定实体之间的关系，还必须设定这些关系和操作的确切运行时含义。</p>
<p><em>• 形式化验证</em>：模型检查(Model
checking)是一种形式化验证方法。它通常涉及执行状态空间探索或可达性分析，以证明所表示的软件设计具有或保留某些感兴趣的模型属性。模型检查的一个例子是验证程序在所有可能的事件或消息到达交错情况下的正确行为的分析。形式化验证需要对软件及其操作环境进行严格规范的模型。该模型通常采用有限状态机或其他形式定义的自动机的形式。</p>
<p><em>• 逻辑推理</em>：逻辑推理(Logical
inference)是一种软件设计方法，它围绕每个重要的设计块指定前置条件和后置条件。使用数学逻辑，它开发证明这些前置条件和后置条件在所有输入下都必须成立。这允许软件工程师在不必执行软件的情况下预测软件行为。一些集成开发环境(IDE)包括表示这些证明和设计或代码的方法。</p>
<p><em>•
轻量级形式化方法</em>：轻量级形式化方法是轻量级的形式化应用，在更实用、易于应用的场景中使用形式化技术的子集。</p>
<h2 id="43-原型方法">4.3. 原型方法</h2>
<p>工程师选择原型方法首先理解最不被理解的软件方面或组件。这种方法与通常从最容易理解的部分开始开发的其他软件工程方法形成对比。通常，原型不会在没有大量开发返工或重构的情况下成为最终软件产品。</p>
<p>本节简要讨论原型风格、目标和评估技术。</p>
<p><em>•
原型风格</em>：原型风格描述了开发原型的各种方法。原型可以开发为一次性代码或纸质产品、工作设计的演进或可执行规范。每种风格通常使用不同的原型生命周期过程。选择的风格基于项目需要的结果类型、所需结果的质量和结果的紧迫性。</p>
<p><em>• 原型目标</em>：原型目标是原型服务的特定产品。</p>
<p>平衡实用性和原型开发工作量的方法。原型开发目标的例子包括需求规格说明、架构设计元素或组件、算法以及人机用户界面。</p>
<p>采用精确且富有表现力的符号表示法，该表示法基于少量简单而稳健的核心概念，但它用能够提供即时反馈的全自动分析取代了基于定理证明的传统分析方法。与定理证明不同，这种分析并非”完备的”：它只检查有限的案例空间。</p>
<p><strong>4.3. 原型开发方法</strong></p>
<p>[1<em>, c12s2, 3</em>, c2s3.1, 6*, c7s3p5]</p>
<p>软件<strong>原型开发</strong>（prototyping）是一项活动，通常创建不完整或功能最小化的软件应用版本，主要用于尝试特定的新功能；征求对软件需求或用户界面的反馈；进一步探索软件需求、软件设计或实现选项；或获得关于软件的其他有用见解。原型开发的目标包括需求规格说明、架构设计元素或组件、算法以及人机用户界面。</p>
<p><strong>•
原型评估技术</strong>：软件工程师或其他项目利益相关者可能以多种方式使用或评估原型，主要由导致原型开发的根本原因驱动。原型可以根据已实现的软件或目标需求进行评估或测试（例如，需求原型）。原型还可以作为未来软件开发的模型（例如，用户界面规格说明）。</p>
<p><strong>4.4. 敏捷方法</strong></p>
<p>[3<em>, c3, 6</em>, c7s3p7, 7*, c6, App. A, 13, 14, 15, 16, 18]</p>
<p>敏捷方法（Agile
methods）是在20世纪90年代发展起来的，旨在减少大规模软件开发项目中使用的重量级、基于计划的方法所带来的明显巨大开销。敏捷方法被认为是轻量级的，因为它们具有以下特点：短周期的迭代开发、自组织团队、更简单的设计、代码重构（refactoring）、测试驱动开发、频繁的客户参与，以及强调在每个开发周期中创建可演示的工作产品。敏捷方法可以被视为戴明改进循环（Deming
improvement
cycle）的Plan-Do-Check-Act（PDCA）在软件工程中的应用。例如，EVO是最早的敏捷方法之一，被认为是以增量方式实施PDCA循环的实用方法。</p>
<p>文献中有许多敏捷方法可供使用。这里简要讨论一些较流行的方法，包括快速应用开发（RAD）、极限编程（XP）、Scrum、特性驱动开发（FDD）和精益软件开发（Lean
software development）。</p>
<p><strong>•
RAD</strong>：RAD方法主要用于数据密集型业务系统应用程序开发。RAD通过专用数据库开发工具实现，软件工程师使用这些工具快速开发、测试和部署新的或修改后的业务应用程序。</p>
<p><strong>•
XP</strong>：这种方法使用故事或场景来描述需求，先开发测试，团队中有客户直接参与（通常定义验收测试），使用结对编程（pair
programming），并提供持续的代码重构和集成。故事被分解为任务，进行优先级排序、估算、开发和测试。每个软件增量都通过自动化和手动测试进行测试。增量可以频繁发布，例如每隔几周发布一次。</p>
<p><strong>•
Scrum</strong>：这种敏捷方法比其他方法更注重项目管理。Scrum主管（Scrum
master）管理项目增量内的活动。每个增量称为冲刺（sprint），持续时间不超过30天。产品负责人（product
owner）确定哪些项目进入产品待办事项列表（product
backlog）并开发产品待办事项列表。从该列表中识别、定义、优先排序和估算任务。在每个增量中测试并发布软件的工作版本。每日Scrum会议确保工作按计划管理。</p>
<p><strong>•
FDD</strong>：这是一种模型驱动的、短周期的迭代软件开发方法，使用五阶段过程：(1)
开发产品模型以界定领域的广度，(2) 创建需求或特性列表，(3)
构建特性开发计划，(4) 为迭代特定特性开发设计，(5)
编码、测试然后集成这些特性。FDD类似于增量软件开发方法。它与XP相似，但代码所有权分配给个人而不是团队。此外，FDD强调软件的整体架构方法，这促进了第一次就正确构建特性，而不是依赖于持续的重构。</p>
<p><strong>• Lean</strong>：这是精益制造原则从丰田生产系统（Toyota
Production
System）改编应用到软件开发的方法。该方法采用制作最小可行产品（Minimum
Viable
Product）的策略，团队发布其产品的最简单版本。团队学习用户的反馈并根据反馈进行迭代。精益的概念是优化整个开发过程，而不是优化单个开发过程。通过全面审视整个价值流，包括设计、制造、销售和服务交付，这种方法优化了流程以快速向用户交付服务。看板（Kanban）也是一种轻量级流程，应用了精益流程的许多理念。然而，存在一些根本差异，因为看板支持管理工作流和可视化。</p>
<p>文献和实践中还有更多敏捷方法的变体。重量级、</p>
<h1 id="基于计划的软件工程方法与轻量级发布周期">基于计划的软件工程方法与轻量级发布周期</h1>
<p>基于计划的软件工程方法以及敏捷方法大放异彩的场景。发布工程(Release
Engineering)是软件工程中的一个子学科，关注源代码的编译、组装和交付，将其转化为最终产品或其他软件组件。此外，新方法正在从敏捷和基于计划方法的组合中出现：实践者正在定义这些新方法，主要基于组织业务需求来平衡重量级和轻量级方法的特性。敏捷中的趋势是集成、构建和测试，这正是发布工程关注的重点。DevOps经常与敏捷和软件开发的持续部署方法混为一谈。为了避免混淆，这些业务需求通常由项目干系人确定，应该并且确实会驱动软件工程方法的选择。发布管理作为一种填补开发和运维之间协作差距的方法。发布经理需要监控开发过程和每个发布的发布日程。</p>
<p>大规模和企业敏捷方法(agile
approaches)反映了近期管理多个敏捷团队并在整个企业范围内应用敏捷原则和实践的努力，同时保持敏捷开发方法论的承诺(参见软件工程过程知识领域中的敏捷模型)。在DevOps中管理软件发布以跟上部署进度的关键是通过自动化管理工具，例如持续集成(Continuous
Integration, CI)系统。</p>
<p>敏捷方法论导致更短的发布周期。因此，发布工程有助于实现轻量级发布周期。</p>
<h2 id="主题与参考资料矩阵-1">主题与参考资料矩阵</h2>
<h3 id="1-建模-2">1. 建模</h3>
<p><strong>1.1. 建模原则</strong> [c3s3, c3s5, c4s2, c7s1, c7s2] [c2s2]
[c5s0]</p>
<p><strong>1.2. 模型的属性和表达</strong> [c7s2, c7s3] [c4s1.1p7,
c4s6p3, c5s0p3]</p>
<p><strong>1.3. 语法、语义和语用学</strong> [c2s2.2.2p6] [c5s0]</p>
<p><strong>1.4. 前置条件、后置条件和不变量(Invariants)</strong> [c4s4]
[c10s4p2, c10s5p2p4]</p>
<h3 id="2-模型类型-1">2. 模型类型</h3>
<p><strong>2.1. 结构建模</strong> [c9s5, c10s5] [c8s1, c5s3] [c4]</p>
<p><strong>2.2. 行为建模</strong> [c9s3, c10s6] [c9s2] [c5s4]</p>
<h3 id="3-模型分析-1">3. 模型分析</h3>
<p><strong>3.1. 完整性分析</strong> [c4s1.1p7, c4s6] [pp8-11]</p>
<p><strong>3.2. 一致性分析</strong> [c4s1.1p7, c4s6] [pp8-11]</p>
<p><strong>3.3. 正确性分析</strong> [pp8-11]</p>
<p><strong>3.4. 可追溯性</strong> [c4s7.1, c4s7.2]</p>
<p><strong>3.5. 交互分析</strong> [c10, c11] [c29s1.1, c29s5] [c5]</p>
<h3 id="4-软件工程方法-2">4. 软件工程方法</h3>
<p><strong>4.1. 启发式方法</strong> [c13] [c2s2.2, c7s1, c5s4.1]</p>
<p><strong>4.2. 形式化方法</strong> [c18s2] [c27] [pp8-24]</p>
<p><strong>4.3. 原型开发方法</strong> [c14s1, c14s2, c14s3] [c2s3.1]
[c7s3p5]</p>
<p><strong>4.4. 敏捷方法</strong> [c14s5, c14s6] [c3] [c7s3p7] [c6, app.
A]</p>
<h2 id="参考文献-9">参考文献</h2>
<p>[1*] D. Budgen, <em>Software Design: Creating Solutions for
Ill-Structured Problems</em>, 3rd Edition, CRC Press, 2021.</p>
<p>[2*] S.J. Mellor and M.J. Balcer, <em>Executable UML: A Foundation
for Model-Driven Architecture</em>, 1st ed. Addison-Wesley, 2002.</p>
<p>[3*] I. Sommerville, <em>Software Engineering</em>, 10th
ed. Addison-Wesley, 2016.</p>
<p>[4*] M. Page-Jones, <em>Fundamentals of Object-Oriented Design in
UML</em>, 1st ed. Addison-Wesley, 1999.</p>
<p>[5*] J.M. Wing, “A Specifier’s Introduction to Formal Methods,”
<em>Computer</em>, vol. 23, pp. 8, 10-23, 1990.</p>
<p>[6*] J.G. Brookshear, <em>Computer Science: An Overview</em>, 10th
ed. Addison-Wesley, 2008.</p>
<p>[7*] B. Boehm and R. Turner, <em>Balancing Agility and Discipline: A
Guide for the Perplexed</em>. Addison-Wesley, 2003.</p>
<p>[8] B. Selic and S. Gerard, <em>Modeling and Analysis of Real-Time
and Embedded Systems with UML and MARTE: Developing Cyber-Physical
Systems</em>, Morgan Kaufmann, 2013.</p>
<p>[9] M. Brambilla, J. Cabot, and M. Wimmer, <em>Model-Driven Software
Engineering in Practice</em>, Morgan &amp; Claypool Publishers,
2017.</p>
<p>[10] D. Jackson, <em>Software Abstractions</em>, revised edition, The
MIT Press, 2016.</p>
<p>[11] R. Aarenstrup, <em>Managing Model-Based Design</em>, CreateSpace
Independent Publishing Platform, 2015.</p>
<p>[12] C. Larman, <em>Applying UML and Patterns: An Introduction to
Object-oriented Analysis and Design and Iterative Development</em>,
Prentice Hall PTR, 2005.</p>
<p>[13] M. Poppendieck and T. Poppendieck, <em>Lean Software
Development</em></p>
<p>[14] 未列出</p>
<p>[15] D.J. Anderson, <em>Kanban: Successful Evolutionary Change for
Your Technology Business</em>, Blue Hole Press; 2010.</p>
<p>[16] J. Goodpasture, <em>Project management the agile way: Making it
work in the enterprise</em>, J. Ross Publishing, 2010.</p>
<p>[17] ISO/IEC 19505-1:2012, Information technology — Object Management
Group Unified Modeling Language (OMG UML) — Part 1: Infrastructure.</p>
<p>[18] ISO/IEC/IEEE 32675:2022, <em>Information technology — DevOps —
Building reliable and secure systems including application build,
package and</em></p>
<h1 id="第12章-1">第12章</h1>
<h1 id="软件质量-3">软件质量</h1>
<p><strong>缩略语</strong></p>
<p>CI/CD 持续集成/持续交付 CoSQ 软件质量成本 COTS 商业现货软件 IV&amp;V
独立验证与确认 PDCA 计划-执行-检查-行动 PSP 个人软件过程 QFD
质量功能展开 FTA 故障树分析 FMEA 失效模式与影响分析 SCM 软件配置管理 RCA
根本原因分析 SQA 软件质量保证 SQAP 软件质量保证计划 SQM 软件质量管理 SQC
软件质量控制 V&amp;V 验证与确认</p>
<h2 id="引言-5">引言</h2>
<p>什么是软件质量？为什么它如此重要，以至于在《SWEBOK指南》的许多知识领域(KA)中都有涉及？一个原因是术语”软件质量”含义过于宽泛。软件质量可以指软件产品的理想特性，指特定软件产品具有这些特性的程度（软件产品质量），以及用于实现这些特性的过程、工具和技术（软件过程质量）。多年来，作者和组织对”质量”一词的定义各不相同。Phil
Crosby将其定义为”符合要求”。Watts
Humphrey将其称为”实现卓越的适用性水平”。与此同时，IBM创造了”市场驱动质量”的说法，其中”客户是最终的仲裁者”。最后，适用性也是一个指代软件质量的术语。适用性是指产品、系统或服务在预期用户、预期用途、预期情境和预期环境条件下使用的适用能力。</p>
<p>最近，软件（产品）质量被定义为”软件产品在规定条件下满足需求的能力”和”软件产品满足利益相关者需求、期望和愿望的程度”。这两个定义都包含符合既定要求的前提。两者都没有提及不同类型的需求（按功能性、可靠性、性能、可依赖性或任何其他特性分类的需求）。然而，这些定义强调质量是需求的一个重要特征。这些定义还说明了在整个《SWEBOK指南》中反复讨论软件质量的另一个原因——软件质量和软件质量需求之间往往不清晰的界限（“性能需求”是这些术语的常见简称）。软件质量需求（软件需求KA中的服务质量约束）是功能性需求的属性（或约束）（系统做什么）。软件需求还可能指定资源使用、通信协议或许多其他特性（软件需求KA中的技术约束）。本知识领域试图通过使用上述定义中最广义的软件质量来澄清需求，并将软件质量需求作为对功能性需求的约束。软件产品质量是通过符合所有需求来实现的，无论指定的特性或需求的分组或命名如何。</p>
<p>软件质量在《SWEBOK指南》的许多其他知识领域中也有讨论，因为它是软件工程工作的基本概念。所有工程产品的主要目标是在平衡既定要求的同时交付最大的利益相关者价值。软件过程质量可以从效率、有效性、可用性和可学习性等过程特性中观察到。该过程中的缺陷很可能会在最终的软件产品中显现为缺陷。</p>
<p>最后，敏捷和DevOps运动旨在通过促进快速迭代反馈循环和通过共同定位用户和软件工程师来消除组织孤岛，从而通过合规性提高软件过程和产品质量。其他实践，如结对编程以及开发、测试和运营服务的自动化，也能带来价值、提高效率，并能及早发现缺陷。（有关DevOps和敏捷生命周期的更多信息，请参阅软件工程运营KA。）</p>
<p>本知识领域概述了理解软件质量的实践、工具和技术。</p>
<figure>
<img alt="图12.1. 软件质量主题分解" src="media/image-001.png"/>
<figcaption aria-hidden="true">图12.1. 软件质量主题分解</figcaption>
</figure>
<p><strong>图12.1.</strong> 软件质量主题分解</p>
<p>软件质量基础 | 软件质量管理过程 | 软件质量保证过程 | 软件质量工具</p>
<ul>
<li><p>软件工程文化与伦理</p></li>
<li><p>质量的价值和成本</p></li>
<li><p>标准、模型和认证 -软件可依赖性和完整性级别</p></li>
<li><p>准备质量保证</p></li>
<li><p>规划质量管理</p></li>
<li><p>评估质量管理</p></li>
<li><p>执行纠正和预防措施</p></li>
<li><p>执行过程保证</p></li>
<li><p>执行产品保证</p></li>
<li><p>验证与确认和测试</p></li>
<li><p>软件改进</p></li>
</ul>
<h1 id="软件质量-4">软件质量</h1>
<p>开发、维护和运营成本的约束条件，有时被描述为<strong>适用性</strong>。利益相关者价值体现在需求中。对于软件产品，利益相关者可能看重价格(他们为产品支付的费用)、交付周期(他们获得产品的速度)和质量。(参见软件需求知识领域以获得更广泛的讨论。)</p>
<p>软件过程质量方面，虽然上述内容已经暗示，但必须明确说明。软件过程的质量也可以</p>
<h2 id="软件质量主题分解">软件质量主题分解</h2>
<p>软件质量知识领域的主题分解如图12.1所示。</p>
<h3 id="1-软件质量基础-1">1. 软件质量基础</h3>
<p>就所有利益相关者对软件质量的认知达成一致，并将该共识传达给软件工程师，需要正式定义和传达质量的多个方面。软件工程师在确保质量方面面临的主要挑战包括:</p>
<ul>
<li>难以清晰定义需求;</li>
<li>与客户/用户保持有效沟通;</li>
<li>偏离规格说明;</li>
<li>架构和设计错误;</li>
<li>编码错误;</li>
<li>不符合当前流程/程序;</li>
<li>工作产品评审和测试不充分;</li>
<li>文档错误。</li>
</ul>
<p>软件质量被定义为”软件产品满足既定需求的程度;然而，质量取决于这些既定需求准确代表利益相关者需求、愿望和期望的程度”[6]。进一步定义为”软件产品满足既定需求的程度;然而，质量取决于这些既定需求准确代表利益相关者需求、愿望和期望的程度”[6]。质量通常意味着没有缺陷。<em>缺陷</em>一词被赋予了太多含义，因为工程师和其他人使用该词指代所有不同类型的异常。然而，不同的工程文化和标准通常将”缺陷”和其他术语理解为具有更具体的含义。为避免混淆，软件工程师应使用其标准提供的含义[14]:</p>
<ul>
<li><em>错误(Error)</em>:“产生不正确结果的人为行为”。也称为<em>人为错误</em>;</li>
<li><em>缺陷(Defect)</em>:(<em>故障的同义词</em>)工作产品中的”不完善或缺陷，该工作产品不满足其需求或规格说明，需要修复或替换”。当开发软件的人员出错时，就会插入缺陷。它隐藏在软件中，直到(如果)被发现;</li>
<li><em>失效(Failure)</em>:“系统终止执行所需功能的能力，或其无法在先前指定的限制内执行;系统规格说明的外部可见偏差”。当软件执行缺陷时会产生失效。</li>
</ul>
<p>软件工程师应理解软件质量概念、特性和价值及其在许多开发、维护和运营活动中的应用。软件需求应定义所需的软件质量属性。此外，软件需求影响评估软件和相关工作产品如何达到期望质量水平的测量方法和验收标准。应尽早规划软件质量，并在软件生命周期的许多里程碑处进行评估。最后，如何调整软件质量保证(SQA)活动以适应不同的生命周期，例如敏捷软件开发，在电气电子工程师学会(IEEE)标准730:2014[6]中有详细介绍。</p>
<h4 id="11-软件工程文化和道德规范-1">1.1. 软件工程文化和道德规范</h4>
<p>[1*, c1s1.6; c2s3] [5*]</p>
<p>组织文化影响软件工程师如何影响软件质量。正如Iberle[19]所解释的，软件工程实践因业务模型(例如定制、大众市场、商业、固件)和软件工程师工作的行业而异。软件工程师应在其行业背景下并作为其文化的一部分，共同致力于软件质量。健康的软件工程文化包括许多特征，例如理解成本、进度和质量之间的权衡是任何产品工程的基本原则。强大的软件工程道德规范假设工程师准确报告与质量相关的信息、条件和结果。</p>
<p>道德规范在软件质量、工程专业文化以及软件工程师的态度中也发挥着重要作用。IEEE计算机协会和美国计算机协会(ACM)制定了道德和专业实践规范。(参见软件工程专业实践知识领域中的道德和专业行为准则。)</p>
<h4 id="12-质量成本">1.2. 质量成本</h4>
<p>质量成本包括一致性成本和不一致性成本。</p>
<p>一致性成本是为预防和评估软件质量而进行的所有支出的总和。预防成本包括质量基础设施、质量工具、工作产品模板和培训。这些成本可能不针对特定项目;它们通常跨越更大的组织。</p>
<p>不一致性成本是处理已检测到的错误和缺陷的所有支出的总和。交付前成本是在评估活动期间发现并在软件产品交付给客户之前修复错误和缺陷所产生的成本。交付后成本包括响应软件失效所产生的成本。</p>
<h2 id="12-质量的价值与成本-1-c2s2">1.2. 质量的价值与成本 [1*, c2s2]</h2>
<p>推动实施软件质量保证(SQA)遭遇阻力的一个主要因素是其被认为的高成本。然而,不实施基本的SQA活动同样可能代价高昂。软件工程师应该向管理层说明,当他们未完全致力于质量时所承担的风险。这可以通过向管理层解释软件质量成本的概念来实现。</p>
<p>软件质量成本(CoSQ, Cost of Software
Quality)被定义为以下项目成本的总和:</p>
<ul>
<li>规划和构建活动的实施成本(例如:规划、设计、开发)</li>
<li>预防活动的成本(流程改进、工具、培训)</li>
<li>缺陷检测活动的评估成本(例如:评审、审计、测试)</li>
<li>不合规和返工成本(内部失效成本和外部失效成本)</li>
</ul>
<p>CoSQ可以分解为两个顶层类别:符合成本和不符合成本。符合成本是在错误和缺陷检测(评估)以及预防活动中所有投资的总和。评估成本来自旨在发现错误和缺陷的项目活动。这些活动包括测试(详见软件测试知识领域)以及评审和审计(详见本知识领域后面部分)。评估成本还延伸到分包的软件供应商(如果有的话)。预防成本包括在软件过程改进(SPI,
Software Process Improvement)工作中的投资。</p>
<p>交付后发现的缺陷会产生外部成本。外部成本包括修复和测试更新版本所需的返工。外部成本还包括返工和修复缺陷造成的非预期和无补偿的副作用或后果。然而,遭遇故障的客户所受的财务影响同样重要。例如,客户的生产力损失、数据丢失以及市场声誉的潜在损失都必须得到承认和考虑。除了对客户的影响之外,低质量软件还可能影响公众和环境。软件工程师应该寻求最优的CoSQ——即特定质量水平下的最小总成本。</p>
<h2 id="13-标准模型和认证-1-c4-7-c24s2">1.3. 标准、模型和认证 [1*, c4] [7,
c24s2]</h2>
<p>合理使用软件工程、软件标准以及软件过程评估和改进可以提升软件质量。关键的通用软件工程标准之一是ISO/IEC/IEEE
12207:2017,该标准描述了软件生命周期过程。首要的是,软件工程师应该了解适用于其特定行业的关键软件工程标准。正如Iberle所讨论的[19],软件工程师使用的实践因其工作所在的行业、商业模式和组织文化而有很大差异。例如,IEEE
1228:1994《软件安全计划标准》和IEEE
1633:2016《软件可靠性推荐实践》针对的是安全性和可靠性至关重要的行业。</p>
<p><a href="#软件质量-1">软件质量</a> 12-5</p>
<p>计划-执行-检查-行动(PDCA,
Plan-Do-Check-Act)范式与标准的不同之处在于,它通常从特定角度为软件工程师提出”最佳实践”。(有关PDCA范式的更多信息,请参阅软件工程过程知识领域。)</p>
<p>其他行业”最佳实践”模型,如用于信息技术治理的信息及相关技术控制目标(COBIT,
Control Objectives for Information and Related
Technologies)[27]、用于项目管理的项目管理知识体系(PMBOK®, Project
Management Body of Knowledge)[25]、业务分析知识体系(BABOK®, Business
Analysis Body of Knowledge)[28]、能力成熟度模型集成(CMMI, Capability
Maturity Model Integration)[29]以及开放组织架构框架(TOGAF, The Open
Group Architecture
Framework)[30],都提出了可以改进软件过程和产品质量的软件相关实践。软件组织还可以考虑获得注册或认证可能带来的优势(例如:质量方面的ISO
9001[10]、安全方面的ISO 27001[31]以及运营方面的ISO
20000[32]),软件工程师也可以获得Scrum和规模化敏捷框架®(SAFe®, Scaled
Agile
Framework)的敏捷过程认证[22]。这些模型和认证的使用已被证明可以增强利益相关者的信心,确信软件工程师的知识和技能是最新的并获得国际认可。</p>
<h2 id="14-软件可靠性和完整性">1.4. 软件可靠性和完整性</h2>
<p>DO-178C[8]和铁路应用EN
50128[18]以及用于更安全地开发安全关键型软件的新兴流程、工具和技术。这些标准、工具和技术降低了将故障注入软件的风险,从而改进了软件的可用性、可靠性和可维护性。软件工程师及其管理者必须理解威胁和问题,并培养预测和预防事故发生所需的技能[15]。</p>
<p>安全关键型软件可分为直接型和间接型。直接型软件嵌入在安全关键型系统中,如飞机的飞行控制计算机。间接型软件包括用于开发安全关键型软件的软件应用程序。间接型软件还包括软件工程环境和软件测试环境中的软件。</p>
<p>降低故障风险的三种互补技术是避免、检测和消除以及损害限制。这些技术影响软件功能需求、性能需求和开发过程。风险增加意味着需要增加SQA和更严格的评审技术,如检查(inspection)[16]。更高的风险级别可能需要对需求、设计和代码进行更彻底的检查,或使用更正式的验证和确认技术。另一种管理和控制软件风险的技术是构建</p>
<h1 id="级别-1-c4s8-c7s33-11-保证案例">级别 [1*, c4s8, c7s3.3] [11]
保证案例</h1>
<p><strong>保证案例</strong>是为支持其主张或多个主张得到满足而创建的、经过推理的、可审计的工件。它包含以下关系：一个或多个关于属性的主张、将证据和任何假设与主张逻辑关联起来的论证、以及支持这些论证的证据和假设主体
[9]。</p>
<p>软件密集型和安全关键型系统是指系统故障可能危害人类生命、其他生物、物理结构或环境的系统。这些系统中的软件被认为是安全关键型的，需要使用系统化的方法和工具来确保其高质量水平。越来越多的行业正在使用安全关键型软件，包括交通运输、化工和核能以及医疗。这些系统中的软件故障可能产生灾难性后果。工程师使用行业标准，如机载系统和设备认证中的软件考虑事项，</p>
<h2 id="141-可依赖性-7-c10">1.4.1. 可依赖性 [7, c10]</h2>
<p>在系统故障可能产生严重后果的情况下，整体可依赖性(dependability)（例如硬件、软件和人员或操作可依赖性）是除基本软件功能外的主要质量要求，12-6
<em>SWEBOK® GUIDE V4.0a</em></p>
<p>原因如下：系统故障影响许多人；用户通常会拒绝不可靠、不安全或不安全的系统；系统故障成本可能很高；不可依赖的系统可能造成信息丢失。许多标准从不同角度处理可依赖性，如可靠性和可用性。系统和软件可依赖性重新组合了几个相关的质量特性：可用性、可靠性、可维护性和可支持性、安全性和安全保障(security)
[21]。在开发可依赖软件时，工程师可以应用工具和技术来降低向中间交付物或最终软件产品注入故障的风险。他们可以使用静态、动态或形式化方法进行验证与确认(V&amp;V)以及测试过程，还可以使用其他专门的技术、方法和工具在软件生命周期的早期识别影响可依赖性的缺陷
[7*,
c10.5]。此外，他们可能必须在软件中加入特定机制来防范外部攻击并在运行期间容忍故障。</p>
<h2 id="142-软件完整性级别-1-c4s8-c7s32-11">1.4.2. 软件完整性级别 [1*,
c4s8, c7s3.2] [11]</h2>
<p>定义完整性级别是一种风险管理方法。<strong>完整性级别</strong>是”代表项目特有特征（例如复杂性、关键性、风险、安全级别、安全保障级别、期望性能和可靠性）的值，这些特征定义了系统、软件或硬件对用户的重要性”
[11]。用于确定软件完整性级别的特征因系统的预期应用和使用而异。软件是系统的一部分，其完整性级别作为该系统的一部分确定。</p>
<p>分配的软件完整性级别可能随着软件演进而改变。在系统或软件中实现的设计、编码、程序和技术特性可以提高或降低分配的软件完整性级别。为项目确定的软件完整性级别来自采购方、供应商、开发方和独立保证机构之间的协议。<strong>软件完整性级别方案</strong>用于确定软件完整性级别
[11]。</p>
<p>某些安全关键型行业，如航空电子、铁路、核电、医疗器械等，特定行业的指导可能要求软件质量活动具有一定程度的独立性，并可按完整性级别分配最低V&amp;V技术（此类技术的示例包括：可用性分析、算法分析、边界值分析、数据流分析、走查评审
[11][26]）。</p>
<h2 id="2-软件质量管理过程-1">2. 软件质量管理过程</h2>
<p>软件质量管理(SQM)关注”指导和控制组织在软件质量方面的协调活动”
[6]。质量管理过程的目的是确保产品、服务和质量管理过程的实施满足组织和项目的质量目标并实现客户满意。</p>
<p>SQM的一个重要概念是质量管理体系(QMS)的设计和维护。ISO90003 [26]
为软件行业解释了ISO9001的概念。QMS定义了流程、流程负责人、流程要求、流程及其输出的测量以及整个软件生命周期中的反馈渠道。QMS包含许多关键活动：SQA、V&amp;V、评审和审计、软件配置管理(SCM)，并要求有策略、程序和流程来确保参与的每个人都理解在软件过程和产品质量方面的期望。为了使QMS有效，管理支持至关重要。管理支持意味着项目接受了QMS要求的培训，并有足够的资源来实现为其定义的质量目标。应在软件项目评审期间频繁争取管理层的支持，以确保执行软件质量活动并处理不符合项。</p>
<p>软件质量 12-7</p>
<p>对于软件项目，软件质量过程包括任务和技术，以说明软件计划（例如软件</p>
<p>质量专家指出，产品的质量直接与利益相关者的关注有关——这也与软件工程相关。</p>
<p>管理、开发、质量管理或配置管理计划）如何实施，以及中间产品和最终产品如何满足其指定要求。这些任务的结果汇总在管理报告中。软件质量管理过程管理的任务是确保报告结果准确并得到执行。</p>
<p>风险管理也可以在交付高质量软件方面发挥重要作用。将规范的风险分析和管理技术融入软件生命周期过程中，有助于提高产品质量。（相关内容请参见软件工程管理知识领域中的风险管理部分。）</p>
<h2 id="21-软件质量改进-1">2.1 软件质量改进</h2>
<p>[1*, c9 and c9s9] [2] [3]</p>
<p>软件质量改进（SQI, Software Quality
Improvement）在软件行业中使用许多不同的方法来完成，包括软件过程改进（SPI,
Software Process Improvement）、六西格玛（Six
Sigma）、精益（Lean）和改善（Kaizen）等等。例如，软件过程改进活动旨在提高过程的有效性、效率和其他特性，以改善软件质量。尽管软件过程改进可以包含在前三个类别中的任何一个，但许多组织将软件过程改进组织成一个单独的类别，可能跨越多个项目。</p>
<p>使用精益原则以及持续改进的迭代过程，也可以改善软件产品质量。持续改进包括管理控制、活动协调以及来自许多并发过程的反馈：（1）改进软件生命周期过程的过程；（2）故障/缺陷分类、检测、移除和预防的过程；（3）个人改进过程。</p>
<p>质量改进背后的理论和概念——例如通过预防和早期检测缺陷来构建质量，持续改进——与过程质量相关联。改进模型如计划-执行-检查-行动（PDCA,
Plan-Do-Check-Act）改进循环、渐进式交付、改善以及质量功能展开（QFD,
Quality Function
Deployment）等技术提供了指定质量目标和确定是否达成目标的方法。</p>
<p>由于软件工程是一个复杂的过程，它不能简化为一本操作手册。为了补充过程和工具改进运动，Humphrey
[32] 提出了个人软件过程（PSP, Personal Software
Process），让软件工程师也能不断评估他们的技能和知识并持续改进。</p>
<h2 id="22-规划质量管理-1">2.2 规划质量管理</h2>
<p>[1*, c13]</p>
<p>软件质量规划包括定义要使用的软件质量过程，确定要使用哪些质量标准和模型，定义具体的质量目标，估算实现每个目标所需的工作量，以及决定软件质量活动应在哪些阶段进行。</p>
<p>首先，软件组织必须通过建立其质量管理体系（QMS, Quality Management
System）来承诺质量，质量管理体系包括质量管理政策、目标和程序。这要求分配实施质量管理体系的责任和权限，并且它们独立于当前的项目管理团队。</p>
<p>经批准的关于软件质量的组织政策有助于指导项目和产品开发决策以及人员行为。软件工程师应推动使用正式批准的过程和程序来实施质量政策，并解释角色、要执行的活动以及关键软件工程活动的预期结果。因此，用于改进的质量管理体系应以其用户为中心进行记录，并明确在何处验证质量控制。</p>
<p>程序详细解释了执行特定活动所采取的步骤。</p>
<h2 id="23-评估质量管理-1">2.3 评估质量管理</h2>
<p>一旦质量管理体系建立，ISO/IEC技术规范TS 33061:2021 [23]
标准定义了使用五个过程能力级别（从级别0：不完整到级别5：优化过程）的软件生命周期过程评估模型。此外，软件工程师可以使用IEEE
730:2014标准指南[6] 评估其软件项目中质量管理体系活动的成熟度。</p>
<p>管理层的支持有助于过程和产品评估。评估结果反馈到改进计划中，用于识别要在可行时间框架内解决的详细行动和改进项目。软件工程师会定期收集和分析质量保证评估结果。这可以通过查看项目产生的质量度量和缺陷特征来实现。</p>
<p>质量保证活动的成本（CoSQ, Cost of Software
Quality）是决定项目或软件开发和维护组织应如何组织时经常提出的问题。通常使用通用的成本模型；这些模型基于何时发现缺陷以及相对于在开发早期发现缺陷，修复缺陷需要多少工作量。内部收集的软件质量度量数据可能会为项目或组织内的成本提供更好的描述。</p>
<p>尽管软件质量度量数据本身可能有用（例如，缺陷需求的数量或缺陷需求的比例），但数学和图形技术可以帮助项目利益相关者解释这些度量。（参见工程基础知识领域和数学基础知识领域。）这些技术包括：</p>
<p>•
基于描述性统计的分析（例如，帕累托分析、运行图、散点图、正态分布）； •
统计检验（例如，二项检验、卡方检验）；</p>
<h2 id="231-软件质量测量">2.3.1. 软件质量测量</h2>
<ul>
<li>趋势分析（例如，控制图；参见《质量工具箱》进一步阅读材料）</li>
<li>预测（例如，可靠性模型）</li>
</ul>
<p>软件质量测量用于支持决策制定。随着软件复杂度的不断提升，质量问题已经超越了软件是否能够工作，而是关注它在多大程度上实现了可测量的质量目标。量化软件的某些属性可以帮助工程师评估其流程质量或流程的质量。（流程测量在软件工程知识领域中有详细描述。）</p>
<p>软件质量测量帮助工程师对软件质量做出判断（因为软件产品质量模型包含了用于确定软件产品实现质量目标程度的测量指标）；回答关于工作量、成本和进度的管理问题；何时停止测试并发布产品（参见软件测试知识领域中的测试相关测量）；以及流程改进工作的效果。基于描述性统计的技术和测试通常能够提供被检查软件产品中较麻烦区域的快照。生成的图表是可视化辅助工具，决策者可以使用它们来集中资源并在最需要的地方进行改进。趋势分析的结果可能表明进度正在延误，或者某些类型的缺陷可能变得更可能发生，除非在开发中采取一些纠正措施。预测技术有助于估算测试工作量和进度，并预测故障。（软件工程流程和软件工程管理知识领域中有更多关于测量的讨论。软件测试知识领域中提供了关于测试测量的更具体信息。）</p>
<p>软件质量测量还包括测量缺陷发生情况，并应用统计方法来了解哪些类型的缺陷最常发生。三种广泛使用的软件质量测量指标是错误密度(error
density)（每单位文档/软件规模的错误数量）、缺陷密度(defect
density)（发现的缺陷数量除以软件规模）和故障率(failure
rate)（平均故障时间）。可靠性模型是根据软件测试期间或服务中的软件收集的故障数据构建的，因此可用于估算未来故障的概率，并协助决定何时停止测试。这些信息可用于软件过程改进(SPI)，以确定防止、减少或消除缺陷重复出现的方法。</p>
<p>这些信息还帮助工程师了解趋势、检测和遏制技术的效果如何，以及开发和维护流程的进展情况。他们可以使用这些测量方法为特定应用领域开发缺陷档案(defect
profiles)。然后，对于该组织内的下一个软件项目，可以使用这些档案来指导软件质量管理流程——即将工作重点放在最可能出现问题的地方。类似地，基准测试或该领域典型的缺陷计数可能帮助工程师确定产品何时准备好交付。（关于使用测量数据改进开发和维护流程的讨论出现在软件工程管理和软件工程流程知识领域中。）</p>
<h2 id="24-执行纠正和预防措施-1">2.4. 执行纠正和预防措施</h2>
<p>当质量管理目标未达成时，记录并提交纠正措施以改进质量管理体系(QMS)，防止问题在未来的软件项目中再次发生，这一点非常重要。这要求项目参与者有一种方式向独立组织报告软件工程流程和工具问题，该组织将记录并监控纠正措施的进展，并通知相关方。</p>
<h3 id="241-缺陷特征分析">2.4.1. 缺陷特征分析</h3>
<p>为了帮助消除现有不符合项或不理想情况的一个或多个原因以防止再次发生，软件工程师可以使用软件质量控制(SQC)技术来发现流程和产品中的错误、缺陷和故障。在跟踪错误、缺陷和故障时，软件工程师关注的是事件的数量和类型。仅有数量而没有分类可能不足以帮助识别根本原因，从而无法在未来预防它们。因此，软件工程师应该建立一个有意义的缺陷分类分类法(taxonomy)来描述和分类此类异常。同行评审和测试发现的一个可能行动结果是尽早从被检查的工作产品中消除这些错误和缺陷。</p>
<p>其他软件质量管理活动试图消除它们的原因（例如，根本原因分析(RCA)）。RCA活动包括分析和总结发现以找到根本原因，并使用测量技术来改进软件工程流程、技术和工具。（流程改进主要在软件工程流程知识领域中讨论。RCA在工程基础知识领域中进一步讨论。）</p>
<p>除非记录下来，否则在软件质量保证(SQA)和控制技术期间发现的错误和缺陷数据可能会丢失。对于某些技术（例如，同行评审和检查），软件工程师在场记录此类数据并解决问题和做出决策。此外，当使用自动化工具时（参见主题4，软件质量工具），工具输出可能提供缺陷趋势报告，可以提供给组织管理层。</p>
<h2 id="3-软件质量保证流程">3. 软件质量保证流程</h2>
<h3 id="31-准备质量保证-1">3.1. 准备质量保证</h3>
<p>软件质量保证(SQA)被定义为</p>
<p>相关的利益相关者(stakeholders)。[“一组定义和评估软件过程充分性的活动，以提供证据来建立对软件过程适合其预期目的并能产生适当质量的软件产品的信心。”[<em>SWEBOK®
GUIDE V4.0a</em>]]</p>
<p>SQA计划不应与软件配置管理计划或任何其他相关的项目规划工件相冲突。此外，它们应被视为互补活动(对于过程SQAP，即SCM过程审计(Process
Audit)和测试活动对于SCM功能审计(Functional
Audit))。为了纠正一个常见的误解，SQA不仅仅是软件测试。在关键系统中，SQA的一个关键属性是SQA职能关于软件产品质量的客观性。在这种情况下，SQA职能也可能在组织上独立于项目；即不受技术、管理和财务压力的影响[6]。SQA有两个方面：产品保证(product
assurance)和过程保证(process assurance)，这将在第2.3节中介绍。</p>
<p>软件质量计划(在某些行业领域，它被称为软件质量保证计划(SQAP))定义了用于确保为特定产品开发的软件满足项目既定要求和用户需求的活动和任务，同时在项目成本和进度约束内，并与项目风险相称。SQAP首先确保质量目标被清晰地定义和理解。</p>
<p>SQAP的质量活动和任务及其成本、资源需求、目标以及与相关目标相关的进度计划，都在软件工程管理、软件开发和软件维护计划中规定。SQAP识别管理项目的文档、标准、实践和约定，以及如何检查和监控这些项目以确保充分性和合规性。SQAP还识别度量；统计技术；问题报告和纠正措施的程序；资源如工具、技术和方法论；物理媒体的安全性；培训；以及SQA报告和文档。此外，SQAP处理软件计划中描述的任何其他类型活动的SQA活动——例如为项目采购供应商软件、商业现货(COTS)软件安装和软件交付后的服务。它还可以包含验收标准以及对软件质量至关重要的报告和管理活动。SQA计划不应与软件配置管理计划或任何其他相关的项目规划工件相冲突。</p>
<p>软件质量涵盖几个视角：软件过程质量、软件最终产品质量和软件工作产品(也称为<em>中间产品</em>)质量。接下来的章节涵盖软件工程师必须具备的软件质量知识的每个视角。</p>
<h2 id="32-执行过程保证-1">3.2. 执行过程保证</h2>
<p>[[1*, c3s2-3, c4s6.1.3, c8, c9] [7, c25]]</p>
<p>Crosby[2]和Humphrey[3]已经证明，软件质量管理(SQM)和软件工程过程质量对最终软件产品的质量有直接影响。(评估和改进软件组织能力的模型和标准主要是项目组织和管理的考虑因素，因此在软件工程管理和软件工程过程知识领域中涵盖。)ISO
9001[10]提出了另一种过程质量视角，其中一个监督过程参与者、活动、控制、输入和输出的管理系统确保输出(例如工作产品和最终产品)的质量。<em>管理系统</em>被定义为”组织的一组相互关联或相互作用的要素，用于建立政策和目标以及实现这些目标的过程”[10]。这种视角要求软件工程组织花时间详细描述他们的政策、过程和程序，以便在生命周期活动期间软件工程师的角色和职责是明确的(如软件工程过程知识领域中详述)。</p>
<p>IEEE730:2014[6]中列出的SQA活动描述了应在软件项目生命周期早期进行的许多质量保证活动以确保质量。软件工程师应该意识到需要在某些项目里程碑处计划和执行SQA活动，并保留其执行记录。这些活动包括文档和代码审查以及验证和确认(V&amp;V)活动，包括测试(如本知识领域第3.4节详述)，这些活动评估过程输出对其需求和规范的符合性。</p>
<p>最后，软件配置管理(SCM)是确保工作产品和软件质量的重要活动。<em>配置管理</em>被定义为”应用技术和管理指导与监督的学科，以：</p>
<p>• 识别和记录功能和</p>
<p>软件工程师负责引出可能在一开始并不明确的质量需求，并理解它们的重要性以及定义它们、测量它们和为最终验收建立它们的难度。软件工程师应该理解如何定义质量需求以及它们的质量目标，以确保它们能够在项目的验收阶段有效地被测量。在项目规划期间，软件工程师必须牢记这些质量需求。如果安全性(safety)、安全性(security)和可靠性(dependability)等属性很重要，他们还必须预见潜在的额外开发成本。</p>
<p>构成软件产品众多可测量质量特性的是</p>
<p>以及配置项的物理特性； • 控制这些特性的变更； •
记录和报告变更处理和实施状态； • 验证是否符合规定的需求。</p>
<p>软件工程师应识别哪些工作产品和软件制品需要配置管理。此外，他们应熟悉源代码版本控制流程，包括跟踪基线版本和增量版本，确保不同开发人员所做的更改不会相互干扰，并且应知道如何操作版本控制工具包。（更多关于此流程的信息，请参阅软件配置管理知识领域。）</p>
<h2 id="33-执行产品保证-1">3.3. 执行产品保证</h2>
<p>[1*, s3.2–s3.3] [7, c4, s6.1.2]</p>
<p>首先，软件工程师必须确定待设计和构建软件的真正目的。利益相关者需求在此至关重要。它们包括质量需求（在软件需求知识领域中称为<em>服务质量约束</em>）和功能需求。因此，软件工程师应根据利益相关者需求定义质量特性，如ISO/IEC
25010:2011
[4]中所述。该标准提出了几个软件产品质量模型，由软件产品质量和使用中软件质量的特性和子特性组成。另一个是IEEE
982.1:2005《产生可靠软件的度量标准字典》。这些软件特性通常称为<em>产品质量需求</em>，它们是非功能性软件需求[7*,
c4,
s6.1.2]。软件工程师应了解在软件构建期间可以计划、实施和度量的众多软件特性（例如，功能适用性、性能效率、兼容性、可用性、可靠性、安全性、可维护性和可移植性）。软件工程师还应了解某些质量特性具有冲突影响。例如，尝试通过加密数据来增强安全性特性可能会对性能特性产生不利影响。该标准还提出了一个通用数据质量模型，专注于作为计算机系统一部分的数据质量，并为人类和系统使用的目标数据定义质量特性。</p>
<p>另一个软件产品质量视角是工作产品的质量。术语<em>工作产品</em>是指由用于创建最终软件产品的流程产生的任何制品。工作产品包括系统/子系统规格说明、系统软件组件的软件需求规格说明、软件设计描述、源代码、软件测试文档和测试报告。良好的工程实践要求在整个软件工程过程中使用工作产品评审和检查（本章稍后讨论）来评估与质量相关的中间工作产品。</p>
<h2 id="34-vv和测试-1">3.4. V&amp;V和测试</h2>
<p>[1*, c7] [11]</p>
<p><em>验证(Verification)</em>确保产品构建正确，即生命周期阶段的输出产品符合前期阶段强加给它们的规格说明。验证定义为”评估系统或组件以确定给定开发阶段的产品是否满足该阶段开始时施加的条件的过程”[11]。或者，<em>确认(Validation)</em>确保构建了正确的产品——产品满足其特定预期目的。它定义为”在开发过程中或结束时评估系统或组件以确定其是否满足规定需求的过程”。</p>
<p>V&amp;V的目的是帮助开发组织在整个开发生命周期中将质量构建到软件中。V&amp;V包括软件测试任务。软件测试是确保产品质量的必要活动。然而，在大多数情况下，软件测试不足以建立软件适合其预期用途的信心。IEEE中列出的V&amp;V任务涉及产品特性，包括产品的直接前身和计划规格说明。还列出了可选的V&amp;V任务，可以提高软件产品质量。在软件工作产品之间保持可追溯性记录有助于增强V&amp;V活动的质量。<em>可追溯性</em>定义为”追溯对象的历史、应用或位置的能力”[14]。</p>
<p>V&amp;V活动的早期规划确保每个资源、角色和职责都被清晰分配。生成的V&amp;V计划记录了各种资源及其角色和SQA活动，以及要使用的技术和工具。软件工程师应根据软件完整性级别选择和应用适当的V&amp;V任务。（参见第1.4.2节）。对于非常关键的软件，V&amp;V也可以由独立组织执行。独立验证和确认(IV&amp;V)定义为”由在技术、管理和财务上独立于开发组织的组织执行的V&amp;V”[11]。</p>
<p>软件V&amp;V任务可以分为静态、动态和形式化任务[20]。动态技术涉及执行软件；静态技术涉及分析文档和源代码但不执行软件；形式化技术使用数学和形式化规格说明语言。“静态分析技术”、“动态分析技术”和”形式化分析技术”之间没有严格的界限。例如，静态和动态分析技术通常具有很强的</p>
<h2 id="标准-10122016-11">标准 1012:2016 [11]</h2>
<p>在整个生命周期中客观评估形式化背景，如数据流分析产品和过程。这种评估证明需求是否正确、完整、准确、一致且可测试。验证过程和确认过程应在开发或维护早期开始。这样可以防止生命周期后期出现缺陷，否则会导致返工并显著增加成本。软件工程师应识别产品完整性级别，并确保为关键任务分配最低限度的
V&amp;V 任务。</p>
<h3 id="341-静态分析技术-1">3.4.1. 静态分析技术</h3>
<p>静态分析技术在不执行软件的情况下分析工作产品的内容和结构（包括需求、接口规范、设计和模型）。检测不可执行代码的唯一方法是通过静态分析，因为没有动态测试可以验证这一点。静态技术可以手动执行或借助工具执行。例如，代码阅读、工作产品的同行评审(peer
review)和源代码控制流的静态分析都被视为静态技术，因为它们不涉及执行软件代码。</p>
<p>第 3.4.5
节将展示评审和审计过程被视为静态分析活动，这意味着不执行软件或模型。相反，它们根据组织或项目为这些工件建立的标准来检查软件工程工件（也称为中间产品或工作产品）。</p>
<h3 id="342-动态分析技术-1">3.4.2. 动态分析技术</h3>
<p>动态分析技术涉及执行或模拟软件代码，寻找错误和缺陷。在软件开发、维护和运营过程中会执行不同的动态技术。通常，这些是测试技术，但模拟、模型分析和模型检查也被视为动态分析技术。（参见软件工程模型和方法
KA。）此外，黑盒测试被视为一种动态分析技术，因为软件工程师分析输入后收到的输出。（参见软件测试
KA。）</p>
<h3 id="343-形式化分析技术-7-c10s5">3.4.3. 形式化分析技术 [7*, c10s5]</h3>
<p>形式化分析技术（也称为形式化方法）是”软件开发的数学方法，在这种方法中，您定义软件的形式化模型。然后可以对该模型进行形式化分析，以搜索错误和不一致性”[7*,
c10s5]。有时，软件需求可能使用称为形式化方法的更正式的规范语言来编写。它们主要用于验证关键系统的关键部分，例如特定的安全性和安全要求。（另请参阅软件工程模型和方法
KA 中的形式化方法。）</p>
<p>在软件开发过程中，不同的团队可能会执行测试，包括独立于开发团队的团队。软件测试
KA 完全致力于这个主题。</p>
<h3 id="344-软件质量控制和测试-1-c7s10">3.4.4. 软件质量控制和测试 [1*,
c7s10]</h3>
<p>测试被认为是软件开发项目 V&amp;V
过程中包含的重要产品质量控制活动。质量控制是”在整个项目生命周期中测量、评估和报告软件项目工件质量的一组活动”[25]。软件测试是众多验证活动之一，这些活动确认软件开发输出满足输入需求。IEEE
730:2014 [6]
列出了软件工程师应计划、执行和记录的许多测试和重新测试活动。它还建议设置测试完成标准。软件工程师应计划测试活动，包括级别、技术、度量和工具。对于关键系统，软件质量工程团队应特别参与在交付前对软件产品进行验证，(i)
用于进一步集成或 (ii)
在目标计算环境中运行；作为独立的测试和评估活动，过程中不涉及开发团队成员。（有关软件工程师应掌握的软件测试知识的详细信息，请参阅测试
KA。）</p>
<h3 id="345-技术评审和审计-1-c5-c6-23-s4-s5">3.4.5. 技术评审和审计 [1*, c5,
c6] [23, s4, s5]</h3>
<p>第 2.4.1 节介绍了用于评估软件质量的 SQC
技术。对于其他工件，产品质量控制是通过对这些工作产品的评审和检查来评估的。这些
SQC 活动在开发、维护和运营活动期间进行计划和执行 [17]。</p>
<p>评审很有价值，因为它们可以在开发早期甚至在设计组件之前识别问题。修复已编码组件中的缺陷比事先发现它要昂贵得多。同行评审被定义为”在开发工作产品期间由同行对工作产品进行的评审，以识别要消除的缺陷”[14]。例如，在软件开发过程中，代码评审（通常使用拉取请求技术/工具完成）发生在同行评审代码时，通常应软件开发人员的请求，在代码合并到项目之前。</p>
<p>审计是更正式的活动，通常要求由第三方执行以确保独立性。在成熟的组织中，技术评审和审计与整体项目计划完全整合。因此，应计划、批准和进行技术评审和审计。尽管项目审计通常涉及整个项目的当前状态，但技术评审也可以更有针对性，并针对特定的项目阶段
[24]。</p>
<h1 id="不同类型的工作产品评审">不同类型的工作产品评审</h1>
<p>不同类型的工作产品评审（例如正式和非正式）通过其目的、独立性水平、使用的工具和技术、涉及的角色以及活动主题来区分。评审在软件质量、配置管理以及同事之间的知识共享中发挥着重要作用。然而，这些不同的角色有一个共同的目的——确保交付产品的质量。评审应该是软件工程文化的一部分，并应在软件生命周期中进行计划、执行和记录。在敏捷生命周期中，结对编程(pair
programming)提供了持续评审。ISO/IEC 20246:2017 [12]
描述了工作产品的不同评审类型：</p>
<p>• 临时评审(Ad hoc reviews) ——
非结构化评审，每个评审者需要尽可能找出任何类型的缺陷；</p>
<p>• 基于检查表的评审(Checklist-based reviews) ——
基于检查表识别问题的系统化评审；</p>
<p>• 基于场景的评审(Scenario-based reviews) ——
向评审者提供关于如何通读被评审工作产品的结构化指南的评审；</p>
<p>• 基于视角的评审(Perspective-based reviews) ——
评审者采用特定技术视角并从该利益相关者的观点评审工作产品的评审；</p>
<p>• 基于角色的评审(Role-based reviews) ——
评审者从各种利益相关者角色的视角评估工作产品的评审，这些角色可能与他们的日常角色不同。</p>
<p>评审有助于确保对顶层系统需求的理解水平足以支持进一步的需求分析和设计活动，并确保系统能够以可接受的风险进入初始系统设计；系统功能性或初步设计评审有助于确保被评审的系统能够以可接受的风险进入初步或详细设计，并且从批准的初步系统规范派生的所有系统需求和功能性能需求都已定义且与项目预算、项目进度、风险和其他项目和系统约束保持一致；初步设计评审有助于确保被评审系统的初步设计足够成熟，准备进入详细设计，并能在项目预算、进度、风险和其他项目和系统约束内满足规定的性能要求；测试就绪评审评估测试目标、测试方法和程序、测试范围、安全性、项目测试和评估的准备情况，以及是否已正确识别和获得测试资源；生产就绪评审确定系统设计是否准备好进行生产，以及项目是否已为进入生产完成了足够的生产计划。</p>
<h2 id="4-软件质量工具-1">4. 软件质量工具</h2>
<p><strong>[c3s2.3, c7s8.1, c7s11]</strong></p>
<p>软件工具改进软件质量。简单的工具可以是表格和检查表（例如需求可追溯性矩阵(requirements
traceability
matrix)或代码评审检查表）。但自动化工具也能极大帮助提高软件效率和质量。自动化工具的例子包括允许代码版本控制/分支的工具（例如Git）和用于代码评审的拉取请求(pull
requests)。DevOps工具在服务/脚本中的应用，如按需环境、持续集成/持续交付(continuous
integration/continuous delivery,
CI/CD)、代码质量评估和自动化测试，是软件质量的重要贡献者。（参见软件运维KA中关于工具的内容。）</p>
<p>这些工具被称为静态和动态分析工具。静态分析工具输入源代码，在不执行代码的情况下进行语法和语义分析。可应用于制品（包括模型）和源代码的静态分析工具在深度、彻底性和范围上有很大差异。（参见软件构造、软件测试和软件维护KA中对动态分析工具的描述。）静态分析工具的类别包括以下内容：</p>
<p>•
促进并部分自动化文档和代码评审和检查的工具。这些工具可以将工作路由给不同的参与者，以部分自动化和控制评审过程。此外，它们允许用户输入在检查和评审期间发现的缺陷，以便稍后移除；</p>
<p>•
帮助组织执行软件安全危害分析的工具。例如，这些工具为失效模式与影响分析(failure
mode and effects analysis, FMEA)和故障树分析(fault tree analysis,
FTA)提供自动化支持；</p>
<p>•
支持跟踪软件问题的工具。这些工具能够输入软件测试期间发现的异常以及后续的分析、处置和解决。一些工具包括对工作流和跟踪问题解决状态的支持；</p>
<p>•
分析从软件工程环境和软件测试环境捕获的数据，并以图形、图表和表格的形式生成量化数据的可视化显示的工具。这些工具有时包括对数据集执行统计分析（以识别趋势并进行预测）的功能。其中一些工具提供缺陷注入和移除率、缺陷密度、产出率，以及每个生命周期阶段缺陷注入和移除的分布。</p>
<div class="page-separator"></div>
<h2 id="主题与参考资料对照矩阵-1">主题与参考资料对照矩阵</h2>
<p><strong>主题</strong> | [d] | [e] | [ar] | [1*] | [lle] | [tw] | [8]
| [vi] | [*] | [an] | [of] | [01] | [*] | [s] | [3*] | [te] | [er] |
[s[5] | [er] | [m] | [7] | [1] | [E S] | [e of] | [or] | [il 2] | [ic] |
[m] | [16] | [E] | [ieg] | [13] | [pr] | [od] | [th] | [Lap] | [A] |
[So] | [20] | [IE] | [C] | [E] | [W] | [20]</p>
<p><strong>1. 软件质量基础</strong></p>
<h2 id="11-软件工程文化与伦理">1.1. 软件工程文化与伦理</h2>
<h2 id="12-质量的价值与成本">1.2. 质量的价值与成本</h2>
<h2 id="13-标准模型与认证">1.3. 标准、模型与认证</h2>
<h2 id="14-软件可靠性与完整性级别">1.4. 软件可靠性与完整性级别</h2>
<p><strong>2. 软件质量管理过程</strong></p>
<h3 id="21-软件质量改进-2">2.1. 软件质量改进</h3>
<h3 id="22-质量管理规划">2.2. 质量管理规划</h3>
<h3 id="23-质量管理评估">2.3. 质量管理评估</h3>
<h3 id="24-执行纠正与预防措施">2.4. 执行纠正与预防措施</h3>
<p><strong>3. 软件质量保证过程</strong></p>
<h3 id="31-质量保证准备">3.1. 质量保证准备</h3>
<h3 id="32-执行过程保证-2">3.2. 执行过程保证</h3>
<h3 id="33-执行产品保证-2">3.3. 执行产品保证</h3>
<h3 id="34-验证确认与测试">3.4. 验证、确认与测试</h3>
<p><strong>4. 软件质量工具</strong></p>
<p><strong>延伸阅读</strong></p>
<p>IEEE 730-2014, “IEEE软件质量保证过程标准”，2014</p>
<p>为所有参与系统和软件管理、开发、测试和维护的组织建立了一个可参考和使用的工作产品评审通用框架。</p>
<p>启动、规划、控制和执行软件开发或维护项目的软件质量保证过程的要求。</p>
<p>IEEE 1012:2016, “IEEE系统、软件和硬件验证与确认标准”，2016</p>
<p>N. Leveson, <em>Safeware: System Safety and Computers</em></p>
<p>验证与确认（V&amp;V）过程用于确定某项活动的开发产品是否符合该活动的要求，以及产品是否满足其预期用途和用户需求。为不同完整性级别规定了V&amp;V生命周期过程要求。</p>
<p>本书描述了软件安全实践的重要性，以及如何将这些实践融入软件开发项目中。</p>
<p>ISO/IEC 20246:2017, “软件和系统工程 — 工作产品评审”，2017</p>
<p>T. Gilb和D. Graham, <em>Software Inspection</em></p>
<p>本书介绍了评审和缺陷的度量和统计抽样方法。它提出了可产生量化结果的技术，用于减少缺陷、提高生产力、跟踪项目和创建文档。</p>
<p>K.E. Wiegers, <em>Peer Reviews in Software: A Practical
Guide</em></p>
<p>本书提供了对不同同行评审方法的清晰简洁的解释，这些方法按正式程度和有效性进行了区分。它为实施这些方法以及确定哪些方法适合特定情况提供了实用指导。</p>
<p><strong>参考文献</strong></p>
<p>[1] C.Y. Laporte和A. April, <em>Software Quality Assurance</em>, IEEE
Press, 2018.</p>
<p>[2] P.B. Crosby, <em>Quality Is Free</em>, McGraw-Hill, 1979.</p>
<p>[3] W. Humphrey, <em>Managing the Software Process</em>,
Addison-Wesley, 1989.</p>
<p>[4] “ISO/IEC 25010:2011系统和软件工程 —
系统和软件质量要求与评估（SQuaRE）— 系统和软件质量模型”，2011.</p>
<p>[5] IEEE
CS/ACM软件工程伦理与专业实践联合工作组，“软件工程伦理与专业实践规范”
https://www.computer.org/education/code-of-ethics.</p>
<p>[6] IEEE 730软件质量保证过程标准，IEEE, 2014.</p>
<p>[7] I. Sommerville, <em>Software Engineering</em>,
第10版，Addison-Wesley, 2016.</p>
<p>[8] RTCA, “DO-178C, 机载系统和设备认证中的软件考虑”，2012.
在EUROCAE中也称为ED-12C。</p>
<p>[9] ISO/IEC 15026-1:2019系统和软件工程 — 系统和软件保证 —
第1部分：概念和词汇，2019.</p>
<p>[10] “ISO 9001:2015质量管理系统 — 要求”，2015.</p>
<p>[11] IEEE Std. 1012:2016, “系统和软件验证与确认标准”，2016.</p>
<p>[12] ISO/IEC 20246:2017, “软件和系统工程 — 工作产品评审”，2017.</p>
<p>[13] K.E. Wiegers, <em>Software Requirements</em>, 第3版，Microsoft
Press, 2013.</p>
<p>[14] ISO/IEC/IEEE 24765:2017系统和软件工程 — 词汇，2017.</p>
<p>[15] N. Leveson, <em>Safeware: System Safety and Computers</em>,
Addison-Wesley Professional, 1995.</p>
<p>[16] T. Gilb和D. Graham, <em>Software Inspection</em>, Addison-Wesley
Professional, 1993.</p>
<p>[17] K.E. Wiegers, <em>Peer Reviews in Software: A Practical
Guide</em>, Addison-Wesley Professional, 2001.</p>
<p>[18] BS EN 50128:2011+A2:2020, “铁路应用标准 – 通信、信号和处理系统 –
铁路控制和保护系统软件”，英国采用的欧洲标准，2020年8月10日.</p>
<p>[19] K. Iberle, <em>They don’t care about quality</em>, STAR
East会议论文集，美国奥兰多，2013，可访问：https://kiberle.com/publications/.</p>
<p>[20] D. Wallace, L.M. Ippolito和B.B. Cuthill, <em>Reference
Information for the Software Verification and Validation Process</em>,
美国国家标准与技术研究院（NIST），美国商务部，特别出版物500-234，1996.</p>
<p>[21] IEC 60300-1:2014, “可靠性管理 —
第1部分：管理和应用指南”，2014.</p>
<p>[22] D. Leffingwell, SAFe <em>4.5 Reference Guide: Scaled Agile
Framework For</em></p>
<p>[27] COBIT, “信息技术控制目标”，2019版，ISACA和IT治理协会。</p>
<p>[28] BABOK, “业务分析知识体系指南”，版本</p>
<p><em>精益企业</em>，第2版，Addison-Wesley，2018年。 [3,
国际商业分析研究所，04-2015。]</p>
<p>[23] ISO/IEC TS 33061:2021， [29] CMMI，“能力成熟度模型集成”，</p>
<p>“信息技术 — 过程评估 — 软件 版本10，ISACA，2023年。</p>
<p>生命周期过程的过程评估模型”，</p>
<p>2021年。 [30] TOGAF，“开放组架构框架”，</p>
<p>版本10，2022年。</p>
<p>[24] IEEE 15288.2:2014，“国防项目</p>
<p>技术审查和审计的IEEE标准”， [31] ISO/IEC 27001:2022，“信息安全、</p>
<p>2014年。 网络安全和隐私保护 — 信息安全 —</p>
<p>管理系统 — 要求”，2022年。</p>
<p>[25] 项目管理知识体系指南，第7版，</p>
<p>PMI，2021年。 [32] Humphrey, W.，PSP：软件工程师</p>
<p>的自我改进过程，Addison-Wesley</p>
<p>[26] ISO/IEC/IEEE 90003:2018， Professional，2005年。</p>
<p>“ISO 9001在计算机软件中应用</p>
<p>的指南”，2018年。</p>
<h2 id="第13章-1"><strong>第13章</strong></h2>
<p><strong>软件安全</strong></p>
<p><strong>缩略词</strong> 将安全性融入软件比在软件开发</p>
<p>后再打补丁要好得多。要将安全性</p>
<p>CC 通用准则 设计到软件中，必须考虑每个开发</p>
<p>SDLC 安全开发生命周期 生命周期阶段。安全软件开发涉及</p>
<p>软件需求安全、软件设计安全、软件</p>
<p>构建安全和软件测试安全。此外，</p>
<p><strong>引言</strong> 在软件维护期间也必须考虑安全性，</p>
<p>因为安全故障和漏洞可能在维护期间</p>
<p>由于潜在的滥用和针对计算机系统 被引入，而且经常如此。</p>
<p>的恶意活动不断增加，安全性已成为</p>
<p>软件开发中的一个重大问题。除了 <em>1.1. 软件安全</em> [10]</p>
<p>通常的正确性和可靠性问题外，软件</p>
<p>开发人员必须关注他们开发的软件
<em>安全性</em>是一种产品质量特性，</p>
<p>的安全性。 表示产品或系统保护信息和数据的</p>
<p>安全软件开发通过遵循一套既定 程度，使人员或其他产品或系统拥有</p>
<p>和/或推荐的规则和实践来构建安全性。
与其类型和授权级别相适应的数据</p>
<p>安全软件维护通过确保在软件维护 访问权限[10]。（有关产品质量的更多</p>
<p>期间不引入安全问题，以及在软件 信息，请参阅软件质量知识领域。）</p>
<p>生命周期中可以处理已识别的漏洞</p>
<p>（攻击者可以利用的错误）来补充 <em>1.2. 信息安全</em> [11]</p>
<p>安全软件开发。安全漏洞不仅在开发</p>
<p>阶段引入，还可能通过第三方组件
<em>信息安全</em>保护信息的机密性、</p>
<p>（如库、商用现货软件(COTS)或操作系统(OS)）
完整性和可用性。还可能涉及其他</p>
<p>引入。 属性，如真实性、问责性、不可</p>
<p>否认性和可靠性[11]。<em>机密性</em>是</p>
<p>确保信息不被泄露给未经授权的</p>
<p><strong>软件安全主题分解</strong>
个人、实体或进程的属性。<em>完整性</em></p>
<p>是准确性和完整性的属性。<em>可用性</em></p>
<p>软件安全知识领域的主题分解如 是由授权实体按需访问和使用的</p>
<p>图13.1所示。 属性。软件工程师应该定义其软件</p>
<p>的安全属性，并在整个软件开发</p>
<p><strong>1. 软件安全基础</strong> [37, 9] 生命周期中维护它们。</p>
<p>关于软件安全的一个普遍接受的观点是，</p>
<p>13-1</p>
<p>13-2 <em>SWEBOK® GUIDE V4.0a</em></p>
<p><strong>软件安全</strong></p>
<figure>
<img alt="图13.1. 软件安全知识领域的主题分解" src="media/image-001.png"/>
<figcaption aria-hidden="true">图13.1.
软件安全知识领域的主题分解</figcaption>
</figure>
<p><em>1.3. 网络安全</em> [12][38] <em>2.1. 能力成熟度模型</em></p>
<p>[3*, c22][14]</p>
<p>网络安全是保护人员、社会、组织</p>
<p>和国家免受网络风险。保护意味着 许多组织在计算机程序的开发中</p>
<p>将网络风险保持在可容忍的水平。 实践安全工程，包括操作系统、</p>
<p>通常，网络安全解决网络空间中的 管理和执行安全的功能、打包的</p>
<p>安全问题，包括以下内容： 软件产品、中间件和应用程序。</p>
<p>因此，各种各样的个人必须知道</p>
<p>• 社会工程攻击 如何应用适当的方法和实践，包括</p>
<p>• 黑客攻击 产品开发人员、服务提供商、系统</p>
<p>• 恶意软件(<em>malware</em>) 集成商、系统管理员甚至安全专家。</p>
<p>• 其他潜在的有害软件[12] 系统安全工程 — 能力成熟度模型</p>
<p>(SSE-CMM)帮助</p>
<h1 id="软件安全-2">软件安全</h1>
<p>软件工程师应将此类威胁的缓解措施作为软件开发的一部分来考虑。能够衡量执行风险评估的组织的过程能力[14]，是一项重要工具。</p>
<h2 id="2-安全管理与组织">2. 安全管理与组织</h2>
<p><strong>[1*, c7][13]</strong></p>
<p>安全治理和管理在系统化实施时最为有效；换句话说，当它们融入组织行为和行动的文化和结构时。项目管理者需要将软件安全从独立的技术关注提升到企业级议题[1]。</p>
<p><strong>2.1. 信息安全管理体系 [15]</strong></p>
<p>ISO/IEC
27001:2022规定了在组织环境中建立、实施、维护和持续改进信息安全管理体系(ISMS)的要求[15]。ISMS是管理组织技术相关安全的文档化计划。这包括记录风险并采取措施应对风险，旨在保护组织数据并防止安全漏洞[15]。组织应使用它持续进行风险评估以识别安全风险和漏洞，并通过部署IT团队监控这些风险来实施保护措施。</p>
<p>ISMS因此也可能提出新的或修改现有的软件安全需求。此外，软件安全需求还来源于法律、法规和合规义务。</p>
<p><strong>2.2. 软件安全的敏捷实践 [4, c15, c16]</strong></p>
<p>敏捷团队需要理解并采用安全实践，并对其系统的安全承担更多责任。安全专业人员必须学会接受变化，更快、更迭代地工作，并以渐进的方式思考安全风险以及如何管理风险。最后也是最重要的，安全需要成为促进者而不是阻碍者。成功的敏捷安全计划的关键是安全团队和开发人员的参与、赋能、自动化以及跟上敏捷团队的敏捷性[4]。</p>
<p>最近，DevSecOps(意为开发、安全和运维的集成)已经出现。除了SDLC之外，DevSecOps还包括文化、自动化和平台设计的方法，使软件生命周期像敏捷开发和持续集成(CI)一样敏捷且负责任。</p>
<h2 id="3-软件安全工程与过程">3. 软件安全工程与过程</h2>
<p><strong>3.1. 安全工程与安全开发生命周期(SDLC) [1*,
c1][16][36]</strong></p>
<p>软件的安全性取决于其开发过程。安全性必须内置于软件工程中以确保软件安全。SDLC概念是旨在实现这一目标的趋势之一。SDLC使用经典的螺旋模型，从软件生命周期的角度全面看待安全，并确保安全是软件设计和开发中固有的，而不是生产后期的事后补救。声称SDLC过程可以降低软件维护成本并提高软件对安全相关故障的可靠性。</p>
<p><strong>3.2. 信息技术安全评估通用准则 [3*, c22,
c25][34][35]</strong></p>
<p>安全评估建立了对IT产品的安全功能以及应用于它们的保证措施的信心。评估结果可以帮助消费者确定IT产品是否满足其安全需求或标准符合性。ISO/IEC
15408:2022，命名为信息技术安全评估通用准则(CC)，可作为开发、评估和/或采购具有安全功能的IT产品的指南[34]。</p>
<p>CC解决资产保护免受未经授权的披露、修改或使用损失的问题。与这三种安全故障类型相关的保护类别通常分别称为<em>机密性(confidentiality)</em>、<em>完整性(integrity)</em>和<em>可用性(availability)</em>。</p>
<h2 id="4-软件系统的安全工程-1-c1-c33-c1-c3">4. 软件系统的安全工程 [1*,
c1, c3][3*, c1, c3]</h2>
<p><strong>4.1. 安全需求 [1*, c3][2, c2][3*, c20, c30][18]</strong></p>
<p>安全需求工程包括提取、规范和优先级排序。它考虑威胁，如误用和滥用案例所示，威胁行为者、安全风险评估、规范方法的选择和应用、优先级排序方法、检查和修订。生命周期模型的选择可能影响活动顺序，软件产品修订意味着需要重新审视安全需求。安全需求在整个开发过程中的可追溯性(traceability)很重要，安全团队可能包括安全需求方面的专家。存在众多支持安全需求工程的方法和工具。</p>
<p><strong>4.2. 安全设计 [1*, c4][2, c5][3*, c20, c31][17,
40]</strong></p>
<p><em>安全设计</em>关注如何防止未经授权的披露、创建、更改、删除或拒绝访问信息。</p>
<p><strong>4.3. 软件构建安全</strong></p>
<p>软件构建安全这个术语对不同的人可能意味着不同的事情。它可以指特定功能的编码方式，使代码本身是安全的，或者可以指将安全性编码到软件中。不幸的是，大多数人在没有区分的情况下将这两种含义混为一谈。造成这种混淆的一个原因是不清楚如何确保特定编码是安全的。例如，在C编程语言中，表达式…</p>
<h2 id="42-安全设计-1">4.2. 安全设计</h2>
<p>安全设计关注软件模块的设计，这些模块需要协同工作以满足安全需求中指定的安全目标。为了满足安全需求，开发人员需要进行威胁建模(threat
modeling)，展示系统如何受到攻击，从而为缓解措施指定安全设计。这一步骤明确了安全考虑的细节，并制定了具体的实施步骤。考虑的因素可能包括框架和访问模式，它们建立整体的安全监控/执行策略，以及各个策略执行机制。</p>
<p>安全设计还涉及资源分配和其他资源管理。它还涉及如何通过限制损害、继续服务、加快修复和恢复以及安全地失败和恢复来容忍与安全相关的攻击或违规。访问控制(access
control)是安全的基本概念。大多数控制建立在加密算法(cryptographic
algorithms)和密钥等加密材料(cryptographic
material)之上。仔细选择这些内容以及加密材料的创建、分发和管理方式非常重要。</p>
<p>表达式”i&lt;&lt;1”(将i的二进制表示向左移动一位)和”2*i”(将变量i的值乘以常数2)在语义上表示同一件事，但它们是否具有相同的安全影响？</p>
<p>答案可能因不同的指令集架构(ISA)和编译器组合而异。由于缺乏这种理解，软件构建安全——在其当前状态下——主要指的是上面提到的第二个方面：将安全性编码到软件中。</p>
<p>将安全性编码到软件中可以通过遵循推荐的规则来实现。一些此类规则包括：</p>
<ul>
<li>构建流程结构，使所有需要额外权限的部分都是模块化的。这些模块应尽可能小，并且只执行需要这些权限的任务。</li>
<li>确保程序中的任何假设都得到验证。如果无法做到这一点，请为安装人员和维护人员记录这些假设，以便他们了解攻击者将试图使哪些假设失效。</li>
<li>确保程序不与任何其他程序共享内存中的对象。</li>
<li>检查每个函数的错误状态。除非错误的原因及其影响都不影响任何安全考虑，否则不要恢复。程序应将软件状态恢复到进程开始之前的状态，然后终止。</li>
</ul>
<p>虽然没有万无一失的方法来实现安全软件开发，但确实存在一些有用的通用指南。</p>
<p>这些指南涵盖软件开发生命周期的每个阶段。计算机应急响应小组(CERT/CC)发布了可靠的指南[22]，以下是其十大软件安全实践：</p>
<ol type="1">
<li>验证输入</li>
<li>注意编译器警告</li>
<li>为安全策略进行架构和设计</li>
<li>保持简单</li>
<li>默认拒绝</li>
<li>遵守最小权限原则(principle of least privilege)</li>
<li>清理发送到其他软件的数据</li>
<li>实践纵深防御(defense in depth)</li>
<li>使用有效的质量保证技术</li>
<li>采用软件构建安全标准</li>
</ol>
<h3 id="43-安全模式-1c41920-21">4.3. 安全模式 [1*,c4][19][20, 21]</h3>
<p><strong>安全模式(security
pattern)</strong>描述了在特定上下文中出现的特定重复出现的安全问题，并提供了经过充分验证的通用解决方案[21]。</p>
<h3 id="44-安全构建-1c53c20c3122-23-24">4.4. 安全构建
[1*,c5][3*,c20,c31][22, 23, 24]</h3>
<p>软件构建安全涉及如何为特定情况编写编程代码以解决安全考虑。</p>
<h3 id="45-安全测试-1c52c73c24c3126-27">4.5. 安全测试
[1*,c5][2,c7][3*,c24,c31][26, 27]</h3>
<p>安全测试确保实现的软件满足安全需求。它还验证软件实现不包含任何已知的漏洞。虽然通用软件测试方法可以处理前者，但后者需要特定于安全的测试方法。(有关测试的更多信息，请参阅软件测试知识领域。)</p>
<p>有两种安全特定测试的通用方法。第一种方法包括通过静态分析(static
analysis)检测漏洞，可以对源代码或编译的二进制文件进行静态分析。对源代码的静态分析可用于</p>
<p>检查代码中的常见漏洞。第二种方法是通过动态测试(dynamic
testing)检测漏洞，通常使用漏洞评估(vulnerability
assessment)或渗透测试(penetration
testing)(也称为道德黑客测试)等技术来检测软件行为中的漏洞。与静态分析一样，有一些工具可以自动化动态测试，例如Web应用程序扫描器和模糊测试(fuzzing)工具。应聘请在应用领域熟练的安全专家来执行这些测试，并且此类测试应始终在法律范围内并获得适当授权的情况下进行。后一个方面对于将此类测试与非法黑客活动区分开来至关重要。</p>
<h3 id="46-漏洞管理-1c53c242829-30">4.6. 漏洞管理 [1*,c5][3*,c24][28,29,
30]</h3>
<p>使用健全的编码实践可以帮助大幅减少在实现过程中常见引入的软件缺陷[1]。此类常见的安全缺陷被分类并与数据库共享：通用漏洞披露(CVE,
Common Vulnerabilities and Exposures)[28]、通用弱点枚举(CWE, Common
Weakness Enumeration)[29]和通用攻击模式枚举与分类(CAPEC, Common Attack
Pattern Enumeration and Classification)[30]；通用漏洞评分系统(CVSS,
Common Vulnerability Scoring
System)[41]表达软件漏洞的特征和严重性。程序员可以参考这些数据库进行安全实现，并且有一些工具可用于检查代码中的常见漏洞。安全维护包括减轻系统中漏洞以及系统使用的第三方组件中漏洞影响的任务。该任务通常</p>
<p>检测编程语言或实现特定的漏洞，而对编译二进制文件的静态分析可用于检测在源代码中由于编译器优化或隐藏在编译的第三方组件中而不明显的漏洞。静态分析可以使用工具实现自动化，但虽然自动化可以发挥重要作用，仍需要安全专业人员的专业知识来正确操作和配置工具，并验证结果。</p>
<p>附带一个漏洞披露流程，允许报告已识别的漏洞。</p>
<h2 id="5-软件安全工具-1">5. 软件安全工具</h2>
<h3 id="51-安全漏洞检查工具-1c625">5.1. 安全漏洞检查工具 [1*,c6][25]</h3>
<p>安全漏洞检查工具，如源代码分析器和二进制分析工具，可用于识别潜在的安全漏洞和问题。源代码分析器检查代码以检测安全漏洞，如注入缺陷、缓冲区溢出和不安全的库使用。它们在发现可通过代码模式和逻辑缺陷识别的漏洞方面很有用。另一方面，二进制分析工具检查编译代码，包括第三方库，以查找在源代码中可能不明显或由编译过程产生的漏洞。虽然这些工具在检测漏洞方面提供了重要帮助，但它们无法找到所有漏洞。例如，它们可能无法捕获在难以产生的软件状态中表现出来的漏洞，或在异常情况下出现的漏洞
[1]。</p>
<h3 id="52-渗透测试工具-2c4">5.2. 渗透测试工具 [2,c4]</h3>
<p>渗透测试工具可用于评估系统在其运行环境中的安全性。这些工具对系统执行受控攻击以发现漏洞和安全弱点，使用诸如模糊测试(fuzzing)[2]等技术，其中向系统的各个入口点提交格式错误、恶意或随机数据以检测故障。使用渗透测试工具暴露漏洞可以深入了解实际攻击者如何利用系统。</p>
<h2 id="6-领域特定软件安全">6. 领域特定软件安全</h2>
<h3 id="61-容器和云安全-31-c1-c3">6.1. 容器和云安全 [31*, c1-c3]</h3>
<p>云基础设施和服务通常价格低廉且易于配置，这可能很快导致在世界各地拥有许多资产并被遗忘。这些被遗忘的资产就像定时炸弹，等待爆发成为安全事件
[31]。</p>
<p>云环境的一个重要区别是物理资产和保护通常不是问题。开发人员可以外包资产标签、反尾随、板对板屏障、数据中心窗口放置、摄像头和其他物理安全及物理资产跟踪控制
[31]。</p>
<h3 id="62-物联网软件安全-3233">6.2. 物联网软件安全 [32,33]</h3>
<p>作为当今物联网(IoT)的一部分，系统与许多其他设备互连，尤其是后端系统，这些系统存在当今商业IT中固有的所有众所周知的安全缺陷。攻击者通过利用浏览器漏洞等方式访问商业IT平台，也可能访问保护薄弱的物联网工业设备。这可能造成严重损害，包括安全事故。因此，从消费者或工业环境引入大量端点为利用薄弱环节创造了肥沃的土壤。加固这些端点、保护设备到设备的通信，以及确保在迄今为止一直是封闭、同质系统中的设备和信息可信度，提出了新的挑战。需要针对物联网平台的全面风险和威胁分析方法以及管理工具
[33]。</p>
<h3 id="63-基于机器学习应用的安全-39c8">6.3. 基于机器学习应用的安全
[39,c8]</h3>
<p>尽管机器学习技术在许多系统中广泛使用，但机器学习存在特定的漏洞。攻击者可以改变机器学习模型的决策。有两种类型的攻击：模型投毒(model
poisoning)，攻击训练数据；以及规避(evasion)，攻击已训练模型的输入
[39]。</p>
<h2 id="主题与参考资料对照表-2">主题与参考资料对照表</h2>
<table>
<colgroup>
<col style="width: 12%"/>
<col style="width: 29%"/>
<col style="width: 29%"/>
<col style="width: 29%"/>
</colgroup>
<thead>
<tr>
<th><strong>主题</strong></th>
<th><strong>Allen等 2008 [1*]</strong></th>
<th><strong>Bishop 2019 [3*]</strong></th>
<th><strong>Dotson 2019 [31*]</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 软件安全基础</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.1. 软件安全</em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.2. 信息安全</em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.3. 网络安全</em></td>
<td></td>
<td>c23</td>
<td></td>
</tr>
<tr>
<td><strong>2. 安全管理和组织</strong></td>
<td></td>
<td>c7</td>
<td></td>
</tr>
<tr>
<td><em>2.1. 能力成熟度模型</em></td>
<td></td>
<td>c22</td>
<td></td>
</tr>
<tr>
<td><em>2.2. 信息安全管理系统</em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>2.3. 软件安全的敏捷实践</em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3. 软件安全工程和流程</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.1. 安全工程和安全开发生命周期</em></td>
<td>c1</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>3.2. 信息技术安全评估通用准则</em></td>
<td></td>
<td>c22, c25</td>
<td></td>
</tr>
<tr>
<td><strong>4. 软件系统安全工程</strong></td>
<td>c1, c3</td>
<td>c1, c3</td>
<td></td>
</tr>
<tr>
<td><em>4.1. 安全需求</em></td>
<td>c3</td>
<td>c20, c31</td>
<td></td>
</tr>
<tr>
<td><em>4.2. 安全设计</em></td>
<td>c4</td>
<td>c20, c31</td>
<td></td>
</tr>
<tr>
<td><em>4.3. 安全模式</em></td>
<td>c4</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>4.4. 安全构建</em></td>
<td>c5</td>
<td>c20, c31</td>
<td></td>
</tr>
<tr>
<td><em>4.5. 安全测试</em></td>
<td>c5</td>
<td>c24, c31</td>
<td></td>
</tr>
<tr>
<td><em>4.6. 漏洞管理</em></td>
<td></td>
<td>c24</td>
<td></td>
</tr>
<tr>
<td><strong>5. 软件安全工具</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.1. 安全漏洞检查工具</em></td>
<td>c6</td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>5.2. 渗透测试工具</em></td>
<td>c4</td>
<td></td>
<td>c31</td>
</tr>
<tr>
<td><strong>6. 领域特定软件安全</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.1. 容器和云安全</em></td>
<td></td>
<td></td>
<td>c1-c3</td>
</tr>
<tr>
<td><em>6.2. 物联网软件安全</em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.3. 基于机器学习应用的安全</em></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="进一步阅读">进一步阅读</h2>
<p>J. Viega, <em>Building Secure Software: How</em></p>
<p>本书介绍了软件安全的定义以及开发和维护安全软件的活动。</p>
<h2 id="软件安全-3">软件安全</h2>
<p><em>以正确的方式避免安全问题</em>，Addison-Wesley，2011。它不仅包括软件开发过程，还包括相关活动，如审计和服务监控。</p>
<p>L. Kohnfelder，<em>设计安全软件：开发者指南</em>，No Starch
Press，2021。</p>
<p><strong>自动化与测试：DevSecOps中的自动化安全扫描和测试工具与技术</strong>，Packt
Publishing，2019。</p>
<p>[7] G.
Wilson，<em>DevSecOps：领导者的安全软件生产指南，在不影响流程、反馈和持续改进的情况下</em>，Rethink
Press，2020。</p>
<p>本书描述了软件设计和实现阶段的安全活动，包括安全编程和Web安全。它还介绍了安全软件开发的最佳实践。</p>
<p>[8] L.
Rice，<em>容器安全：保护容器化应用的基础技术概念</em>，O’Reilly &amp;
Associates Inc.，2020。</p>
<p>C.W. Axelrod，<em>工程化安全可靠的软件系统</em>，Artech House
Publishers，2012。</p>
<p>[9] ISO/IEC/JTC1
SC27标准：可信性、密码学、数据安全、密码学、安全评估和测试、安全控制、身份管理和隐私技术。</p>
<p>本书从风险管理的角度描述了使软件系统安全可靠的工程活动。它介绍了安全性和安全性的风险评估和缓解方法。</p>
<p>[10] ISO/IEC 25010:2023
系统和软件工程——系统和软件质量要求与评估(SQuaRE)——产品质量模型。</p>
<p><strong>参考文献</strong></p>
<p>[1*] J.H. Allen, S.J. Barnum, R.J. Ellison, G. McGraw, and N.R.
Mead，<em>软件安全工程：项目经理指南</em>，Addison-Wesley
Professional，2008。</p>
<p>[11] ISO/IEC 27000:2018
信息技术——安全技术——信息安全管理系统——概述和词汇。</p>
<p>[2] G. McGraw，<em>软件安全：构建安全性</em>，Addison-Wesley
Professional，2006。</p>
<p>[12] ISO/IEC 27032:2012 信息技术——安全技术——网络安全指南。</p>
<p>[3] M. Bishop，<em>计算机安全</em>，第2版，Addison-Wesley
Professional，2019。</p>
<p>[13] ISO/IEC 19770-1:2017
信息技术——IT资产管理——第1部分：IT资产管理系统——要求。</p>
<p>[4] L. Bell, M. Brunton-Spall, R. Smith, and J.
Bird，<em>敏捷应用安全</em>，O’Reilly，2017。</p>
<p>[14] ISO/IEC 21827:2008
信息技术——安全技术——系统安全工程——能力成熟度模型(SSE-CMM)。</p>
<p>[5] T. Hsiang-Chih
Hsu，<em>DevOps实践安全：通过DevSecOps确保持续安全、部署和交付</em>，Packt
Publishing，2018。</p>
<p>[15] ISO/IEC 27001:2022
信息安全、网络安全和隐私保护——信息安全管理系统——要求。</p>
<p>[6] T. Hsiang-Chih
Hsu，<em>实用安全自动化和测试：DevSecOps中的自动化安全扫描和测试工具与技术</em>，Packt
Publishing，2019。</p>
<p>[26] K. Scarfone, M. Souppaya, A. Cody, and A.
Orebaugh，<em>信息安全测试和评估技术指南</em>，NIST
SP800-115，2008。</p>
<p>[16] M. Howard and S. Lipner，<em>安全开发生命周期</em>，Microsoft
Press，2006。</p>
<p>[27] PCI安全标准委员会，PCI
DSS：支付卡行业数据安全标准，版本3.2，2017。</p>
<p>[17] F. Swiderski and W.
Snyder，<em>威胁建模：为安全而设计</em>，Wiley，2014。</p>
<p>[28] <em>MITRE</em>，“通用漏洞披露(CVE)”，<a href="https://www.cve.org/">https://www.cve.org/</a>。</p>
<p>[18] D.
Firesmith，“安全用例”，<em>面向对象技术期刊</em>，第2卷，第1期，第53-64页，2003。</p>
<p>[29] <em>MITRE</em>，“通用弱点枚举(CWE)”，<a href="https://cwe.mitre.org/">https://cwe.mitre.org/</a>。</p>
<p>[19] E.
Fernandez-Buglioni，<em>实践中的安全模式：使用软件模式设计安全架构</em>，Wiley，2013。</p>
<p>[30] <em>MITRE</em>，“通用攻击模式枚举与分类(CAPEC)”，<a href="https://capec.mitre.org/">https://capec.mitre.org/</a>。</p>
<p>[20] C. Nagappan, R. Lai, and R.
Steel，<em>核心安全模式：J2EE、Web服务和身份管理的最佳实践与策略</em>，Prentice
Hall，2005。</p>
<p>[31*] C. Dotson，<em>实用云安全</em>，O’Reilly，2019。</p>
<p>[21] M. Schumacher, E. Fernandez-Buglioni, D. Hybertson, F.
Buschmann, and P.
Sommerlad，<em>安全模式：集成安全与系统工程</em>，Wiley，2006。</p>
<p>[32] “物联网安全最佳实践”，<em>IEEE</em>，2017，<a href="https://standards.ieee.org/wp-content/uploads/import/documents/other/whitepaper-internet-of-things-2017-dh-v1.pdf">https://standards.ieee.org/wp-content/uploads/import/documents/other/whitepaper-internet-of-things-2017-dh-v1.pdf</a>。</p>
<p>[22] R.C. Seacord，<em>CERT C安全编码标准</em>，Addison-Wesley
Professional，2008。</p>
<p>[33] “IoT 2020：智能和安全的IoT平台”，<em>IEC</em>，2016，<a href="https://www.iec.ch/basecamp/iot-2020-smart-and-secure-iot-platform">https://www.iec.ch/basecamp/iot-2020-smart-and-secure-iot-platform</a>。</p>
<p>[23] R.C. Seacord，<em>C++安全编码</em></p>
<p>[34] ISO/IEC 15408-1:2022
信息安全、网络安全和隐私保护——IT安全评估标准——第1部分：介绍和</p>
<h1 id="第十四章">第十四章</h1>
<h1 id="软件工程专业实践-1">软件工程专业实践</h1>
<p><strong>缩略词</strong></p>
<ul>
<li><strong>ACM</strong> - 美国计算机协会（Association for Computing
Machinery）</li>
<li><strong>CCPA</strong> - 加州消费者隐私法案（The California Consumer
Privacy Act）</li>
<li><strong>EEA</strong> - 欧洲经济区（European Economic Area）</li>
<li><strong>ENAEE</strong> - 欧洲工程教育认证网络（European Network for
Accreditation of Engineering Education）</li>
<li><strong>EU</strong> - 欧盟（European Union）</li>
<li><strong>IEA</strong> - 国际工程联盟（International Engineering
Alliance）</li>
<li><strong>IEC</strong> - 国际电工委员会（International
Electrotechnical Commission）</li>
<li><strong>IEEE CS</strong> - IEEE计算机学会（IEEE Computer
Society）</li>
<li><strong>GDPR</strong> - 通用数据保护条例（General Data Protection
Regulation）</li>
<li><strong>IFIP</strong> - 国际信息处理联合会（International Federation
for Information Processing）</li>
<li><strong>IP</strong> - 知识产权（Intellectual Property）</li>
<li><strong>ISO</strong> - 国际标准化组织（International Organization
for Standardization）</li>
<li><strong>NDA</strong> - 保密协议（Nondisclosure Agreement）</li>
<li><strong>UI/UX</strong> - 用户界面/用户体验（User Interface/User
Experience）</li>
<li><strong>WIPO</strong> - 世界知识产权组织（World Intellectual
Property Organization）</li>
<li><strong>WTO</strong> - 世界贸易组织（World Trade Organization）</li>
</ul>
<h2 id="引言-6">引言</h2>
<p>软件工程专业实践知识领域（KA）关注软件工程师以专业、负责和道德的方式进行软件工程实践所必须具备的知识、技能和态度。由于软件产品在社会和个人生活中的应用日益广泛，软件产品质量可能深刻影响个人福祉和社会和谐。软件工程师必须处理独特的工程问题，以生产具有已知特性和可靠性的软件。这一要求需要软件工程师在专业实践中拥有适当的知识、技能、培训和经验。</p>
<p>专业实践（Professional
practice）是指以达到特定标准或准则的方式进行服务。这些标准和准则既可以包括技术方面，也可以包括非技术方面。</p>
<p>专业实践的概念特别适用于具有普遍认可的知识体系的职业；包括针对违规行为的道德规范和职业行为准则及其处罚；被认可的认证、资格和许可流程；以及提供和管理所有这些的专业学会。进入这些专业学会通常需要预设的教育和经验组合。</p>
<p>软件工程师通过遵循相关专业学会制定的普遍认可的实践、标准和指南来维持专业实践，这些专业学会包括美国计算机协会（ACM）、电气和电子工程师学会（IEEE）、国际信息处理联合会（IFIP）、IEEE计算机学会（IEEE
CS）、国际标准化组织/国际电工委员会（ISO/IEC），以及ISO/IEC/IEEE提供的国际认可的软件工程标准。所有这些标准和指南构成了软件工程专业实践的基础。</p>
<p>随着软件在社会中的应用更加广泛和深入，利益相关者的需求也变得更加广泛和深入。随着软件对社会的重要性日益增加，软件工程师努力将用户界面作为进入专业社区的准入标准的基础。这些准则构成了认证和许可活动的基础，并可能决定工程能力或过失。</p>
<h2 id="软件工程专业实践的主题分类">软件工程专业实践的主题分类</h2>
<p><strong>图14.1. 软件工程专业实践知识领域的主题分类</strong></p>
<p>该知识领域包括以下主要主题：</p>
<h3 id="专业精神professionalism">专业精神（Professionalism）</h3>
<ul>
<li>认证、资格和许可</li>
<li>道德规范和职业行为</li>
<li>专业学会的性质和作用</li>
<li>软件工程标准的性质和作用</li>
<li>软件的经济影响</li>
<li>雇佣合同</li>
<li>法律问题</li>
<li>文档</li>
<li>权衡分析</li>
</ul>
<h3 id="团队动力学和心理学group-dynamics-and-psychology">团队动力学和心理学（Group
Dynamics and Psychology）</h3>
<ul>
<li>团队/小组工作的动力学</li>
<li>个人认知</li>
<li>沟通</li>
<li>与利益相关者互动</li>
<li>应对不确定性和歧义</li>
<li>应对问题复杂性</li>
<li>应对公平、多元化和包容性</li>
</ul>
<h3 id="沟通技能communication-skills">沟通技能（Communication
Skills）</h3>
<ul>
<li>阅读、理解和总结</li>
<li>写作</li>
<li>演讲技能</li>
<li>团队和小组沟通</li>
</ul>
<h1 id="软件工程专业实践-2">软件工程专业实践</h1>
<p>软件工程专业实践知识领域(KA)的主题分解如图14.1所示，涵盖了面向社会包容性概念的用户体验(UI/UX)。</p>
<p>本知识领域呈现的子领域包括专业素养、群体动力学和心理学，以及沟通技能。[1*,
cls4-s5, cls10] [2] [4*, c12s10] [6] [7] [8] [9]</p>
<h2 id="1-专业素养">1. 专业素养</h2>
<p>软件工程师表现出专业素养，主要体现在遵守职业道德和专业行为准则，以及遵循工程师专业社群建立的标准和实践。</p>
<p>一个或多个专业协会通常代表一个专业社群，工程社群就是如此。这些协会发布职业道德和专业行为准则，以及独立于政府的认证标准，通常由私人会员协会执行。目前有两个主要的全球认证组织。</p>
<p>一个是国际工程联盟(IEA)，其中华盛顿协议是其组成部分。另一个是欧洲工程教育认证网络(ENAEE)，该网络管理EUR-ACE®，这是授予本科和硕士级别工程学位课程的标签，由欧盟委员会列出。</p>
<p>虽然每个国家和司法管辖区的认证流程可能有所不同，但总体含义是相同的。认证机构对某所院校课程的认证意味着”认证机构认可该教育机构保持的标准使毕业生有资格进入更高或更专业的机构或从事专业实践。”</p>
<h3 id="11-认证资格认定和执业许可">1.1. 认证、资格认定和执业许可</h3>
<h4 id="111-认证accreditation">1.1.1. 认证(Accreditation)</h4>
<p>认证证明组织的能力、权威性或可信度。经过认证的学校或项目表明它们遵守特定标准并保持一定的质量。在许多国家，工程师获取知识的基本途径是完成经过认证的课程学习。</p>
<h4 id="112-资格认定和资质认证">1.1.2. 资格认定和资质认证</h4>
<p>ISO/IEC
24773-1《软件和系统工程——软件和系统工程专业人员认证——第1部分：通用要求》[8]定义了资格认定和资质认证。ISO/IEC
24773-4《软件和系统工程——软件和系统工程专业人员认证——第4部分：软件工程》[9]详细阐述了基于ISO/IEC
24773-1的认证方案的要求和建议，这些要求和建议专门针对软件工程领域。资质认证包含重新认证。资格认定与资质认证相似，但不需要重新认定资格。</p>
<p>资质认证指的是对个人特定特征的确认。一种常见的资质认证类型是专业资质认证，它证明个人能够以规定的能力水平完成某一学科的活动。专业资质认证可以验证持有人满足专业标准和在解决或处理问题时应用专业判断的能力。专业资质认证还可以验证规定的知识、对最佳实践和经过验证的方法论的掌握，以及专业经验。</p>
<p>工程师通常通过参加考试并满足其他基于经验的标准来获得资质认证。非政府组织，如专业协会，通常负责管理这些考试。在软件工程领域，资质认证证明个人作为软件工程师的能力。</p>
<p>资格认定和资质认证项目旨在确认软件工程师对标准软件工程实践的了解，并促进工程师的职业发展。缺乏资格认定或资质认证并不排除个人从事软件工程师工作。软件工程的资格认定或资质认证是自愿的。大多数软件工程师没有在任何项目下获得资格认定或资质认证。</p>
<h4 id="113-执业许可licensing">1.1.3. 执业许可(Licensing)</h4>
<p>执业许可授权个人从事某些活动并对由此产生的工程产品承担责任。名词”license”既指该授权，也指记录该授权的文件。政府当局或法定机构通常颁发执业许可。</p>
<p>获得执业许可要求个人达到某一标准的某种执业或操作能力。有时入门级要求设定了执业的最低技能和能力，随着专业人员的职业发展，所需的技能和能力也会变化和发展。</p>
<p>工程师获得执业许可是为了保护公众免受不合格人员的影响。在一些国家，除非获得执业许可，否则任何人都不能从事专业工程师的工作；此外，除非至少雇用一名持有执业许可的工程师，否则任何公司都不得提供”工程服务”。</p>
<h3 id="12-职业道德和专业行为准则">1.2. 职业道德和专业行为准则</h3>
<p>[1*, cls7-s9, c10s2, Appendix] [3*, c8] [4*, cls2] [5*, c33][10] [11]
[13*]</p>
<p>职业道德和专业行为准则描述了工程师的专业实践和决策应该体现的价值观和行为。专业社群建立职业道德和专业行为准则。该准则存在于社会规范和地方法律的背景下，并根据需要进行调整以与这些规范和法律保持一致。</p>
<p>工程师有责任继续学习，以保持其专业实践的最新状态。</p>
<h3 id="13-专业协会的性质和作用-1">1.3. 专业协会的性质和作用</h3>
<h1 id="道德准则和职业行为规范">道德准则和职业行为规范</h1>
<p>道德准则和职业行为规范 [[1*, c2s3] [4*, c1s2] [5*, c35s1]]
可以在面临相互冲突的职责时提供指导。不止一套这样的准则服务于专业工程社区。例如，1999年，IEEE
CS 和 ACM
联合发起了一个软件工程道德与职业实践工作组，以发布道德准则。2018年，ACM
发布了其《ACM 道德准则和职业行为规范》，2020年，IEEE
发布了其《道德准则》的修订版，该准则最初于1912年获得批准。然后，2021年，IFIP
发布了其《道德准则和职业行为规范》，改编自 ACM
的《道德准则和职业行为规范》。</p>
<p>一旦建立，道德准则和职业行为规范由职业社团代表的专业领域或法定机构执行。违规行为可能是主动作为，例如隐瞒不充分的工作、泄露机密信息、伪造信息或虚报能力。也可能是不作为，包括未能披露风险或提供重要信息、未能给予适当的认可或引用参考文献，以及未能代表客户利益。违反道德准则和职业行为规范可能导致处罚，甚至可能被取消专业资格。</p>
<p>软件工程师应致力于使软件的分析、规格说明、设计、开发、测试和维护成为一项有益且受尊重的职业。遵循对公众健康、安全和福利的承诺，软件工程师应遵守
IEEE 董事会于2020年6月通过的 IEEE 道德准则中的十项原则。</p>
<p>由于道德准则和职业行为规范可能随时被引入、修改或替换，个别软件工程师应及时了解相关内容。</p>
<h2 id="专业社团">专业社团</h2>
<p>专业社团由从业者和学者混合组成。这些社团定义、推进和规范其相应的专业。专业社团帮助建立专业标准以及道德准则和职业行为规范。它们还参与相关活动，包括以下内容：</p>
<p>• 建立和传播公认的知识体系 •
为许可(licensing)、认证(certifying)和资质认可(accrediting)提供基础 •
执行纪律处分 • 通过会议、培训、出版物和标准推进专业发展</p>
<p>参与专业社团有助于工程师个人保持和提高其专业知识和相关性，并扩展和维护其专业网络。</p>
<h2 id="14-软件工程标准的性质和作用-1">1.4. 软件工程标准的性质和作用</h2>
<p>[[1*, c10s2] [2] [4*] [5*, c32s6]]</p>
<p>软件工程标准涵盖各种主题。它们为软件工程实践以及软件开发、维护和支持期间使用的过程提供指南。通过建立共同的知识体系和经验，软件工程标准建立了进一步制定指南的基础。本《指南》的附录B列出了支持本《指南》知识领域的
IEEE、ISO/IEC 和 ISO/IEC/IEEE 软件工程标准。</p>
<p>标准是关于需求和其他指导的宝贵信息来源，可以支持软件工程师的日常活动。遵守标准通过列举产品和实践的最低特征来促进纪律。这种纪律有助于减轻潜意识假设或对设计的过度自信。因此，执行软件工程活动的组织通常将符合标准作为其组织政策的一部分。</p>
<h2 id="15-软件的经济影响-1">1.5. 软件的经济影响</h2>
<p>[3*, c1s1, c10s8] [4*, c1s1] [13*]</p>
<p>软件在个人、企业和社会层面具有经济影响。例如，软件的”成功”可能由产品对已识别问题的适用性以及应用于该问题时的有效性来决定。在个人层面，工程师的持续就业可能取决于他们解释和执行任务以满足客户或雇主需求和期望的能力和意愿。客户或雇主的财务状况可能会受到软件采购的积极或消极影响。</p>
<p>在企业层面，软件正确应用于问题可以节省数月时间。</p>
<h2 id="16-雇佣合同-1">1.6. 雇佣合同</h2>
<p>[[1*, c6, c7] [10] [11] [12]]</p>
<p>软件工程服务可以通过多种客户-工程师关系提供。例如，工作可能通过公司对客户的供应商安排、工程师对客户的咨询安排、直接雇佣，甚至通过志愿服务来完成。在这些情况下，客户和供应商同意提供产品或服务以换取某种对价。在这里，我们最关心的是工程师对客户的安排及其相关协议或合同，无论它们是直接雇佣还是咨询性质，以及它们通常涉及的问题。</p>
<p>软件工程合同中的一个常见关注点是保密性。雇主从知识产权(IP)中获得商业优势，因此他们努力保护该财产不被泄露。因此，软件工程师通常被要求签署保密协议(NDA)或知识产权协议作为工作的前提条件。这些协议通常适用于软件工程师只能通过与客户的关联获得的信息。这些协议的条款可能延续到关联结束之后。</p>
<h1 id="工作并转化为更高的利润或更有效的组织">工作并转化为更高的利润或更有效的组织</h1>
<p>组织的终止是另一个关注点，即知识产权(IP)所有权问题。对软件工程资产的权利——包括产品、创新、发明、发现和想法——可能归属于雇主或客户，这取决于明确的合同条款或相关法律，如果这些资产是在软件工程师与雇主或客户的关系期间获得的。合同对于使用非雇主拥有的设备或信息创建的资产的所有权各不相同。</p>
<p>最后，合同还可以规定以下要素：</p>
<ul>
<li>执行工作的地点</li>
<li>工作所遵循的标准</li>
<li>用于开发的系统配置</li>
<li>软件工程师和雇主责任的限制</li>
</ul>
<h2 id="16-swebok-指南-v40a">1.6 SWEBOK® 指南 V4.0a</h2>
<ul>
<li>沟通矩阵和/或升级计划</li>
<li>管理细节，如费率、报酬频率、工作时间和工作条件</li>
</ul>
<h2 id="17-法律问题-1">1.7 法律问题</h2>
<p>[1*, c6, c11] [2] [3*, c5s3–c5s4] [4*, c12s3, c13s2]</p>
<p>围绕软件工程专业实践的法律问题包括与标准、商标、专利、版权、商业秘密、专业责任、法律要求、贸易合规、网络犯罪和数据隐私相关的事项。因此，了解这些问题及其适用性是有益的。此外，法律问题是基于司法管辖区的，因此软件工程师必须咨询专门从事所识别法律问题类型和管辖区的律师。</p>
<h3 id="171-标准-1">1.7.1 标准</h3>
<p>遵守标准可以为对抗法律诉讼或渎职指控提供辩护。</p>
<h3 id="172-商标-1">1.7.2 商标</h3>
<p>商标涉及在商业交易中使用的任何文字、名称、符号或设备。它用于”表明商品的来源或产地”。商标保护涵盖名称、标志、图像和包装。然而，如果名称、图像或其他商标资产成为通用术语，商标保护就会失效。</p>
<p>世界知识产权组织(World Intellectual Property Organization,
WIPO)是制定商标规则和法规的权威机构。WIPO是联合国机构，致力于保护知识产权的使用，作为刺激创新和创造力的手段。</p>
<h3 id="173-专利-1">1.7.3 专利</h3>
<p>专利保护发明人制造和销售某个想法的权利。专利由主权政府授予个人、个人团体或组织在有限期限内的专有权利。专利是一种古老的想法所有权保护形式，可以追溯到15世纪。</p>
<p>申请专利需要保存和提供导致发明的过程的详细记录。此外，专利律师帮助撰写专利披露声明，以最有可能保护软件工程师权利的方式。请注意，如果发明是在软件工程合同期间产生的，所有权可能属于雇主或客户，或共同持有，而不是属于软件工程师。</p>
<p>关于什么可以申请专利、什么不可以申请专利，规则各不相同。在许多国家，软件代码不可申请专利，但软件算法可以。现有和已提交的专利申请可以在WIPO找到。</p>
<h3 id="174-版权-1">1.7.4 版权</h3>
<p>大多数立法赋予原创作品的创作者专有权利，通常在有限时间内，以版权形式实施。版权保护想法的呈现方式——而不是想法本身。例如，它们可能保护对历史事件描述的特定措辞，而事件本身不受保护。版权是长期的且可续期的。作为知识产权的一种形式,它们可以追溯到17世纪。</p>
<h3 id="175-商业秘密-1">1.7.5 商业秘密</h3>
<p>在许多国家，诸如配方、算法、流程、设计、方法、模式、工具或信息汇编等知识资产可能被视为<em>商业秘密</em>，前提是该资产不为人所知并且可能为企业提供某种经济优势。“商业秘密”的指定在资产被窃取时提供法律保护。这种保护不受时间限制。然而，如果另一方合法地推导或发现相同的资产，那么该资产就不再受保护，另一方也将拥有使用它的所有权利。</p>
<h2 id="软件工程专业实践-14-7">软件工程专业实践 14-7</h2>
<h3 id="176-专业责任">1.7.6 专业责任</h3>
<p>软件工程师通常关注专业责任问题。当工程师向客户或雇主提供服务时,遵守标准和公认的实践至关重要，以保护自己免受与渎职、疏忽或无能相关的指控或诉讼。</p>
<ul>
<li>合同协议</li>
<li>非合同法律问题，例如管辖责任的问题</li>
</ul>
<p>有关国际法律框架的基本信息可以从世界贸易组织(World Trade
Organization, WTO)获取。</p>
<h3 id="178-贸易合规-1">1.7.8 贸易合规</h3>
<p>对于工程师(包括软件工程师)来说,职业责任与产品责任相关。根据其所在司法管辖区的法律和规则,工程师可能会因未能完全和认真地遵循建议的实践而被追究责任;这被称为<em>疏忽</em>(negligence)。他们还可能受到管辖<em>严格责任</em>(strict
liability)以及明示或默示担保的法律约束,即通过销售产品,工程师被认为保证产品既适合使用又安全。在某些国家(例如美国),<em>合同关系</em>(privity)(一种只能起诉产品销售者的原则)不再是对责任诉讼的抗辩理由。</p>
<p>在美国,责任诉讼可以根据侵权法提起,允许任何受到伤害的人追回损失,即使没有做出任何保证。由于难以衡量软件的适用性或安全性,未尽应有注意义务可以用来证明软件工程师的疏忽。工程师可以通过证明他们在开发产品时遵循了标准和普遍接受的实践来为自己辩护,并准备就任何相关司法管辖区的注意标准咨询律师,以管理与产品责任或职业责任相关的风险。</p>
<h2 id="177-法律要求-1">1.7.7. 法律要求</h2>
<p>软件工程师必须在地方、国家和国际法律框架内运作。因此,软件工程师必须了解以下方面的法律要求:</p>
<p>• 注册和许可,包括考试、教育、经验和培训要求</p>
<p>所有软件专业人员必须了解其工作所在司法管辖区对商品、服务和技术的进口、出口或再出口的法律限制。此类规则通常涉及出口管制和分类;商品转让;获取在国外使用硬件和软件所需的政府许可证;受制裁国家、企业或个体实体的服务和技术;以及进口限制和关税。应咨询贸易专家以获得详细的合规指导。</p>
<h2 id="179-网络犯罪-1">1.7.9. 网络犯罪</h2>
<p>网络犯罪是指涉及计算机、计算机软件、计算机网络或控制系统的嵌入式软件的任何犯罪。计算机或软件可能已被用于实施犯罪,或成为犯罪的目标。这类犯罪包括欺诈、未经授权的访问、垃圾邮件、淫秽或冒犯性内容、威胁、骚扰、窃取敏感个人数据或商业秘密,以及使用一台计算机损坏或渗透其他计算机和自动化系统控制。</p>
<p>计算机和软件用户通过更改电子数据来促进非法活动而实施欺诈。未经授权访问的形式包括黑客攻击、窃听以及以对所有者隐蔽的方式使用计算机系统。许多国家都有专门涵盖网络犯罪的法律,但许多国家没有有效的法规,这使得网络犯罪在某些情况下难以起诉。</p>
<p>软件工程师有专业义务考虑网络犯罪的威胁,并考虑软件系统的安全性如何保护软件免受意外或恶意访问、使用、修改、破坏或泄露。</p>
<p>暗黑模式(Dark
patterns)是欺骗性的UI/UX交互,旨在误导或诱骗用户做他们可能不想做的事情。这些模式没有考虑用户的利益,追求可利用性而非可用性。创建暗黑模式不是良好的道德实践。软件工程师应该对自己的行为负责,对用户保持透明,而不是操纵他们。</p>
<h2 id="1710-数据隐私-1">1.7.10. 数据隐私</h2>
<p>软件工程师应该知道,数据隐私在许多国家是关键的法律要求。《通用数据保护条例》(General
Data Protection Regulation,
GDPR)于2016年4月14日通过,自2018年5月25日起强制执行,规范了欧盟(EU)和欧洲经济区(EEA)的数据保护和隐私。它还涉及个人数据在欧盟和欧洲经济区以外的传输。GDPR的主要目标是增强个人对其数据的控制和权利,并简化国际商业的监管环境。</p>
<p>该条例成为欧盟以外许多国家法律的典范,包括英国、智利、日本、巴西、韩国、阿根廷和肯尼亚。2018年6月28日通过的《加州消费者隐私法》(California
Consumer Privacy Act, CCPA)与GDPR有许多相似之处。</p>
<p><em>SWEBOK® GUIDE V4.0a</em> 14-8</p>
<h2 id="软件工程师应提供的信息">软件工程师应提供的信息</h2>
<p>• 相关事实和用户信息 • 重大风险和权衡 •
关于使用或误用软件可能产生的不良或危险后果的警告 •
与归属、许可类型和来源相关的相关信息</p>
<p>软件工程师应该避免:</p>
<p>• 认证或批准不可接受的产品 • 泄露机密信息 • 伪造事实或数据</p>
<p>此外,软件工程师及其管理者应为软件开发组织的其他要素提供以下文档供使用:</p>
<p>•
软件需求规格说明、软件设计文档、所用软件工程工具的详细信息、软件测试规格说明和结果,以及所采用软件工程方法的详细信息
• 开发过程中遇到的问题</p>
<p>对于外部利益相关者(客户、用户、其他人),软件文档应提供以下内容:</p>
<p>• 确定软件是否可能满足客户和用户需求所需的信息 •
软件安全和不安全使用的描述 • 如何保护敏感信息的说明</p>
<p><em>1.8. 文档</em></p>
<p>[1*, c10s5.8] [3*, c1s5] [4*] [5*, c32]</p>
<p>• 清楚标识警告和关键流程</p>
<p>提供清晰、全面且准确的文档是每位软件工程师的责任。文档的充分性根据利益相关者的需求，按照不同的标准进行评判。好的文档应符合公认的标准和指南。特别是，软件工程师应当记录以下内容：</p>
<p>由软件创建或使用软件存储的信息</p>
<p>软件使用可能包括安装、操作、管理以及由不同用户群体和支持人员执行的其他功能。如果客户将获得软件源代码的所有权或修改代码的权利，软件工程师应提供功能规格说明、软件设计、测试套件以及软件所需的运行环境的文档。文档应至少保留到软件产品生命周期结束或相关组织或监管要求规定的时间。</p>
<p><em>1.9. 权衡分析</em></p>
<p>[3*, c1s2, c10] [4*, c7s2, c13s4] [13*, c9s5.10]</p>
<p>软件工程师经常需要在备选的问题解决方案之间做出选择。这些选择的结果由软件工程师与利益相关者合作，对每个备选方案的风险、成本和收益进行专业评估来决定。软件工程师的评估被称为<em>权衡分析</em>（trade-off
analysis）。权衡分析特别需要识别相互竞争和互补的软件需求，以便对定义待构建软件的最终需求进行优先级排序。（参见软件需求知识领域中的需求协商和软件工程管理知识领域中的需求确定与协商。）</p>
<p>当正在进行的软件开发项目延期或超出预算时，通常会进行权衡分析来决定哪些软件需求可以放宽或删除，以及由此产生的影响。权衡分析的第一步是建立设计目标（参见工程基础知识领域中的工程设计），并设置这些目标的相对重要性。这允许确定最接近满足这些目标的解决方案；这意味着目标的表述方式至关重要。</p>
<p>设计目标可能包括最小化货币成本，以及在各个维度上最大化可靠性、性能或其他标准。然而，很难制定成本与风险的权衡分析，特别是在必须将主要生产成本和次要基于风险的成本相互权衡时。</p>
<p>软件工程师必须以符合道德的方式进行权衡分析——特别是在选择比较备选问题解决方案的标准和为这些标准分配权重或重要性时，要保持客观和公正。此外，任何利益冲突都必须预先披露。</p>
<h2 id="2-群体动力学与心理学">2. 群体动力学与心理学</h2>
<p>工程工作通常以团队形式进行。软件工程师应与他人进行合作和建设性的互动，以首先确定然后满足需求和期望。在与客户、同事、供应商和下属互动以解决软件工程问题时，了解群体动力学和心理学是一项资产。</p>
<p><em>2.1. 团队/小组工作的动力学</em></p>
<p>[3*, c1s6] [14*, c1s3.5, c10]</p>
<p>软件工程师必须与他人合作。一方面，他们在工程团队内部工作；另一方面，他们与客户、公众成员、监管机构和其他利益相关者合作。高效团队——那些展现出一致的工作质量并朝着目标前进的团队——具有凝聚力，并拥有合作、诚实和专注的氛围。个人和团队目标是一致的，因此成员自然地承诺并对共同成果有归属感。</p>
<p>团队成员通过在智力上保持诚实、运用集体思维、承认无知和承认错误来促进这种氛围。他们公平地分担责任、奖励和工作量。他们在文档和源代码中清晰直接地相互沟通，使信息对每个人都可访问。关于工作产品的同行评审以建设性和非个人化的方式进行。（参见软件质量知识领域中的评审和审计。）这使所有成员能够追求持续改进和成长周期，而没有个人风险。有凝聚力团队的成员表现出对彼此和他们领导的尊重。</p>
<p>需要强调的一点是，软件工程师必须能够在多学科环境和各种应用领域中工作。因为软件无处不在，从手机到汽车，它对人们生活的影响远远超出了为商业环境中的信息管理而制作的软件这一传统概念。</p>
<p><em>2.2. 个体认知</em></p>
<p>[3*, c1s6.5] [5*, c33]</p>
<p>工程师希望解决问题。每个工程师都努力有效且高效地解决问题。然而，每个工程师都有其局限性和偏好。通过拥抱好奇心和追求持续的专业发展，工程师获得技能和知识。阅读、建立人脉网络以及尝试新的工具、技术和方法都是专业发展的有效途径。</p>
<p><em>2.3. 处理问题复杂性</em></p>
<p>[3*, c3s2] [4*, c1s1, c20s1-s5] [5*, c33]</p>
<p>许多（如果不是大多数）软件工程问题过于复杂和困难，无法作为一个整体来解决，也无法由单个软件工程师来处理。当出现这种情况时，工程师通常使用团队合作。</p>
<h2 id="2-个体认知过程如何影响问题解决与问题分解">2.
个体认知过程如何影响问题解决与问题分解</h2>
<p>（详见计算基础知识领域中的问题解决技巧。）</p>
<p>个体认知在软件工程的问题解决中扮演着重要角色，部分原因在于软件本身具有高度抽象的性质。</p>
<p>团队协作处理大型复杂问题，通过分担负担并利用彼此的知识和创造力。当软件工程师在团队中工作时，不同工程师的观点和能力相互补充，有助于构建原本难以获得的解决方案。软件工程中团队协作的一些例子包括结对编程（pair
programming）（详见软件工程模型和方法知识领域中的敏捷方法）和代码审查（详见软件质量知识领域中的评审和审计）。</p>
<p>个人（尤其是软件工程师）分解问题和创造性开发解决方案的能力可能受到以下因素的抑制：</p>
<p>• 需要更多知识 • 潜意识假设 • 数据量 • 对失败或失败后果的恐惧 •
应用领域或组织的文化 • 缺乏表达问题的能力 • 感知到的工作氛围 •
个人的情绪状态</p>
<p>通过培养良好的问题解决习惯，最小化误导性假设的影响，可以减少这些抑制因素的影响。专注能力至关重要，智力谦逊（intellectual
humility）也同样重要。两者都能让软件工程师暂时搁置个人考虑，自由地与他人协商，这在团队工作中尤为重要。</p>
<p>工程师使用基本方法来促进问题解决。（详见计算基础知识领域中的问题解决技巧。）分解问题并逐个解决可以减少认知过载（cognitive
overload）。通过利用专业</p>
<h3 id="24-与利益相关者互动-4">2.4. 与利益相关者互动 [4*]</h3>
<p>软件工程工作的成功取决于与利益相关者的积极互动。利益相关者应在软件生命周期的所有阶段提供支持、信息和反馈。例如，在早期阶段，识别所有利益相关者并了解产品将如何影响他们至关重要，以便正确捕获足够的利益相关者需求定义。</p>
<p>在敏捷软件开发中，利益相关者的参与比其他类型的开发更为重要。首先，在开发过程中，利益相关者可能对规范或软件早期版本、优先级变更以及详细或新软件需求的澄清提供反馈。最后，在软件维护和产品生命周期结束之前，利益相关者可以对不断演变的或新的需求以及问题报告提供反馈，以便扩展和改进软件。</p>
<p>显然，利益相关者的定期参与将带来更好的应用程序。在软件产品生命周期中与利益相关者保持开放和富有成效的沟通至关重要。</p>
<h3 id="25-处理不确定性和模糊性">2.5. 处理不确定性和模糊性</h3>
<p>[4*, c4s1, c4s4, c11s5, c24s5] [14*, c9s4]</p>
<p>与其他领域的工程师一样，软件工程师在提供服务和开发产品时必须经常处理和解决不确定性和模糊性。软件工程师必须减少或消除任何阻碍工作执行的不明确之处。</p>
<p>通常，不确定性反映了知识的缺乏。如果是这种情况，通过阅读正式资料（如教科书和专业期刊）、采访利益相关者或咨询队友和同行来调查问题，很可能可以解决问题。</p>
<p>当无法轻易克服不确定性或模糊性时，软件工程师或组织可能将其视为项目风险。在这种情况下，工作估算或定价会进行调整，以减轻解决它的预期成本。（详见软件工程管理知识领域中的风险管理。）</p>
<h3 id="26-处理公平性多样性和包容性">2.6. 处理公平性、多样性和包容性</h3>
<p>[4*] [14*, c10s7]</p>
<p>公平性、多样性和包容性环境会影响团队动态。这在软件工程中比其他工程领域更为普遍，因为国际外包的强劲趋势以及软件组件可以瞬间在全球范围内轻松运输。例如，将软件项目跨越国家和文化边界划分是很常见的。软件项目团队由来自不同文化背景的人员组成也很常见。</p>
<p>为了使软件项目成功，团队成员必须包容不同的文化和社会规范，承认并非所有社会都有相同的社会期望。领导层和管理层的支持可以促进包容和理解。更频繁的沟通，包括面对面会议，可以帮助缓解地理和文化差异，促进凝聚力，提高生产力。此外，用队友的母语与他们交流可能是有益的。</p>
<p>在软件行业中，性别偏见仍然普遍存在。实施更广泛的招聘策略、具体和可衡量的绩效评估标准以及透明的薪酬分配程序可以减少软件行业的性别不平等。这些趋势有助于为所有软件工程师（无论其性别如何）建立多元化环境。</p>
<h2 id="3-沟通技能">3. 沟通技能</h2>
<p>软件工程师必须在口头、阅读和写作方面进行良好的沟通。为了满足软件需求和截止日期，工程师必须与客户、主管、同事建立清晰的沟通。</p>
<p>这在群体地理位置分散或沟通不频繁时尤其明显，因为这种分离会提升每次接触的重要性。如果时区差异导致口头交流更加不频繁，跨文化沟通会变得更加困难。</p>
<p>多元文化环境在软件工程中很普遍，可能比其他领域更为常见。最优问题解决能力通过调查、理解和总结信息的能力得以实现。客户对产品的接受度和安全使用依赖于相关的培训和文档。软件工程师的职业成功取决于始终如一地及时有效地提供口头和书面沟通。</p>
<p>14-12 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<p><strong>3.1. 阅读、理解和总结</strong> [4*, c4s5] [5*, c33s3]</p>
<p>软件工程师必须能够阅读和理解技术材料。技术材料包括参考书、手册、研究论文、在线资源和程序源代码。</p>
<p>阅读不仅是提升技能的主要方式，也是收集信息以完成工程目标的方法。</p>
<p>软件工程师需要筛选积累的信息，专注于最有帮助的部分。客户可能要求软件工程师总结这些信息收集的结果，简化或解释信息，以便他们能够在竞争性解决方案中做出最终选择。</p>
<p>阅读和理解源代码也是信息收集和问题解决的组成部分。例如，当工程师修改、扩展或重写软件时，他们必须理解其实现（直接从代码中获得）和设计（通常必须推断）。</p>
<p><strong>3.2. 写作</strong> [3*, c1s5] [4*, c4s2-s3]</p>
<p>软件工程师能够撰写客户要求或普遍接受的实践所需的书面产品。这些书面产品可能包括源代码、软件项目计划、软件需求文档、风险分析、软件设计文档、软件测试计划、用户手册、技术报告和评估、论证、图表等。</p>
<p>清晰、简洁的写作很重要，因为写作通常是相关方之间的主要沟通方式。在所有情况下，书面软件工程产品必须对其目标受众来说是易于访问、可理解和相关的。</p>
<p><strong>3.3. 团队和小组沟通</strong> [3*, c1s6.8] [4*, c22s3] [5*,
c27s1] [14*, c10s4]</p>
<p>团队和小组成员之间的有效沟通对于软件工程工作至关重要。必须咨询利益相关者(stakeholders)；必须做出决策，必须制定计划。团队和小组成员越多，沟通的需求就越大。</p>
<p>然而，随着每个团队成员的加入，沟通路径的数量会呈二次方增长。此外，团队成员不太可能与任何被认为与他们相距超过两个层级的人沟通。当软件工程工作或组织跨越国家和大陆边界时，这个问题可能会更加严重。</p>
<p>一些沟通可以通过书面形式完成。软件文档是直接交互的常见替代品。电子邮件是另一种方式，但尽管它很有用，但并不总是足够。此外，如果收到太多消息，就很难识别重要信息。越来越多的组织正在使用企业协作工具来共享信息。此外，电子信息库可供所有团队成员访问组织政策、标准、通用工程程序和项目特定信息，这可能是有益的。</p>
<p>一些软件工程团队专注于面对面互动，并通过办公空间安排促进这种互动。虽然私人办公室可以提高个人生产力，但其他安排，如将团队成员安置在物理或虚拟空间中并提供公共工作区域，可以促进协作努力。</p>
<p><strong>3.4. 演示技能</strong> [3*, c1s5] [4*, c22] [14*,
c10s7–c10s8]</p>
<p>软件工程师在软件生命周期过程中依赖他们的演示技能。例如，软件工程师可能会在该阶段向客户和团队成员介绍软件需求，并进行正式的需求评审。（参见软件需求知识领域中的需求评审。）在软件设计、软件构造和软件维护期间和之后，软件工程师领导评审、产品演练（参见软件质量知识领域中的评审和审计）和培训。这些都需要向小组展示技术信息并征求想法或反馈的能力。</p>
<p>因此，软件工程师在演示中有效传达概念的能力</p>
<p>[SOFTWARE ENGINEERING PROFESSIONAL PRACTICE] 14-13</p>
<p>影响产品接受度、管理和客户支持。它还影响利益相关者理解和协助产品工作的能力。这些知识需要归档在幻灯片、知识文档、技术白皮书和其他用于知识创建的材料中。</p>
<p><strong>主题与参考材料矩阵</strong></p>
<h1 id="第15章-软件工程经济学">第15章 软件工程经济学</h1>
<h2 id="缩略词">缩略词</h2>
<ul>
<li>IRR：内部收益率(Internal Rate of Return)</li>
<li>MARR：最低可接受收益率(Minimum Acceptable Rate of Return)</li>
<li>SPLC：软件产品生命周期(Software Product Life Cycle)</li>
<li>SDLC：软件开发生命周期(Software Development Life Cycle)</li>
<li>ROI：投资回报率(Return on Investment)</li>
<li>SEI：软件工程研究所(Software Engineering Institute)</li>
<li>TCO：总拥有成本(Total Cost of Ownership)</li>
</ul>
<h2 id="引言-7">引言</h2>
<p>软件无处不在,并已成为许多组织的必需品。它以以下方式服务于组织:</p>
<ul>
<li>作为达成组织业务或战略目标的杠杆;</li>
<li>作为组织专业知识(know-how)的催化剂以提升价值。</li>
</ul>
<p>这两个方面直接导致了关键的软件工程需求:</p>
<ul>
<li>提高生产力</li>
<li>减少返工</li>
<li>缩短开发时间</li>
<li>缩短维护周转时间</li>
<li>长期可持续性</li>
<li>创新</li>
<li>竞争力</li>
<li>与组织目标保持一致</li>
</ul>
<p>软件工程经济学是所有公认工程学科的关键要素。经济学是选择的科学,而非金钱的科学。工程经济学是经济学的应用微观经济学分支。它提出了一个基本问题:“将有限的资源投资于这项技术工作是否符合企业的最佳利益,还是同样的投资在其他地方会产生更高的回报?”转述[1]中的定义,工程就是”在技术上可行和经济上可接受之间找到平衡”。</p>
<p>软件工程必须是基于价值的。组织在软件上的投资若产生中性甚至负面的价值是不可持续的。软件工程经济学将软件技术决策与组织的业务目标相协调。</p>
<p>“组织”至少包括雇用软件工程师的组织。但是,当软件工程师参与任何第三方工作时,例如通过外部数字化转型合同或其他”委托作品”情况,该第三方的业务目标也是相关的。</p>
<p>在所有类型的组织中——营利性、非营利性和政府机构——基于价值的方法转化为长期可持续性。在营利性组织中,这意味着在软件投资上实现切实的回报。在非营利性组织中,这意味着以最低成本实现最大收益。</p>
<p>软件技术决策,例如组织决定使用现有库</p>
<div class="page-separator"></div>
<h2 id="1-专业素养-1">1. 专业素养</h2>
<h3 id="11-认证资格认定和许可">1.1. 认证、资格认定和许可</h3>
<p>[c1s5,] [c12s10] [c1s10]</p>
<h3 id="12-道德准则和职业行为">1.2. 道德准则和职业行为</h3>
<p>[c1s7-s9,] [c1s2] [c10s2, App]</p>
<h3 id="13-专业协会的性质和作用-2">1.3. 专业协会的性质和作用</h3>
<p>[c2s3] [c1s2] [c35s1]</p>
<h3 id="14-软件工程标准的性质和作用-2">1.4. 软件工程标准的性质和作用</h3>
<p>[c10s2,] [*] [c32s6]</p>
<h3 id="15-软件的经济影响-2">1.5. 软件的经济影响</h3>
<p>[c1s1,] [c1s1] [*] [c10s8]</p>
<h3 id="16-雇佣合同-2">1.6. 雇佣合同</h3>
<p>[c6, c7] [*]</p>
<h3 id="17-法律问题-2">1.7. 法律问题</h3>
<p>[c6, c11] [c5s3-s4,] [c12s3,] [c13s2]</p>
<h3 id="18-文档-1">1.8. 文档</h3>
<p>[c10s5] [c1s5] [*] [c32]</p>
<h3 id="19-权衡分析trade-off-analysis">1.9. 权衡分析(Trade-Off
Analysis)</h3>
<p>[c1s2,] [c7s2,] [c9s5-10] [c10] [c13s4]</p>
<h2 id="2-群体动力学和心理学-1">2. 群体动力学和心理学</h2>
<h3 id="21-团队小组工作的动力学">2.1. 团队/小组工作的动力学</h3>
<p>[c1s6] [c1s3-5,] [c10]</p>
<h3 id="22-个体认知-1">2.2. 个体认知</h3>
<p>[c1s6] [c33]</p>
<h3 id="23-处理问题复杂性-1">2.3. 处理问题复杂性</h3>
<p>[c3s2] [c1s1,] [c20s1-s5]</p>
<h3 id="24-与利益相关者互动">2.4. 与利益相关者互动</h3>
<p>[*]</p>
<h3 id="25-处理不确定性和模糊性-1">2.5. 处理不确定性和模糊性</h3>
<p>[c4s1,c4s4,] [c9s4] [c11s5c24s5]</p>
<h3 id="26-处理公平多样性和包容性">2.6. 处理公平、多样性和包容性</h3>
<p>[*] [c10s7]</p>
<h2 id="3-沟通技能-1">3. 沟通技能</h2>
<h3 id="31-阅读理解和总结">3.1. 阅读、理解和总结</h3>
<p>[c4s5] [c33s3]</p>
<h3 id="32-写作">3.2. 写作</h3>
<p>[c1s5] [c4s2-s3]</p>
<h3 id="33-团队和小组沟通">3.3. 团队和小组沟通</h3>
<p>[c1s6] [c22s3] [c27s1] [c10s4]</p>
<h3 id="34-演讲技能">3.4. 演讲技能</h3>
<p>[c1s5] [c22] [c10s7-s8]</p>
<h2 id="进一步阅读-1">进一步阅读</h2>
<p>G.M. Weinberg,《计算机编程心理学》[15]。</p>
<p>这是第一本将编程作为个人和团队工作来探讨的重要著作;它已成为该领域的经典之作。</p>
<p>Kinney and Lange, P.A.,《商业律师知识产权法》[16]。</p>
<p>本书涵盖美国的知识产权法。它不仅讲述知识产权法是什么;还解释了为什么它看起来是这个样子。</p>
<h2 id="参考文献-10">参考文献</h2>
<p>[1*] F. Bott et al.,《软件工程专业问题》,第3版,Taylor &amp; Francis,
2000。</p>
<p>[2] 本指南附录B。</p>
<p>[3*] G. Voland,《设计工程》,第2版,Prentice-Hall, 2003。</p>
<p>[4*] I. Sommerville,《软件工程》,第10版,Addison-Wesley, 2016。</p>
<p>[5*] S. McConnell,《代码大全》,第2版,Microsoft Press, 2004。</p>
<p>[6] 25 Years Washington Accord, IEC, 2014。</p>
<p>[7] EUR-ACE, 2017。</p>
<p>[8] ISO/IEC
24773-1,软件和系统工程——软件和系统工程专业人员认证——第1部分:总体要求。</p>
<p>[9] ISO/IEC 24773-4
软件和系统工程——软件和系统工程专业人员认证——第4部分:软件工程。</p>
<p>[10] ACM道德和职业行为准则,2018。</p>
<p>[11] IEEE道德准则,2020。</p>
<p>[12] IFIP道德和职业行为准则,2021。</p>
<p>[13*] S. Tockey,《软件的回报:最大化您的软件投资回报》,Addison-Wesley,
2004。</p>
<p>[14*] R. E. Fairley,《软件项目管理与领导》,Wiley-IEEE Computer
Society Press, 2009。</p>
<p>[15] G. M. Weinberg,《计算机编程心理学:银禧纪念版》,Dorset House,
1998。</p>
<p>[16] Kinney and Lange, P.A.,《商业律师知识产权法》,Thomson West,
2013。</p>
<h1 id="软件工程经济学-1">软件工程经济学</h1>
<p>或者开发自己的系统，从纯技术角度来看可能显得简单。然而，这些决策可能通过软件项目的商业可行性以及产品本身产生严重影响。大多数软件从业者都在思考这些问题。</p>
<p>软件工程经济学帮助软件工程师以满足这些关键需求的方式工作。《SWEBOK指南》导言部分解释说，工程经济学是一门</p>
<p>15-1</p>
<p><strong>软件工程经济学</strong></p>
<p><strong>基础概念</strong> | <strong>工程决策过程</strong> |
<strong>软件工程实践中的经济学</strong> | <strong>多属性决策</strong> |
<strong>识别和表征无形资产</strong> | <strong>营利性决策</strong> |
<strong>非营利性决策</strong> | <strong>当前经济决策</strong> |
<strong>实践考虑因素</strong> | <strong>相关概念</strong></p>
<p>方案 | 决策过程 | 最小可接受性 | 收益成本分析 | 盈亏平衡分析 |
补偿技术 | 识别流程和可接受性 | 专家判断 | 商业案例 | 会计</p>
<p>现金流 | 概述 | 投资回报率 | 定义 | 理解真实问题 | 成本-优化 |
非-时间价值 | 类比 | 货币 | 财务 | 商业目标 | 真实问题 | 经济生命周期 |
有效性分析 | 分解 | 识别 | 识别所有 | 等价系统 | 分析周期 | 无形资产 |
效率和生产力 | 合理性 | 参数化 | 与商业目标关联的思维 | 基础决策 |
有效性 | 技术上可行的 | 替换 | 商业目标 | 比较 | 多个 | 可行的 | 决策 |
估算 | 解决方案 | 备选方案 | 识别 | 退役决策 | 产品或服务 | 软件 |
无形资产 | 定义 | 高级营利性决策考虑因素 | 支持 | 项目 | 选择标准 | 商业
| 无形资产 | 程序 | 评估每个 | 模型 | 定义和 | 备选方案 | 组合 |
衡量指标 | 商业 | 无形资产 | 根据选择标准 | 产品生命周期 |
选择首选备选方案 | 表征 | 项目生命周期 | 监控所选备选方案的绩效 |
将特定无形资产与商业模型关联 | 价格和定价 | 无形资产表征 | 决策 |
将特定无形资产与商业模型关联 | 优先级排序</p>
<p><strong>图15.1</strong> 软件工程经济学知识领域主题分解</p>
<p>这些问题是否适用于他们。但经济决策是工程的基础。一个不能从技术和经济角度做出决策的人不能被视为真正的工程师。</p>
<p>软件工程经济学适用于整个软件产品生命周期(SPLC)的决策，从项目前期的软件开发决策到现有软件的生命周期终止决策。它也适用于所有技术细节层面的决策。例如，以下所有问题都涉及经济视角：</p>
<p>• 客户组织能否从数字化转型中受益？ •
项目提案（投标）是否与客户的商业目标一致？ •
某些软件功能应该购买还是自己构建？ • 某些需求是否应该包含在范围内？ •
什么是最高效、最具成本效益的架构和设计？ •
对于基于云的部署，什么是最优的负载均衡策略，既能为客户提供足够的响应时间又不会产生不必要的运营成本？
• 基于风险的测试做到什么程度才够？ •
是重构、重新开发还是就这样使用具有高技术债务的代码？</p>
<p>• 将维护工作重点放在添加新功能上还是修复已知缺陷上更好？ •
使用敏捷流程通过早期交付部分功能获得的价值是否超过了迭代方法中固有的返工和持续测试的开销？</p>
<p>软件工程经济学知识领域直接或间接地与本指南中的所有其他知识领域相关。</p>
<p>本知识领域还持有这样的立场：需要拓宽更传统的、纯财务视角的工程经济学观点[2]。价值并不总是仅仅来自金钱；价值也可以来自”不可量化的因素”，如企业公民责任、员工福祉、环境友好性、客户忠诚度等。因此，软件工程决策还必须考虑相关的不可量化标准。</p>
<h2 id="软件工程经济学主题分解">软件工程经济学主题分解</h2>
<p>软件工程经济学知识领域的主题分解如图15.1所示。</p>
<h2 id="1-软件工程经济学基础概念">1. 软件工程经济学基础概念</h2>
<h3 id="11-方案-3-c3pp23-24">1.1. 方案 [3*, c3pp23-24]</h3>
<p>软件工程决策始于<em>方案</em>的概念——要考虑的单一、独立的行动方案（例如，执行特定的软件开发项目或不执行）。另一个方案可能是增强现有的软件组件；另一个方案可能是从头重新开发同一软件。在决定使用什么算法来实现某个功能时，每个考虑的候选方案都是一个方案。每个方案代表一个二元选择单位——软件工程师要么执行该方案，要么选择不执行。软件工程经济学旨在识别最符合组织目标的方案。</p>
<h3 id="12-现金流-3-c3pp24-32">1.2. 现金流 [3*, c3pp24-32]</h3>
<pre><code>$8150
$5900
$3650
$2900
$650  $1400
0  1  2  3  4  5  6  7
-$850

-$10,000</code></pre>
<p><strong>图15.2</strong> 方案B的现金流图</p>
<p>如果方案B的情况如此——在其他条件相同的情况下——组织执行方案A在财务上比执行方案B更有利。</p>
<p>因此，现金流是工程决策中的重要元素。</p>
<p>工程师必须从财务角度评估提案，才能做出有意义的决策。现金流实例(cash
flow instance)和现金流流(cash flow
stream)的概念描述了提案的财务视角。</p>
<p>现金流实例是指作为执行提案的直接结果，在特定时间流入或流出组织的特定金额。例如，在开发和推出产品X的提案中，如果需要购买新计算机，其支付款项就是流出现金流实例的一个例子。为了执行该提案需要花钱。产品X在市场推出后第11个月的销售收入就是流入现金流实例的一个例子。由于执行该提案而获得收入。</p>
<p>现金流流是指因执行该提案而随时间产生的一组现金流实例。现金流流是该提案的完整财务视图。流出多少钱?何时流出?流入多少钱?何时流入?因此，现金流流是工程决策的重要元素。</p>
<p>现金流图(cash flow
diagram)是现金流流的图示。现金流图快速总结了提案的财务视图。图15.2展示了一个现金流图示例。</p>
<p>现金流流以二维方式呈现。时间从左到右，金额上下移动。水平轴分为代表年、月、周等单位，根据提案的需要而定。每个净现金流实例根据其时间点在左右位置上绘制。现金流实例的金额以向上或向下的箭头表示。向上箭头表示资金流入(收入)，而向下箭头表示资金支出(费用)。箭头的长度通常与净金额成正比。</p>
<p><strong>1.3. 货币的时间价值</strong> [3*, c5-6]</p>
<p>经济学中最基本的概念之一——因此也是商业决策中的基本概念——是货币具有时间价值(time-value):其价值随时间而变化。现在的特定金额几乎总是与其他时间的相同金额具有不同的价值。15-4
<em>SWEBOK® GUIDE V4.0a</em></p>
<p>这个概念自有人类历史记载以来就存在，通常表现为利息(interest)。</p>
<p><strong>1.4. 等价性</strong> [3*, c7]</p>
<p>由于货币的时间价值，两个或更多现金流只有在相同时间等于相同金额时才是等价的。因此，比较现金流只有在它们以相同时间框架表示时才有意义。然后，可以准确确定两个现金流之间缺乏等价性，并可作为选择的依据。在相同时间框架内价值最高的提案在财务上最理想。</p>
<p><strong>1.5. 比较基础</strong> [3*, c8]</p>
<p>比较基础(basis for
comparison)是用于比较两个或多个现金流流的共同参考框架。它使用等价性来有意义地比较两个或多个提案。存在多种比较基础，包括以下几种:</p>
<p>• 现值; • 终值; • 年度等值; • 内部收益率(IRR); • 折现回收期。</p>
<p><strong>1.6. 备选方案</strong> [3*, c9]</p>
<p>通常，一个组织可以执行多个提案。但提案之间可能存在需要考虑的重要关系。也许只有执行提案X，提案Y才能执行。或者也许如果执行提案Q，提案P就无法执行，反之亦然。当存在互斥路径——A、或B、或C、或其他项目，而没有其他选择时，决策会更容易。本主题解释如何将任何一组提案及其相互关系转化为一组互斥备选方案。可以为其包含的所有提案计算任何备选方案的现金流流。然后可以在这些备选方案中做出选择。一个特殊情况称为无为备选方案(do-nothing
alternative)。有时最佳行动方案是不执行任何正在考虑的提案。无为备选方案代表这种情况。它并不意味着什么都不做;它意味着”做其他事情，不在这组选择中的事情。“在大多数(但不是所有)情况下都应该考虑无为备选方案。</p>
<p><strong>1.7. 无形资产</strong></p>
<p>无形资产(intangible assets)，也称为知识资产(knowledge
assets)，是指存在于组织不可见一面但影响该组织财务绩效的任何知识。根据国际评估标准(IVS)
210 §
20.1，“无形资产是一种非货币资产，通过其经济属性表现出来。它没有实体形式，但赋予其所有者权利和经济利益”[4]。</p>
<p>这可能包括但不限于政策、程序、工具和规范，以及组织文化、经验和专业知识。</p>
<p>了解组织的无形资产有助于软件工程师更好地理解提案可能如何影响或被组织现实所影响。否则，可能无法暴露可能影响提案成功或失败的隐藏风险和机会。</p>
<p>考虑无形资产所需的技能如下:</p>
<p>•
无形资产识别和评估[信息时代技能框架(SFIA)，类别:战略与架构，子类别:业务战略与规划];
• 知识管理[SFIA，类别:战略与架构，子类别:业务战略与规划]。</p>
<p>识别和表征无形资产将在后面更详细地讨论。</p>
<p>另一种选择是此KA中现金流流的总和。</p>
<p><a href="#软件工程经济学">软件工程经济学</a> 15-5</p>
<p>[定义] [选择标准]</p>
<p>[理解] [根据] [真实问题] [选择标准评估每个替代方案] [识别所有]
[合理的技术上] [可行的解决方案]</p>
<p>[首选替代方案] [选择] [监控] [所选替代方案的] [性能]</p>
<p><strong>图15.3.</strong> 工程决策过程</p>
<p><em>1.8. 商业模式</em>
当错误决策的后果很严重时，例如大型项目的进行/不进行决策，应该花费更多的时间、精力和</p>
<p>现代管理学奠基人Peter
Drucker将良好的商业模式定义为能够回答以下问题的模式[5]：</p>
<p>• 谁是客户？ • 客户重视什么？ • 我们如何赚钱？ •
解释我们如何以适当成本向客户交付价值的基本经济逻辑是什么？</p>
<p>理解组织的商业模式以及其无形资产(intangible
assets)，有助于软件工程师更好地理解提案可能如何影响或受到组织现实的影响。分析商业模式可以帮助软件工程师识别可能影响提案成功或失败的隐藏风险和机会[6]。</p>
<p><strong>2. 工程决策过程</strong></p>
<p><em>2.1. 过程概述</em> [3*, c4pp35-36]</p>
<p>图15.3提供了工程决策过程的概述。</p>
<p>该过程显示为逐步和顺序的；然而，在实践中它可以更加灵活。步骤可以迭代执行，可以重叠，甚至可以按不同顺序进行。只需确保不要跳过任何步骤或执行不当。</p>
<p>关注这个问题。应彻底仔细地完成所有步骤。ISO 12207[7]和ISO
15288[8]建议采取两项额外的早期活动，这在高后果决策中可能很重要：</p>
<p>• 定义决策管理策略 — 该策略可能指定角色、职责、程序和工具； •
识别相关利益相关者(stakeholders)，可能包括适当的主题专家。</p>
<p>当错误决策的后果较小时，例如选择次要算法或数据结构的后果，可以花费较少的时间、精力和关注，但仍遵循相同的一般过程。每个步骤在下面更详细地讨论。</p>
<p><em>2.2. 理解真实问题</em> [3*, c4pp37-39]</p>
<p>问题的最佳解决方案只能来自对要解决的真实问题的彻底理解。此步骤的关键方面包括使用诸如”5个为什么”技术之类的质疑技术(interrogative
technique)，以及考虑围绕问题的更广泛背景。设计思维(Design
Thinking)[9]中的同理心阶段（考虑无形资产）以及仔细研究组织的</p>
<p>15-6 <em>SWEBOK® GUIDE V4.0a</em></p>
<p>商业模式都是考虑更广泛背景的例子。</p>
<p><em>2.3. 识别所有合理的技术可行解决方案</em> [3*, c4pp40-41]</p>
<p>工程决策的目标是找到最佳解决方案。然而，最佳解决方案必须首先被识别为候选方案，然后才能被选为最佳。如果最佳解决方案不在正在考虑的解决方案集合中，它就无法被选中。当错误决策的后果很严重时，此步骤中创造性思维的重要性怎么强调都不为过。</p>
<p>对于某些潜在解决方案或候选方案，原型设计(prototyping)是验证技术可行性的有用方法。同行评审(peer
review)也可以帮助验证技术可行性，并可能促进识别更多候选方案。</p>
<p>一方面，增加候选方案会增加最佳方案在集合中的概率。另一方面，每个候选方案都会增加决策过程的成本。软件工程师在决定何时拥有足够的候选方案时必须运用最佳判断。这些候选方案就是基础主题第1节中定义的”提案”。</p>
<p><em>2.4. 定义选择标准</em> [3*, c4pp39-40, c26pp441-442]</p>
<p>工程决策几乎总是考虑财务角度。然而，其他决策标准也可能相关；当这种情况发生时，该决策是一个多属性</p>
<p>决策。决策标准的示例包括安全性、可靠性、可维护性、可扩展性、关键路径上的时间、对环境的影响、风险、政治影响、对客户或用户的影响以及过河能力。不能客观表达的决策标准被称为”不可量化因素”、“不可约因素”或”无形因素”。</p>
<p>定义决策标准可能是一项主观任务。太多的标准可能使分析变得笨拙。另一方面，太少的标准可能无法很好地区分提案，从而可能导致次优选择。通过包含更多标准提供更好决策的潜力必须与分析这些标准所需的额外工作相平衡。</p>
<p>就金钱是选择标准而言，决策的背景将限制决策者进行营利性、非营利性或现值经济决策分析，如本KA后面的主题3、4和5所解释的。</p>
<p><em>2.5. 根据选择标准评估每个替代方案</em> [3*, c4pp41-42]</p>
<p>根据每个选择标准评估每个替代方案。当选择标准涉及金钱时，必须从相同的角度判断每个替代方案。使用相同的比较基础（现值、未来价值、内部收益率(IRR)等，在营利性决策中；效益成本比(benefit-cost
ratio)或成本效益(cost-effectiveness)在非营利性决策中，等等），相同的规划期限，并考虑相同类型的成本和收入。一个示例决策可能是购买和调整现成软件产品与从头构建自定义应用程序。对一个提案考虑比另一个更长时间框架的成本将使使用较短时间框架的那个</p>
<p>评估决策。例如，一个具有环保意识的组织可能会选择一个经济性较差的解决方案，如果它更环保的话。</p>
<p>在许多情况下，错误决策的后果越严重，就需要考虑越多的选择标准。</p>
<p>尽可能客观地表达每个标准。理想情况下，这些客观术语将用货币价值表示——但不一定如此。清洁河流的”价值”是什么？按每公斤鱼的价格乘以河中鱼的估计数量来评估河流的价值可能没有意义。</p>
<p>看起来似乎是更好的选择，即使在相同的时间范围内它可能并不更好。</p>
<h2 id="26-选择首选方案">2.6. 选择首选方案</h2>
<p>[3*, c4p42, c26pp447-458]</p>
<p>如果唯一的选择标准是金钱，将选择具有最高现值、未来价值等的方案。当有多个标准时，可以使用各种技术来共同评估这些标准。多属性决策将在本知识领域后面详细介绍。</p>
<p>软件工程经济学 15-7</p>
<p>工程决策基于估算（将在本知识领域后面讨论）。估算的准确性在理论和实践中都是有限的，不准确的程度取决于具体情况
[3*,
c21pp344-356]。如果不准确程度足够高，该不准确性可能会改变最终决策。以下技术
[3*, c23] 可以帮助工程师应对这些情况：</p>
<p>• 考虑估算范围； • 执行敏感性分析； • 延迟最终决策。</p>
<p>此外，两类技术可以处理决策的多个潜在结果：</p>
<p>• 风险决策技术 [3*, c24]
用于可以为不同潜在结果分配概率的情况。具体技术包括期望值决策、期望方差和决策、蒙特卡洛分析、决策树和完全信息的期望值；</p>
<p>• 不确定性决策技术 [3*, c25]
用于无法为不同潜在结果分配概率的情况。具体技术包括拉普拉斯规则(Laplace
Rule)、最大最小规则(Maximin Rule)、最大最大规则(Maximax
Rule)、赫维茨规则(Hurwicz Rule)和最小最大后悔规则(Minimax Regret
Rule)。</p>
<p>高后果决策可能受益于正式记录所选方案以及选择该方案的理由。</p>
<h2 id="27-监控所选方案的性能">2.7. 监控所选方案的性能</h2>
<p>[3*, c4pp42-43]</p>
<p>因为估算是工程决策的基本要素，决策的质量取决于估算的质量。错误的估算很容易导致错误的决策。软件工程师需要通过将估算与实际结果进行比较来”闭环”估算。否则，没有人会知道估算是否准确
[3*,
c21pp356-358]。这也有助于随着时间的推移改进估算。了解估算与实际结果之间差异的驱动因素，有助于工程师改进估算技术，以便在未来产生更准确的估算。</p>
<h2 id="3-营利性决策">3. 营利性决策</h2>
<p>当组织的目标是利润时，适用营利性决策技术——这在大多数公司中都是这种情况。</p>
<p>图15.4展示了从一组提案中识别财务上最佳方案的过程。按初始投资递增的顺序排列方案，然后选择严格更好的候选方案，意味着在所有其他条件相同的情况下，将选择初始投资较小的方案。“下一个候选方案是否严格更好？”的决策是根据适当的比较基础做出的：现值、未来价值、内部收益率(IRR)等。</p>
<h2 id="31-最低可接受收益率">3.1. 最低可接受收益率</h2>
<p>[3*, c10pp141-143]</p>
<p>最低可接受收益率(MARR, Minimum Acceptable Rate of
Return)是组织认为是良好投资的最低内部收益率。一般来说，当另一项活动的回报率为20%时，投资回报率为10%的活动是不明智的。MARR表明组织有信心至少能实现该回报率。MARR代表组织的投资机会成本。通过投资某个方案，组织明确决定不将同样的资金投资到其他地方。如果组织已经有信心能够实现已知的回报率，则只有在方案的回报率至少达到该水平时才应选择该方案。考虑该机会成本的简单方法是使用MARR作为比较基础中的利率。</p>
<h2 id="32-经济寿命">3.2. 经济寿命</h2>
<p>[3*, c11pp160-164]</p>
<p>当组织投资于特定方案时，资金被占用在该</p>
<p>15-8 <em>SWEBOK® GUIDE V4.0a</em></p>
<figure>
<img alt="图15.4. 营利性决策过程" src="media/image-001.png"/>
<figcaption aria-hidden="true">图15.4. 营利性决策过程</figcaption>
</figure>
<p>方案中——即所谓的冻结资产(frozen
assets)。冻结资产的经济影响通常开始时较高，随时间推移而降低。另一方面，运营和维护成本往往开始时较低，随时间推移而增加。方案的</p>
<p>能够做出合理估算的时间范围需要纳入规划期限的确定中。一旦确定了规划期限，就有几种技术可用于将具有不同生命周期的提案</p>
<p>原生的总成本是计划期内这两项成本的总和。最初，冻结资产成本占主导地位；</p>
<p>后来，运营和维护成本占主导地位。在某个时刻，两项成本之和达到最小；这就是<em>经济寿命(economic
life)</em>或<em>最小成本寿命(minimum cost lifetime)</em>。</p>
<h2 id="33-规划期限">3.3. 规划期限</h2>
<p>为了正确比较一个四年寿命的方案和一个六年寿命的方案，需要解决将六年方案缩短两年或将四年方案的利润再投资两年的经济影响。<em>规划期限(planning
horizon)</em>，有时也称为<em>研究期(study
period)</em>，是同一决策中所有方案考虑的一致时间框架。经济寿命和时间等方面需要在规划期限内考虑。</p>
<h2 id="34-替换决策">3.4. 替换决策</h2>
<p>替换决策发生在组织已经拥有某个特定资产并考虑用不同资产替换它的情况下（例如，在维护和支持遗留软件或从头重新开发之间做出决定）。替换决策使用相同的盈利决策过程，但还有两个额外的重要考虑因素：沉没成本和残值。替换不一定需要涉及整个资产。在资产可以以较小增量替换的范围内，决策者可以在各种经济替代方案中考虑增量替换选项。</p>
<h2 id="35-退役决策">3.5. 退役决策</h2>
<p>退役决策是关于完全退出某项活动，例如软件公司考虑不再销售某个软件产品，或硬件制造商考虑不再构建和销售特定的计算机型号。退役决策可以是预先计划的，也可以是自发发生的（例如，当未达到性能目标时）。退役决策可能受到锁定因素的影响，如技术依赖性和高退出成本。</p>
<h2 id="36-高级盈利决策考虑因素">3.6. 高级盈利决策考虑因素</h2>
<p>上述概念和技术通常足以做出良好的盈利决策。然而，特别是当错误决策的后果很严重时，可能需要在决策分析中考虑其他因素，包括以下内容：</p>
<p>• 通货膨胀或通货紧缩； • 折旧； • 所得税。</p>
<h2 id="4-非营利决策">4. 非营利决策</h2>
<p>当组织的目标不是利润时，盈利决策技术不适用——政府和非营利组织就是这种情况。这些组织有不同的目标，因此需要不同的决策技术。这两种技术是效益-成本分析和成本效益分析（如下所述）。</p>
<h3 id="41-效益-成本分析">4.1. 效益-成本分析</h3>
<p>效益-成本分析是评估非营利组织方案最广泛使用的方法之一。方案的财务收益除以其成本。任何效益-成本比小于1.0的方案通常可以在不进一步分析的情况下被拒绝，因为它的成本会超过对组织的收益。当同时考虑两个或更多方案时，需要额外的考虑因素。</p>
<h3 id="42-成本效益分析">4.2. 成本效益分析</h3>
<p>成本效益分析在很大程度上共享效益-成本分析的理念和方法。成本效益分析有两个版本。固定成本版本寻求在成本的固定上限下最大化收益。固定效益版本寻求最小化实现固定目标的成本。</p>
<h2 id="5-现值经济决策">5. 现值经济决策</h2>
<p>工程决策的这一子集称为<em>现值经济(present
economy)</em>，因为它不涉及货币的时间价值（未来经济）。下面介绍两种形式的现值经济决策。</p>
<h3 id="51-盈亏平衡分析">5.1. 盈亏平衡分析</h3>
<p>给定描述两个或多个方案成本的函数，盈亏平衡分析通过识别这些成本函数相等的点来帮助工程师在它们之间做出选择。在盈亏平衡点以下，一个方案是首选的，在该点以上，另一个方案是首选的。例如，考虑在两个云服务提供商之间做出选择。一个提供商每月固定成本较低但使用增量费用较高，而另一个提供商每月固定成本较高但使用增量费用较低。盈亏平衡分析确定成本相同的使用水平。可以将组织的预期使用水平与盈亏平衡点进行比较，以确定成本较低的提供商。</p>
<h3 id="52-优化分析">5.2. 优化分析</h3>
<p>优化分析研究一个或多个成本函数在一系列值上的表现，以找到总体成本最低的点。软件的经典空间-时间权衡是优化的一个例子；运行速度更快的算法通常使用更多内存。优化平衡更快运行时间的价值与额外内存的成本。</p>
<h2 id="6-多属性决策">6. 多属性决策</h2>
<p>到目前为止，本KA中介绍的大多数主题都讨论了基于单一标准——金钱的决策。具有最佳财务结果的替代方案被选中。然而，许多决策涉及多个标准。</p>
<h3 id="62-非补偿技术">6.2. 非补偿技术</h3>
<p>也称为<em>全维度技术(fully dimensioned
techniques)</em>，这一类别中的技术不允许标准之间进行权衡。每个标准在选择过程中都被视为一个独立的实体。非补偿技术包括优势、满意和词典式排序。</p>
<h2 id="7-识别和描述无形资产">7. 识别和描述无形资产</h2>
<p>最优现值、最优增量内部收益率（IRR）、最优增量效益成本比等方法来选择。除了技术可行性，资金通常是最重要的决策标准，但肯定不是唯一的标准。通常，还需要考虑其他无法用金钱衡量的标准或”属性”。多属性决策技术允许将非货币标准纳入决策。</p>
<p>可以使用多种技术来处理多个标准，包括非货币标准。这些技术分为两类。</p>
<p><strong>6.1. 补偿性技术</strong> [3*, c26pp449-458]</p>
<p>也称为<em>单维技术</em>，此类技术将所有标准合并为单一的优值指标。这一类别被称为<em>补偿性</em>，因为对于任何给定的备选方案，某一标准的较低分数可以通过其他标准的较高分数来补偿或权衡。补偿性技术包括无量纲量表法、加权求和法和层次分析法（AHP）。</p>
<p>Gilb的影响估算[11]和软件工程研究所（SEI）的架构权衡分析方法（ATAM）[12]是补偿性多属性决策技术的示例，专注于识别最佳软件设计。</p>
<h2 id="7-无形资产">7. 无形资产</h2>
<p>组织的无形方面是其内部的宝贵知识。这包括员工关于流程、结构、程序等的知识（隐性或内隐知识），以及记录在各种组织资源中的机构知识（显性知识）。这些资产通常是隐藏的，就像冰山的大部分在水下一样。在许多决策中必须明确考虑无形资产，特别是当错误决策对客户的后果很严重时，无论客户是软件项目所服务组织的内部还是外部客户。</p>
<p>如果这些资产没有得到充分考虑，软件工程师就有可能开发出不适合客户组织的软件解决方案。只有明确考虑无形资产，才能将不合适软件解决方案的风险降到最低。战略无形流程资产特征化（SIPAC）方法[13]已被有效地用于实现这一目标。以下小节概述了SIPAC的步骤。</p>
<p><strong>7.1. 识别流程并定义业务目标</strong></p>
<p>首先要理解组织的业务流程和业务目标。如果组织有完善的流程文档，应该使用这些文档；否则，需要进行有目的的调查。</p>
<p>业务目标可以包括但不限于以下内容：</p>
<ol type="1">
<li>维持组织的增长和持续性；</li>
<li>实现财务目标；</li>
<li>履行对员工的责任；</li>
<li>履行对社会的责任；</li>
<li>管理市场地位。</li>
</ol>
<p><strong>7.2. 识别与业务目标相关的无形资产</strong></p>
<p>下一步是全面识别无形资产。常见示例包括政策、记录的业务流程、检查清单、经验教训、模板、标准、程序、计划和培训材料。组织开发或获取这些资产以实现其业务目标。这些资产代表提供商业价值的投资。识别组织无形资产的一种有效方法是从以下参考文献[14]中描述的分类法开始。目标是识别尽可能多的无形资产，这些资产可以作为实现上一步中识别的业务目标的杠杆。在实践中，这可以是一个迭代过程，通过审查已识别的资产来揭示其他资产的存在。一个实用的方法是迭代地关注[6]中描述的11种通用无形资产（GIA）。</p>
<p>可能的通用无形资产代表任何业务中可能涉及数字化转型的所有潜在部分。关注其中一个或多个通用无形资产可以让软件工程师更好地理解和界定项目的影响。通过迭代地关注这11个通用无形资产，软件工程师将选择要考虑的通用无形资产类型，并据此引导出要描述、实施或改进的具体无形资产。</p>
<p><strong>7.3. 识别支持无形资产的软件产品</strong></p>
<p>支持特定无形资产的软件产品将成为向客户提交的数字化转型提案的一部分，以帮助他们决定实施什么样的数字化转型。</p>
<p>为了识别与特定无形资产相关的产品，软件工程师可以从以下方法中选择：</p>
<p>•
通过使用Osterwalder[13]的方法在单一时间发现所有产品，该方法通过生成包含利益相关者新兴需求的价值图来促进创新，将产品映射到特定的无形资产；
• 如果产品已知，则列出它们，然后将它们映射到特定的无形资产； •
通过以下方式迭代地处理各个无形资产：(1) 选择特定的无形资产，(2)
识别产品，继续进行直到分析了所有特定的无形资产。</p>
<p>单个产品可以支持多个特定的无形资产，每个特定的无形资产可以由多个产品支持。</p>
<p><strong>7.4. 定义和测量指标</strong></p>
<p>此步骤定义和测量将用于表征无形资产（通过支持这些无形资产的软件产品）如何通过描述、实施或改进已识别的产品来帮助实现业务目标的指标。</p>
<h1 id="与每个gia相关的无形资产">与每个GIA相关的无形资产</h1>
<p>除了识别具体的无形资产外，还必须为每个已识别的资产添加定性的相对”重要性”。重要性是一个介于1到5之间的值（1表示较低重要性，5表示较高重要性），取决于该资产对实现业务目标的支持程度。重要性最高的无形资产可能是客户组织最合适的目标。</p>
<p>质量指标评估特定无形资产的特征或特性。影响指标评估特定无形资产对流程或业务目标的贡献程度。</p>
<p>指标必须经过归一化和标准化才能正确运行。</p>
<h2 id="75-无形资产特征化">7.5. 无形资产特征化</h2>
<p>基于收集的信息，软件工程师根据15-12个已识别的特定无形资产的质量和影响来确定其价值。特定无形资产可以根据其对业务目标的影响以及作为组织资产的质量来进行特征化。</p>
<p>有三种重要的特征化情况：</p>
<ul>
<li>情况1：同时具有影响指标和质量指标的特定无形资产（警告、可替换、演进中或稳定）；</li>
<li>情况2：仅具有质量指标的特定无形资产（可接受质量或不可接受质量）；</li>
<li>情况3：仅具有影响指标的特定无形资产（可接受影响或不可接受影响）。</li>
</ul>
<p>这三种特征化情况如图15.5所示。象限代表构成不同特征化水平的”状态”。分隔象限的线是影响和质量的阈值，定义了特定无形资产的影响或质量对每个组织来说可以被认为是可接受还是不可接受的点。这些阈值针对每个客户组织建立，并规定了他们对知识/无形资产在组织绩效、质量和影响方面的要求水平。阈值用于确定质量和/或影响何时是可接受或不可接受的。让我们看一个如何解释Qval和Ival的例子（Qval和Ival都将在以下章节中解释）。例如，假设我们正在分析一个同时具有质量和影响指标的无形资产的状态，并且Qval低于质量阈值，Ival低于影响阈值。在这种情况下，我们会说该无形资产的状态是”警告”，如图15.5所示。</p>
<p>特征化使用标准化-归一化指标的信息来评估已识别的无形资产。这种评估会产生一个描述性值，从定量角度确定资产的总体健康状态。</p>
<h3 id="质量定量评估">质量定量评估</h3>
<p>质量评估仅考虑无形资产的<strong>质量</strong>类型指标，并计算其总体评估。要评估质量指标子集，给定无形资产<strong><em>n</em></strong>的<strong><em>q</em></strong>个质量指标集合，质量评估按照公式1给出：</p>
<p><strong><em>Qval</em></strong> = ∑(<strong><em>i</em></strong>=1 to
<strong><em>q</em></strong>)
<strong><em>X</em></strong><sub><strong><em>n</em></strong></sub><sub><strong><em>i</em></strong></sub>
/ <strong><em>q</em></strong></p>
<p><em>公式1. 知识资产的质量评估</em></p>
<p>其中<strong><em>X</em></strong><sub><strong><em>n</em></strong></sub><sub><strong><em>i</em></strong></sub>是无形资产<strong><em>n</em></strong>具有的<strong><em>q</em></strong>个归一化质量指标中的每一个。</p>
<p>上述<strong><em>Qval</em></strong>是相应特定无形资产的质量指标归一化值的平均值。</p>
<h3 id="影响定量评估">影响定量评估</h3>
<p>无形资产的影响评估是仅考虑被分类为”影响”指标的归一化指标的评估。要评估影响指标子集，给定无形资产<strong><em>n</em></strong>的<strong><em>p</em></strong>个归一化影响指标集合，评估按照公式2给出：</p>
<p><strong><em>Ival</em></strong> = ∑(<strong><em>i</em></strong>=1 to
<strong><em>p</em></strong>)
<strong><em>Z</em></strong><sub><strong><em>n</em></strong></sub><sub><strong><em>i</em></strong></sub>
/ <strong><em>p</em></strong></p>
<p><em>公式2. 特定无形资产的影响评估</em></p>
<p>其中<strong><em>Z</em></strong><sub><strong><em>n</em></strong></sub><sub><strong><em>i</em></strong></sub>是知识资产<strong><em>n</em></strong>具有的<strong><em>p</em></strong>个归一化影响指标中的每一个。</p>
<p><strong><em>Ival</em></strong>是相应知识资产的影响指标归一化值的平均值。</p>
<h3 id="线性值计算">线性值计算</h3>
<p>最后，无形资产特征化的线性值由质量和影响评估（<strong><em>Qval</em></strong>和<strong><em>Ival</em></strong>）给出，遵循以下规则，假设质量和影响同等重要，因此<strong><em>KAval</em></strong>（无形资产的评估值）由以下公式给出：</p>
<p><strong>如果</strong> <strong><em>Qval</em></strong> &gt;
<strong><em>Ival</em></strong>，<strong>那么</strong>
<strong><em>KAval</em></strong> = (<strong><em>Qval</em></strong> +
<strong><em>Ival</em></strong>) / 2</p>
<p><strong>如果</strong> <strong><em>Qval</em></strong> =
<strong><em>Ival</em></strong>，<strong>那么</strong>
<strong><em>KAval</em></strong> = <strong><em>Qval</em></strong></p>
<p><strong>如果</strong> <strong><em>Qval</em></strong> &lt;
<strong><em>Ival</em></strong>，<strong>那么</strong>
<strong><em>KAval</em></strong> = <strong><em>Ival</em></strong></p>
<p>这个线性值代表基于其指标状态的无形资产总体状态。它使用标准化和归一化指标的代数平均值来表示。</p>
<p>必须考虑所有标准来决定应该为客户组织开发哪些软件产品，这使得这是一个多属性决策。（参见第6节，多属性决策制定。）</p>
<p>决策标准包括： - 无形资产对业务目标的影响（在前面步骤中定义）； -
达到的特征化（在前面步骤中定义）； -
无形资产状态对待改进组织的竞争对手的影响； - 无形资产对业务模型的影响；
- 实施产品的成本； - 实施产品的时间； - 产品的复杂性。</p>
<p>代表资产在[-1,
1]尺度上的总体状态，并基于相应的解释阈值。如果没有明确提及阈值，线性值的解释如下：如果值为0，则无形资产处于目标水平；如果值为1，表示无形资产超出目标100%；如果值为-1，则无形资产低于目标-100%。</p>
<p>在考虑所有相关标准后，组织可以看到实施软件解决方案来自动化那些价值不高或状态不佳的流程所带来的风险。相反，软件工程师可以透明地提供更好满足组织业务需求的建议。</p>
<p><em>7.6. 将特定无形资产与业务模型关联</em></p>
<p>当需要做出工程决策时，这种方法很有用，但在项目前期阶段尤为关键，此时需要向客户组织提供最有利于业务价值的建议。</p>
<p>可视化客户业务模型，并将分配到该模型中的无形资产状态进行丰富展示，能让组织领导层清楚理解拟议软件解决方案、无形资产、业务模型和业务目标之间的重要关系。软件工程师可以清楚地展示哪个拟议解决方案为业务创造最大价值。示例见[6]。</p>
<p><strong>8. 估算</strong> <strong>[3*, c21-26]</strong></p>
<p>估算是分析性地预测某个量，如项目的规模、成本或进度。软件工程中还会估算许多其他量，例如云服务需要支持的平均活跃客户端会话数、代码段执行期间函数被调用的次数，或软件产品中交付缺陷的数量。</p>
<p><em>7.7. 决策制定</em></p>
<p>软件工程师进行估算不是为了估算本身。软件工程师进行估算是为了在关键量未知时做出决策。例如，在15天内购买某功能还是自行构建的决策</p>
<p>决策过程的下一步是对客户组织最感兴趣的软件产品进行优先级排序和选择。没有简单的规则；必须考虑多个标准：</p>
<p>15-14 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<figure>
<img alt="案例2：仅质量指标 案例1：质量和影响指标 可接受的质量 可替代的 稳定的 质量阈值 不可接受的质量 警告 演进中的质量 案例3：仅影响指标 不可接受的影响 可接受的影响 影响阈值" src="media/image-001.png"/>
<figcaption aria-hidden="true">案例2：仅质量指标 案例1：质量和影响指标
可接受的质量 可替代的 稳定的 质量阈值 不可接受的质量 警告 演进中的质量
案例3：仅影响指标 不可接受的影响 可接受的影响 影响阈值</figcaption>
</figure>
<p>[<strong>图 15.5.</strong> ][特定无形资产的扩展特征描述]</p>
<p>组织肯定基于构建成本做决策。但构建的实际成本在组织真正构建之前无法精确知道。做出工程决策所需的关键信息通常在需要做出这些决策时是未知的。相反，决策基于估算。每个估算背后都有一个或多个决策。</p>
<p>在他们工作或提议工作的任何项目上提供这些估算的不确定性评估（为强调而加下划线）。（见[3*,
c21pp358-361]。）估算在[17]、[18]和[3*]中有广泛涉及。存在几种通用技术，这里概述每一种。所有特定估算技术都使用这些通用技术中的一种或组合。</p>
<p>鉴于估算是预测，实际结果与估算不同的概率非零。所有估算本质上都是不确定的。有时不确定性很大，有时很小。但它始终存在。幸运的是，估算不需要完美；它们只需要足够好，能引导决策者做出正确决策。</p>
<p><em>8.1. 专家判断</em> [3*, c22pp367-369]</p>
<p>软件工程道德与专业实践规范[16]指出：“3.09.
在他们工作或提议工作的任何项目上，确保对成本、进度、人员、质量和结果进行现实的定量估算”（为强调而加下划线）。（见[3*,
c21pp358-361]。）</p>
<p>在专家判断估算中，估算纯粹基于估算者的专业意见。这是最简单的技术，始终可用，在其他技术不可用时特别有用。缺点是这种技术产生的估算最不准确。多个专家判断估算可以输入到宽带德尔菲(Wide
Band Delphi)和规划扑克(Planning
Poker)等群体估算过程中，以产生更准确的估算。</p>
<p>[SOFTWARE ENGINEERING ECONOMICS] 15-15</p>
<p><em>8.2. 类比</em> [3*, c22pp369-371]</p>
<p>分解估算假设最低层级部分的高估会抵消部分的相应低估，从而得出更准确的整体估算。主要缺点如下：</p>
<p>类比估算假设如果被估算的事物与已知的事物相似，那么新事物的估算可以基于相似事物的实际结果，并对相关差异进行调整。类比估算的步骤如下：</p>
<p>• 它可能比任何其他技术需要更多工作； •
如果底层估算偏高或偏低，抵消效应就不会发生。</p>
<ol type="1">
<li>理解要估算的事物。</li>
<li>找到实际结果已知的合适类比。</li>
<li>列出被估算事物与类比之间可能显著影响结果的差异。</li>
<li>估算每个已识别差异的幅度。</li>
</ol>
<p><em>8.4. 参数化</em> [3*, c22pp374-377]</p>
<p>也称为<em>统计方法估算</em>，参数化估算利用</p>
<p>确定差异。已知的、数学关系介于</p>
<ol start="5" type="1">
<li>从类比的实际结果和针对被估算事物的可调整因素（如计算建筑物的建造成本作为其建筑面积的函数）中建立估算。估算模型是一个方程：首先，计算可观察因素，然后将它们代入方程以获得最终估算。</li>
</ol>
<p>通过类比进行估算比专家判断产生更准确的结果，并且仍然相对快速和简单。另一方面，必须有一个已知准确结果的适当类比可用，这种方法才能奏效。</p>
<p>参数化(parametric)估算通常是最准确、最易辩护和最易使用的，前提是方程已经开发和验证。缺点是开发和验证这样的方程需要充足的准确历史数据基础以及一些重要的数学和统计知识。</p>
<p><strong>8.3. 分解法</strong> [3*, c22pp371-374]</p>
<p>有时称为自底向上估算(bottom-up estimation)，分解估算的步骤是：</p>
<ol type="1">
<li>将要估算的事物分解成越来越小的部分，直到最小的部分可以合理地估算。</li>
<li>估算这些最小的部分。</li>
<li>将最小部分的估算值相加以建立整体的估算。</li>
<li>如果最小部分的估算不包括重要横切因素的余量，则找到解决这些因素的方法。例如，当从设计估算软件项目时，设计元素的估算可能不包括需求工作、集成工作、测试工作和用户文档工作的余量。</li>
</ol>
<p><strong>8.5. 多重估算</strong> [3*, c22pp377-379]</p>
<p>当错误决策的后果很小时，可以接受基于来自单一估算者使用单一估算技术的单一估算来做决策。然而，当错误决策的后果很重大时，投入额外努力开发多个估算是值得的。</p>
<p>要使用这种方法，工程师使用不同的技术估算同一事物，可能由不同的估算者完成。然后，他们寻找这些多个估算之间的收敛或发散。收敛表明各个估算可能是准确的，其中任何一个都可以用来做决策。发散表明可能忽略了一个或多个重要因素。找到导致发散的因素并重新估算以产生收敛结果通常会导致更好的估算，从而做出更好的决策。</p>
<h2 id="9-实践考虑">9. 实践考虑</h2>
<p><strong>9.1. 商业案例</strong></p>
<p>商业案例是从不同角度（成本、收益、风险等）为决策者和其他相关利益相关者(stakeholder)总结和解释推荐商业决策的综合、文档化信息。它用于评估产品的潜在价值，可作为投资决策的基础。</p>
<p><strong>9.2. 多货币分析</strong></p>
<p>当决策分析涉及跨境财务时，可能需要考虑货币汇率变化。这通常使用历史数据完成。</p>
<p><strong>9.3. 系统思维</strong></p>
<p>软件工程师发展其职业生涯的生态系统是复杂的。为了理解客户组织周围的全貌并形成对他们分析的场景的整体观，软件工程师可以使用系统思维方法。这种方法帮助软件工程师创建一套完整的可能场景，在这些场景中提供的软件可能有用，并利用这些信息向客户解释软件解决方案如何成为组织的价值提供者。系统思维方法的来源是[19]和[20]。连接系统思维的一种方式</p>
<h2 id="10-相关概念">10. 相关概念</h2>
<p>本主题包括软件工程师可能想要记住的概念。</p>
<p><strong>10.1. 会计</strong> [3*, c15pp234-245]</p>
<p>会计是金融的一部分。它让那些资金被用于运营组织的人了解他们投资的结果：他们是否获得了期望的利润？在营利组织中，这与有形的投资回报率(ROI,
Return on
Investment)相关，而在非营利和政府组织以及营利组织中，它转化为可持续地维持业务。会计的主要作用是衡量组织的实际财务绩效，并向利益相关者（如股东、财务审计师和投资者）传达有关商业实体的财务信息。沟通通常采用显示要控制的经济资源的财务报表形式。必须呈现正确的信息——与用户相关且可靠的信息。信息及其时机部分受风险管理和治理政策的约束。会计系统也是估算历史数据的丰富来源。</p>
<p>软件工程师必须意识到软件在数字时代作为业务账目驱动因素的重要性。</p>
<p><strong>10.2. 成本和成本计算</strong> [3*, c15pp245-259]</p>
<p>成本是用于生产某物的资金，因此不再可用。在经济学中，成本是作为决策结果而放弃的替代方案。</p>
<p>沉没成本(sunk
cost)是指已经发生的不可收回的费用，这可能会在展望未来时造成情感障碍。从传统经济学观点来看，沉没成本不应该在决策中被考虑。机会成本(opportunity
cost)是必须放弃的替代方案的成本。</p>
<h1 id="软件工程经济学-2">软件工程经济学</h1>
<p>思维方法论与业务模型的开发相结合，以理解客户组织的支柱，这在[21]中有所阐述。</p>
<p><strong>成本核算(Costing)是财务和产品管理的一部分。它是基于费用(如生产、软件工程、分销、返工)和目标成本来确定成本的过程，以便在市场中具有竞争力和成功。目标成本可能低于实际估算成本。这些成本的规划和控制(称为成本管理)非常重要，应始终包含在成本核算中。</strong></p>
<p><strong>成本核算中的一个重要概念是总拥有成本(Total Cost of Ownership,
TCO)。这对软件尤其适用，因为在初始产品开发之后的软件生命周期(SPLC)活动中存在许多不太明显的成本。软件产品的TCO定义为获取该产品、激活它并保持其运行的总成本。这些成本可以分为直接成本和间接成本。TCO是一种会计方法，对于做出明智的经济决策至关重要。</strong></p>
<h2 id="103-财务">10.3. 财务</h2>
<p><strong>财务是经济学的一个分支，涉及资源的分配、管理、获取和投资。财务是每个组织的一个要素，包括软件工程组织。</strong></p>
<p><strong>财务领域涉及时间、金钱和风险的概念，以及它们之间的相互关系。它还涉及资金的使用和预算编制。公司财务(Corporate
Finance)关注为组织的活动提供资金。通常，这涉及平衡风险和盈利能力，同时试图最大化组织的财富和股票价值。这主要适用于营利性组织，但也适用于非营利组织。后者需要财务来确保可持续性，即使不是为了获得有形利润。为此，组织必须：</strong></p>
<ul>
<li><strong>确定组织目标、时间范围、风险因素、税务考虑和财务约束；</strong></li>
<li><strong>确定并实施适当的业务战略，例如采取哪些投资组合和投资决策，如何管理现金流以及从哪里获得资金；</strong></li>
<li><strong>衡量财务绩效，如现金流和投资回报率(ROI)，并在偏离目标和战略时采取纠正措施。</strong></li>
</ul>
<p><strong>鉴于许多组织使用软件开发或获取来保持竞争力，软件工程师必须意识到软件对业务财务的重要性。</strong></p>
<h2 id="104-控制">10.4. 控制</h2>
<p><strong>控制是财务和会计的要素，涉及衡量和纠正绩效。它确保组织的目标和计划得以实现。成本控制(Controlling
Cost)是控制的一个专门分支，用于检测实际成本与计划成本的偏差。</strong></p>
<p><strong>在软件工程中，这个概念被称为过程和产品的控制与演进。虽然组织被视为具有自身目标的实体，组织目标的控制被视为独立的，但软件工程师必须通过确保其软件与业务目标保持一致，将组织控制视为其工作的一部分。</strong></p>
<h2 id="105-效率和有效性">10.5. 效率和有效性</h2>
<p>[10*, c22pp422-23]</p>
<p><strong>过程、活动或任务的<em>经济效率(Economic
Efficiency)</em>是消耗资源与预期消耗资源的比率。效率意味着”正确地做事”。高效的行为，如有效的行为，能够产生结果并最大限度地减少努力。影响软件工程效率的因素包括产品复杂性、质量要求、时间压力、过程能力、团队分布、中断、功能变更、工具和编程语言。</strong></p>
<p><strong>有效性是关于产生影响。它是实现目标与定义目标之间的关系。<em>有效性(Effectiveness)</em>意味着”做正确的事”。有效性只关注是否达到了定义的目标，而不关注如何达到这些目标。</strong></p>
<h2 id="106-生产力">10.6. 生产力</h2>
<p>[10*, c23pp689]</p>
<p><strong>从经济角度看，<em>生产力(Productivity)</em>是产出与投入的比率。<em>产出(Output)</em>是交付的价值。<em>投入(Input)</em>涵盖生成产出所花费的所有资源(如工作量)。</strong></p>
<p><strong>生产力从价值导向的角度结合了效率和有效性。最大化生产力是指以最低的资源消耗产生最高的价值。</strong></p>
<p><strong>《项目管理知识体系指南》[23]将返工(Rework)定义为”为使有缺陷或不符合要求的组件符合要求或规范而采取的行动”。值得注意的是，大多数软件组织并不知道最大的单一资源消耗者实际上是返工。在许多软件项目中，返工的成本高于所有其他项目活动的总成本。提高生产力的最有效方法可能就是减少返工。</strong></p>
<h2 id="107-产品">10.7. 产品</h2>
<p><strong>软件产品作为商品提供给客户(如软件应用程序)，可以原样提供，也可以作为另一个产品的组件(如嵌入式软件)。</strong></p>
<h2 id="108-项目">10.8. 项目</h2>
<p>[22*, c2s2.4]</p>
<p><strong>“<em>项目(Project)</em>是为创建独特的产品、服务或成果而进行的临时性工作”[24]。在软件工程中，区分了不同的项目类型(如产品开发、外包服务、软件维护、服务创建等)。在其生命周期中，软件产品可能需要许多项目。例如，在产品构思阶段，可能会进行一个项目来确定客户需求和市场要求；在维护期间，可能会进行一个项目来生产产品的下一个版本。</strong></p>
<h2 id="109-计划">10.9. 计划</h2>
<p><strong>“<em>计划(Program)</em>是一组相关的项目、子项目”</strong></p>
<h1 id="软件工程经济学-3">软件工程经济学</h1>
<p>减少软件项目返工涉及程序和程序活动，以协调的方式管理以获得单独管理时无法获得的收益，包括主动的质量改进行动（参见第12章，软件质量知识领域）：</p>
<ol type="a">
<li>更早地识别缺陷，以便以更低的资源成本修复这些缺陷</li>
<li>降低缺陷成本增长的程度（例如，有意简化的代码比复杂代码更易于修改，因此主动管理和控制代码复杂性可降低缺陷修复成本）</li>
<li>首先通过例如在开发和维护中使用适当的模板和检查清单来防止缺陷</li>
</ol>
<p>程序通常用于识别和管理在几年的时间范围内向单个客户或市场的不同交付。</p>
<h2 id="1010-项目组合">10.10. 项目组合</h2>
<p><em>项目组合</em>是”作为一个组进行管理以实现战略目标的项目、程序、子项目组合和运营”。项目组合用于分组并同时管理业务线或组织内的所有资产。拥有整个项目组合有助于确保考虑决策的更广泛影响，例如决定将资源分配给特定项目，这意味着相同的资源将无法用于项目组合中的其他项目。</p>
<p><em>10.7. 产品或服务</em></p>
<p><em>产品</em>是在将产品要素（或输入）转化为输出的过程中创建的有形经济商品（或输出）。<em>服务</em>是无形资源，如咨询。销售时，产品或服务是为其消费者创造价值和体验的可交付成果。产品或服务可以是内部交付（例如内部IT解决方案）或外部交付（例如）的系统、解决方案和材料的组合。</p>
<h2 id="1011-产品生命周期">10.11. 产品生命周期</h2>
<p>SPLC（软件产品生命周期）包括定义、构建、运营、维护和淘汰软件产品或服务及其变体所需的所有活动。SPLC的”运营”、“维护”和”淘汰”活动发生的时间范围比初始软件开发（软件开发生命周期(SDLC)）长得多。（参见软件工程过程知识领域中的软件生命周期模型。）此外，SPLC的运营-维护-淘汰活动比SDLC活动消耗更多的总体工作量和其他资源。（参见软件维护知识领域中的大部分维护成本。）软件产品或相关服务贡献的价值可以在”运营和维护”时间范围内客观确定。软件工程经济学应关注所有SPLC活动，包括初始产品发布后发生的活动。</p>
<h2 id="1012-项目生命周期">10.12. 项目生命周期</h2>
<p>项目生命周期活动通常涉及五个过程组：启动、规划、执行、监控和收尾。（参见软件工程管理知识领域。）软件项目生命周期内的活动通常以各种方式交错、重叠和迭代。（参见软件工程过程知识领域。）例如，SPLC内的敏捷产品开发涉及多次迭代，产生可交付软件的增量。SPLC应包括风险管理和与不同供应商（如有）的同步，同时提供可审计的决策信息（例如，以符合产品责任需求或治理法规）。软件项目生命周期和SPLC是相互关联的；一个SPLC可能包括多个SDLC。</p>
<h2 id="1013-价格和定价">10.13. 价格和定价</h2>
<p><em>价格</em>是为换取商品或服务而支付的金额。价格是金融建模的基本方面，是营销组合四P之一。其他三个P是产品、促销和地点。价格是四P中唯一产生收入的要素；其余都是成本。</p>
<p><em>定价</em>是金融和营销的一个要素。它决定公司将因其产品而获得什么回报。定价因素包括制造成本、市场定位、竞争、市场状况和产品质量。定价基于固定金额、数量折扣、促销或销售活动、特定供应商报价、发货或发票日期、多个订单的组合、服务产品等因素将价格应用于产品和服务。只有当消费者有购买产品的意愿和能力时，消费者的需求才能转化为需求。因此，定价在营销中至关重要。定价最初在项目启动阶段完成，是”开始”决策过程的一部分。</p>
<h2 id="1014-优先级排序">10.14. 优先级排序</h2>
<p><em>优先级排序</em>涉及基于共同标准对备选方案进行排名，以提供最佳价值。例如，在软件工程项目中，软件需求通常被优先排序，以在进度、预算、资源和技术的约束内为客户提供最大价值，或允许团队以增量方式构建产品，其中第一批增量为客户提供最高价值。（参见软件需求知识领域中的需求优先级排序和软件工程过程知识领域中的软件生命周期模型。）在2.6节”选择首选备选方案”的讨论中至少隐含了对备选方案的优先级排序，但在使用补偿技术时是显式的，如7.6节”多属性决策”中所述。</p>
<p><strong>主题与参考材料对照表</strong></p>
<table>
<colgroup>
<col style="width: 25%"/>
<col style="width: 25%"/>
<col style="width: 25%"/>
<col style="width: 25%"/>
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Tockey 2005 [3*]</strong></th>
<th><strong>Sommerville 2016 [10*]</strong></th>
<th><strong>Fairley 2009 [22*]</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 软件工程经济学</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="基础知识">基础知识</h1>
<h2 id="11-提案">1.1. 提案</h2>
<h2 id="12-现金流">1.2. 现金流</h2>
<h2 id="13-货币的时间价值">1.3. 货币的时间价值</h2>
<h2 id="14-等价性">1.4. 等价性</h2>
<h2 id="15-比较基础">1.5. 比较基础</h2>
<h2 id="16-备选方案">1.6. 备选方案</h2>
<h2 id="17-无形资产">1.7. 无形资产</h2>
<h2 id="18-商业模式">1.8. 商业模式</h2>
<h1 id="2-工程决策制定过程">2. 工程决策制定过程</h1>
<h2 id="21-流程概述">2.1. 流程概述</h2>
<h2 id="22-理解真正的问题">2.2. 理解真正的问题</h2>
<h2 id="23-识别所有合理的技术可行解决方案">2.3.
识别所有合理的技术可行解决方案</h2>
<h2 id="24-定义选择标准">2.4. 定义选择标准</h2>
<h2 id="25-根据选择标准评估每个备选方案">2.5.
根据选择标准评估每个备选方案</h2>
<h2 id="26-选择首选备选方案">2.6. 选择首选备选方案</h2>
<h2 id="27-监控所选备选方案的性能">2.7. 监控所选备选方案的性能</h2>
<h1 id="3-营利性决策制定">3. 营利性决策制定</h1>
<h2 id="31-最低可接受回报率">3.1. 最低可接受回报率</h2>
<h2 id="32-经济寿命-1">3.2. 经济寿命</h2>
<h2 id="33-规划期限-1">3.3. 规划期限</h2>
<h2 id="34-替换决策-1">3.4. 替换决策</h2>
<h2 id="35-退役决策-1">3.5. 退役决策</h2>
<h2 id="36-高级营利性决策考虑因素">3.6. 高级营利性决策考虑因素</h2>
<h1 id="4-非营利性决策制定">4. 非营利性决策制定</h1>
<h2 id="41-效益成本分析">4.1. 效益成本分析</h2>
<h2 id="42-成本效益分析-1">4.2. 成本效益分析</h2>
<h1 id="5-当前经济决策制定">5. 当前经济决策制定</h1>
<p>软件工程经济学 15-21</p>
<h2 id="51-盈亏平衡分析-1">5.1. 盈亏平衡分析</h2>
<h2 id="52-优化分析-1">5.2. 优化分析</h2>
<h1 id="6-多属性决策制定">6. 多属性决策制定</h1>
<h2 id="61-补偿性技术">6.1. 补偿性技术</h2>
<h2 id="62-非补偿性技术">6.2. 非补偿性技术</h2>
<h1 id="7-识别和描述无形资产-1">7. 识别和描述无形资产</h1>
<h2 id="71-识别流程并定义业务目标">7.1. 识别流程并定义业务目标</h2>
<h2 id="72-识别与业务目标相关的无形资产">7.2.
识别与业务目标相关的无形资产</h2>
<h2 id="73-识别支持无形资产的软件产品">7.3. 识别支持无形资产的软件产品</h2>
<h2 id="74-定义和衡量指标">7.4. 定义和衡量指标</h2>
<h2 id="75-无形资产描述">7.5. 无形资产描述</h2>
<h2 id="76-将特定无形资产与业务模式关联">7.6.
将特定无形资产与业务模式关联</h2>
<h2 id="77-决策制定">7.7. 决策制定</h2>
<h1 id="8-估算">8. 估算</h1>
<h2 id="81-专家判断">8.1. 专家判断</h2>
<h2 id="82-类比法">8.2. 类比法</h2>
<h2 id="83-分解法">8.3. 分解法</h2>
<h2 id="84-参数法">8.4. 参数法</h2>
<h2 id="85-多重估算">8.5. 多重估算</h2>
<h1 id="9-实际考虑因素">9. 实际考虑因素</h1>
<h2 id="91-商业案例">9.1. 商业案例</h2>
<h2 id="92-多货币分析">9.2. 多货币分析</h2>
<h2 id="93-系统思维">9.3. 系统思维</h2>
<h1 id="10-相关概念-1">10. 相关概念</h1>
<h2 id="101-会计">10.1. 会计</h2>
<h2 id="102-成本和成本计算">10.2. 成本和成本计算</h2>
<h2 id="103-金融">10.3. 金融</h2>
<h2 id="104-控制-1">10.4. 控制</h2>
<h2 id="105-效率和有效性-1">10.5. 效率和有效性</h2>
<h2 id="106-生产力-1">10.6. 生产力</h2>
<h2 id="107-产品或服务">10.7. 产品或服务</h2>
<h2 id="108-项目-1">10.8. 项目</h2>
<p>SWEBOK® 指南 V4.0a 15-22</p>
<h2 id="109-计划-1">10.9. 计划</h2>
<h2 id="1010-投资组合">10.10. 投资组合</h2>
<h2 id="1011-产品生命周期-1">10.11. 产品生命周期</h2>
<h2 id="1012-项目生命周期-1">10.12. 项目生命周期</h2>
<h2 id="1013-价格和定价-1">10.13. 价格和定价</h2>
<h2 id="1014-优先级排序-1">10.14. 优先级排序</h2>
<h1 id="延伸阅读-3">延伸阅读</h1>
<p>C. Ebert and R. Dumke, <em>Software Measurement</em> [27].</p>
<p>项目管理协会，<em>项目管理知识体系指南（PMBOK® Guide）</em> [24].</p>
<p><em>PMBOK® Guide</em>
提供了管理单个项目的指南，并定义了与项目管理相关的概念。它还描述了项目管理生命周期及其相关流程，以及项目生命周期。它是全球公认的项目管理专业指南。</p>
<p>项目管理协会和 IEEE
计算机协会，<em>项目管理知识体系指南软件扩展（SWX）</em> [25].</p>
<p><em>SWX</em> 为管理软件项目提供了对 <em>PMBOK® Guide</em>
中记录的项目管理通用实践的调整和扩展。该扩展对 <em>PMBOK® Guide</em>
的主要贡献是描述了适用于管理自适应生命周期软件项目的流程。</p>
<p>B.W. Boehm, <em>Software Engineering Economics</em> [26].</p>
<p>这本书是软件工程经济学的经典读物。它概述了软件工程中的商业思维。尽管示例和数据已经过时，但仍然值得阅读。</p>
<p>本书概述了软件工程中的定量方法，从测量理论开始，进而讨论性能管理和业务决策制定。</p>
<p>D.J. Reifer, <em>Making the Software Business Case: Improvement by
the Numbers</em> [28].</p>
<p>这本书是软件和IT行业制定商业案例的经典读物。许多有用的示例说明了如何制定和量化商业案例。</p>
<h1 id="参考文献-11">参考文献</h1>
<p>[1] E. DeGarmo et al., <em>Engineering Economy</em>, 第9版，Prentice
Hall, 1993.</p>
<p>[2] P. Rodriguez, C. Urquhart, and E. Mendes. “A Theory of Value for
Value-based Feature Selection in Software Engineering,” <em>IEEE
Transactions on Software Engineering</em>, 1, 2020.</p>
<p>[3*] S. Tockey, <em>Return on Software: Maximizing the Return on Your
Software Investment</em>, Addison-Wesley, 2005.</p>
<p>[4] <em>International Valuation Standards (IVS)</em>, Norwich: Page
Bros, 2019.</p>
<p>软件工程经济学 15-23</p>
<p>[5] K. Voigt, O. Buliga, and K. Michl, <em>Business Model Pioneers:
How Innovators Successfully Implement New Business Models</em>,
Springer, 2017.</p>
<p>[6] M.-I. Sanchez-Segura, G.-L. Dugarte-Peña, A. Amescua-Seco, and F.
Medina-Domínguez, “Exploring How The Intangible Side of an Organization
Impacts its Business</p>
<p>Characterization of Process Assets Based on Asset Quality and
Business Impact,” <em>Industrial Management and Data Systems</em>,
117(8), 1720-1734. https://doi.org/10.1108/IMDS-10-2016-0422, 2017.</p>
<p>[14] M.I. Sanchez-Segura, A. Ruiz Robles, F. Medina-Domínguez.
“Uncovering Hidden Process Assets: A Case Study.” <em>Information
Systems Frontiers</em>,</p>
<p>Model,” Kybernetes, Vol. 50 No. 10, pp. 2790-2822. 2021.
https://doi.org/10.1108/K-05-2020-0302</p>
<p>[7] ISO/IEC/IEEE 12207-2:2020 – 系统和软件工程 — 软件生命周期过程 —
第2部分：ISO/IEC/IEEE 12207:2017与ISO/IEC
12207:2008之间的关系和映射，IEEE，2020，pp. 1-278。</p>
<p>[8*] ISO/IEC/IEEE 15288:2023 – 系统和软件工程 –
系统生命周期过程，IEEE。</p>
<p>[9] T. Brown and B. Katz,
<em>设计改变：设计思维如何变革组织并激发创新</em>，修订更新版，Harper
Collins，2019。</p>
<p>[10*] I. Sommerville,
<em>软件工程</em>，第10版，Addison-Wesley，2016。</p>
<p>[11] T. Gilb,
<em>竞争工程：系统工程、需求工程和软件工程手册（使用Planguage）</em>，Elsevier
Butterworth-Heinemann，2005。</p>
<p>[12] R. Kazman, M. Klein, and P. Clements, “ATAMSM：架构评估方法，”
CMU/SEI-2000-TR-004，软件工程研究所，2000年8月。</p>
<p>[13] M.I. Sanchez-Segura, A. Ruiz-Robles, F. Medina-Domínguez, and
G.L. Dugarte-Peña. “战略决策”</p>
<p>15-24 <em>SWEBOK® GUIDE V4.0a</em></p>
<p>[14] M.I. Sanchez-Segura, G. Dugarte-Peña, et al.,
“揭示隐藏的过程资产：案例研究中的模型视图，”
https://www.springerprofessional.de/en/uncovering-hidden-process-assets-a-case-study/11724394，2016。</p>
<p>[15] A. Osterwalder, Y. Pigneur, G. Bernarda, A. Smith, and T.
Papadakos, <em>价值主张设计</em>，Wiley，2015。</p>
<p>[16] D. Gotterbarn, K. Miller, and S. Rogerson, “软件工程伦理规范，”
<em>Commun</em>. ACM 40, 11, 110-118, doi: 10.1145/265684.265699,
1997。</p>
<p>[17] S. McConnell,
<em>软件估算：揭开黑色艺术的神秘面纱</em>，第1版，Microsoft
Press，2009。</p>
<p>[18] R.D. Stutzke,
<em>估算软件密集型系统项目、产品和过程</em>，第1版，Addison-Wesley，2005。</p>
<p>[19] M. Ben-Eli,
<em>理解系统。系统创新</em>，https://netzerocities.app/_content/files/knowledge/3148/understanding_systems_thinking___systems_modelling_the_sustainability_lab_2019__1_.pdf，2019。</p>
<p>[20] J. Sterman,
<em>业务动态：复杂世界的系统思考和建模</em>，McGraw-Hill，2000。</p>
<p>[21] S. Pereira, G. Medina, et al.,
“协作商业模式的系统思维和商业模式画布设计，”
<em>IFIP信息与通信技术进展</em>，Vol. 488，pp. 461-468，2016。</p>
<p>[22*] R.E. Fairley, <em>管理和领导软件项目</em>，Wiley-IEEE Computer
Society Press，2009。</p>
<p>[23] Project Management Institute,
<em>项目管理知识体系指南（PMBOK®指南）</em>，第7版，Project Management
Institute，2021。</p>
<p>[24] Project Management Institute,
<em>PMI项目管理术语词典</em>，2012。</p>
<p>[25] Project Management Institute and IEEE Computer Society,
<em>PMBOK®指南第五版的软件扩展</em>，Project Management
Institute，2013。</p>
<p>[26] B.W. Boehm, <em>软件工程经济学</em>，Prentice-Hall，1981。</p>
<p>[27] C. Ebert and R. Dumke, <em>软件度量</em>，Springer，2007。</p>
<p>[28] D.J. Reifer,
<em>软件商业案例：按数字改进</em>，Addison-Wesley，2002。</p>
<h2 id="第16章-1"><strong>第16章</strong></h2>
<h2 id="计算基础-1">计算基础</h2>
<p><strong>缩写词</strong></p>
<p>ADT 抽象数据类型(Abstract Data Type)</p>
<p>AI 人工智能(Artificial Intelligence)</p>
<p>ANSI 美国国家标准协会(American National Standards Institute)</p>
<p>AVL Tree AVL树(Adelson-Velskii and Landis Tree)</p>
<p>BCNF BC范式(Boyce-Codd Normal Form)</p>
<p>BST 二叉搜索树(Binary Search Tree)</p>
<p>CASE 通用应用服务元素(Common Application Service Element)</p>
<p>CDRAM 缓存DRAM(Cache DRAM)</p>
<p>CERT 计算机工程响应团队(Computer Engineering Response Team)</p>
<p>CISC 复杂指令集计算机(Complex Instruction Set Computer)</p>
<p>CRUD 创建、读取、更新、删除(Create, Read, Update, Delete)</p>
<p>CUDA 统一计算设备架构(Compute Unified Device Architecture)</p>
<p>DAG 有向无环图(Directed Acyclic Graph)</p>
<p>DAL 数据库访问语言(Database Access Language)</p>
<p>DAS 直接访问存储(Direct Access Storage)</p>
<p>DBCS 双字节字符集(Double Byte Character Set)</p>
<p>DCL 数据控制语言(Data Control Language)</p>
<p>DDL 数据定义语言(Data Definition Language)</p>
<p>DDR SDRAM 双倍数据速率SDRAM(Double Data Rate SDRAM)</p>
<p>DKNF 域/键范式(Domain/Key Normal Form)</p>
<p>FPU 浮点运算单元(Floating Point Unit)</p>
<p>HCI 人机界面(Human-Computer Interface)</p>
<p>HMPP 混合多核并行编程(Hybrid Multicore Parallel Programming)</p>
<p>HTTP 超文本传输协议(Hyper Text Transfer Protocol)</p>
<p>IPC 进程间通信(Inter-Process Communication)</p>
<p>ISA 指令集架构(Instruction Set Architecture)</p>
<p>MIMD 多指令多数据流(Multiple Instruction, Multiple Data Stream)</p>
<p>MISD 多指令单数据流(Multiple Instruction, Single Data Stream)</p>
<p>MISRA 汽车工业软件可靠性协会(Motor Industry Software Reliability
Association)</p>
<p>ML 机器学习(Machine Learning)</p>
<p>NAS 网络访问存储(Network Access Storage)</p>
<p>OSI 开放系统互连(Open Systems Interconnection)</p>
<p>PDU 协议数据单元(Protocol Data Unit)</p>
<p>RDBMS 关系数据库管理系统(Relational DBMS)</p>
<p>RDRAM Rambus DRAM</p>
<p>RDM 运行时数据库管理器(Runtime Database Manager)</p>
<p>RISC 精简指令集计算机(Reduced Instruction Set Computer)</p>
<p>RTOS 实时操作系统(Real Time Operating System)</p>
<p>SAN 存储区域网络(Storage Area Network)</p>
<p>SASE 特定应用服务元素(Specific Application Service Element)</p>
<p>SDRAM 同步DRAM(Synchronous DRAM)</p>
<p>SEI 软件工程研究所(Software Engineering Institute)</p>
<h1 id="计算基础-2">计算基础</h1>
<h2 id="基本概念">基本概念</h2>
<h3 id="缩写词表">缩写词表</h3>
<ul>
<li>DMA: 直接内存访问 (Direct Memory Access)</li>
<li>SIMD: 单指令多数据流 (Single Instruction, Multiple Data Stream)</li>
<li>DML: 数据操作语言 (Data Manipulation Language)</li>
<li>SISD: 单指令单数据流 (Single Instruction, Single Data Stream)</li>
<li>EDW: 企业数据仓库 (Enterprise Data Warehouse)</li>
<li>FCFS: 先来先服务 (First Come, First Served)</li>
<li>SQL: 结构化查询语言 (Structured Query Language)</li>
<li>FIFO: 先进先出 (First In, First Out)</li>
<li>SRTF: 最短剩余时间优先 (Shortest Remaining Time First)</li>
</ul>
<h2 id="swebok-指南-v40a">SWEBOK® 指南 V4.0a</h2>
<h3 id="计算基础-3">计算基础</h3>
<h4 id="知识领域主题分解">知识领域主题分解</h4>
<p><strong>核心主题：</strong></p>
<ul>
<li><strong>基本概念</strong>：系统或解决方案的基本概念</li>
<li><strong>计算机编程</strong>：编程基础与语言</li>
<li><strong>计算机架构与组织</strong>：架构和组织结构</li>
<li><strong>人机因素</strong>：用户和开发者因素</li>
<li><strong>数据结构与算法</strong>：数据结构和算法</li>
<li><strong>操作系统</strong>：操作系统基础</li>
<li><strong>数据库管理</strong>：数据库管理系统</li>
<li><strong>网络与通信</strong>：网络和通信</li>
<li><strong>人工智能与机器学习</strong>：AI和机器学习</li>
</ul>
<p><strong>详细主题：</strong></p>
<ul>
<li>数据结构类型</li>
<li>数据结构操作</li>
<li>编程基础</li>
<li>内存管理和存储</li>
<li>开发者人机因素</li>
<li>模型</li>
<li>计算机架构</li>
<li>语法、语义和类型系统</li>
<li>内存管理</li>
<li>数据模型</li>
<li>分层架构</li>
<li>算法和属性</li>
<li>微架构</li>
<li>子程序和协程</li>
<li>管理</li>
<li>问题解决</li>
<li>设备管理</li>
<li>数据模型</li>
<li>学习</li>
<li>计算机组织</li>
<li>算法类型</li>
<li>编程语言类型</li>
<li>处理器管理</li>
<li>模式</li>
<li>网络类型</li>
<li>用户人机因素</li>
<li>推理</li>
<li>算法复杂度</li>
<li>面向对象编程</li>
<li>开放系统互连模型</li>
<li>自然语言处理</li>
<li>信息管理</li>
<li>算法复杂度度量</li>
<li>分布式系统</li>
<li>管理</li>
<li>封装和解封装</li>
<li>输入/输出</li>
<li>复杂度测量</li>
<li>并行编程</li>
<li>系统和应用层协议</li>
<li>控制单元</li>
<li>算法设计</li>
<li>结构化编程和调试</li>
<li>规范化</li>
<li>I/O设备</li>
<li>应用层协议标准和指南</li>
<li>查询语言</li>
<li>高效可靠算法设计技术</li>
<li>排序技术</li>
<li>数据挖掘和数据仓库</li>
<li>搜索技术</li>
<li>互联网协议套件</li>
<li>散列</li>
<li>数据库备份和恢复</li>
<li>无线和移动网络</li>
<li>安全性和漏洞</li>
</ul>
<p><strong>图 16.1</strong> 计算基础知识领域主题分解</p>
<h2 id="引言-8">引言</h2>
<p>软件工程师必须深刻理解其角色与计算机程序员角色之间的差异。典型的程序员将给定算法转换为一组计算机指令，编译代码，创建与相关库的链接，绑定，将程序加载到目标系统，执行程序并生成输出。</p>
<p>另一方面，软件工程师研究需求，架构和设计主要系统模块，识别最优算法，通信机制，性能标准，测试和验收计划，维护方法，以及适合应用的工程过程和方法等。</p>
<p>《软件工程知识体系指南》(SWEBOK Guide)
的核心目的是识别全球实践领域专家认为专业软件工程师必须掌握的知识领域。</p>
<p>软件工程师需要对计算机科学的各种概念有深入而广泛的了解，并能够应用它们。这些概念构成了计算基础。</p>
<h2 id="计算基础知识领域主题分解">计算基础知识领域主题分解</h2>
<p>计算基础知识领域 (KA) 的主题分解如图 16.1 所示。</p>
<h3 id="1-系统或解决方案的基本概念-6-c10">1. 系统或解决方案的基本概念 [6*,
C10]</h3>
<p>需要更详细地分析要解决的问题，包括功能需求、用户交互、性能需求、设备接口、安全性、漏洞、耐久性和可升级性。系统是一组集成的子系统、模块和组件，独立执行特定功能。明确界定问题和解决方案至关重要。</p>
<p>工程化系统确保子系统设计具有以下特性：</p>
<ul>
<li><strong>模块化</strong>：每个子系统（模块）是统一的（大小相似）</li>
<li><strong>内聚性</strong>：每个子系统执行一个特定任务。理想情况下，系统应该是高内聚的</li>
<li><strong>耦合性</strong>：每个子系统尽可能独立运行。理想情况下，系统应该是松耦合的</li>
</ul>
<p>子系统可以进一步分解为模块和子模块，这些模块和子模块也表现出这些特征。</p>
<p>系统可能包括软件和硬件子系统。硬件必须设计为支持软件子系统并满足所有用户需求，特别是用户界面（输入/输出
(I/O)）和性能。</p>
<p>本节重点关注设计和构建工程化软件子系统。应用程序可能需要手动、全自动或半自动系统；实时、在线或离线系统；分布式或单点系统等。</p>
<p>软件子系统的架构师必须考虑适当的技术、工具和方法。</p>
<p>本内容领域讨论系统或软件架构师需要了解的各种计算机架构和组织。</p>
<h4 id="21-计算机架构-8-c11">2.1 计算机架构 [8*, C1.1]</h4>
<p>架构描述计算机或系统的功能及其组件，如内存、数据存储设备、图形以及计算机或处理器的计算能力。</p>
<p>计算系统通常具有内存、I/O 设备和中央处理单元
(CPU)。这些组件通过称为<em>总线</em>的物理信号线连接。通常，三种类型的总线用于特定目的：</p>
<ul>
<li><strong>地址总线</strong>：用于寻址或访问</li>
</ul>
<p>数据结构、操作系统、数据库（如果需要）、用户界面、编程语言，以及在其他方面优化计算解决方案的算法等特定内存位置或I/O设备。</p>
<p>数据总线，用于向内存位置存储（写入）或从内存位置检索（读取）数据。</p>
<p>软件需求、架构、设计、构建、测试、方法和模型、质量保证和安全性在其他章节中作为独立的知识领域(KA)详细讨论。</p>
<p>控制总线，提供从CPU到I/O设备的控制信号（读取或写入、启用或禁用、中断、状态、复位等）。</p>
<p>计算基础知识领域重点解释软件工程师为了架构、设计、构建、部署和维护有用的高质量软件子系统而必须熟知的关键计算机科学概念。</p>
<p>软件工程师需要了解不同类型总线的功能和时序细节——第一代、第二代和第三代总线；内部和外部总线；串行和并行总线；单工、全双工和半双工总线；Mil-Std-1553B总线、Wishbone总线等。</p>
<h2 id="2-计算机架构与组织-6-c6">2. 计算机架构与组织 <strong>[6*,
C6]</strong></h2>
<p>计算机架构是指为特定目的而设计的计算机系统组件。计算机组织解释了系统内各单元如何连接和交互以实现这些目的。</p>
<h3 id="22-计算机架构类型-8-c414-c5">2.2. 计算机架构类型 [8*, C4.14,
C5]</h3>
<p>系统架构师必须分析计算机系统要设计或开发的应用；识别关键组件，包括所需的I/O设备（及其吞吐量）、内存类型和数量、处理能力和所需的协处理器；并选择或设计适当的计算机架构和组织。应为所需资源建立应急预案。</p>
<h4 id="221-冯诺依曼架构-8-c19">2.2.1. 冯·诺依曼架构 [8*, C1.9]</h4>
<p>约翰·冯·诺依曼设计了一个计算机系统架构，具有五个基本组件，如图16.2所示：</p>
<p>算术逻辑单元(ALU)，执行算术和逻辑计算。</p>
<p>程序和数据加载和执行的内存（程序和数据驻留在同一内存空间中）。</p>
<p>16-4 <em>SWEBOK® GUIDE V4.0a</em></p>
<p><strong>内存</strong></p>
<p><strong>输入设备</strong> <strong>ALU</strong>
<strong>输出设备</strong></p>
<p><strong>控制单元</strong></p>
<p><strong>图16.2.</strong> 计算机架构</p>
<p>输入设备（例如键盘、鼠标、串行端口、硬盘），允许用户提供输入和控制命令。</p>
<p>为系统定义的指令集。ISA定义了寄存器（地址、数据、标志）、数据类型、计算机或系统特定的指令、内存（内部和外部）寻址方案以及I/O处理模型。</p>
<p>输出设备（例如显示器、打印机），传输或通信计算结果。</p>
<p>精简指令集计算机(RISC)架构和复杂指令集计算机(CISC)架构是ISA的两种主要类型。</p>
<p>控制单元同步所有设备、内存和ALU。</p>
<p>在RISC中，指令执行单一任务，如从内存或I/O读取、执行算术或逻辑计算，以及将数据存储到内存或I/O。</p>
<h4 id="222-哈佛架构-20">2.2.2. 哈佛架构 [20*]</h4>
<p>哈佛架构为代码（程序或指令）和数据提供独立的内存块。由于代码和数据内存块不同，代码块中地址0000的内容与数据块中地址0000的内容是不同的。CPU从代码地址读取指令，从数据地址读取数据。</p>
<p>计算机系统很简单，但需要更多指令来执行任务。它每条指令需要较少的时钟周期，指令大小趋于固定。由于指令集很小（指令较少），因此更容易构建编译器，程序可能相对较大。RISC架构通常设计用于通用处理器。</p>
<p>原始哈佛架构中的系统设计和实现相对复杂。改进的哈佛架构提供一个内存块，但将其划分为代码和数据部分。数据内存部分可读/写，代码内存部分为只读（从而保护代码在运行时不被损坏）。I/O操作可以同时执行。</p>
<p>CISC中的指令相对更强大，可以执行多个任务，如从内存读取数据 +
执行算术运算 +
将结果存储到内存。这里，执行任务需要更少的指令，但指令需要更多时钟周期才能完成。</p>
<h4 id="223-指令集架构-8-c483">2.2.3. 指令集架构 [8*, C4.8.3]</h4>
<p>根据寄存器、内存和I/O的操作，指令大小变化很大。</p>
<p>指令集架构(ISA)是CPU如何执行为系统定义的指令集的抽象模型。</p>
<p>程序相对较小。CISC通常设计用于特定用途，如数字信号处理(DSP)和图形处理。</p>
<p>计算基础 16-5</p>
<h4 id="224-弗林架构或分类法-8-c93">2.2.4. 弗林架构或分类法 [8*, C9.3]</h4>
<p>一次一个盒子。这种架构通常用于为特定应用设计的解决方案。</p>
<p>上述计算架构一次只考虑一台计算机。迈克尔·J·弗林提出了并发计算机架构，其中系统中使用多个指令流和多个数据流。软件工程师需要了解</p>
<p>分布式系统架构：计算和存储位于独立但联网的盒子中。这种架构支持扩展，提供集中或隔离的数据存储，并共享计算负载。</p>
<p>Flynn架构的不同类型，包括以下示例：</p>
<p>•
池化系统架构：多个计算、存储和网络资源以资源池的形式提供，并根据需求分配。这种架构能够高效利用共享资源。</p>
<p>• 单指令单数据流（SISD）架构。</p>
<p>• 单指令多数据流（SIMD）架构。</p>
<p>•
汇聚系统架构：顾名思义，这是分布式架构和池化架构的融合。这种架构支持敏捷性和可扩展性。</p>
<p>• 多指令单数据流（MISD）架构。</p>
<p>• 多指令多数据流（MIMD）架构。</p>
<p>软件工程师还需要了解并能够应用各种其他架构，包括.NET
Framework架构、Unix架构和虚拟机架构。</p>
<p>这些架构的变体包括阵列处理、并行处理和关联处理；处理单程序多数据流和多程序多数据流。软件工程师需要了解这些架构之间的差异以及相关案例研究，以便能够选择合适的架构来解决手头的问题。</p>
<h2 id="23-微架构或计算机组成-8-c4">2.3 微架构或计算机组成 [8*, C4]</h2>
<p><em>2.2.5. 系统架构</em> [6*, C6]</p>
<p>微架构或计算机组成解释了计算机的ISA如何实现，以及系统中不同组件如何运作和相互交互以产生期望的结果。</p>
<p>系统架构是整体系统设计，考虑硬件架构、软件架构、模块、接口、数据管理和模块间通信。随着高效、高端、高性能服务器、存储、网络设备、软件和工具的发展，分布式计算变得更加经济实惠。对于任何给定的应用，都有多种参考设计或架构可供选择。</p>
<p>系统架构师和工程师必须了解系统中使用的各种组件及其功能。以下讨论其中一些组件。</p>
<p>典型的系统架构包括：</p>
<h3 id="231-算术逻辑单元-8-c12">2.3.1. 算术逻辑单元 [8*, C1.2]</h3>
<p>• 集成系统架构：计算、I/O、数据和网络紧密耦合，并且实时可用。</p>
<p>ALU执行所有算术计算和逻辑运算。CPU通常包含ALU、处理器、内存和控制单元。高端CPU还可能具有其他功能专用的处理单元，例如浮点运算单元（FPU），用于执行涉及浮点数或实数（分数）的计算。ALU有寄存器，这些寄存器是高速内存且位于ALU内部。ALU执行处理器指令集。所有操作通常都在寄存器上执行。</p>
<p>16-6 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<p>软件工程师需要了解I/O设备与系统的接口，无论它们是内存映射I/O还是I/O映射I/O设备，以及用户或应用程序通过操作系统与设备交互所需的设备驱动程序。</p>
<p>可以实施各种方案来提高ALU的性能，包括流水线处理和并行处理。最新的CPU提供多核和多线程，有助于实现最大吞吐量。软件工程师需要了解多核和多线程之间的差异，以及说明它们最佳使用场景的具体案例。</p>
<h3 id="234-控制单元-8-c42">2.3.4. 控制单元 [8*, C4.2]</h3>
<p>专用协处理器和关联处理器与主处理器一起使用以支持更快的处理。</p>
<p>控制单元同步计算机系统中的多个组件。通常，控制单元是CPU的一部分。它们解释指令并协调不同组件（内存、I/O设备和ALU）之间的数据移动。控制单元还用于启用或禁用组件或设备以及重置设备。</p>
<h3 id="232-内存单元-8-c6">2.3.2. 内存单元 [8*, C6]</h3>
<p>内存单元用于存储CPU访问的数据或信息。计算机可以拥有的总内存量取决于CPU支持的最大地址线数。系统中使用的不同类型的内存包括只读存储器（ROM）和读写存储器或随机存取存储器（RAM）。</p>
<p>软件工程师需要了解不同类型的控制单元，包括硬件控制单元和微可编程控制单元（单级和两级控制存储），以及每种控制单元的优点和挑战。</p>
<h2 id="3-数据结构和算法-8-c2-18-c10-part-v">3. 数据结构和算法 [8*, C2]
[18*, C10 Part V]</h2>
<p>从事性能关键应用的软件工程师需要了解各种类型内存之间的差异，包括静态RAM（SRAM）、动态RAM（DRAM）、异步DRAM（ADRAM）、同步DRAM（SDRAM）、双倍数据速率SDRAM（DDR
SDRAM）、Rambus
DRAM（RDRAM）和缓存DRAM（CDRAM），以及每种的优缺点和使用场景。</p>
<p>数据结构是计算机科学和软件工程的基础。每个程序都使用数据——接收输入（数据），对数据执行特定功能并产生输出。数据结构是关于有效地表示不同类型的数据、高效地对数据执行各种操作，以及高效地存储和检索数据。软件工程师必须内化数据结构、数据结构的选择以及针对特定应用的操作。</p>
<h3 id="233-输入输出设备-8-c7">2.3.3. 输入/输出设备 [8*, C7]</h3>
<p>在本章中，介绍了不同类型的数据结构及其各种操作。</p>
<p>正如其名称所示，输入设备是为计算机系统提供输入的设备，而输出设备是将计算机系统的输出传递给用户的设备。虽然有些设备仅用于输入（键盘、鼠标、麦克风等）或仅用于输出（打印机、显示器、扬声器等），但也有少数设备同时用于输入和输出（例如触摸屏、硬盘、USB驱动器）。</p>
<p><strong>3.1. 数据结构的类型</strong> [18*, C10], [5*, C2.1 - 2.6]</p>
<p>数据类型是数据的一个属性。根据数据的不同特征、数据项分组的需求以及对数据执行的各种操作，可以识别和定义各种数据类型。</p>
<p><a href="#计算基础">计算基础</a> 16-7</p>
<p>数据结构主要根据数据项的物理和逻辑排序进行分组。</p>
<p>主要地，数据分为三种类型：基本类型、复合类型和抽象类型。</p>
<p>基本或原始数据类型包括字符、整数、浮点数或实数、布尔值和指针数据。</p>
<p>复合数据类型由多个基本或原始数据类型，甚至多个复合数据类型组成。一些复合数据类型包括集合、图、记录和分区。</p>
<p>抽象数据类型(ADT)是从用户角度通过其行为（语义）来定义的，特别是从可能的值和操作的角度来定义。</p>
<p>复合数据类型进一步分为线性和层次化或非线性数据类型。</p>
<p>线性数据类型包括一维和多维数组、字符串、链表（单链表、双链表、循环链表）、栈、队列和哈希表。</p>
<p>层次化或非线性数据类型包括树、二叉树、n叉树、B树、B+树、加权平衡树、红黑树、堆、二叉堆和图。</p>
<p>在当前自由文本查询或自然语言处理的时代，软件工程师可能需要理解字符串和字符串的各种操作，并能够分析跳表(skip
list)。</p>
<p>软件工程师必须理解各种类型数据的细微差别及其在内存中的大小（短整数、整数、长整数、长长整数、有符号和无符号整数、浮点数、双精度、长双精度、双字节字符集(DBCS)、布尔值等），以及各种数据类型如何在内存中表示和存储，以及如何对它们执行各种操作。</p>
<p>集合、图和树在数学基础知识领域中有更详细的讨论。</p>
<p><strong>3.2. 数据结构上的操作</strong> [5*, C2.1 - 2.6]</p>
<p>对数据结构执行的基本操作包括创建、读取、更新和删除(CRUD)。</p>
<p>复合数据类型还需要通过各种方式遍历数据集，以在执行操作之前识别特定的数据项。</p>
<p>重要的是要确保数据集或数据库中任何项的插入或删除不会以违反设计和构建数据库时所遵循的任何策略的方式改变数据集或数据库。</p>
<p>对数据结构执行的其他操作包括按特定顺序对数据项进行排序、搜索和定位数据项，以及将两个或多个数据集合并为一个集合而不破坏构建数据集所基于的策略。搜索和排序算法将在下一节中讨论。</p>
<p>创建不同的数据结构是为了适应特定的应用，例如栈、队列、树和图。鼓励软件工程师学习非线性数据结构的遍历，其中包括不同的树解析器（前序、中序和后序树遍历）、树上的CRUD操作、树平衡、二叉搜索树(BST)、AVL树和红黑树，以及学习树搜索算法（深度优先、广度优先、最短路径等）。其中一些在数学基础知识领域中进行了讨论。</p>
<p><strong>3.3. 算法和算法的属性</strong> [18*, C26, C27]</p>
<p>所有软件都实现逻辑以执行所需的功能。执行特定任务的逻辑或算法必须在设计或选择时考虑系统性能、安全性、可移植性、可维护性、可扩展性和简洁性等因素。</p>
<p>算法的复杂度是通过测量该算法对给定数据集所消耗的计算资源（计算能力和空间）来确定的。</p>
<p>透彻理解数据结构对于分析和设计良好的算法至关重要。有关更多详细信息，请参阅”数据结构和组织”内容领域。</p>
<p>算法的属性有很多，包括功能性、正确性、健壮性、16-8 <em>SWEBOK</em>
<em>®</em> GUIDE V4.0a</p>
<p><strong>表 16.1. 算法的渐近符号</strong></p>
<table>
<thead>
<tr>
<th><strong>渐近符号</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>大O符号(Big O)</td>
<td>大O符号提供函数f(n)的操作上界（最坏情况）</td>
</tr>
<tr>
<td>小o符号(little-o)</td>
<td>小o符号用于描述上界不紧的情况</td>
</tr>
<tr>
<td>大Ω符号(Big Omega)</td>
<td>大Ω符号用于描述函数f(n)的下界（最佳情况）</td>
</tr>
<tr>
<td>小ω符号(little-omega)</td>
<td>小ω符号用于描述算法的松散界定最佳情况</td>
</tr>
<tr>
<td>Θ符号(Theta)</td>
<td>Θ符号从上方和下方界定函数（提供算法的平均情况复杂度）</td>
</tr>
</tbody>
</table>
<p>模块化、可维护性、程序员友好性（易于集成到项目中和易于使用）、用户友好性（即人们理解的容易程度）、程序员时间需求、简洁性和可扩展性。</p>
<p>最坏情况。算法的复杂度通常通过渐近符号来衡量给定数据集的最佳情况、最坏情况和平均情况下的资源消耗。</p>
<h1 id="算法的常用属性">算法的常用属性</h1>
<p>算法通常强调的一个属性是”性能”或”效率”。</p>
<p>影响算法资源消耗的参数包括但不限于：</p>
<ol type="1">
<li>硬件</li>
<li>软件</li>
<li>针对特定问题的算法选择和设计</li>
<li>有效的实现</li>
</ol>
<h2 id="34-算法复杂度-5-s1-s3-s4-s5-s6-s7-s11-s12">3.4. 算法复杂度 [5*, S1,
S3, S4, S5, S6, S7, S11, S12]</h2>
<p>算法的复杂度是对其针对特定问题和给定数据集所消耗资源（计算能力或内存）的度量。</p>
<p>选择正确的数据结构和数据结构上的操作，以及确保算法的最优实现，也会影响算法的复杂度。</p>
<p>算法的效率通过其消耗的资源来衡量，主要是计算时间和内存。</p>
<h2 id="35-复杂度的度量-5-s11-s3-s4-s5-s6-s111-s121">3.5. 复杂度的度量
[5*, S1.1, S3, S4, S5, S6, S11.1, S12.1]</h2>
<p>通常，算法的复杂度用其消耗的资源来表示，算法常用的渐近符号(asymptotic
notation)列在表16.1中。</p>
<p>学习计算不同输入数据集（例如，已排序、未排序和逆序排序）的列出符号是很重要的。</p>
<p>算法的复杂度可以是常数、线性、二次、三次、指数或对数。这些复杂度在表16.2中描述。通常，在计算算法效率时不考虑常数。</p>
<p><strong>表16.2. 算法复杂度列表</strong></p>
<table>
<colgroup>
<col style="width: 33%"/>
<col style="width: 33%"/>
<col style="width: 33%"/>
</colgroup>
<thead>
<tr>
<th><strong>复杂度</strong></th>
<th><strong>符号</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>常数</td>
<td>O(1)</td>
<td>无论数据大小如何，算法执行操作所需的步骤数都是恒定的。</td>
</tr>
<tr>
<td>线性</td>
<td>O(n)</td>
<td>操作数与数据集大小<em>n</em>成线性比例（步骤是数据集大小<em>n</em>的常数倍）。</td>
</tr>
<tr>
<td>二次</td>
<td>O(n²)</td>
<td>算法对大小为<em>n</em>的数据集执行操作需要<em>n²</em>级的步骤。</td>
</tr>
<tr>
<td>三次</td>
<td>O(n³)</td>
<td>算法对大小为<em>n</em>的数据集执行操作需要<em>n³</em>级的步骤。</td>
</tr>
<tr>
<td>指数</td>
<td>O(nᵏ) O(2ⁿ) O(n!)</td>
<td>算法对大小为<em>n</em>的数据集执行操作具有指数级依赖性。</td>
</tr>
<tr>
<td>对数</td>
<td>O(log(n)) O(N*log(n))</td>
<td>算法需要log(<em>n</em>)级的步骤（log的底通常为2）。</td>
</tr>
</tbody>
</table>
<h2 id="36-算法设计-18-part-iv-part-vi">3.6. 算法设计 [18*, Part IV, Part
VI]</h2>
<p>软件工程师必须考虑特定应用的目的和性能要求，以便选择合适的算法。此外，软件工程师还必须考虑线性编程与并行编程，以及单线程与多线程。</p>
<p>软件工程师需要了解一些标准算法和相关概念，包括以下内容：</p>
<ul>
<li>常见算法类型：暴力算法(Brute force algorithm)、递归算法(Recursive
algorithm)、分治算法(Divide &amp; Conquer
algorithm)、动态规划算法(Dynamic programming algorithm)、贪心算法(Greedy
algorithm)、回溯算法(Backtracking algorithm)、随机化算法(Randomized
algorithm)</li>
<li>随机化近似算法(Randomized approximation
algorithm)、随机舍入(randomized rounding)、近似算法(approximation
algorithm)、P和NP复杂度类算法、Cook定理(Cook’s
theorem)、归约和完全性算法(reduction and completeness algorithm)</li>
<li>在计算网络模型中同时执行多个比较操作。流行的排序网络算法包括比较网络(comparison
network)、零一原理(zero-one principle)、归并网络(merging
network)和双调排序器(bitonic sorter)</li>
<li>用于对矩阵执行多种操作的优化算法，如矩阵乘法、转置、矩阵求逆、中值和求行列式</li>
<li>密码学复杂度和算法：密钥（对称）加密算法、公钥（非对称）加密算法和哈希函数</li>
<li>单向函数(one-way function)、UP类、空间复杂度(space
complexity)、确定性和非确定性空间复杂度类、可达性方法(reachability
method)和Savitch定理(Savitch’s theorem)</li>
<li>图表示、图算法、广度优先搜索和深度优先搜索、拓扑排序(topological
sort)、最小生成树(minimum spanning
tree)、Kruskal算法和Prim算法，以及单源最短路径（Bellman-Ford算法和Dijkstra算法）</li>
<li>随机化计算的复杂度、交互式证明(interactive
proof)、计数的复杂度、布尔电路复杂度(Boolean circuit complexity)</li>
</ul>
<p>在许多软件系统中特别重要的是排序和搜索算法，下面将更详细地讨论这些算法。</p>
<h2 id="37-排序技术-18-c6-c9">3.7. 排序技术 [18*, C6-C9]</h2>
<p>排序是按特定顺序排列数据项的过程。</p>
<p>流行的排序算法包括线性排序(Linear sort)、冒泡排序(Bubble
sort)、快速排序(Quick sort)、归并排序(Merge sort)、基数排序(Radix
sort)、堆排序(Heap sort)、桶排序(Bucket sort)、鸽巢排序(Pigeonhole
sort)、双调排序(Bitonic sort)、树排序(Tree sort)、笛卡尔树排序(Cartesian
Tree sort)、三路快速排序(3-Way Quick sort)、三路归并排序(3-Way Merge
sort)，以及单/双链表排序。</p>
<p>每种排序算法都有其优点和缺点。选择合适的算法取决于输入数据的大小、数据类型（线性或非线性）以及数据集的类型（完全未排序、部分排序等）。这些算法以迭代和递归方法实现。</p>
<p>通常，迭代方法在CPU性能和内存方面优于递归方法。然而，递归为解决特定问题（如树操作）提供了简便的方法。如果有足够的计算能力和内存，递归和迭代实现方法之间的差异可以忽略不计。</p>
<p>在设计或选择哈希函数时，必须理解和考虑相关因素。</p>
<p>为不同类型的键值、应用和数据库大小设计了各种类型的哈希函数。哈希函数类型包括平凡哈希函数(trivial
hash function)、除法方法(division method)、平方取中法(mid-square
method)、数字折叠法(digit folding method)、乘法哈希(multiplicative
hashing)、双重哈希(double hashing)等。</p>
<p>对于某些哈希算法（开放哈希和封闭哈希、再哈希、可扩展哈希，以及加密和非加密哈希函数）效果最好的应用程序，软件工程师应该学习并适应使用它们时涉及的任何前提条件和复杂性（对内存和计算能力的需求）。软件工程师应该学习、实现并能够比较不同类型的哈希算法、各种冲突解决技术、线性探测(linear
probing)、二次探测(quadratic probing)、分离链接(separate
chaining)和开放寻址(open addressing)。</p>
<h2 id="38-搜索技术">3.8. 搜索技术</h2>
<p>搜索是在一组数据项或数据库中查找特定数据项或记录的过程。</p>
<p>搜索算法主要分为顺序搜索(sequential
search)（按顺序遍历数据集直到数据集末尾）和区间搜索(interval
search)（在排序列表、平衡树等中高效移动），这是基于数据集的组织方式。</p>
<p>根据数据项的类型和数据集的大小，使用各种搜索技术来查找所需的数据项。常见的搜索算法包括线性搜索、二分搜索、跳跃搜索、插值搜索、指数搜索、斐波那契搜索、子列表搜索（在另一个列表中搜索链表）、对数搜索、树搜索和哈希搜索。</p>
<h2 id="39-哈希">3.9. 哈希</h2>
<p>哈希是一种非常重要且流行的技术，其中任意大小的数据（键值）被转换为固定大小的值，称为哈希值(hash
values)，用于索引哈希表，以便可以轻松定位数据记录。用于该目的的函数称为哈希函数(hash
function)，返回的值称为哈希值、哈希码(hash
codes)、摘要(digests)或哈希键(hash keys)。</p>
<p>哈希函数的不同属性，如均匀性、效率、通用性、适用性、确定性、定义或可变范围、数据标准化、测试和度量。</p>
<h2 id="4-编程基础和语言">4. 编程基础和语言</h2>
<p>计算机程序是按顺序执行的步骤或指令，对提供的输入进行处理并生成期望的或特定的输出。</p>
<p>软件工程师在选择编程语言解决特定问题之前，必须仔细考虑各个方面。</p>
<h3 id="41-编程语言类型">4.1. 编程语言类型</h3>
<p>根据硬件、操作系统和应用，开发和使用各种类型的编程语言。基本类型的编程语言包括微编程(microprogramming)、机器语言、汇编编程和高级编程。</p>
<p>微编程在微控制器或微处理器芯片内执行，以执行汇编语言指令。汇编语言程序使用微控制器或微处理器指定的助记符(mnemonic)。通常，微控制器或微处理器被设计用于特定应用（DSP处理器、图形芯片、I/O控制器、数学协处理器、通用处理器等）。</p>
<p>高级语言使程序能够用类似英语的指令编写，这使开发人员和维护人员易于编写和维护程序。各种类型的高级编程语言包括以下几种：</p>
<p>• 函数式编程语言(Functional programming languages) •
过程式编程语言(Procedural programming languages) •
面向对象编程语言(Object-oriented programming languages) •
脚本语言(Scripting languages) • 逻辑编程语言(Logic programming
languages)</p>
<p>一种编程语言可以支持多种编程范式(paradigms)。软件工程师需要学习多种编程语言，以便为特定应用选择合适的语言。</p>
<p>许多编程语言，如C、C++和Java，使用编译器构建可执行文件，而其他编程语言，如JavaScript、Ruby和Python，使用解释器。</p>
<h3 id="42-编程语法语义类型系统">4.2. 编程语法、语义、类型系统</h3>
<p>编程语言的语法(syntax)是其语法规则——编程语言使用的各种结构。编译器或解释器检查所有声明、语句（算法语句、条件或逻辑语句、控制语句、循环、特定语言的语句、宏等）和函数或过程的语法，并创建任何错误的通知。</p>
<p>语义(semantics)指语句的含义或解释。含义可能是指令的本地含义或全局含义。</p>
<p>软件工程师应该了解高级编程语言如何被翻译成机器语言，熟悉各种类型的编译器，并了解编译器、解释器、交叉编译器、汇编器和交叉汇编器之间的区别。鼓励软件工程师学习编译器阶段(compiler
phases)，包括预处理、词法分析(lexical analysis)、语法分析(syntax
analysis)、中间代码生成、优化、代码生成器、链接器、加载器和调试器。</p>
<p>标记(tokens)、语法、语法树(syntax trees)、解析树(parse
trees)和算术和逻辑方程中各种运算符的权重（优先级）对于分析和理解很重要。</p>
<h3 id="43-子程序和协程">4.3. 子程序和协程</h3>
<p>子程序(subprograms)或函数是在完整项目范围内执行特定（部分）功能的程序或构建块。子程序提供将较大的程序分解为较小的模块。这些模块通常是在多个地方多次使用的代码段。子程序减少内存空间，提高程序的可读性和可维护性，并在不同的地方和时间使用不同的值执行程序的部分。</p>
<p>子程序有一个入口点，通常有多个输入参数，子程序对这些参数进行操作并产生输出。输入参数的作用域(scope)是子程序的局部作用域。通过名称返回值的子程序（可以用作</p>
<p>变量在运行时可能会根据运行时的值而变化，而不设计返回任何值的子程序被称为<strong>过程(procedures)</strong>。</p>
<p>类型系统为数据项或程序结构(如变量、表达式和函数)分配类型。在静态类型(static
typing)中,类型是固定的;它在程序创建时定义,并在编译时检查。C、C++和Java等语言支持静态类型。在动态类型(dynamic
typing)中,变量的类型可以在运行时根据上下文而改变,因此在运行时进行检查。动态类型语言包括Python、Perl、PHP和Ruby。动态类型也称为多态类型(polymorphic
typing)。</p>
<p>默认情况下,子程序参数的作用域是动态的,并且是子程序的局部作用域。但是,如果子程序必须记住其历史或先前的值,则必须将它们声明为静态的,或按所选编程语言中的规定进行声明。</p>
<p>不同的编程语言支持一种或多种参数传递类型,包括值传递(pass-by-value)、引用传递(pass-by-reference)、名称传递(pass-by-name)、结果传递(pass-by-result)和结果值传递(pass-by-result-value)。软件工程师应该了解这些类型之间的差异并适当地使用它们。</p>
<p>许多高级语言支持子程序的嵌套和递归,其中子程序调用自身。不同类型的递归包括循环或直接递归(子程序调用自身)和非循环或间接递归(子程序A调用子程序B,而子程序B又调用子程序A)。在递归子程序中建立退出标准很重要。</p>
<p>软件工程师应通过案例研究来理解子程序返回地址和参数如何存储在内存(运行时栈)中,它们如何在子程序中使用以及如何返回到调用的子程序,以及变量的作用域(全局和局部)。</p>
<p>具有多个入口点的子程序,其中记住先前的退出点以便稍后恢复,称为<strong>协程(Coroutine)</strong>。协程调用通常称为<em>恢复调用(resume
call)</em>。第一次恢复调用从开头进入子程序,后续恢复调用在上次退出的位置进入子程序。</p>
<p><strong>子程序S1</strong></p>
<p>恢复S2</p>
<p>恢复S3</p>
<p>恢复S1</p>
<p><strong>子程序S2</strong></p>
<p>恢复S1</p>
<p>恢复S3</p>
<p>恢复S2</p>
<p><strong>子程序S3</strong></p>
<p>恢复S2</p>
<p>恢复S1</p>
<p>恢复S3</p>
<p><strong>图16.3. 协程示例</strong></p>
<p>支持协程的高级语言包括C++20、C#、Java、JavaScript、Kotlin、Perl、.NET
Framework、Python、Ruby和许多汇编语言。软件工程师应该了解协程有用的特定应用,并使用协程。在C中实现协程是一个有趣的练习,因为C不原生支持协程。</p>
<p>图16.3描述了协程的功能或控制流。</p>
<h2 id="44-面向对象编程-4-c65">4.4. 面向对象编程 [4*, C6.5]</h2>
<p>顾名思义,面向对象编程语言基于对象。对象通常同时具有数据和操作该数据的函数。对象的数据通常称为对象的属性(attributes)或特性(properties),而处理属性的代码或函数在外部(由客户端或用户)称为操作(operations),在内部(指开发人员如何实现操作)称为方法(methods)。</p>
<p>类(Class)是程序员定义的原型,它定义了属性和方法。对象(Objects)是类的实际实例。一个类可以有多个具有不同特征的对象。例如,可以通过车辆的特征和操作来定义类,而对象是类车辆的实例,如汽车、公共汽车或卡车。</p>
<p>对象使用方法或操作相互交互。</p>
<p>面向对象编程(OOP)的重要特征是抽象(Abstraction)、封装(Encapsulation)、继承(Inheritance)和多态(Polymorphism)。</p>
<p>抽象是一种只向用户公开所需或相关信息和功能的特性,隐藏细节和非必要内容。因此,实现对超类的用户是隐藏的。</p>
<p>封装的主要好处之一是能够隐藏或保护数据免受未经授权的用户访问。软件工程师可以通过将数据和方法声明为私有(private,类的局部)或公共(public,对其他类可用)来为数据和方法提供不同级别的保护。这也可以保护数据免受有意或无意的损坏。</p>
<p>继承是OOP的一个重要特性,其中子类或派生类继承超类或基类的属性。主要的继承模式包括公共(public)、受保护(protected)和私有(private)模式。</p>
<p>多态是OOP的另一个关键特性。多态是为不同类型的实体提供单一接口的规定。例如,形状可以是具有绘制(draw)方法的基类,而对象可以是圆形、三角形或矩形。方法draw的实现虽然名称相同,但对于圆形、三角形和矩形是不同的。多态有两种类型:</p>
<p><strong>静态或编译时多态:</strong></p>
<p><em>4.6. 调试</em> [6*, C2.2.2]</p>
<p>程序在编写时,预期能够正常运行并生成预期的输出。然而,程序员在软件开发的不同阶段经常面临三种类型的错误——语法错误(syntax
errors)、运行时错误(runtime errors)和逻辑错误(logical errors)。</p>
<p>语法错误是偏离编程语言指定的标准格式的错误。</p>
<h2 id="45-分布式编程和并行编程-4-c66">4.5. 分布式编程和并行编程 [4*,
C6.6]</h2>
<p>在分布式计算机系统中，软件的多个部分在通过计算机网络连接的多台计算机上运行，以实现共同的目标。编写这样的程序称为<strong>分布式编程</strong>。</p>
<p>并行编程是一种计算类型，程序的不同部分并行运行以实现相同的目标或目的。表16.3比较了分布式编程和并行编程。</p>
<p>方法（函数）或操作符是重载的，并在编译时解析。例如：这些方法虽然名称相同，但参数的类型或数量不同。</p>
<p>•
<strong>动态或运行时多态性：</strong>要执行的重载方法在运行时解析。例如：当基类和派生类都有相同的方法时，基类方法被称为被覆盖。</p>
<p>流行的面向对象编程语言包括C++、C#、Cobol
2002、Java、Python、Lisp、Perl、Object Pascal、Ruby和Smalltalk。</p>
<p>重要的是要认识到，使用面向对象编程需要与使用传统的、过程式的或结构化编程不同的思维方式。</p>
<p>运行时错误在程序遇到意外情况时出现，例如除以零、内存溢出、访问错误或未授权的内存位置或设备，或者当程序试图执行非法或未授权的操作或试图访问库时。程序必须针对各种类型的输入（有效数据集、无效数据集和边界值数据集）和条件进行彻底测试，以识别这些错误。一旦识别出来，运行时错误很容易修复。</p>
<p>逻辑错误是在实现逻辑以达到所需输出时的失误。必须用各种数据对每个功能进行跟踪和解决这些错误。几种复杂的高端调试器帮助跟踪每个变量或数据项，并支持设置各种类型的断点。</p>
<h2 id="47-标准和指南-3-c285-c315">4.7. 标准和指南 [3*, C28.5,
C31.5]</h2>
<p>随着计算系统或应用程序变得越来越大和复杂，涉及更多的程序员。他们各自的编程风格会影响项目进度，使系统集成变得困难，因此系统容易出现缺陷，维护和增强变得具有挑战性。</p>
<p><strong>表16.3 分布式编程和并行编程的比较</strong></p>
<table>
<colgroup>
<col style="width: 25%"/>
<col style="width: 40%"/>
<col style="width: 34%"/>
</colgroup>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>分布式编程</strong></th>
<th><strong>并行编程</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>任务由多台联网的计算机共享和执行。</td>
<td>计算机上的两个或多个处理器并行共享和执行任务。</td>
</tr>
<tr>
<td>计算机</td>
<td>位于不同位置但已联网的多台计算机。</td>
<td>具有一个或多个处理器或核心的两台计算机。</td>
</tr>
<tr>
<td>内存</td>
<td>每台计算机都有自己的内存。</td>
<td>计算机可以有共享或分布式内存。</td>
</tr>
<tr>
<td>通信</td>
<td>计算机通过网络通信。</td>
<td>进程通过总线或进程间通信(IPC)方法通信。</td>
</tr>
<tr>
<td>优点</td>
<td>一台计算机的故障不会影响任务的功能，因为它会转移到另一台计算机。为最终用户提供可扩展性和可靠性。</td>
<td>由于多个进程并行运行，通常性能会提高。一个处理器的故障不会影响其他处理器或核心的性能。</td>
</tr>
<tr>
<td>缺点</td>
<td>拥有多个系统可能很昂贵；成本必须与客户对应用程序正常运行时间的需求进行权衡。网络延迟可能会影响任务的整体功能。设计高效的分布式计算系统相对困难。</td>
<td>使用多个处理器或核心可能很昂贵。一个进程对另一个进程的依赖可能会引入延迟。</td>
</tr>
<tr>
<td>示例应用</td>
<td>电话和蜂窝网络、互联网、万维网网络、分布式数据库管理系统、网络文件系统、网格计算、云计算。</td>
<td>计算机图形学中的2D和3D模拟和渲染、科学计算。</td>
</tr>
<tr>
<td>示例编程语言、库、引擎、框架</td>
<td>Golang、Elixir、Scala、Fortran、C和C++。</td>
<td>Apache Hadoop、Apache Spark、Apache Flink、Apache
Beam、CUDA、OpenCL、OpenHMPP、MPP、用于C、C++和Fortran的OpenMP。</td>
</tr>
</tbody>
</table>
<p>据估计，82%的漏洞是由编程风格的冲突造成的。</p>
<p>因此，注重质量的公司通常定义了工具、标准和指南，为他们的程序员和测试人员设定规则和建议。</p>
<p>当软件团队遵循适当的编码标准时，他们会创建可读、更清洁、可移植、可重用、模块化、易于维护、缺陷较少的软件代码，项目进度变得更可预测。以下实践可以帮助组织成功实施这些标准：</p>
<p>• 仔细选择适合正在开发的应用程序或系统的编码标准和指南。 •
考虑由社区参与创建的开放标准，例如软件工程研究所(SEI)计算机应急响应小组(CERT)，以及由工作组创建的封闭标准，例如汽车工业软件可靠性协会(MISRA)。
• 教育程序员遵循采用的标准。</p>
<p>软件工程师需要理解操作系统的基本结构、系统架构类型、设计方法、分布式操作系统的架构以及分布式操作系统中的问题。</p>
<p>操作系统通常有四个主要组件：处理器管理、</p>
<p>标准和指南。[内存管理、设备管理]</p>
<p>• 使用工具和定期审查来确保和信息管理已采用的标准和指南得到遵循。</p>
<p>• 不时审查和修订标准和指南，从项目执行中学习。</p>
<p><strong>5.1. 处理器管理</strong> [19*, C2, C8]</p>
<p>软件工程师必须理解处理器(processor)、进程(process)和地址空间的概念。他们必须理解启动、进程、核心、线程、用户线程和内核线程、fork和exec、同步以及硬件锁定支持。他们应该比较和对比各种CPU调度概念、调度算法、算法评估、多处理器调度和实时调度、并发编程、死锁、临界区、条件临界区和监视器。</p>
<p>SC 22是ISO和IEC的联合技术委员会ISO/IEC JTC
1的一个分委员会,用于定义编程语言、其环境和系统软件接口的标准(<strong>ISO/IEC
JTC 1/SC 22</strong>)。建议软件工程师参考这些标准。</p>
<p>不同进程之间的通信在多任务、多用户操作系统中很重要。软件工程师必须深入理解进程间通信(IPC)和IPC的类型,包括消息、管道、共享内存、信号量、模块化和进程同步。</p>
<h2 id="5-操作系统-19"><strong>5. 操作系统</strong> [19*]</h2>
<p>操作系统(OS)是管理计算机硬件并为软件应用程序提供平台的软件。软件工程师需要对操作系统及其目标、服务和功能有良好的总体理解。</p>
<p>随着时间的推移,设计了不同类型的操作系统来支持各种类型的系统或应用程序,包括批处理、多道程序设计、分时和双模式操作——用于保护I/O、内存、CPU、内核和微内核。</p>
<p>为了选择合适的操作系统,软件工程师必须分析不同类型的操作系统,例如单用户、单任务、多用户、多任务和多线程操作系统;实时操作系统(RTOS);网络操作系统;和分布式操作系统。对于小型系统,可能不需要操作系统。研究每种类型的示例并比较它们的优势和局限性很重要。</p>
<p>各种类型的锁用于确保进程间数据的正确同步,包括信号量、二进制信号量、计数信号量和互斥锁。深入理解IPC的常见挑战、死锁、死锁场景和死锁特征;死锁的预防、避免、检测和恢复;以及优先级图是至关重要的,需要通过案例研究来内化。</p>
<p>软件工程师需要通过示例学习并发语言、进程和调度、作业和进程概念,以及各种类型的调度:CPU-I/O交错、非抢占、上下文切换和调度算法(先来先服务(FCFS)、最短作业优先(SJF)、最短剩余时间优先(SRTF)、优先级调度、轮转调度和组合方案)。</p>
<h3 id="52-内存管理-19-c3"><strong>5.2. 内存管理</strong> [19*, C3]</h3>
<p>软件工程师需要非常好地理解系统中内存的管理方式以及不同类型的内存和相关概念——物理内存、虚拟内存、辅助内存、内存层次结构、链接和内存分配。</p>
<p>工程师必须理解内存碎片(外部碎片和内部碎片),以及各种内存管理概念,包括单元、分页、页表、分段、分页分段、虚拟内存管理、请求分页、页面置换、抖动和交换。</p>
<p>内存以不同方式分配给进程——例如,通过连续分配、非连续分配、动态分区内存分配、静态交换和覆盖。</p>
<p>理解逻辑地址、分区、静态与动态内存分配、空闲空间管理和内存块碎片整理也很重要。</p>
<p>由于可用的物理内存总是有限的,因此设计和实现了各种内存页面置换策略。这些策略包括先进先出(FIFO)、最近未使用(NRU)、最近最少使用</p>
<h3 id="53-设备管理"><strong>5.3. 设备管理</strong></h3>
<p>设备驱动程序是在硬件和应用程序之间提供接口的软件程序。软件工程师应该理解设备驱动程序、各种类型的设备驱动程序、设备驱动程序表、设备驱动程序功能以及各种类型硬件设备的接口,以及硬件和软件中断以及中断和轮询的接口。</p>
<p>软件工程师还应该理解,在多用户、多任务操作系统中,共享设备可能会出现缓存、调度、假脱机和性能问题,以及解决这些问题的机制。</p>
<h3 id="54-信息管理-19-c4"><strong>5.4. 信息管理</strong> [19*, C4]</h3>
<p>软件工程师需要理解以下内容:</p>
<p>•
进程的概念、系统程序员对进程的视图、操作系统对进程的视图以及用于进程管理的操作系统服务</p>
<p>•
文件系统管理、存储管理、文件属性、目录结构、文件系统结构、大容量存储结构、I/O系统、保护和安全</p>
<p>•
用户和操作系统对文件系统的视图以及各种类型的文件系统——简单文件系统、符号文件系统、逻辑文件系统和物理文件系统</p>
<p>工程师应该熟悉各种</p>
<p>(LRU)、最近最常使用(MRU)、最不经常使用(LFU)、最常使用(MFU)、最长距离优先(LDF)、第二次机会和老化等。</p>
<h2 id="53-设备管理-19-c5">5.3. 设备管理 [19*, C5]</h2>
<p>软件工程师必须充分了解不同类型的I/O设备——内存映射和I/O映射设备、块设备和字符设备以及缓冲设备。工程师应该比较和对比轮询、中断驱动和直接内存访问(DMA)I/O设备，以及阻塞与非阻塞I/O设备。</p>
<p>操作包括访问控制列表(ACLs)、访问矩阵、访问控制、访问控制验证、能力分配策略、I/O启动器、设备策略、设备处理程序、磁盘调度、磁盘空间管理、存在性和并发控制、方案和组合方案、身份验证方案、目录命名空间、层次结构、有向无环图(DAGs)、硬链接和软链接。</p>
<h2 id="55-网络管理-4-c41">5.5. 网络管理 [4*, C4.1]</h2>
<p>网络管理是管理和维护各种类型网络的过程。该内容领域包括网络管理概念、分布式对象、分布式文件系统以及网络架构、设计、问题和解决方案。</p>
<p>网络管理员需要详细了解物理和逻辑时间，以及网络管理中的内部和外部同步协议，如Cristian算法、Berkeley算法、网络时间协议、Lamport逻辑时钟、向量时钟、消息的因果排序和全局状态。</p>
<p>其他重要主题包括分布式计算、终止检测、分布式互斥和选举、简单和基于多播的互斥算法；集中式、基于环的、Ricart
Agrawala算法、Maekawa算法、选举算法、Bully算法和多播通信。</p>
<p>此外，软件工程师应该理解重要原则，包括硬件安全、外部安全、操作安全、密码保护、访问控制、安全内核和分层方法。</p>
<h2 id="6-数据库管理">6. 数据库管理</h2>
<p>数据库是相关数据元素的集合，专门为一个或多个应用程序使用而收集，并以有组织的格式存储，以便使用一个或多个键值快速访问。数据项或元素存储在一个或多个数据库或文件中，它们之间的关系通过数据库模式建立。</p>
<p>在数据库上执行的基本操作包括创建数据库及其元素(表、索引、视图、函数、过程等)、从数据库中删除或丢弃项、修改数据库的内容和结构、数据检索、注释和重命名操作。</p>
<p>不同类型的数据库包括关系数据库、非结构化查询语言(NoSQL)数据库、列式数据库、面向对象数据库、键值数据库、文档数据库、层次数据库、图数据库、时间序列数据库和网络数据库。理解什么类型的数据库最适合特定应用，以及分析每种数据库类型的定义、结构、具体优缺点和示例，有助于软件工程师为给定应用选择正确的数据库类型。</p>
<p>在选择数据库时，软件工程师应该评估数据模型、存储模型、数据库类型、键值、图、列族、数据量、一致的数据访问时间以及访问数据库的用户或应用程序数量(流量)等。</p>
<p>数据库系统的学习者和用户需要创建两个角色(数据库用户和数据库架构师)，审查几个复杂度递增的案例研究，创建多个数据库并分析信息。这个过程对理解和内化数据库设计和管理有很大帮助。</p>
<h3 id="61-模式-22-c214">6.1. 模式 [22*, C2.1.4]</h3>
<p>数据库模式是在一个或多个数据库表中定义的数据项或记录的结构，以及它们之间的关系。模式还可能包含用于检查数据项完整性的公式、关系、索引、函数或过程和视图。物理模式解释数据库在物理层面(文件)的设计方式，而逻辑模式描述不同数据项如何在一个或多个表中定义和互连。</p>
<p>业界使用的不同类型模式包括星型、雪花型和事实星座模式。模式中使用的不同类型键包括主键、次要/备用键、外键、复合键、代理键和候选键。</p>
<p>影响模式定义和使用的参数包括重叠保持、扩展重叠保持、规范化和最小性。</p>
<h3 id="62-数据模型和存储模型-22-c23">6.2. 数据模型和存储模型 [22*,
C2.3]</h3>
<p>数据模型指定数据存储中数据结构的逻辑方面，存储模型指定数据存储中数据结构的物理方面。在数据库中很难同时实现数据一致性和高可用性。</p>
<p>用于区分数据库的两种主要数据模型如下：</p>
<p>•
ACID(原子性、一致性、隔离性、持久性)模型提供高数据一致性。符合ACID的数据库提供高数据一致性。</p>
<p>•
运行时数据库管理器(RDM)：RDM在执行任何操作之前检查用户身份验证和权限，提供对基于上下文的数据库的访问，为多个用户提供对数据库的并发访问。</p>
<p>备份、检索、维护、克隆和删除数据等操作也负责通过补丁和更新维护DBMS。</p>
<p>数据库非常适合金融密集型应用，并确保数据完整性。</p>
<p>•
BASE（基本可用、软状态、最终一致性）模型提供了灵活的数据处理方法，适合NoSQL数据库类型。</p>
<p>存储模型类型包括以下几种：</p>
<p><strong>数据库语言：</strong>
这些语言帮助存储、检索、修改和获取数据，控制用户访问（权限），指定模式和视图，以及执行各种操作。流行的数据库语言包括数据定义语言(DDL)、数据库访问语言(DAL)、数据操作语言(DML)、事务控制语言(TCL)和数据控制语言(DCL)。</p>
<ol type="i">
<li><p>DAS（直接访问存储）：存储设备物理上或直接连接到处理数据的计算机。</p></li>
<li><p>NAS（网络访问存储）：数据存储在网络中，由多台计算机或应用程序访问。</p></li>
<li><p>SAN（存储区域网络）：数据存储在多个服务器中，通过计算机网络高效地提供给用户。</p></li>
</ol>
<p><strong>查询处理器：</strong>
这是DBMS的基本和关键组件，为用户提供有效、丰富且类似英语的界面来访问数据库并执行各种功能或操作。</p>
<p><strong>报告：</strong>
报告应用指定的过滤器，提取请求的数据和记录从一个或多个数据库表中，并按指定方式呈现信息。</p>
<h2 id="63-数据库管理系统-22-c13">6.3. 数据库管理系统 [22*, C1.3]</h2>
<p>数据库管理系统(DBMS)是提供必要工具的软件系统，用于优化维护数据、有效检索存储信息、保护和保障存储数据，以及管理不同权限级别用户的访问。</p>
<p>典型的DBMS包括：</p>
<p><strong>数据库引擎：</strong>
这是DBMS的核心。数据库引擎管理数据的高效存储和检索。有权限的用户可以访问数据库引擎。</p>
<p><strong>数据库管理器：</strong>
这个程序或程序集在数据库中执行所有DBMS功能（创建、清除、</p>
<p>目前有几个免费和开源的数据库管理系统可用。</p>
<h2 id="64-关系数据库管理系统和规范化-22-c4">6.4.
关系数据库管理系统和规范化 [22*, C4]</h2>
<p>传统的基于文件系统的数据库存在数据冗余、数据不一致、数据访问困难、未授权访问、缺乏并发访问等问题。</p>
<p>关系数据库管理系统(RDBMS)将数据存储在表中，与DBMS不同，其数据表彼此关联，可以同时访问多个数据项，处理大量数据，多个用户可以同时访问数据，数据冗余显著减少，并支持多级数据安全。</p>
<p><a href="#计算基础">计算基础</a> 16-19</p>
<p>计算机科学工程师必须理解各种类型RDBMS之间的区别，例如对象RDBMS、面向对象RDBMS，熟悉示例和案例研究，并理解如果数据库未规范化将面临的挑战。尽管规范化是必要的并提供各种好处，但它也会增加表的数量和处理时间。</p>
<p>数据库规范化是在数据库中组织数据的过程，从表中消除数据冗余和数据不一致。规范化可能会增加表的数量并增加查询时间。如果发生这种情况，那么根据应用程序和需求，会应用反规范化(de-normalization)，即添加数据冗余以实现更快的数据访问。</p>
<p>不同类型的数据库规范化如下：</p>
<ol type="i">
<li><p>第一范式(1
NF)：消除重复或冗余。每个表单元格都有一个单一值（创建更多条目和表）。每行都有唯一值。相关数据用唯一键标识。</p></li>
<li><p>第二范式(2 NF)：表应处于1
NF；没有部分依赖（创建单独的表，其中记录由多个记录或表引用）。</p></li>
<li><p>第三范式(3 NF)：表应处于2 NF。传递依赖被消除。</p></li>
<li><p>Boyce-Codd范式(BCNF/3.5 NF)：表应处于3
NF，对于任何(X-&gt;Y)，X应该是超键。</p></li>
<li><p>第四范式(4 NF)：表应处于3.5 NF，并且不应有多值依赖。</p></li>
<li><p>第五范式(5 NF)：表应处于4
NF，不能再拆分为任何更多表而不丢失数据。</p></li>
</ol>
<h2 id="65-结构化查询语言-22-c6-c7-c8">6.5. 结构化查询语言 [22*, C6, C7,
C8]</h2>
<p>结构化查询语言(SQL)是用于创建、更新和删除数据库以及从数据库中检索信息的标准和流行数据库语言。SQL是大多数数据库管理系统不可或缺的一部分。</p>
<p>典型的SQL语法有几个语言结构或元素，包括子句、表达式、谓词、查询和语句。</p>
<p>对数据库的所有操作，包括创建、更新、删除和查看表；执行不同的规范化；清除数据；以及基于各种参数或过滤器组合在数据库中搜索，都可以使用SQL执行。</p>
<p>大多数数据库都支持SQL（NoSQL数据库除外），不同数据库提供商支持的SQL语法和函数库各不相同（很像编程语言——尽管不同语言支持类似的功能，但语法各不相同）。</p>
<p>数据库工程师还必须决定是使用静态/嵌入式SQL、动态SQL还是两者的组合，在权衡每个选项对特定应用的利弊之后。他们还应该知道简单视图和复杂视图之间的区别，并适当使用它们。</p>
<p>SQL已标准化并被</p>
<h2 id="标准化范式">标准化范式</h2>
<h3 id="vii-第六范式或域键范式-6-nfdknf">vii. 第六范式或域/键范式 (6
NF/DKNF)</h3>
<p>表应处于第五范式，并且每个连接依赖都是平凡的。</p>
<p>美国国家标准协会 (ANSI) 和 ISO 会定期修订标准；第一个 SQL 标准是 1986
年发布的 SQL-86，最新的是 SQL:2019。</p>
<p>大多数数据库通常规范化到第三范式或 BCNF。另一种范式 DKNF
定义了避免插入和删除异常的情况（参见 [13]）。</p>
<p>鼓励数据库工程师理解规范化范式。</p>
<h3 id="66-数据挖掘和数据仓库">6.6. 数据挖掘和数据仓库</h3>
<p>[22*, C34]</p>
<p>数据库设计用于存储事务并高效检索它们。</p>
<p>数据仓库从多个数据库中高效提取数据并将其存储在公共数据库中，以便对编译后的数据有效执行数据挖掘。数据仓库通常是巨大的，因为它们存储历史数据记录。</p>
<p>数据挖掘从数据仓库中提取所需信息，应用各种过滤器和条件。数据挖掘将模式识别算法应用于大型数据集以生成所需的报告。</p>
<p>不同类型的仓库包括企业数据仓库 (EDW)、运营数据存储 (ODS) 和数据集市
(DM)。</p>
<p>有许多高效的工具可用于创建数据仓库并从中挖掘数据。数据库工程师必须了解不同的数据挖掘技术，包括关联、聚类、分类、序列模式和预测，并知道如何将它们应用于各种用途和行业，例如医疗保健、欺诈检测、客户关系管理、金融和银行业、异常检测、预测、神经网络、统计和数据可视化。</p>
<h3 id="67-数据库备份和恢复">6.7. 数据库备份和恢复</h3>
<p>[22*, C22]</p>
<p>数据库系统容易出现故障，数据可能会损坏。防止数据损坏以及在损坏发生时立即识别并恢复数据至关重要。</p>
<p>必须仔细更新事务的数据库（在特定检查点提交），并且必须结合诸如撤消、延迟更新、立即更新、缓存或缓冲以及影子分页等技术。</p>
<p>必须定期备份数据库以确保数据安全。备份技术包括完整数据库备份、差异备份和事务日志备份。</p>
<h2 id="7-计算机网络和通信">7. 计算机网络和通信</h2>
<p>[4*, C4.1], [24*, C1]</p>
<p>计算机网络是为共享信息而连接的一组设备。连接的设备（网络上的节点）可以彼此靠近、在同一场所或其他地方。网络是某些好处所必需的，包括某些通信和信息共享模式；共享打印机、路由器和摄像头等设备的能力；全球信息和数据存储；安全和策略执行；远程监控；共享业务模型；以及网页浏览。</p>
<p>由于我们处于互联网时代，计算机网络是计算中的关键要素，计算机科学工程的从业者必须学习计算机网络和通信概念，包括示例和案例研究。许多计算范式（分布式计算、网格计算、云计算等）都基于网络原理。</p>
<p>软件工程师必须了解以下内容：</p>
<p>• 不同类型的计算机网络 • 网络的分层架构 • 开放系统互连 (OSI) 层 •
封装和解封装 • 应用层协议 • 可靠高效网络的设计技术 • 互联网和数据包传递
• 无线和移动网络 • 安全性和漏洞</p>
<h3 id="71-计算机网络的类型">7.1. 计算机网络的类型</h3>
<p>[4*, C4.1], [24*, C1.2.1]</p>
<p>根据需要设计和使用不同类型的计算机网络，例如以下类型：</p>
<ol type="1">
<li>个人区域网络 (PAN) / 家庭网络</li>
<li>局域网 (LAN)</li>
<li>无线局域网 (WLAN)</li>
<li>广域网 (WAN)</li>
<li>校园网 (CAN)</li>
<li>城域网 (MAN)</li>
<li>存储区域网络 (SAN)</li>
<li>系统区域网络 (SAN)</li>
<li>企业专用网络 (EPN)</li>
<li>虚拟专用网络 (VPN)</li>
</ol>
<p>了解上述每种网络类型以及示例、优点、局限性和规避挑战的可用解决方案非常重要。</p>
<h3 id="72-网络的分层架构">7.2. 网络的分层架构</h3>
<p>[24*, C1.5]</p>
<p>通信系统包括硬件和软件，这些组件已变得复杂以满足复杂的使用场景和用户需求。为了支持此类系统的实施和维护，ISO
开发了一种分层方法，其中每一层都有特定的功能。</p>
<figure>
<img alt="图16.4. 分层网络的图示表示" src="media/image-placeholder.png"/>
<figcaption aria-hidden="true">图16.4. 分层网络的图示表示</figcaption>
</figure>
<p><strong>• 服务：</strong> 层向相邻的更高层提供的一组操作是服务。</p>
<p><strong>• 协议：</strong>
层用于与对等实体交换信息的一组规则称为协议。这些规则主要用于管理所用消息的内容和顺序。</p>
<p><strong>• 接口：</strong>
接口提供了将消息从一层传输到另一层的媒介。</p>
<p>软件工程师应该了解所需的基本功能，以及数据或信息从一层传送到另一层的各种模式。</p>
<p>处理数据并将其从一个节点传输到另一个节点，以及在对等层之间进行数据包的形成和解释。一个有用的练习是分析不同协议的示例。</p>
<p>每一层在功能上都是独立的，并从下层向上层提供服务，而不提供每层服务如何实现的细节。一台机器上的每一层（“n”）与对等机器上的相同层（“n”）进行通信。对话中使用的规则称为<strong>层-n
协议</strong>（见图16.4）。分层方法的基本要素是服务、协议和接口。</p>
<p>OSI
提出了七（7）层，每一层都被分配了特定的任务。每一层独立处理从上层或下层接收到的数据，并根据需要将其传递给下层或上层。</p>
<p>工程师必须理解每个 OSI
层、其功能协议、每一层在每个方向上的输入和输出（从下层到上层，反之亦然）。工程师应该分析是否所有协议都需要全部七层，以及为了优化性能需要什么。</p>
<ol type="1">
<li>物理层（第1层）</li>
<li>数据链路层（第2层）</li>
<li>网络层（第3层）</li>
<li>传输层（第4层）</li>
<li>会话层（第5层）</li>
<li>表示层（第6层）</li>
<li>应用层（第7层）</li>
</ol>
<p>工程师必须理解每一层的细微差别，并提供示例。</p>
<h2 id="73-开放系统互连模型-24-c15">7.3. 开放系统互连模型 [24*, C1.5]</h2>
<p>开放系统互连（OSI）模型由 ISO
定义。它作为通过物理介质在两个系统或计算机上的应用程序之间交换信息的参考模型。</p>
<h2 id="74-封装与解封装-24-c152">7.4. 封装与解封装 [24*, C1.5.2]</h2>
<p>每一层在将数据从上层发送到下层时，会在从上层接收到的数据包的开头（头部）插入附加信息，并可选地在末尾插入信息，将从上层接收到的数据包视为数据。这就是封装。协议数据单元（PDU）是包含来自所有层的附加信息的数据包，被发送到接收系统。在接收端，每一层从
PDU 中提取其头部，解读信息以适当处理数据，并将剩余的 PDU
发送到上层。</p>
<p>了解跨层优化(cross-layer
optimization)、它必须遵循的原则及其应用非常重要。工程师应该分析
OSI、互联网协议套件和异步传输模式（ATM）各层的 PDU 结构。</p>
<h2 id="75-应用层协议-24-c2">7.5. 应用层协议 [24*, C2]</h2>
<p>应用层作为最顶层，提供服务和接口以与用户的应用程序交互。OSI
模型中有两种类型的应用层：公共应用服务元素（CASE）和特定应用服务元素（SASE）。示例应用包括文件传输（FTP、TFTP、NFS）、远程登录（Telnet、Zoho
Assist、Anydesk、TeamViewer
等）、电子邮件（SMTP）、网络支持（DNS）、网络管理（SNMP、DHCP）、设备（LPD）等。</p>
<p>从事网络领域的软件工程师需要理解 CASE 和 SASE
应用服务，包括每个类别中的示例应用。</p>
<h2 id="76-可靠和高效网络的设计技术-24-c15">7.6. 可靠和高效网络的设计技术
[24*, C1.5]</h2>
<p>当今基于信息技术的业务需要全天候、可靠、高效和可扩展的网络以及高速互联网可用性。为了满足不同的业务需求，网络及其管理也变得复杂。</p>
<p>识别网络需求（包括业务目标和技术解决方案）以及路线图（可扩展性）至关重要。基本设计目标应包括可靠性、安全性、可用性和可管理性。工程师应该预期多个层面的威胁和入侵，并在多个层面设计安全性。必须建立系统来监控网络的正常运行和故障，快速识别故障、漏洞和黑客攻击，并修复它们。</p>
<p>工程师必须理解和学习网络设计的细微差别，同时使用适当的防火墙、LAN/VLAN、子网、服务质量（QoS）、非军事区（DMZ）、生成树（特别是对于分层网络）、端口或网络接口控制器（NIC）通道、安全性（包括轮询安全和物理安全）、无线接入点和无线接入控制器。</p>
<p>即使设计和实施经过精心规划和执行，也必须对攻击保持警惕，并不断升级到更好的系统、设备和工具。</p>
<h2 id="77-互联网协议套件-24-c3">7.7. 互联网协议套件 [24*, C3]</h2>
<p>数据以数据包的形式从一台计算机传输到另一台计算机，无论是在同一网络中还是在不同网络中。互联网协议套件或
TCP/IP 定义了通过互联网连接的两台计算机之间的数据通信。OSI
模型的顶部三层（应用层、表示层和会话层）合并到应用层，网络层专门针对互联网功能进行了修订。</p>
<p>设备包括双栈路由器、隧道和 NAT 协议转换器。</p>
<p>专业的计算机网络架构师和程序员需要理解 IPV6 寻址、路由、从 IPV4
过渡到 IPV6、双地址栈、隧道和 NAT64。</p>
<h2 id="78-无线和移动网络-24-c7">7.8. 无线和移动网络 [24*, C7]</h2>
<p>无线网络为设备提供了无需电线和电缆连接和通信的能力。它们还提供了使用设备的灵活性和便利性。不同的无线技术用于不同的应用：</p>
<p>协议是当今互联网或网络层的支点。</p>
<p>互联网协议的多种变体针对不同目的而设计和使用。这些协议包括
TCP/IP（传输控制协议/互联网协议）、UDP/IP（用户数据报协议/互联网协议）、SMTP（简单邮件传输协议）、PPP（点对点协议）、FTP（文件传输协议）、SFTP（安全FTP）、HTTP（超文本传输协议）、HTTPS（HTTP安全协议）、Telnet（终端网络）、PoP3（邮局协议3）、VOIP（网络语音协议）、SLIP（串行线路互联网协议）。了解这些协议之间的差异以及用例（每种类型使用的应用程序或其最佳工作场景）非常重要。</p>
<p>移动互联网协议是一种符合 IETF（互联网工程任务组(Internet Engineering
Task Force)）标准的通信协议，允许用户在不更改 IP
地址的情况下将其移动设备（笔记本电脑、手机等）从一个网络无缝移动到另一个网络。</p>
<p>互联网协议版本4（IPV4）使用32位 IP 地址，而 IPV6 使用128位 IP
地址。</p>
<p>私有 IP 地址使用 NAT（网络地址转换(network address translation)）或
PAT（端口地址转换(port address translation)）转换为公共 IP
地址。两者都使用 IPV4，但 PAT 使用端口号。不同的技术用于 IPV4 和 IPV6
之间的通信。</p>
<h2 id="无线网络类型">无线网络类型</h2>
<ul>
<li>无线个人局域网（WPAN）</li>
<li>无线局域网（WLAN）</li>
<li>无线广域网（WWAN）</li>
</ul>
<p>移动或蜂窝网络是分布在特定陆地区域（称为蜂窝小区(cell)）的无线电网络。小区由基站提供服务，基站是固定位置的收发器。</p>
<p>为避免干扰并确保保证带宽，相邻小区使用不同的频率集。这些小区连接后，提供广域无线电覆盖。小区模式采用不同的形状，但正方形、圆形和六边形是典型形状。</p>
<p>信道之间使用不同的数据传输方法，如频分多址（FDMA）、时分多址（TDMA）、码分多址（CDMA）、空分多址（SDMA）等。</p>
<p>无线技术已经历多代演进。鼓励软件工程师学习 1G、2G、3G、4G 和 5G
技术之间的差异，以及每种技术使用的核心网络、接入系统、频率、带宽和技术。</p>
<h2 id="79-安全和漏洞-24-c9">7.9. 安全和漏洞 [24*, C9]</h2>
<p>尽管无线技术提供了无缝连接到网络的便利性，但除非网络得到保护，否则也容易受到攻击。未受保护的无线网络面临的风险包括搭便车(Piggybacking)、战争驾驶(Wardriving)、邪恶双胞胎攻击(Evil
Twins attacks)、无线嗅探(Wireless
sniffing)、未经授权的计算机访问、肩窥(Shoulder
sniffing)和移动设备盗窃。</p>
<p>通过移动设备进行的互联网通信极易受到网络攻击。除了上述提到的战争驾驶，典型的无线和移动设备攻击还包括
SMiShing、WEP 攻击、WPA 攻击、蓝牙劫持(Bluejacking)、重放攻击(Reply
attacks)、蓝牙窃听(Blue snarfing)、射频干扰(RF Jamming)等。</p>
<p>必须实施并严格遵守许多预防措施来降低此类风险。这些措施包括更改默认密码、频繁更改密码、限制授权用户访问、加密系统和网络上的数据，以及安装多层防火墙。此外，用户必须保护和隐藏（不公开）服务集标识符（SSID），使用有效的防病毒软件并定期更新和升级；使用虚拟专用网络（VPN），谨慎使用文件共享或系统共享访问，使用后禁用访问；并在安全补丁可用时更新或升级接入点或接入控制器、网关和其他设备。</p>
<h1 id="8-用户和开发者人因">8. 用户和开发者人因</h1>
<p>软件开发者的思维过程和行为通常与软件用户不同。本内容领域识别了对最终用户重要的关键参数以及开发者的视角。</p>
<p>人机界面（HCI）专注于设计和开发计算机技术，供用户与之交互。</p>
<h2 id="81-用户界面设计">8.1. 用户界面设计</h2>
<p>用户界面应该直观；通过最少、智能、易于遵循的步骤引导用户实现最终结果；要安全；并提供快速、一致的响应。</p>
<p>界面应帮助用户轻松使用系统。界面应该是自解释的并支持自学习。消息，无论是传达结果还是错误，都应该清晰完整。如果出现错误，系统应该能够恢复到其原始状态。</p>
<p>系统应允许用户在处理过程中中断并在可能的情况下撤消操作。</p>
<p>软件工程师需要识别系统用户的配置文件；系统的功能、用户用于与系统交互的输入和输出接口（键盘、触摸板、音频、视频等）、系统的容错性、系统的性能参数等。</p>
<p>通常，用户界面开发会经历多次迭代，从原型开始。用户界面设备必须是健壮的。</p>
<h2 id="82-开发者人因-3-c31-c32">8.2. 开发者人因 [3*, C31 - C32]</h2>
<p>软件的生命周期远长于开发所需的时间。维护代码的软件工程师通常与开发人员不同。因此，代码必须更加谨慎地编写，供其他程序员/软件工程师使用。</p>
<p>在软件生命周期的所有阶段，有意义且全面的文档至关重要。</p>
<p>为项目定义和采用合适的编码标准，并确保每个团队成员切实执行，这是关键。</p>
<h1 id="计算系统">计算系统</h1>
<p>用户满意度通过用户体验(UX)来衡量。理想的界面应该促进交互，使其像两个人之间的交互一样自然。</p>
<p><strong>8.1. 用户人因(User Human Factors)</strong> [3*, C8]</p>
<p>用户期望软件具有鲁棒性；拥有直观的图形用户界面(GUI)</p>
<p><a href="#计算基础">计算基础</a> 16-25</p>
<p>用于开发能够长久存在的整洁代码，只需最少的维护。</p>
<p>编程风格是优秀代码的另一个关键要素。代码必须清晰可读，应该像阅读一首好诗一样，易于理解。使用有意义、一致和详细的注释对于确保代码可读性至关重要。</p>
<p>优秀软件程序员的其他特质包括：是团队合作者、喜欢创造性地解决难题、敏捷、结构化/模块化等等。</p>
<p>良好的编码标准包括为各种类型的变量、函数/过程定义命名约定，注释结构/风格，缩进风格，将代码结构化为段落(相关函数的集合)等。</p>
<p><em>“代码被阅读的次数远多于被编写的次数。考虑一下编写时的便利性是否是一种虚假经济”——Steve
McConnell</em></p>
<p><em>“整洁的代码总是看起来像是由一个用心的人编写的”——Robert (Uncle
Bob) Martin</em></p>
<p><strong>9. 人工智能与机器学习 [17*]</strong></p>
<p><em>智能</em>是获取和关联信息与知识以便为特定任务做出正确决策的能力。<em>人工智能(AI)</em>使计算机系统能够像人类一样变得智能。<em>机器学习(ML)</em>使计算机系统能够从经验中学习，并使用获得的知识做出明智的决策——成为人工智能。深度学习使用人工神经网络模型进行学习和预测。</p>
<p>每个人都期望他们使用的所有系统是智能的、可靠的、一致的、安全的和容错的——并且每天都在变得更好。AI和ML致力于使系统实现所有这些目标。</p>
<p>理想的AI系统应该是人类无法识别它是计算机的系统；人类无法将计算机与人类区分开来。</p>
<p>已经开发了多种工具可用于创建AI系统。使用经过验证的工具帮助工程师更快地构建稳定的系统。</p>
<p><strong>9.1. 推理</strong></p>
<p><em>推理</em>意味着分析给定情况的可用信息集，并确定情况的原因。得出这个结论是AI的一项重要能力，因为结论会告知AI关于下一步做什么的决策。</p>
<p>AI中使用的不同类型的推理包括以下内容：</p>
<p><strong>演绎推理(Deductive
Reasoning)</strong>是一种标准和策略性的方法，用于映射可用的事实、信息和知识以得出结论。在这种方法中，可用的事实和信息被认为是真实的。例如，如果前提是”所有女孩都很漂亮”和”Michu是女孩”，那么结论是”Michu很漂亮”。</p>
<p><strong>归纳推理(Inductive
Reasoning)</strong>是引入假设并从可用的事实和前提创建概括。与演绎推理不同，在归纳推理中，即使前提是确定的，结论也是<em>可能的</em>，这取决于归纳论证是强还是弱。例如，检查在一个项目上工作的所有工程师的位置，如果他们都来自印度班加罗尔，则声明”所有在游戏项目上工作的员工都来自班加罗尔”。</p>
<p><strong>溯因推理(Abductive
Reasoning)</strong>从不完整的数据或信息集开始，并继续从最新数据中得出最可能的结论。例如，医生分析患者的最新实验室报告来预测疾病的进程。</p>
<p><strong>常识推理(Common Sense
Reasoning)</strong>基于类似的过去经验对情况进行推断。例如，如果摩托车在湿路上行驶时打滑，该信息会被记住并在未来骑行时被考虑。</p>
<p><strong>单调推理(Monotonic
Reasoning)</strong>发生在结论在得出后保持永久或恒定时。例如，“喜马拉雅山脉是最高的山脉之一”。</p>
<p><strong>非单调推理(Non-Monotonic Reasoning,
NMR)</strong>发生在推断基于新知识或信息改变值或方向时。NMR基于假设并处理不完整或未知的事实。例如，规则是”鸟会飞”。但少数鸟不会飞，包括企鹅。</p>
<p>鼓励软件工程师学习其他推理方法，如元级推理、过程数值推理和形式推理等。</p>
<p><strong>9.2. 学习</strong></p>
<p>我们从观察、实验和经验中学习。使计算机能够学习并记住它们所学的内容以供将来使用，对于构建AI系统至关重要。当观察和实验结果(信号)被反馈到系统时，AI系统就会学习。不同类型的学习包括以下内容：</p>
<p>学习。这是一种试错法的学习方法。</p>
<p>从事AI工作的软件工程师预计还要了解各种其他学习技术，包括降维学习、自学习、特征学习、稀疏学习、异常检测和机器人学习，以及各方法之间的关键差异和每种方法有效应用的场景。</p>
<p><strong>9.3. 模型</strong></p>
<p>AI模型是推理引擎或工具(算法)，可以根据相关数据得出最佳决策。</p>
<p>创建不同的模型以实现高效的ML，无论是否有训练数据。ML中使用的模型包括以下内容：</p>
<p>16-26 [<em>SWEBOK</em>][<em>®</em>][指南 V4.0a]</p>
<p><strong>监督学习（Supervised
Learning）</strong>，计算机系统通过接收标记数据（即训练数据）进行训练。<strong>线性回归（Linear
Regression）</strong>模型基于监督学习，其中确定输入和输出变量之间的关系并使用。随后，当提供任何输入时，系统将其与训练过的数据进行比较并生成输出。自然地，训练数据越多，结果越好。监督学习使用多种学习技术，包括分类技术和回归技术。监督学习可能无法处理复杂任务。该模型通常用于医疗保健和银行应用。</p>
<p><strong>逻辑回归（Logistic
Regression）</strong>模型是一种统计模型，主要用于从给定的自变量中对因变量进行分类。</p>
<p><strong>无监督学习（Unsupervised
Learning）</strong>，不向系统提供标记数据或训练数据。系统必须从给定的输入中找出共同模式并进行推断。数据是实时分析的。</p>
<p><strong>人工神经网络（Artificial Neural
Networks）</strong>受大脑中生物神经网络的启发。这些系统被设计为自然地从输入中学习，而无需特定规则。</p>
<p><strong>决策树（Decision
Tree）</strong>模型用于使用过去的决策来做出决策。之所以使用”树”这个名称，是因为数据以树的形式存储。</p>
<p><strong>半监督学习（Semi-supervised
Learning）</strong>，系统使用部分标记和部分未标记的数据进行训练。这种类型的学习已被证明是有效的。</p>
<p><strong>朴素贝叶斯（Naïve
Bayes）</strong>模型基于一个假设，即一个特征的存在不依赖于任何其他特征的存在。垃圾邮件过滤是适合该模型的应用之一。</p>
<p><strong>强化学习（Reinforcement
Learning）</strong>基于与环境的交互。在这种类型的学习中，系统接收反馈（错误消息或奖励）并从该反馈中学习。不向系统提供数据（既不标记也不未标记）。在强化学习中会产生各种算法。</p>
<p><strong>支持向量机（Support Vector Machine,
SVM）</strong>是一种监督机器学习算法，用于分析有限的数据量。SVM通常比人工神经网络更快，因为它处理有限的数据。</p>
<p><strong>随机森林（Random
Forest）</strong>模型使用多个决策树来做出最终决策。随机森林模型对于解决回归和分类问题都很有用。</p>
<p>AI模型是做出最恰当决策的关键。由于不同的模型适合特定的应用或领域，鼓励软件工程师学习许多其他AI模型，例如线性判别分析、学习向量量化、K最近邻（KNN）等。</p>
<p><strong>9.4. 感知和问题解决</strong></p>
<p>高效快速地解决问题是AI的目标。问题解决主要包括理解用户命令并执行它们，就像人类所做的那样。根据应用和要解决的问题，AI系统使用相关的知识库和谓词逻辑来确定最合适的解决方案。</p>
<p>处理外部世界的AI系统通过传感器（摄像头、麦克风、温度传感器、压力传感器和光传感器等）获取环境数据，使用其知识库或推理引擎分析数据，并据此采取行动。</p>
<p>根据功能和能力，AI系统分为多种类型。</p>
<p>I型AI系统被设计为智能地执行特定任务。例如国际象棋游戏、语音和图像识别等。</p>
<p>II型AI系统分析当前情况或环境，通常不参考在类似情况下做出的先前决策来采取适当的行动。反应式系统或反应式机器通常在那一刻做出决策并执行命令，参考现有的知识库。一个很好的例子是自动驾驶汽车。</p>
<p>III型或自我意识AI系统能够识别一个人的行为或行为类型。例如，如果系统后面车辆中的驾驶员按喇叭，那么AI系统可能会得出结论，该驾驶员生气或不高兴。社会和道德行为是有意识系统的一部分。</p>
<p><strong>9.5. 自然语言处理</strong></p>
<p>自然语言处理（Natural Language Processing,
NLP）是AI系统的关键部分，使用户能够以类似于他们与其他人交互的方式与AI系统交互。AI系统理解人类语言并执行以这些语言传递的命令。基于语音命令工作的AI系统不仅需要理解人类语言，还需要理解用户的俚语或发音。</p>
<p><strong>9.6. AI与软件工程</strong></p>
<p>软件工程和AI基本上以两种方式相互关联：AI在软件工程中的应用（即AI for
SE）和AI系统的软件工程（即SE for AI）。</p>
<p>AI for
SE旨在通过复制人类开发人员的行为来建立构建高质量软件系统的有效方法。它几乎涵盖所有开发阶段，从解决模糊需求到预测可维护性（maintainability），特别是在软件质量保证和分析方面应用良好，例如缺陷预测、测试用例生成、漏洞分析和过程评估[15]。尽管以人为中心的软件工程活动受益，工程师应该意识到AI和机器学习本质固有的局限性和挑战，特别是不确定和随机行为以及需要足够标记和结构化数据集的必要性[15]。</p>
<p>AI系统的开发与传统软件系统不同，因为AI系统的规则和系统行为是从训练数据中推断出来的，而不是作为程序代码编写的[16]。因此，存在</p>
<h2 id="意识和觉知">意识和觉知</h2>
<p>这些系统[需要对AI软件工程的特殊支持，例如]采用心智理论并根据对方或实体的情绪预测其心态[数据科学家和软件工程师的跨学科协作团队、软件演进（关注大型且不断变化的数据集）以及伦理和公平性需求工程][16]。推荐的软件工程实践通常被形式化为模式，例如机器学习软件设计模式][17]。</p>
<h2 id="主题与参考资料对照矩阵-2">主题与参考资料对照矩阵</h2>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<thead>
<tr>
<th><strong>主题</strong></th>
<th>参考资料</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 系统或解决方案的基本概念</strong></td>
<td>C10</td>
</tr>
<tr>
<td><strong>2. 计算机体系结构与组成</strong></td>
<td></td>
</tr>
<tr>
<td><em>2.1 计算机体系结构</em></td>
<td>C1.1</td>
</tr>
<tr>
<td><em>2.2 计算机体系结构类型</em></td>
<td>C4.14, C5</td>
</tr>
<tr>
<td><em>2.2.1 冯·诺依曼体系结构</em></td>
<td>C1.9</td>
</tr>
<tr>
<td><em>2.2.2 哈佛体系结构</em></td>
<td>[20]</td>
</tr>
<tr>
<td><em>2.2.3 指令集体系结构</em></td>
<td>C4.8.3</td>
</tr>
<tr>
<td><em>2.2.4 弗林分类法或弗林体系结构</em></td>
<td>C9.3</td>
</tr>
<tr>
<td><em>2.2.5 系统体系结构</em></td>
<td>C6, C6</td>
</tr>
<tr>
<td><em>2.3 微体系结构或计算机组成</em></td>
<td>C4</td>
</tr>
<tr>
<td><em>2.3.1 算术逻辑单元</em></td>
<td>C1.2</td>
</tr>
<tr>
<td><em>2.3.2 存储单元</em></td>
<td>C6</td>
</tr>
<tr>
<td><em>2.3.3 输入/输出单元</em></td>
<td>C7</td>
</tr>
<tr>
<td><em>2.3.4 控制单元</em></td>
<td>C4.2</td>
</tr>
<tr>
<td><strong>3. 数据结构和算法</strong></td>
<td>c10, Part V, C2</td>
</tr>
<tr>
<td><em>3.1 数据结构类型</em></td>
<td>c10, S2.1-2.6</td>
</tr>
<tr>
<td><em>3.2 数据结构操作</em></td>
<td>S2.1-2.6</td>
</tr>
<tr>
<td><em>3.3 算法和算法属性</em></td>
<td>c26, c27</td>
</tr>
<tr>
<td><em>3.4 算法复杂度</em></td>
<td>s1.1–1.3, s3.3–3.6, s4.1–4.8, s5.1–5.7, s6.1–6.3, 7.6, s11.1,
s12.1</td>
</tr>
<tr>
<td><em>3.5 复杂度度量</em></td>
<td>s1.1–s3.3–3.6, s4.1–4.8, s5.1–5.7, s6.1–6.3, s7.1–7.6, s11.1,
s12.1</td>
</tr>
<tr>
<td><em>3.6 算法设计</em></td>
<td>Part IV, Part VII</td>
</tr>
<tr>
<td><em>3.7 排序技术</em></td>
<td>c6, c7, c8, c9</td>
</tr>
<tr>
<td><em>3.8 搜索技术</em></td>
<td>C6</td>
</tr>
<tr>
<td><em>3.9 散列</em></td>
<td>c11.2</td>
</tr>
<tr>
<td><strong>4. 编程基础与语言</strong></td>
<td>C6</td>
</tr>
<tr>
<td><em>4.1 编程语言类型</em></td>
<td>C8.4.4</td>
</tr>
<tr>
<td><em>4.2 编程语法、语义、类型系统</em></td>
<td>C8.4.4</td>
</tr>
<tr>
<td><em>4.3 子程序和协程</em></td>
<td>C6.3</td>
</tr>
<tr>
<td><em>4.4 面向对象编程</em></td>
<td>C6.5</td>
</tr>
<tr>
<td><em>4.5 分布式编程和并行编程</em></td>
<td>C6.6</td>
</tr>
<tr>
<td><em>4.6 调试</em></td>
<td>C2.2.2</td>
</tr>
<tr>
<td><em>4.7 标准和指南</em></td>
<td>C28.5, C31.5</td>
</tr>
<tr>
<td><strong>5. 操作系统</strong></td>
<td></td>
</tr>
<tr>
<td><em>5.1 处理器管理</em></td>
<td>c2, c8</td>
</tr>
<tr>
<td><em>5.2 内存管理</em></td>
<td>c3</td>
</tr>
<tr>
<td><em>5.3 设备管理</em></td>
<td>c5</td>
</tr>
<tr>
<td><em>5.4 信息管理</em></td>
<td>c4</td>
</tr>
<tr>
<td><em>5.5 网络管理</em></td>
<td>C4.1</td>
</tr>
<tr>
<td><strong>6. 数据库管理</strong></td>
<td></td>
</tr>
<tr>
<td><em>6.1 模式</em></td>
<td>C2.1.4</td>
</tr>
<tr>
<td><em>6.2 数据模型和存储模型</em></td>
<td>C2.3</td>
</tr>
<tr>
<td><em>6.3 数据库管理系统</em></td>
<td>C1.3</td>
</tr>
<tr>
<td><em>6.4 关系数据库管理系统和规范化</em></td>
<td>C4</td>
</tr>
<tr>
<td><em>6.5 结构化查询语言</em></td>
<td>C6, C7, C8</td>
</tr>
<tr>
<td><em>6.6 数据挖掘和数据仓库</em></td>
<td>C34</td>
</tr>
<tr>
<td><em>6.7 数据库备份与恢复</em></td>
<td>C22</td>
</tr>
<tr>
<td><strong>7. 计算机网络与通信</strong></td>
<td>C4.1, C1</td>
</tr>
<tr>
<td><em>7.1 计算机网络类型</em></td>
<td>C4.1, C1.2.1</td>
</tr>
<tr>
<td><em>7.2 网络分层体系结构</em></td>
<td>C1.5</td>
</tr>
<tr>
<td><em>7.3 开放系统互连模型</em></td>
<td>C1.5</td>
</tr>
<tr>
<td><em>7.4 封装与解封装</em></td>
<td>C1.5.2</td>
</tr>
<tr>
<td><em>7.5 应用层协议</em></td>
<td>C2</td>
</tr>
<tr>
<td><em>7.6 可靠高效网络的设计技术</em></td>
<td>C1.5</td>
</tr>
<tr>
<td><em>7.7 互联网协议套件</em></td>
<td>C3</td>
</tr>
<tr>
<td><em>7.8 无线和移动网络</em></td>
<td>C7</td>
</tr>
<tr>
<td><em>7.9 安全性和漏洞</em></td>
<td>C8</td>
</tr>
<tr>
<td><strong>8. 用户和开发者人因</strong></td>
<td></td>
</tr>
<tr>
<td><em>8.1 用户人因</em></td>
<td>c8</td>
</tr>
<tr>
<td><em>8.2 开发者人因</em></td>
<td>c31-c32</td>
</tr>
<tr>
<td><strong>9. 人工智能和机器学习</strong></td>
<td>C1</td>
</tr>
<tr>
<td><em>9.1 推理</em></td>
<td></td>
</tr>
<tr>
<td><em>9.2 学习</em></td>
<td></td>
</tr>
<tr>
<td><em>9.3 模型</em></td>
<td></td>
</tr>
<tr>
<td><em>9.4 感知和问题解决</em></td>
<td></td>
</tr>
<tr>
<td><em>9.5 自然语言处理</em></td>
<td></td>
</tr>
<tr>
<td><em>9.6 人工智能与软件工程</em></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="参考文献-12">参考文献</h2>
<p>[1] Joint Task Force on Computing Curricula, IEEE Computer Society
and Association for Computing Machinery, Software Engineering 2014:
Curriculum Guidelines for Undergraduate Degree Programs in Software
Engineering</p>
<p>[13] R. Fagin, “A Normal Form for Relational Databases that is based
on Domains and Keys,” <em>ACM Transactions on Database Systems, Vol. 6,
No. 3</em>, ACM, September 1981</p>
<p>[14] I. Goodfellow, Y. Bengio, A. Courville, <em>Deep Learning
(Adaptive Computation and Machine Learning</em></p>
<p>2014; <a href="http://sites.computer.org/ccse/SE2004Volume.pdf">http://sites.computer.org/ccse/</a>
<em>系列)</em> 图解版，2018年。</p>
<p><a href="http://sites.computer.org/ccse/SE2004Volume.pdf">SE2004Volume.pdf.</a></p>
<p>[15] S. Shafiq, A. Mashkoor, C. Mayr-</p>
<p>[2*] G. Voland，《工程设计》，第2版，Prentice Hall，2003年。Dorn, A.
Egyed，“在软件开发生命周期中使用机器学习的文献综述”，《IEEE
Access》，第9卷，IEEE，2021年10月。</p>
<p>[3*] S. McConnell，《代码大全》，第2版，Microsoft Press，2004年。</p>
<p>[4*] J.G.
Brookshear，《计算机科学：概览》，第12版，Addison-Wesley，2017年。</p>
<p>[16] S. Martínez-Fernández, J. Bogner, X. Franch, M. Oriol, J.
Siebert, A. Trendowicz, A. M.
Vollmer，“基于人工智能系统的软件工程：一项调查”，《ACM软件工程与方法学汇刊》，第31卷，第2期，ACM，2022年4月。</p>
<p>[5*] E. Horowitz 等，《计算机算法》，第2版，Silicon
Press，2007年。</p>
<p>[6*] I.
Sommerville，《软件工程》，第10版，Addison-Wesley，2016年。</p>
<p>[17] H. Washizaki, F. Khomh, Y. G. Gueheneuc, H. Takeuchi, N. Natori,
T. Doi, S.
Okuda，“机器学习应用的软件设计模式”，《Computer》，第55卷，第3期，IEEE计算机学会，2022年3月。</p>
<p>[7] ISO/IEC/IEEE，“ISO/IEC/IEEE 24765:2017
系统与软件工程——词汇表”，第2版，2017年。</p>
<p>[8*] L. Null 和 J. Lobur，《计算机组织与架构基础》，第5版，Jones and
Bartlett Publishers，2018年。</p>
<p>[18] Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, Clifford
Stein，《算法导论》，第四版，2022年。</p>
<p>[9*] J. Nielsen，《可用性工程》，Morgan Kaufmann，1994年。</p>
<p>[19] Andrew W Tanenbaum, Herbert
Bos，《现代操作系统》，第4版，2016年。</p>
<p>[10] ISO 9241-420:2011《人机交互的人体工程学》，ISO，2011年。</p>
<p>[20] <a href="https://ieeexplore.ieee.org/document/9779481">https://ieeexplore.ieee.org/document/9779481</a></p>
<p>[11*] M.
Bishop，《计算机安全：艺术与科学》，第2版，Addison-Wesley，2018年。</p>
<p>[21] Neal Ford, Mark Richards, Pramod Sadalage 和 Zhamak
Dehgh，《软件架构：困难的部分》，O Reilly，第一版——2021年</p>
<p>[12] R.C. Seacord，《CERT C安全编码标准》，Addison-Wesley
Professional，2016年。</p>
<p><a href="#计算基础">计算基础</a> 16-33</p>
<p>[22] Thomas Connolly, Carolyn
Begg，《数据库系统——设计、实现与管理的实用方法》，第6版——Pearson</p>
<p>[23] Michael J.
Hernandez，《普通人的数据库设计》，第4版，Addison-Wesley</p>
<p>[24] James F Kurose, Keith W
Ross，《计算机网络——自顶向下方法》，第7版，Pearson</p>
<h1 id="第17章-1">第17章</h1>
<h1 id="数学基础-1">数学基础</h1>
<p><strong>缩略语</strong></p>
<p>[CFG] 上下文无关文法(Context-Free Grammar)</p>
<p>[BST] 二叉搜索树(Binary Search Tree)</p>
<p>[FSM] 有限状态机(Finite-State Machine)</p>
<p>[CSG] 上下文相关文法(Context-Sensitive Grammar)</p>
<p>[IH] 归纳假设(Induction Hypothesis)</p>
<p>[GCD] 最大公约数(Greatest Common Divisor)</p>
<p>[LHS] 左侧(Left-Hand Side)</p>
<p>[PSG] 短语结构文法(Phrase Structure Grammar)</p>
<p>[RHS] 右侧(Right-Hand Side)</p>
<p><strong>引言</strong></p>
<p>数学基础知识领域(KA)涵盖了识别复杂、多样化应用领域规则集的基本技术。</p>
<p>软件工程师只能为遵循明确理解、无歧义逻辑的内容编写代码。数学基础知识领域帮助软件工程师理解这种逻辑，并将其转化为源代码。这个知识领域中的数学与典型的算术有很大不同，后者处理的是数字。本知识领域关注逻辑和推理，这是软件工程师必须处理的数学的本质。</p>
<p>从某种意义上说，数学是对形式系统的研究。形式(formal)一词与精确性相关，因此对事实不能有歧义或错误的解释。因此，数学是研究关于任何概念的所有确定真理。这个概念可以是关于数字、符号、图像、声音或视频的——几乎任何东西。简而言之，数字和数字方程式并不是唯一的研究对象。软件工程师必须对精确性有准确的抽象。相反，软件工程师必须对复杂、多样化的应用领域有精确的抽象。</p>
<p>学习。在所研究系统的上下文中，遵循这些规则可以推导出的任何内容都是绝对确定的，并且在该系统的上下文中讨论了能够代表和推进软件工程师推理的技术。</p>
<p>本知识领域定义并讨论了能够以精确(因此是数学)方式表示和推进软件工程师推理和判断的技术。所讨论的逻辑语言和方法允许软件工程师描述数学证明，以确定地推断某些概念的绝对真实性，而不仅仅是数字。本知识领域的目标是帮助软件工程师培养识别和描述这种逻辑的能力，并验证代码中的逻辑与抽象一致。重点是帮助软件工程师理解基本概念，而不是发展他们的算术能力。</p>
<p><strong>数学基础的主题分解</strong></p>
<p>数学基础知识领域的主题分解如图17.1所示。</p>
<h2 id="1-基本逻辑-1-c1">1. 基本逻辑 [1*, c1]</h2>
<h3 id="11-命题逻辑">1.1. 命题逻辑</h3>
<p>命题(proposition)是一个陈述，它要么为真，要么为假，但不能既真又假。考虑陈述句，为其分配两种状态值中的任何一个都是有意义的：真</p>
<p>17-1</p>
<p>17-2 <em>SWEBOK® GUIDE V4.0a</em></p>
<figure>
<img alt="图17.1 数学基础的主题分解" src="media/image.png"/>
<figcaption aria-hidden="true">图17.1 数学基础的主题分解</figcaption>
</figure>
<p><strong>数学基础</strong></p>
<p><strong>基本逻辑</strong> | <strong>集合、关系、函数</strong> |
<strong>有限状态机</strong> | <strong>离散概率</strong> |
<strong>代数结构</strong> | <strong>数论</strong></p>
<p>命题逻辑 | 集合运算 | 数的类型 | 群(Group)</p>
<p>谓词逻辑 | 集合的性质 | 可除性 | 环(Ring)</p>
<p>关系与函数 | 素数 | 最大公约数</p>
<h1 id="数学基础-2">数学基础</h1>
<h2 id="1-逻辑学">1. 逻辑学</h2>
<h3 id="11-命题逻辑-1">1.1. 命题逻辑</h3>
<p><strong>命题(proposition)</strong>
是一个陈述句，它要么为真，要么为假。以下是一些命题的例子：</p>
<ul>
<li>太阳是一颗恒星。</li>
<li>大象是哺乳动物。</li>
<li>2 + 3 = 5。</li>
</ul>
<p>然而，a + 3 = b
不是一个命题，因为它既不为真也不为假。它是否为真取决于变量 <em>a</em> 和
<em>b</em> 的值。</p>
<p><strong>排中律(Law of Excluded Middle)：</strong> 对于每个命题
p，要么 p 为真，要么 p 为假。</p>
<p><strong>矛盾律(Law of Contradiction)：</strong> 对于每个命题 p，p
不可能既为真又为假。</p>
<p><strong>命题逻辑(propositional logic)</strong>
是处理命题的逻辑领域。<strong>真值表(truth table)</strong>
显示命题真值之间的关系。</p>
<p><strong>布尔变量(Boolean variable)</strong>
是其值为真或假的变量。计算机位运算对应于布尔变量的逻辑运算。</p>
<p>基本逻辑运算符包括否定(not, ¬ p)、合取(and, p ∧ q)、析取(or, p ∨
q)、异或(exclusion, p ⊕ q)和蕴含(implication, p →
q)。可以使用各种逻辑运算符形成复合命题。</p>
<p>永真的复合命题是<strong>重言式(tautology)</strong>。永假的复合命题是<strong>矛盾式(contradiction)</strong>。既不是重言式也不是矛盾式的复合命题是<strong>偶然式(contingency)</strong>。</p>
<p>始终具有相同真值的复合命题称为<strong>逻辑等价(logically
equivalent)</strong>(记为 ≡)。一些常见的逻辑等价式如下：</p>
<p>• 同一律(Identity laws)： p ∧ T ≡ p p ∨ F ≡ p</p>
<p>• 支配律(Domination laws)： p ∨ T ≡ T p ∧ F ≡ F</p>
<p>• 幂等律(Idempotent laws)： p ∨ p ≡ p p ∧ p ≡ p</p>
<p>• 双重否定律(Double negation law)： ¬ (¬ p) ≡ p</p>
<p>• 交换律(Commutative laws)： p ∨ q ≡ q ∨ p p ∧ q ≡ q ∧ p</p>
<p>• 结合律(Associative laws)： (p ∨ q) ∨ r ≡ p ∨ (q ∨ r) (p ∧ q) ∧ r ≡
p ∧ (q ∧ r)</p>
<p>• 分配律(Distributive laws)： p ∨ (q ∧ r) ≡ (p ∨ q) ∧ (p ∨ r) p ∧ (q
∨ r) ≡ (p ∧ q) ∨ (p ∧ r)</p>
<p>• 德摩根律(De Morgan’s laws)： ¬ (p ∧ q) ≡ ¬ p ∨ ¬ q ¬ (p ∨ q) ≡ ¬ p
∧ ¬ q</p>
<h3 id="12-谓词逻辑">1.2. 谓词逻辑</h3>
<p><strong>谓词(predicate)</strong>
是描述对象属性或变量所表示的对象之间关系的动词短语模板。例如，在句子”花是红色的”中，模板”是红色的”是一个谓词。它描述了花的一个属性。同一个谓词可以用于其他句子。</p>
<p>谓词通常被赋予一个名称(例如，<em>red</em> 或简单地
<em>R</em>)来表示该谓词(在这种情况下，<em>red</em> 或 <em>R</em>
可以表示谓词”是红色的”)。假设 <em>R</em>
是谓词”是红色的”的名称，断言对象具有红色的句子可以表示为
<em>R(x)</em>，其中 <em>x</em> 表示任意对象。<em>R(x)</em> 读作”x
是红色的”。</p>
<p>量词允许对整个对象集合进行陈述，而不必逐一列举每个对象的名称。</p>
<p>• <strong>全称量词(universal quantifier)</strong> ∀ <em>x</em>
断言一个句子对变量 <em>x</em> 的所有值都为真(例如，∀<em>x</em>
Tiger(<em>x</em>) → Mammal(<em>x</em>) 表示所有老虎都是哺乳动物)。</p>
<p>• <strong>存在量词(existential quantifier)</strong> ∃<em>x</em>
断言一个句子对至少一个变量 <em>x</em> 的值为真(例如，∃<em>x</em>
Tiger(<em>x</em>) → Man-eater(<em>x</em>)
表示至少存在一只老虎是食人虎)。</p>
<p>因此，全称量化使用蕴含，而存在量化自然地使用合取。</p>
<p>通过量词引入到逻辑表达式中的变量 <em>x</em>
被绑定到最近的外围量词。类似地，在块结构化编程语言中，逻辑表达式中的变量引用其出现范围内最近的量词。例如，在
∃<em>x</em> (Cat(<em>x</em>) ∧ ∀ <em>x</em> (Black(<em>x</em>)))
中，Black(<em>x</em>) 中的 <em>x</em>
是全称量化的。因此，该谓词意味着所有事物都是黑色的。</p>
<p>如果变量未绑定到量词，则它是<strong>自由变量(free
variable)</strong>。</p>
<p>命题逻辑在表示数学、计算机科学以及软件工程中使用的许多断言方面存在不足。它也无法比较命题之间的等价性和其他关系。例如，断言”<em>a</em>
大于 1”不是一个命题，因为在不知道 <em>a</em>
的值的情况下，无法推断它是真还是假。因此，命题逻辑无法处理这样的句子。然而，这样的断言在数学中经常出现，我们希望从这些断言中推断信息。此外，命题逻辑无法捕获以下两个逻辑等价式中涉及的模式：“并非所有男人都是吸烟者”和”有些男人不吸烟。“这两个命题在命题逻辑中分别独立处理。命题逻辑中没有机制来确定这两者是否等价。因此，命题逻辑单独处理每个等价命题，而不是应用一个涵盖所有等价性的通用公式。</p>
<p>谓词逻辑(predicate
logic)解决了这些问题。从某种意义上说，谓词逻辑(也称为一阶逻辑(first-order
logic)或谓词演算(predicate
calculus))将命题逻辑扩展到涉及项和谓词的公式。</p>
<h2 id="2-证明技术">2. 证明技术</h2>
<p><strong>证明(proof)</strong>
是严格确立陈述真实性的论证。证明本身可以形式化地表示为离散结构。</p>
<p>证明中使用的陈述包括公理(axioms)和公设(postulates)，它们本质上是关于数学结构的基本假设、要证明的定理的假设以及先前证明的定理。</p>
<p>• <strong>定理(theorem)</strong> 是可以被证明为真的陈述。 •
<strong>引理(lemma)</strong> 是用于证明其他定理的简单定理。 •
<strong>推论(corollary)</strong>
是可以从已证明的定理直接推导出来的命题。</p>
<figure>
<img alt="图17.1. 数学基础知识领域主题分解" src="media/image.png"/>
<figcaption aria-hidden="true">图17.1.
数学基础知识领域主题分解</figcaption>
</figure>
<p>该至少存在一只猫，并且所有 [直接从已被证明的定理中建立的]</p>
<p>猫都是黑色的。</p>
<p>17-4 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<p>• <em>猜想(conjecture)</em> 是真值未知的陈述。 <em>2.3.
归纳法证明</em></p>
<p>当猜想的证明被找到时，该猜想就成为 归纳法证明分为两部分。</p>
<p>一个定理。很多时候，猜想被证明是错
首先，对基础情况建立命题为真——通</p>
<p>误的，因此不是定理。 [常是对正整数1。然后，在第二部分中，]</p>
<p>[建立如果命题对任意正整数 <em>k</em> 成立，那]</p>
<p><em>2.1. 直接证明</em> [么它也必须对下一个更大的整数 <em>k</em> + 1
]</p>
<p>成立。</p>
<p>直接证明是通过证明当 p 为真时 q 必
[换句话说，归纳法证明基于这样的推理]</p>
<p>[须为真来建立蕴含式 p → q 为真的技术。] [规则：一个无限命题序列
P(<em>n</em>), ∀<em>n</em> ∈ [1 ]</p>
<p>例如，要证明如果 <em>n</em> 是奇数，则 <em>n</em>[2] − 1 [… ∞]
的真值可以被建立，如果首先 P(1) ]</p>
<p>是偶数，假设对某个整数 <em>k</em>，<em>n</em> 是奇数 [为真，其次 ∀
<em>k</em> ∈ [2 … <em>n</em>] 如果 P(<em>k</em>) → ]</p>
<p>——即 <em>n</em> = 2<em>k</em> + 1： [P(<em>k</em> +
1)。对于归纳法证明，不假定 ]</p>
<p>[P(<em>k</em>) 对所有正整数 <em>k</em> 都为真。证明一个]</p>
<p>∴ <em>n</em>[2] = (2<em>k</em> + 1)[2] = 4<em>k</em>[2] + 4<em>k</em>
+ 1 [定理或命题只需要我们建立：如果假设]</p>
<p>[P(<em>k</em>) 对任意正整数 <em>k</em> 为真，则 P(<em>k</em> + 1)
]</p>
<p>由于右边(RHS)的前两项无论 <em>k</em> 的值
[也为真。关于归纳作为有效证明技术的]</p>
<p>如何都是偶数，所以左边(LHS)(<em>n</em>[2])是
[正确性的深入讨论超出了本KA的范围。]</p>
<p>奇数。因此，<em>n</em>[2] − 1 是偶数。直接证明
以下命题使用归纳法证明：</p>
<p>也可以称为<em>演绎证明</em>。</p>
<p>命题：前 <em>n</em> 个正奇数之和 S(<em>n</em>) 是 <em>n</em>[2]。</p>
<p><em>2.2. 反证法</em> 基础步骤：命题对 <em>n</em> = 1 为真，因为</p>
<p>S(1) = 1[2] = 1。基础步骤完成。</p>
<p>如果命题 p 基于蕴含式 ¬ p → q 的真值 [归纳步骤：归纳假设(IH)是命题对
<em>n</em> = ]</p>
<p>被证明，其中 q 是矛盾，则通过反证法 [<em>k</em> 为真，<em>k</em>
是任意正整数。]</p>
<p>证明命题 p 为真。例如，要证明 2<em>x</em> + 1</p>
<p>和 2<em>y</em> − 1 的和是偶数，假设 2<em>x</em> + 1 和 ∴ 1 + 3 + 5 +
… + (2<em>k</em> − 1) = <em>k</em>[2]</p>
<p>2<em>y</em> − 1 的和是奇数。换句话说，2(<em>x</em> + 现在，要证明
S(<em>k</em>) → S(<em>k</em> + 1)。</p>
<p><em>y</em>)，它是2的倍数，是奇数。这是一个 [S(<em>k</em> + 1) = 1 + 3
+ 5 + … + (2<em>k</em> − 1) + (2<em>k</em> ]</p>
<p>矛盾。因此，2<em>x</em> + 1 和 2<em>y</em> − 1 的和是 [+ 1)]</p>
<p>偶数。 = S(<em>k</em>) + (2<em>k</em> + 1)</p>
<p>= <em>k</em> [2] + (2<em>k</em> + 1) [使用 IH]</p>
<p>推理规则是一种模式，它建立如果一组 = <em>k</em> [2] + 2<em>k</em> +
1</p>
<p>前提都为真，则可以推导出某个结论陈 = (<em>k</em> + 1)[2]</p>
<p>述为真。需要研究加法、简化和合取的</p>
<p>参考规则。 [因此，证明了如果命题对 <em>n</em> = <em>k</em>
为真，]</p>
<p>[则对 n* = <em>k</em> + 1 也为真。]</p>
<p>一种密切相关的方法，<em>逆否证明</em>，采</p>
<p>取相反的方法，假设结论为假并证明假 [基础步骤与归纳步骤一起证明了 S(1)
]</p>
<p>设也为假。如果可以证明 ¬ q → ¬ p 为 [为真，并且条件陈述 S(<em>k</em>)
→ S(<em>k</em> + 1) 对]</p>
<p>真，则 p → q 也必须为真。 [所有正整数 <em>k</em>
都为真。因此，命题得证。]</p>
<p><a href="#数学基础">数学基础</a> 17-5</p>
<p><strong>X</strong> ∩ <strong>Y</strong></p>
<p><strong>X</strong> <strong>X</strong> <strong>Y</strong></p>
<p><strong>U</strong> <strong>U</strong></p>
<p>[<strong>图 17.2.</strong> 集合 <em>X</em> 的文氏图] [<strong>图
17.3.</strong> 集合 <em>X</em> 和 <em>Y</em> 的交集]</p>
<p><em>2.4. 举例证明</em> [<em>基数。</em> 有限集合 S 的基数是 S
中元素]</p>
<p>[的个数。这表示为 |S|（例如，如果 S = ]</p>
<p>举例证明仅在证明的核心是”存在”并 [{5, 6, 7}，则 |S| = 3）。]</p>
<p>且只需要证明至少存在一个有效实例时 <em>全集。</em>
一般来说，<em>S</em> = {<em>x</em> ∈ U |</p>
<p>才有效。然而，更一般地说，举例证明 [p(<em>x</em>)}，其中 U
是必须解释谓词 P(<em>x</em>) ]</p>
<p>经常被称为不当归纳(Inappropriate [的论域(universe of
discourse)。给定谓]</p>
<p>Generalization)，其中通过一个或几个
[词的<em>论域</em>通常被称为<em>全集</em>。或者，]</p>
<p>例子假设有效性得到证明，而不是完整
可以将全集定义为所有元素的集合。</p>
<p>的证明。仅展示一个或几个 p → q 的具 [<em>集合相等。</em>
两个集合相等当且仅当它]</p>
<p>体例子不足以证明对所有情况 p → q。 [们有相同的元素——即 <em>X</em> =
<em>Y</em> ≡ ∀ <em>p</em> (<em>p</em> ]</p>
<p>∈ <em>X</em> ↔︎ <em>p</em> ∈ <em>Y</em>)。</p>
<p><strong>3. 集合、关系、函数</strong> <strong>[1*, c2]</strong>
[<em>子集。X</em> 是集合 <em>Y</em> 的子集，或 <em>X</em> 包含]</p>
<p><em>集合。</em> 集合是称为元素的对象的集合。 [于 Y，如果 <em>X</em>
的所有元素都包含在 <em>Y</em> ]</p>
<p>集合可以通过在大括号之间列出其元素 [中。这表示为 <em>X</em> ⊆
<em>Y</em>。换句话说，<em>X</em> ⊆ ]</p>
<p>来表示（例如，<em>S</em> = {1, 2, 3}）。 [<em>Y</em> 当且仅当 ∀p(p ∈
X → p ∈ Y)。如果 <em>X</em> ]</p>
<p>符号 ∈ 用于表示一个元素属于一个集合 [= {1, 2, 3} 且 <em>Y</em> = {1,
2, 3, 4, 5}，则 <em>X</em> ⊆ ]</p>
<p>或是集合的成员。它的否定用 ∉ 表示 [<em>Y</em>。如果 <em>X</em> 不是
<em>Y</em> 的子集，则表示为 ]</p>
<p>（例如，1 ∈ <em>S</em>，但 4 ∉ <em>S</em>）。 <em>X</em>
<em>Y</em>。</p>
<p>在使用集合构造符号的更紧凑的集合表 <em>真子集。</em> X 是 <em>Y</em>
的真子集(Proper</p>
<p>示中，{x | P(x)} 是满足条件的集合 Subset)（表示为 <em>X</em> ⊂
<em>Y</em>），如果 <em>X</em> 是</p>
<p><em>Y</em> 的子集但</p>
<p>对于任意命题 P(x) 不等于 <em>Y</em> 的所有 x — 即，<em>X</em>
中存在某个不在 <em>Y</em> 中的元素。</p>
<p>换句话说，当且仅当 (<em>X</em> ⊆ <em>Y</em>) ∧ (<em>X</em> ≠
<em>Y</em>) 时，<em>X</em> ⊂ <em>Y</em>。如果 <em>X</em> = {1, 2,
3}，<em>Y</em> = {1, 2, 3, 4}，<em>Z</em> = {1, 2, 3}，那么 <em>X</em> ⊂
<em>Y</em>，但 <em>X</em> 不是 <em>Z</em> 的真子集。集合 <em>X</em> 和
<em>Z</em> 是相等集合。</p>
<p>如果 <em>X</em> 不是 <em>Y</em> 的真子集，则记为 <em>X</em> ⊄
<em>Y</em>。</p>
<p><em>超集。</em> 如果 <em>X</em> 是 <em>Y</em> 的子集，那么 <em>Y</em>
称为 <em>X</em> 的超集。这表示为 <em>Y</em> ⊇ <em>X</em> — 即，当且仅当
<em>X</em> ⊆ <em>Y</em> 时，<em>Y</em> ⊇ <em>X</em>。如果 <em>X</em> =
{1, 2, 3} 且 <em>Y</em> = {1, 2, 3, 4, 5}，那么 <em>Y</em> ⊇
<em>X</em>。</p>
<p><em>空集。</em> 没有元素的集合称为空集。空集用 Ø
表示，也称为零集或空集。</p>
<p>一些重要的集合包括：</p>
<p>• Ν = {0, 1, 2, 3, …} = 非负整数集。</p>
<p>• Ζ = {…, -3, -2, -1, 0, 1, 2, 3, …} = 整数集。</p>
<p><em>有限集和无限集。</em>
具有有限个元素的集合称为有限集。相反，任何不具有有限个元素的集合是无限集。例如，所有自然数的集合是无限集。</p>
<p><em>幂集。</em> 集合 <em>X</em> 的所有子集的集合称为 <em>X</em>
的幂集。表示为 ℘(<em>X</em>)。如果 <em>X =</em> {a, b, c}，那么
℘(<em>X)</em> = {Ø, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b,
c}}。如果 <em>|X</em>| = n，那么 <em>|</em>℘(<em>X</em>)| = 2ⁿ。</p>
<p><em>维恩图。</em>
维恩图是将集合表示为平面中封闭区域的图形表示。例如，在图 17.2
中，矩形表示全集，阴影区域表示集合 <em>X</em>。</p>
<h3 id="31-集合运算">3.1. 集合运算</h3>
<p><em>交集。</em> 两个集合 <em>X</em> 和 <em>Y</em> 的交集，记为 X ∩
<em>Y</em>，是 X 和 Y 中的公共元素集合。换句话说，X ∩ <em>Y</em> = {p |
(p ∈ <em>X</em>) ∧ (p ∈ <em>Y</em>)}。例如，{1, 2, 3} ∩ {3, 4, 6} =
{3}。</p>
<p>如果 <em>X</em> ∩ <em>Y</em> = φ，那么两个集合 <em>X</em> 和
<em>Y</em> 称为<em>不相交</em>。</p>
<p>图 17.3 显示了集合交集的维恩图。两个集合的公共部分表示集合交集。</p>
<p><em>并集。</em> 两个集合 <em>X</em> 和 <em>Y</em> 的并集，记为
<em>X</em> ∪ <em>Y</em>，是在 <em>X</em> 中、在 <em>Y</em>
中或在两者中的所有元素的集合。换句话说，<em>X</em> ∪ <em>Y</em> = {p |
(p ∈ <em>X</em>) ∨ (p ∈ Y)}。例如，{1, 2, 3} ∪ {3, 4, 6} = {1, 2, 3, 4,
6}。</p>
<figure>
<img alt="图 17.4. 集合 X 和 Y 的并集" src="media/image-004.png"/>
<figcaption aria-hidden="true">图 17.4. 集合 <em>X</em> 和 <em>Y</em>
的并集</figcaption>
</figure>
<p>需要注意的是 |<em>X</em> ∪ <em>Y</em>| = |<em>X</em>| + |<em>Y</em>|
− |<em>X</em> ∩ <em>Y</em>|。</p>
<p>图 17.4 中的阴影区域用维恩图表示两个集合的并集。</p>
<p><em>补集。</em> 全集中不属于给定集合 <em>X</em> 的元素集合称为其补集
<em>X̄</em>。换句话说，<em>X̄</em> ={p | (p ∈ U) ∧ (p ∉ <em>X</em>)}。</p>
<figure>
<img alt="图 17.5. X 的补集维恩图" src="media/image-005.png"/>
<figcaption aria-hidden="true">图 17.5. <em>X</em>
的补集维恩图</figcaption>
</figure>
<p>图 17.5 中维恩图的阴影部分表示 <em>X</em> 的补集。</p>
<p><em>集合差或相对补集。</em> 属于集合 <em>X</em> 但不属于集合
<em>Y</em> 的元素集合构成从 <em>X</em> 中减去 <em>Y</em>
的集合差。表示为 <em>X</em> − <em>Y</em>。换句话说，<em>X</em> −
<em>Y</em> = {p | (p ∈ <em>X</em>) ∧ (p ∉ <em>Y</em> )}。例如，{1, 2, 3}
− {3, 4, 6} = {1, 2}。</p>
<p>可以证明 <em>X</em> − <em>Y</em> = <em>X</em> ∩ <em>Ȳ</em>。</p>
<figure>
<img alt="图 17.6. X − Y 的维恩图" src="media/image-006.png"/>
<figcaption aria-hidden="true">图 17.6. <em>X</em> <strong>−</strong>
<em>Y</em> 的维恩图</figcaption>
</figure>
<p>图 17.6 用维恩图的阴影区域说明了集合差 <em>X</em> – <em>Y</em>。</p>
<p><em>笛卡尔积。</em> 普通对 {<em>p</em>, <em>q</em>}
是具有两个元素的集合。在集合中，元素的顺序无关紧要，因此 {<em>p</em>,
<em>q</em>} = {<em>q</em>, <em>p</em>}。在有序对 (<em>p</em>,
<em>q</em>) 中，元素出现的顺序是相关的。因此，(<em>p</em>, <em>q</em>) ≠
(<em>q</em>, <em>p</em>) 除非 <em>p</em> =
<em>q</em>。一般来说，当且仅当 <em>p</em> = <em>s</em> 且 <em>q</em> =
<em>t</em> 时，(<em>p</em>, <em>q</em>) = (<em>s</em>, <em>t</em>)。</p>
<p>给定两个集合 <em>X</em> 和 <em>Y</em>，它们的笛卡尔积 <em>X</em> ×
<em>Y</em> 是所有有序对 (<em>p</em>, <em>q</em>) 的集合，使得 <em>p</em>
∈ <em>X</em> 且 <em>q</em> ∈ <em>Y</em>。换句话说，<em>X</em> ×
<em>Y</em> = {(<em>p</em>, <em>q</em>) | (<em>p</em> ∈ <em>X</em>) ∧
(<em>q</em> ∈ <em>Y</em>)}。例如，{<em>a</em>, <em>b</em>} × {1, 2} =
{(<em>a</em>, 1), (<em>a</em>, 2), (<em>b</em>, 1), (<em>b</em>,
2)}。</p>
<h3 id="32-集合的性质">3.2. 集合的性质</h3>
<p>集合的一些重要性质和定律有：</p>
<p>结合律： • <em>X</em> ∪ (<em>Y</em> ∪ <em>Z</em>) = (<em>X</em> ∪
<em>Y</em>) ∪ <em>Z</em> • <em>X</em> ∩ (<em>Y</em> ∩ <em>Z</em>) =
(<em>X</em> ∩ <em>Y</em>) ∩ <em>Z</em></p>
<p>交换律： • <em>X</em> ∪ <em>Y</em> = <em>Y</em> ∪ <em>X</em> •
<em>X</em> ∩ <em>Y</em> = <em>Y</em> ∩ <em>X</em></p>
<p>分配律： • <em>X</em> ∪ (<em>Y</em> ∩ <em>Z</em>) = (<em>X</em> ∪
<em>Y</em>) ∩ (<em>X</em> ∪ <em>Z</em>) • <em>X</em> ∩ (<em>Y</em> ∪
<em>Z</em>) = (<em>X</em> ∩ <em>Y</em>) ∪ (<em>X</em> ∩ <em>Z</em>)</p>
<p>恒等律： • <em>X</em> ∪ φ = <em>X</em> • <em>X</em> ∩ <em>U</em> =
<em>X</em></p>
<p>补集律： • <em>X</em> ∪ <em>X̄</em> = <em>U</em> • <em>X</em> ∩
<em>X̄</em> = φ</p>
<p>幂等律： • <em>X</em> ∪ <em>X</em> = <em>X</em> • <em>X</em> ∩
<em>X</em> = <em>X</em></p>
<p>边界律： • <em>X</em> ∪ <em>U</em> = <em>U</em> • <em>X</em> ∩ φ =
φ</p>
<p>吸收律： • <em>X</em> ∪ (<em>X</em> ∩ <em>Y</em>) = <em>X</em> •
<em>X</em> ∩ (<em>X</em> ∪ <em>Y</em>) = <em>X</em></p>
<p>德摩根定律： • (<em>X</em> ∪ <em>Y</em>)’ = <em>X̄</em> ∩ <em>Ȳ</em> •
(<em>X</em> ∩ <em>Y</em>)’ = <em>X̄</em> ∪ <em>Ȳ</em></p>
<h3 id="33-关系和函数">3.3. 关系和函数</h3>
<p><em>关系</em>是两个集合之间的关联。</p>
<figure>
<img alt="图 17.7. 函数的垂直线测试" src="media/image-007.png"/>
<figcaption aria-hidden="true">图 17.7. 函数的垂直线测试</figcaption>
</figure>
<p>如果我们在居民姓名和他们的出生日期之间建立关系，以出生日期集合作为定义域，这个关系就不是函数。然而，如果我们在居民姓名和他们的出生日期之间建立关系，以姓名集合作为定义域，那么这就成为一个良好的关系，因此是一个函数。这意味着虽然所有函数都是关系，但并非所有关系都是函数。在函数的情况下，给定一个
x，对于每个有序对 (x, y)，有且仅有一个 y。</p>
<p>例如，考虑以下两个关系：</p>
<p><em>A</em>: {(3, –9), (5, 8), (7, –6), (3, 9), (6, 3)} <em>B</em>:
{(5, 8), (7, 8), (3, 8), (6, 8)}</p>
<p>这些也是函数吗？</p>
<p>在关系 <em>A</em> 中，定义域是所有 <em>x</em> 值 — 即 {3, 5, 6, 7} —
值域是所有 <em>y</em> 值 — 即 {–9, –6, 3, 8, 9}。</p>
<p>关系 <em>A</em> 不是函数，因为存在</p>
<p>信息。考虑一个城市的居民集合及其电话号码。姓名与对应电话号码的配对就是一个关系(relation)。这种配对对于整个关系来说是<em>有序的</em>。对于每一对，要么姓名在前，后面跟着电话号码，要么相反。第一个元素所取自的集合称为<em>定义域集合</em>，另一个集合称为<em>值域集合</em>。定义域(domain)是你开始的地方，值域(range)是你结束的地方。</p>
<p>函数(function)是一个良好表现的关系。如果定义域集合X的每个元素对应值域集合Y的单个元素，则关系R(X,
Y)是良好表现的。将定义域集合X视为一组人，将值域集合Y视为他们的电话号码。如果一个人可能有多个电话号码，那么这个关系就不是函数。</p>
<p>同一个<em>x</em>值有两个不同的值域值，–9和9，这对应位置3。</p>
<p>在关系B中，定义域与A相同——即{3, 5, 6,
7}。然而，值域是单个元素——{8}。即使所有x值都映射到同一个y值，这也符合函数的条件。这里，每个x值都是不同的，所以关系是良好表现的，因此是一个函数。因此，关系B可以用方程y
= 8表示。</p>
<p>一个关系是否可以被表征为函数，可以使用下面介绍的垂直线测试(vertical
line test)来验证：</p>
<p>给定一个关系的图形，如果可以画一条垂直线在多个位置与图形相交，那么该关系不是函数。</p>
<p>17-8 <em>SWEBOK® GUIDE V4.0a</em></p>
<p>在图17.7中，线L1和L2都与关系的图形相交三次。这表示对于这些x值中的每一个(L1代表一个x值，L2代表另一个x值)，都有三个不同的y值。因此，该关系不是函数。当然，仅L1或L2中的任何一条就足以证明该关系不是函数。</p>
<p><strong>4. 图和树</strong> <strong>[1*, c10, c11]</strong></p>
<p><em>4.1. 图</em></p>
<p>在图<em>G</em> = (<em>V</em>,
<em>E</em>)中，<em>V</em>是顶点(节点)的集合，<em>E</em>是边的集合。边也称为<em>弧</em>或<em>链接</em>。</p>
<p><em>F</em>是将边集<em>E</em>映射到元素<em>V</em>的有序或无序对集合的函数。在图17.8中，<em>G</em>
= (<em>V</em>, <em>E</em>)，其中<em>V</em> = {A, B, C}，<em>E</em> =
{<em>e1</em>, <em>e2</em>, <em>e3</em>}，<em>F</em> = {(<em>e1</em>, (A,
C)), (<em>e2</em>, (C, B)), (<em>e3</em>, (B, A))}。</p>
<p>图17.8中的简单图(simple
graph)由一组顶点或节点以及一组连接无序对的边组成。简单图中的边是无向的。这样的图也称为<em>无向图</em>。在图17.8中，(<em>e1</em>,
(A, C))可以替换为(<em>e1</em>, (C,
A))，因为顶点A和C之间的对是无序的。这对其他两条边也是如此。</p>
<p>在多重图(multigraph)中，可能有多条边连接同一对顶点。连接同一对顶点的两条或多条边可能反映同一对顶点之间的多重关联。这样的边称为<em>平行边</em>或<em>多重边</em>。在图17.9中，边<em>e3</em>和<em>e4</em>都连接A和B。图17.9是一个多重图，其中边<em>e3</em>和<em>e4</em>是多重边。</p>
<p>在<em>伪图</em>(pseudograph)中，允许节点连接到自身的边。这样的边称为<em>环</em>(loop)。在图17.10中，边<em>e4</em>开始和结束都在B。图17.10是一个伪图，其中<em>e4</em>是一个环。</p>
<p><em>有向图</em> <em>G</em> = (<em>V</em>,
<em>E</em>)由顶点集<em>V</em>和边集<em>E</em>组成，边集是<em>V</em>元素的有序对。有向图可能包含环。在图17.11中，<em>G</em>
= (<em>V</em>, <em>E</em>)是一个有向图，其中<em>V</em> = {A, B,
C}，<em>E</em> = {<em>e1</em>, <em>e2</em>, <em>e3</em>}，<em>F</em> =
{(<em>e1</em>, (A, C)), (<em>e2</em>, (B, C)), (<em>e3</em>, (B,
A))}。</p>
<p><strong>[图17.8.** 图的示例**]</strong></p>
<p><strong>[图17.9.** 多重图的示例**]</strong></p>
<p><strong>[图17.10.** 伪图的示例**]</strong></p>
<p><strong>[图17.11.** 有向图的示例**]</strong></p>
<p><strong>[图17.12.** 加权图的示例**]</strong></p>
<p>数学基础 17-9</p>
<p>在<em>加权图G</em> = (<em>V</em>,
<em>E</em>)中，每条边都有一个与之关联的权重。边的权重通常表示对应两个顶点之间关系的数值。在图17.12中，边<em>e1</em>、<em>e2</em>和<em>e3</em>的权重分别为76、93和15。如果顶点A、B和C代表一个州的三个城市，权重可以是例如这些城市之间的公里距离。</p>
<p>设<em>G</em> = (<em>V</em>,
<em>E</em>)是一个具有边集<em>E</em>的无向图。那么，对于一条边<em>e</em>
= {<em>u</em>, <em>v</em>} ∈ <em>E</em>，经常使用以下表达：</p>
<p>•
<em>u</em>、<em>v</em>被称为<em>相邻</em>、<em>邻居</em>或<em>连接的</em>。
• 边<em>e</em>与顶点<em>u</em>和<em>v</em> <em>关联</em>。 •
边<em>e</em>连接<em>u</em>和<em>v</em>。 •
顶点<em>u</em>和<em>v</em>是边<em>e</em>的<em>端点</em>。</p>
<p>如果顶点<em>v</em> ∈ V，在无向图<em>G</em> = (<em>V</em>,
<em>E</em>)中，则：</p>
<p>•
<em>v</em>的<em>度</em>，deg(<em>v</em>)，是其关联边的数量，但任何自环要计算两次。
• 度为0的顶点称为<em>孤立顶点</em>。</p>
<p>• <em>v</em>的<em>出度</em>，deg<a href="*v*">+</a>，是从<em>v</em>出发的边的数量，即<em>v</em>是起始顶点的边。
• <em>v</em>的<em>度</em>，deg(<em>v</em>) = deg<a href="*v*">−</a> +
deg<a href="*v*">+</a>，是<em>v</em>的入度和出度的和。 •
顶点上的环对该顶点的入度和出度各贡献1。</p>
<p><strong>[图17.13.**
循环<em>C</em>3和<em>C</em>4的示例**]</strong></p>
<table>
<thead>
<tr>
<th><strong>顶点</strong></th>
<th><strong>相邻节点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B, C</td>
</tr>
<tr>
<td>B</td>
<td>A, B, C</td>
</tr>
<tr>
<td>C</td>
<td>A, B</td>
</tr>
</tbody>
</table>
<p><strong>[图17.14.** 图17.10的邻接表**]</strong></p>
<p>• 度为1的顶点被称为<em>悬挂顶点</em>。</p>
<p>设 <em>G</em> = (<em>V</em>, <em>E</em>) 为有向图。如果
<em>e</em>(<em>u</em>, <em>v</em>) 是 <em>G</em>
的一条边，那么可以用以下表达式来描述该图：</p>
<p>• <em>u</em> <em>邻接到</em> <em>v</em>，<em>v</em> <em>从</em>
<em>u</em> <em>邻接</em>。 • <em>e</em> <em>从</em> <em>u</em>
<em>出发</em>并<em>指向</em> <em>v</em>。 • <em>e</em> <em>连接</em>
<em>u</em> <em>到</em> <em>v</em>，或 <em>e</em> <em>从</em> <em>u</em>
<em>指向</em> <em>v</em>。 • <em>e</em> 的<em>起始顶点</em>是
<em>u</em>。 • <em>e</em> 的<em>终止顶点</em>是 <em>v</em>。</p>
<p>如果顶点 <em>v</em> 在有向图 <em>G</em> = (<em>V</em>, <em>E</em>)
的顶点集中，那么：</p>
<p>• <em>v</em> 的<em>入度</em>，记为 deg<a href="*v*">−</a>，是指向
<em>v</em> 的边的数量，即 <em>v</em> 作为终止顶点的边数。</p>
<p>根据上述定义，无论我们将边视为有向边还是无向边，节点的度数都保持不变。</p>
<p>在无向图中，从 <em>u</em> 到 <em>v</em> 的长度为 <em>n</em>
的路径是从顶点 <em>u</em> 到顶点 <em>v</em> 的 <em>n</em>
条相邻边的序列。</p>
<p>• 如果 <em>u</em> = <em>v</em>，则路径称为<em>回路</em>。 •
路径<em>遍历</em>沿途的顶点。 •
如果路径不包含重复的边，则称为<em>简单</em>路径。</p>
<p>对于任意 <em>n</em> ≥ 3，<em>n</em> 个顶点上的循环 C[<em>n</em>]
是一个简单图，其中 <em>V</em> = {<em>v</em>[1], <em>v</em>[2], …,
<em>v</em>[<em>n</em>]}，<em>E</em> = {{<em>v</em>[1], <em>v</em>[2]},
{<em>v</em>[2], <em>v</em>[3]}, …, {<em>v</em>[<em>n</em>−1],
<em>v</em>[<em>n</em>]}, {<em>v</em>[<em>n</em>], <em>v</em>[1]}}。</p>
<p>例如，图17.13展示了长度为3和4的两个循环。</p>
<p><em>邻接表</em>是一个表格，每个顶点占一行，列出其相邻顶点。</p>
<p>17-10 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<p><strong>A</strong> <em>J</em>, <em>K</em>}。边集 <em>E</em> 为
{(<em>A</em>, <em>B</em>), (<em>A</em>, <em>C</em>), (<em>A</em>,
<em>D</em>), (<em>B</em>, <em>E</em>), (<em>B</em>, <em>F</em>),
(<em>B</em>, <em>G</em>), (<em>C</em>, <em>H</em>), (<em>C</em>,
<em>I</em>), (<em>D</em>, <em>J</em>), (<em>D</em>, <em>K</em>)}。</p>
<p><strong>B</strong> <strong>C</strong> <strong>D</strong></p>
<p>非根节点 <em>v</em> 的父节点是唯一具有从 <em>u</em> 到 <em>v</em>
的有向边的节点
<em>u</em>。树中的每个节点都有唯一的父节点，除了树的根节点。虽然根节点可以作为父节点，但它们本身没有父节点。在图17.15中，根节点
<em>A</em> 是节点 <em>B</em>、<em>C</em> 和 <em>D</em>
的父节点。同样，<em>B</em> 是 <em>E</em>、<em>F</em> 和 <em>G</em>
的父节点，依此类推。根节点 <em>A</em> 没有父节点。</p>
<p><strong>E</strong> <strong>F G</strong> <strong>H</strong>
<strong>I</strong> <strong>J</strong> <strong>K</strong></p>
<p>[<strong>图17.15.</strong> 树的示例]</p>
<p>有向图的邻接表维护每个顶点的终止节点列表。图17.14展示了图17.10中伪图和图17.11中有向图的邻接表。由于图17.11中顶点C的出度为0，因此邻接表中没有与C对应的条目。</p>
<p>需要研究图的不同表示方法，例如邻接矩阵、关联矩阵和邻接表。</p>
<h2 id="42-树">4.2. 树</h2>
<p>树 <em>T</em>(<em>N</em>, <em>E</em>) 是一个包含 <em>n</em> =
|<em>N</em>| 个节点的层次化数据结构，具有一个特别指定的根节点
<em>R</em>，而其余 <em>n</em> − 1 个节点在根节点 <em>R</em>
下形成子树。</p>
<p>树中的边数 |<em>E</em>| 总是等于 |<em>N</em>| − 1。</p>
<p>节点 <em>X</em> 处的子树是树的子图，由节点
<em>X</em>、其后代以及与这些后代关联的所有边组成。作为这个递归定义的替代方案，树可以定义为没有简单回路的连通无向图。</p>
<p>然而，树是严格层次化的，而图是扁平的。在树中，两个节点之间建立了父子有序对。树中的每个子节点只与一个父节点关联，而这种限制对图来说毫无意义，因为图中不存在父子关联。</p>
<p>当且仅当无向图的任意两个顶点之间存在唯一的简单路径时，该无向图是一棵树。</p>
<p>图17.15展示了一棵树 <em>T</em>(<em>N</em>, <em>E</em>)，其节点集
<em>N</em> = {<em>A</em>, <em>B</em>, <em>C</em>, <em>D</em>,
<em>E</em>, <em>F</em>, <em>G</em>, <em>H</em>, <em>I</em>, <em>J</em>,
<em>K</em>}。</p>
<p>拥有子节点的节点称为<em>内部节点</em>。例如，在图17.15中，节点
<em>A</em> 和节点 <em>B</em>
是内部节点的示例。树中节点的度数与其子节点数相同。例如，在图17.15中，根节点
<em>A</em> 及其子节点 <em>B</em> 的度数都为3。节点 <em>C</em> 和
<em>D</em> 的度数为2。</p>
<p>节点距离根节点的跳数称为其<em>层级</em>。根节点位于第0层。或者说，节点
<em>X</em> 的层级是从树的根到节点 <em>X</em>
的唯一路径的长度。在图17.15中，根节点 <em>A</em> 位于第0层。节点
<em>B</em>、<em>C</em> 和 <em>D</em>
位于第1层。图17.15中的其余节点位于第2层。树的高度是树节点层级的最大值。例如，在图17.15中，树的高度为2。</p>
<p>如果节点没有子节点，则称为<em>叶子</em>节点，叶子节点的度数为0。例如，在图17.15中，节点
<em>E</em> 到 <em>K</em> 是度数为0的叶子节点。</p>
<p>非根节点 <em>X</em> 的祖先或前驱是从根到节点 <em>X</em>
的路径中的所有节点。例如，在图17.15中，节点 <em>A</em> 和 <em>D</em>
构成 <em>J</em> 的祖先集合。</p>
<p>节点 <em>X</em> 的后继或后代是所有以X为祖先的节点。对于具有
<em>n</em> 个节点的树，其余 <em>n</em> − 1
个节点都是根节点的后继。在图17.15中，节点 <em>B</em> 的后继为
<em>E</em>、<em>F</em> 和 <em>G</em>。<em>如果节点</em> X
<em>是节点</em> Y <em>的祖先，则节点</em> Y <em>是</em> X
<em>的后继。</em></p>
<p>共享同一父节点的两个或多个节点称为<em>兄弟</em>节点。例如，在图17.15中，节点
<em>E</em> 和 <em>G</em> 是兄弟节点。然而，节点 <em>E</em> 和 <em>J</em>
虽然在同一层级，但不是兄弟节点。</p>
<p>[MATHEMATICAL FOUNDATIONS] 17-11</p>
<p><em>两个兄弟节点在同一层级，但同一层级上的两个节点不一定是兄弟节点。</em></p>
<p>如果子节点出现的相对位置很重要，则该树称为<em>有序树</em>。例如，如果作为规则，兄长的名字总是出现在弟妹之前(在左侧)，那么家谱树就是有序树。</p>
<p><strong>A</strong> <strong>A</strong></p>
<p><strong>B</strong> <strong>C</strong> <strong>C</strong>
<strong>B</strong></p>
<p>[<strong>图17.16.</strong> 二叉树示例]</p>
<p>在无序树中，兄弟节点之间出现的相对位置没有意义，可以任意改变。</p>
<p>二叉树由1个或多个节点组成，其中有一个根节点<em>R</em>，所有剩余节点在根节点下形成一对有序子树。在二叉树中，任何内部节点都不能有超过两个子节点。除了对内部节点度数的这一标准外，二叉树总是有序的。如果树中任何节点的左右子树位置互换，就会创建一棵新树。</p>
<p>在图17.16中，这两棵二叉树是不同的，因为<em>A</em>的子节点在两棵树中的位置不同。</p>
<p>根据[1*]，如果每个内部节点恰好有两个子节点，则称该二叉树为满二叉树(full
binary
tree)。例如，图17.17中的二叉树是满二叉树，因为内部节点<em>A</em>和<em>B</em>的度数都是2。符合上述定义的满二叉树也称为<em>严格二叉树(strictly
binary tree)</em>。</p>
<figure>
<img alt="图17.17. 满二叉树示例" src="Figure%2017.17"/>
<figcaption aria-hidden="true">图17.17. 满二叉树示例</figcaption>
</figure>
<p>图17.18中的两棵二叉树都是完全二叉树(complete binary
tree)。图17.18(a)中的树既是完全二叉树又是满二叉树。完全二叉树的所有层级都是满的，除了可能的最后一层。如果完全二叉树的最后一层不满，节点从最左边的可用位置开始出现。</p>
<figure>
<img alt="图17.18. 完全二叉树示例" src="Figure%2017.18"/>
<figcaption aria-hidden="true">图17.18. 完全二叉树示例</figcaption>
</figure>
<p>有趣的是，按照上述定义，图17.18(b)中的树是完全但不是满二叉树，因为节点<em>B</em>只有一个子节点<em>D</em>。相反，图17.17中的树是满但不是完全二叉树，因为<em>B</em>的子节点出现在树中，而<em>C</em>的子节点没有出现在最后一层。</p>
<p>如果所有叶节点都出现在<em>H</em>层或<em>H</em> −
1层，则高度为<em>H</em>的二叉树是平衡的(balanced)。图17.17和图17.18中的所有三棵二叉树都是平衡二叉树。</p>
<p>高度为<em>H</em>的二叉树最多有2^<em>H</em>个叶节点。换句话说，如果有<em>L</em>个叶节点的二叉树是满的且平衡的，那么其高度为<em>H</em>
=
log₂<em>L</em>。这对图17.17和图17.18(a)中的两棵树都成立，因为两棵树都是满的且平衡的。然而，图17.18(b)中的树不是满二叉树。</p>
<p>二叉搜索树(BST, binary search
tree)是一种特殊的二叉树，其中每个节点包含一个不同的键值，树中每个节点的键值小于其右子树中的每个键值，并且大于其左子树中的每个键值。</p>
<p>遍历算法(traversal
algorithm)是系统地访问二叉树每个节点的过程。树遍历可以递归定义。</p>
<figure>
<img alt="图17.19. 二叉搜索树" src="Figure%2017.19"/>
<figcaption aria-hidden="true">图17.19. 二叉搜索树</figcaption>
</figure>
<p>InOrder(<em>T</em>) = InOrder(<em>T</em>_<em>L</em>), <em>R</em>,
InOrder(<em>T</em>_<em>R</em>)</p>
<p>公式3</p>
<p>图17.19中的树是二叉搜索树(BST)。该BST的前序、后序和中序遍历输出分别如下：</p>
<p>前序输出：9, 5, 2, 1, 4, 7, 6, 8, 13, 11, 10, 15</p>
<p>后序输出：1, 4, 2, 6, 8, 7, 5, 10, 11, 15, 13, 9</p>
<p>中序输出：1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15</p>
<h2 id="5-有限状态机-1-c13">5. 有限状态机 [1*, c13]</h2>
<p>计算机系统可以抽象为一个从状态到状态的映射，由输入驱动。换句话说，系统可以被视为一个转换函数<em>T</em>:
<em>S</em> × <em>I</em> → <em>S</em> ×
<em>O</em>，其中<em>S</em>是状态集，<em>I</em>和<em>O</em>是输入和输出函数。</p>
<p>如果状态集<em>S</em>是有限的，则该系统称为有限状态机(FSM,
finite-state machine)。</p>
<p>或者说，有限状态机(FSM)是由有限数量的状态以及这些状态之间的转换组成的数学抽象。例如，如果域<em>S</em>
×
<em>I</em>足够小，那么可以明确指定<em>T</em>，使用类似流程图的图表来说明不同输入的逻辑流程。然而，这仅对信息容量非常小的机器实用。</p>
<figure>
<img alt="图17.20. FSM示例" src="Figure%2017.20"/>
<figcaption aria-hidden="true">图17.20. FSM示例</figcaption>
</figure>
<p>FSM具有有限的内部存储器，一个依次读取符号序列的输入特性，以及一个输出特性。</p>
<p>FSM的操作从起始状态开始，根据输入经过转换到达不同状态，并可以在任何有效状态结束。然而，只有少数状态标志着操作的成功流程。这些称为接受状态(accept
states)。</p>
<p>FSM的信息容量(information capacity)为<em>C</em> = log
|<em>S</em>|。因此，如果我们将信息容量为<em>C</em>位的机器表示为FSM，那么其状态转换图将有|<em>S</em>|
= 2^<em>C</em>个节点。</p>
<p>如果<em>T</em>是具有根<em>R</em>的二叉树，其余节点在<em>R</em>下形成一对有序的非空左子树<em>T</em>_<em>L</em>和非空右子树<em>T</em>_<em>R</em>，则前序遍历函数PreOrder(<em>T</em>)定义为：</p>
<p>PreOrder(<em>T</em>) = <em>R</em>, PreOrder(<em>T</em>_<em>L</em>),
PreOrder(<em>T</em>_<em>R</em>)</p>
<p>公式1</p>
<p>查找子树前序遍历的递归过程会持续进行，直到发现子树为空。这里使用逗号作为分隔符以提高可读性。</p>
<p>后序和中序遍历可以类似地使用公式2和公式3定义。</p>
<p>PostOrder(<em>T</em>) = PostOrder(<em>T</em>_<em>L</em>),
PostOrder(<em>T</em>_<em>R</em>), <em>R</em></p>
<p>公式2</p>
<p>FSM正式定义为<em>M</em> = (<em>S</em>, <em>I</em>, <em>O</em>,
<em>f</em>, <em>g</em>, <em>s</em>₀)。</p>
<table>
<thead>
<tr>
<th>当前状态</th>
<th>输入0</th>
<th>输入1</th>
<th>当前状态</th>
<th>输出</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p><em>S</em> 是状态集合。<em>I</em> 是输入符号集合。</p>
<p><em>O</em> 是输出符号集合。</p>
<p><em>f</em> 是状态转换函数。</p>
<p><em>g</em> 是输出函数。</p>
<p><em>s</em>[0] 是初始状态。</p>
<p>给定状态 <em>S</em>[<em>k</em>] 上的输入 <em>x</em> ∈ <em>I</em>，FSM
按照状态转换函数 <em>f</em> 转换到状态
<em>S</em>[<em>h</em>]，并使用输出函数 <em>g</em> 产生输出 <em>y</em> ∈
<em>O</em>。</p>
<p>图 17.20 展示了一个以 <em>S</em>[0] 作为起始状态、<em>S</em>[1]
作为最终状态的 FSM。这里，<em>S</em> = {<em>S</em>[0], <em>S</em>[1],
<em>S</em>[2]}; <em>I</em> = {0, 1}; <em>O</em> = {2, 3};
<em>f</em>(<em>S</em>[0], 0) = <em>S</em>[2]; <em>f</em>(<em>S</em>[0],
1) = <em>S</em>[1]; <em>f</em>(<em>S</em>[1], 0) = <em>S</em>[2];
<em>f</em>(<em>S</em>[1], 1) = <em>S</em>[2]; <em>f</em>(<em>S</em>[2],
0) = <em>S</em>[2]; <em>f</em>(<em>S</em>[2], 1) = <em>S</em>[0];
<em>g</em>(<em>S</em>[0], 0) = 3; <em>g</em>(<em>S</em>[0], 1) = 2;
<em>g</em>(<em>S</em>[1], 0) = 3; <em>g</em>(<em>S</em>[1], 1) = 2;
<em>g</em>(<em>S</em>[2], 0) = 2; <em>g</em>(<em>S</em>[2], 1) = 3。</p>
<p>不同状态下不同输入的状态转换和输出值也可以用状态表来表示。图 17.20 中
FSM 的状态表如图 17.21
所示。每个输入符号对应的一对值表示新状态和输出符号。图 17.21(a) 和图
17.21(b) 是图 17.20 中 FSM 的替代表示。</p>
<figure>
<img alt="图 17.21. FSM的表格表示" src="media/image-001.png"/>
<figcaption aria-hidden="true">图 17.21. FSM的表格表示</figcaption>
</figure>
<h2 id="6-文法">6. 文法</h2>
<p>自然语言的文法定义了词语组合是否构成有效句子。与自然语言不同，形式语言的语法由一组定义良好的规则指定。形式语言的有效句子可以通过文法借助这些规则来描述，这些规则称为产生式规则(production
rules)。</p>
<p>文法隐含了一种算法，可以生成该语言的所有合法句子。文法有不同的类型。</p>
<p>短语结构文法(phrase structure grammar, PSG)或 Type-0 文法 <em>G</em>
= (<em>V</em>, <em>T</em>, <em>S</em>, <em>P</em>)
是一个四元组，其中：</p>
<ul>
<li><em>V</em> 是词汇表——即词的集合</li>
<li><em>T</em> ⊆ <em>V</em> 是一组称为终结符(terminals)的词</li>
<li><em>S</em> ∈ <em>N</em> 是一个称为起始符号(start
symbol)的特殊词</li>
<li><em>P</em> 是用于将一个句子片段替换为另一个片段的产生式规则集</li>
</ul>
<p>形式语言是有限字母表上的有限长度词或字符串的集合，文法指定了形成这些词或字符串的规则。对文法有效的所有词的完整集合构成该文法的语言。因此，文法
<em>G</em> 是语言 <em>L</em>
的任何紧凑、精确的数学定义，而不是该语言中所有合法句子或句子示例的原始列表。</p>
<p>存在另一个集合 <em>N</em> = <em>V</em> −
<em>T</em>，称为非终结符(nonterminals)。非终结符表示诸如名词之类的概念。产生式规则应用于包含非终结符的字符串，直到字符串中不再存在非终结符。起始符号
<em>S</em> 是一个非终结符。</p>
<p>由形式文法 <em>G</em> 生成的语言，记为 <em>L(G)</em>，是集合
<em>V</em>
上所有字符串的集合，这些字符串可以从起始符号开始，通过应用产生式规则直到字符串中的所有非终结符都被替换而生成。</p>
<p>例如，设 <em>G</em> = ({<em>S</em>, <em>A</em>, <em>a</em>,
<em>b</em>}, {<em>a</em>, <em>b</em>}, <em>S</em>, {<em>S</em> →
<em>aA</em>, <em>S</em> → <em>b</em>, <em>A</em> →
<em>aa</em>})。这里，终结符集合是 <em>N</em> = {<em>S</em>,
<em>A</em>}，其中 <em>S</em> 是起始符号。该文法的三个产生式规则为
<em>P1</em>: <em>S</em> → <em>aA</em>; <em>P2</em>: <em>S</em> →
<em>b</em>; <em>P3</em>: <em>A</em> → <em>aa</em>。</p>
<p>以所有可能的方式应用产生式规则，可以从起始符号生成以下词：</p>
<p><em>S</em> → <em>aA</em> (对起始符号使用 <em>P1</em>) → <em>aaa</em>
(使用 <em>P3</em>) <em>S</em> → <em>b</em> (对起始符号使用
<em>P2</em>)</p>
<p>无法从 <em>G</em> 派生出其他内容。因此，文法 <em>G</em>
的语言只包含两个词：<em>L(G)</em> = {<em>aaa</em>, <em>b</em>}。</p>
<h3 id="61-语言识别">6.1. 语言识别</h3>
<p>形式文法可以根据它们允许的产生式类型进行分类。乔姆斯基层次结构(Chomsky
hierarchy)(由诺姆·乔姆斯基于 1956 年引入)描述了这样一种分类方案。</p>
<figure>
<img alt="图 17.22. 文法的乔姆斯基层次结构" src="media/image-002.png"/>
<figcaption aria-hidden="true">图 17.22.
文法的乔姆斯基层次结构</figcaption>
</figure>
<p>从图 17.22 可以推断出关于不同文法的以下信息：</p>
<ol type="1">
<li>每个正则文法都是上下文无关文法(context-free grammar, CFG)。</li>
<li>每个 CFG 都是上下文敏感文法(context-sensitive grammar, CSG)。</li>
</ol>
<p><em>A</em> 总是可以被 <em>a</em>
替换，无论它出现在什么上下文中。如果一个 CFG
生成一个形式语言，则该语言是上下文无关的(context-free)。上下文无关语言是大多数编程语言语法的理论基础。</p>
<p><em>正则文法(Regular Grammar):</em>
右侧(RHS)的所有片段要么是单个终结符，要么是由一个终结符和一个非终结符构成的序对；如果
<em>A</em> → <em>a</em>，则要么 <em>a</em> ∈ <em>T</em>，<em>a</em> =
<em>cD</em>，要么 <em>a</em> = <em>Dc</em>，其中 <em>c</em> ∈
<em>T</em>，<em>D</em> ∈ <em>N</em>。</p>
<p>如果 <em>a</em> = <em>cD</em>，该文法称为右线性文法(right linear
grammar)。另一方面，如果 <em>a</em> =
<em>Dc</em>，该文法称为左线性文法(left linear
grammar)。右线性文法和左线性文法都是正则文法或 Type-3 文法。</p>
<p>由正则文法 <em>G</em> 生成的语言 <em>L(G)</em> 称为正则语言(regular
language)。</p>
<p>正则表达式(regular expression) <em>A</em>
是由以下信息片段形成的字符串(或模式)：<em>a</em> ∈
Σ(字母表集合)、ε、0，以及运算 OR (+)、PRODUCT (•) 和 CONCATENATION
(<em>)。</em>G* 的语言 <em>L(G)</em> 等于所有匹配 <em>G</em>
的字符串，<em>L(G)</em> = {<em>x</em> ∈ Σ<em>|</em>x* 匹配
<em>G</em>}。</p>
<p>对于任意 <em>a</em> ∈ Σ，<em>L(a)</em> = <em>a</em>; <em>L</em>(ε) =
{ε}; <em>L</em>(0) = 0。</p>
<ul>
<li>作为或运算，<em>L</em>(<em>A</em> + <em>B</em>) =
<em>L</em>(<em>A</em>) ∪ <em>L</em>(<em>B</em>)。</li>
</ul>
<p>• 创建积结构，<em>L</em>(<em>AB</em>) = <em>L(A)</em> •
<em>L(B)</em>。</p>
<ul>
<li>表示连接，<em>L(A</em>)* = {<em>x</em>[1]<em>x</em>[2] …
<em>x</em>[<em>n</em>] | <em>x</em>[<em>i</em>] ∈ <em>L(A)</em> 且
<em>n</em> ≥ 0}。</li>
</ul>
<p>语法（CSG）。[例如，正则表达式 (<em>ab</em>)* ]</p>
<p>3. 每个 CSG 都是一个短语结构 匹配字符串集合：{ε, <em>ab</em>,
<em>abab</em>, <em>ababab</em>,</p>
<p>语法（PSG）。[<em>abababab</em>, …}。正则表达式 (<em>aa</em>)* ]</p>
<p>匹配由单个字母 <em>‘a’</em> 组成的字符串集合，且</p>
<p><em>上下文敏感文法（Context-Sensitive Grammar, CSG）：</em> 所有
长度为偶数。正则表达式 <em>(aaa)*</em> +</p>
<p>RHS 中的片段要么比 [<em>(aaaaa)*</em> 匹配长度为 3 或 5
的倍数的字符串集合。]</p>
<p>LHS 中相应的片段长，要么相等；换句话说，如果 <em>b</em> →
<em>a</em>，则 |<em>b</em>| &lt; |<em>a</em>| 或 <em>a</em> =
φ。如果一个形式语言由 CSG 生成，则该语言是上下文敏感的。</p>
<p><strong>7. 数论</strong> <strong>[1*, c4]</strong></p>
<p><em>上下文无关文法（Context-Free Grammar, CFG）：</em> 所有</p>
<p>LHS 中的片段长度为 1；换句话说，如果 <em>A</em> →
<em>a</em>，则对于所有 <em>A</em> ∈ <em>N</em>，|<em>A</em>| =
1。[数论是纯数学最古老的分支之一，也是最大的分支之一。]</p>
<p>上下文无关这个术语源于以下事实：[它研究的是关于数的问题，通常是指整数，以及分数或有理数。]</p>
<p><a href="#数学基础">数学基础</a> 17-15</p>
<p>不同类型的数包括，例如：自然数、整数、[<em>虚数（Imaginary
Numbers）：</em> 这些数都基于虚数单位 <em>i</em>。这个虚数单位]</p>
<p>有理数、实数和复数。等于 −1 的平方根。<em>i</em>
的任何实数倍数都是虚数</p>
<p>（例如，<em>i</em>、5<em>i</em>、3.2<em>i</em>、−2.6<em>i</em>）。</p>
<p><em>7.1. 数的类型</em></p>
<p><em>复数（Complex Numbers）：</em> 复数是实数和虚数的组合，</p>
<p><em>自然数（Natural Numbers）：</em> 这组数从 1 开始，形式为
<em>a</em> + <em>bi</em>。实部是 <em>a</em>，<em>b</em>
称为虚部。复数集合的</p>
<p>然后是 2、3、4、5，以此类推。0
不在这组数中。这组数中没有[常用数学符号是 C。例如，]</p>
<p>负数或分数。自然数集合的[2 + 3<em>i</em>、3 − 5<em>i</em>、7.3 +
0<em>i</em> 和 0 + 5<em>i</em> 都是复数，]</p>
<p>常用数学符号是 N。[但后两者分别等价于实数。7.3 + 0<em>i</em> 与]</p>
<p><em>整数（Whole Numbers）：</em> 这组数包含所有自然数[实数 7.3
相同。类似地，0 + 5<em>i</em> 与]</p>
<p>加上数字 0。[虚数 5<em>i</em> 相同。所有实数都是虚部为 0
的复数，]</p>
<p>不幸的是，并非所有人都接受上述[所有虚数都是实部为 0 的复数。]</p>
<p>关于自然数和整数的定义。关于是否将 0</p>
<p>包含在自然数集合中，并没有普遍共识。<em>7.2. 整除性</em></p>
<p>许多数学家认为，在欧洲，自然数序列</p>
<p>传统上从 1 开始（希腊人甚至不认为 0 是[初等数论涉及整数间的整除性。设
<em>a</em>、<em>b</em> ∈ Z 且 <em>a</em> ≠ 0。]</p>
<p>一个数）。在 19 世纪，集合论者和其他数学家开始将 0
包含在自然数集合中的惯例。表达式 <em>a</em>|<em>b</em> 表示 <em>a</em>
整除 <em>b</em>，如果 ∃<em>c</em> ∈ Z，</p>
<p><em>整数（Integers）：</em> 这组数包括所有整数[且表达式 <em>b</em> =
<em>ac</em> 意味着存在一个整数 <em>c</em>，使得 <em>c</em> 乘以
<em>a</em> 等于 <em>b</em>。例如，]</p>
<p>及其负数。整数集合的常用数学符号是 Z，3|−12 为真，但 3|7 为假。</p>
<p>即 Z = {…, −3, −2, −1, 0, 1, 2, 3, …}。[如果 <em>a</em> 整除
<em>b</em>，则称 <em>a</em> 是 <em>b</em> 的因子或 <em>a</em> 是
<em>b</em> 的除数，<em>b</em> 是 <em>a</em> 的倍数。]</p>
<p><em>有理数（Rational Numbers）：</em> 这些数可以表示为[当且仅当 2
整除 <em>b</em> 时，<em>b</em> 是偶数。]</p>
<p>两个整数的比。有理数集合的常用符号是 Q。设 <em>a</em>, <em>d</em> ∈ Z
且 <em>d</em> &gt; 0，则 <em>a mod d</em></p>
<p>有理数可以根据小数的表现形式分为[表示除法算法中以 <em>a</em>
为被除数、<em>d</em> 为除数得到的余数 <em>r</em>，即]</p>
<p>三类：(1) 无小数（例如 15）；或 (2) 有小数[<em>a</em> 除以 <em>d</em>
的余数。我们可以]</p>
<p>且小数终止（例如 15.6）；(3) 有小数通过 <em>a − d</em> ⎣
<em>a/d</em>⎦ 计算 <em>(a mod d)</em>，其中 ⎣ <em>a/d</em>⎦</p>
<p>且小数以某种模式重复，如 1.666…（即 5/3）。表示实数的向下取整。</p>
<p><em>无理数（Irrational Numbers）：</em> 这些数无法表示为设 Z[+] =
{<em>n</em> ∈ Z | <em>n</em> &gt; 0} 且 <em>a</em>, <em>b</em> ∈
Z，<em>m</em> ∈</p>
<p>一个整数除以另一个整数。这些数的小数 Z[+]，则 <em>a</em> 与
<em>b</em> 模 <em>m</em> 同余，记作</p>
<p>永不终止且永不重复（例如 π 或 √2）。<em>a</em> ≡ <em>b (mod
m)</em>，当且仅当 <em>m</em> | <em>a − b</em>。</p>
<p><em>实数（Real Numbers）：</em> 这组数包含所有[另外，<em>a</em> 与
<em>b</em> 模 <em>m</em> 同余当且仅当 <em>(a − b) mod m = 0</em>。]</p>
<p>有理数和无理数。代数中使用的数都是实数。实数集合的常用数学符号是
R。</p>
<p><em>7.3. 质数</em></p>
<p>[整数 <em>p</em> &gt; 1 是质数，当且仅当它不是]</p>
<p>[任何两个大于 1 的整数的乘积；]</p>
<p>即，当 <em>p</em> &gt; 1 ∧ ¬ ∃ <em>a</em>, <em>b</em> ∈ N: <em>a</em>
&gt; 1, <em>b</em> &gt; 1, <em>a</em> * <em>b</em> = <em>p</em>
时，<em>p</em> 是质数。</p>
<p>17-16 [<em>SWEBOK</em>] [<em>®</em>][ 指南 V4.0a]</p>
<p>质数 <em>p</em> 的唯一正因子是 选出一名短跑运动员或跳远运动员？</p>
<p>1 和 <em>p</em> 本身。数字 2、13、29、61 [使用加法法则，答案是]</p>
<p>等都是质数。大于 1 的非质数称为 <em>合数（composite
numbers）</em>。200 + 30 = 230。</p>
<p>合数可以由两个大于 1 的整数相乘得到。<em>乘法法则（product
rule）</em> 指出，如果任务 <em>t</em>[<em>1</em> ]有
<em>n</em>[<em>1</em>] 种完成方式，且在第一个任务完成后，第二个任务
<em>t</em>[<em>2</em> ]有 <em>n</em>[<em>2</em>] 种完成方式，</p>
<p>关于质数有许多有趣的应用。</p>
<h2 id="74-最大公约数greatest-common-divisor">7.4. 最大公约数(Greatest
Common Divisor)</h2>
<p>整数 <em>a</em>、<em>b</em> 的最大公约数 <em>gcd</em>(<em>a</em>,
<em>b</em>) 是同时整除 <em>a</em> 和 <em>b</em> 的最大整数
<em>d</em>，即：</p>
<p><em>d</em> = <em>gcd</em> (<em>a</em>, <em>b</em>) for max
(<em>d</em>: <em>d</em>|<em>a</em> ∧ <em>d</em>|<em>b</em>)。</p>
<p>例如，<em>gcd</em> (24, 36) = 12。</p>
<p>如果 <em>gcd</em>(<em>a</em>, <em>b</em>) = 1，则称整数 <em>a</em> 和
<em>b</em> 为<strong>互质</strong>(relatively
prime)或<strong>互素</strong>(coprime)。例如，35 和 6
都不是质数，但它们互质，因为 <em>gcd</em>(35, 6) = 1。</p>
<p>如果整数集合 <em>X</em> = {<em>i</em>[<em>1</em>],
<em>i</em>[<em>2</em>], …} 中任意两个不同元素
<em>i</em>[<em>h</em>]、<em>i</em>[<em>k</em>]（<em>h</em> ≠
<em>k</em>）都互质，则称该集合为互质集合。</p>
<h2 id="8-计数基础">8. 计数基础</h2>
<p><strong>加法法则</strong>(sum rule)指出：如果任务
<em>t</em>[<em>1</em>] 可以用 <em>n</em>[<em>1</em>] 种方式完成，任务
<em>t</em>[<em>2</em>] 可以用 <em>n</em>[<em>2</em>]
种方式完成，且这两个任务不能同时进行，那么完成任一任务有
<em>n</em>[<em>1</em>] + <em>n</em>[<em>2</em>] 种方式。</p>
<p>• 如果 <em>A</em> 和 <em>B</em> 是不相交集合，则 |<em>A</em> ∪
<em>B</em>| = |<em>A</em>| + |<em>B</em>|。 • 一般地，如果
<em>A1</em>、<em>A2</em>、…、<em>An</em> 是不相交集合，则 |<em>A1</em> ∪
<em>A2</em> ∪ … ∪ <em>An</em>| = |<em>A1</em>| + |<em>A2</em>| + … +
|<em>An</em>|。</p>
<p>如果 200 名运动员参加短跑项目，30
名其他运动员参加跳远项目，那么选出两名运动员，使得一名是短跑运动员，另一名是跳远运动员，有多少种方式？</p>
<p><strong>乘法法则</strong>(product
rule)指出：如果一个程序由两个任务组成，任务 <em>t</em>[<em>1</em>]
可以用 <em>n</em>[<em>1</em>] 种方式完成，任务 <em>t</em>[<em>2</em>]
可以用 <em>n</em>[<em>2</em>] 种方式完成，那么完成该程序有
<em>n</em>[<em>1</em>] * <em>n</em>[<em>2</em>] 种方式。</p>
<p>• 如果 <em>A</em> 和 <em>B</em> 是不相交集合，则 |<em>A</em> ×
<em>B</em>| = |<em>A</em>| * |<em>B</em>|。 • 一般地，如果
<em>A1</em>、<em>A2</em>、…、<em>An</em> 是不相交集合，则 |<em>A1</em> ×
<em>A2</em> × … × <em>An</em>| = |<em>A1</em>| * |<em>A2</em>| * …. *
|<em>An</em>|。</p>
<p>使用乘法法则，答案是 200 * 30 = 6,000。</p>
<p><strong>容斥原理</strong>(principle of
inclusion-exclusion)指出：如果任务 <em>t</em>[<em>1</em>] 可以用
<em>n</em>[<em>1</em>] 种方式完成，任务 <em>t</em>[<em>2</em>] 可以用
<em>n</em>[<em>2</em>]
种方式完成，且这两个任务可以同时进行，那么要找出完成这两个任务的总方式数，必须从
<em>n</em>[<em>1</em>] + <em>n</em>[<em>2</em>]
中减去同时完成两个任务的方式数。</p>
<p>• 如果 <em>A</em> 和 <em>B</em> 不是不相交集合，则 |<em>A</em> ∪
<em>B</em>| = |<em>A</em>| + |<em>B</em>| − |<em>A</em> ∩
<em>B</em>|。</p>
<p>换句话说，容斥原理旨在确保两个集合交集中的对象不被重复计数。</p>
<p><strong>递归</strong>(Recursion)是用对象自身来定义该对象的通用术语。存在递归算法、递归定义的函数、关系、集合等。</p>
<p>递归函数是调用自身的函数。例如，我们可以定义 <em>f(n)</em> = 3 *
<em>f</em>(<em>n</em> − 1)，对于所有 <em>n</em> ∈ N 且 <em>n</em> ≠
0，以及 <em>f</em>(0) = 5。</p>
<p>如果算法通过将问题简化为输入更小的同类问题实例来解决问题，则该算法是递归的。</p>
<p>如果单个结果不确定，但许多单个结果的长期模式是可预测的，则称该现象为<strong>随机</strong>(random)现象。</p>
<p>随机现象任何结果的概率是该结果在大量重复中出现的比例。</p>
<p>任何事件 <em>A</em> 的概率 <em>P(A)</em> 满足 0 ≤ <em>P(A)</em> ≤
1。任何概率都是 0 到 1 之间的数字。如果 <em>S</em>
是概率模型中的样本空间，则 <em>P(S)</em> =
1。所有可能的结果合计的概率必须为 1。</p>
<p>如果两个事件没有共同的结果，因此永远不能同时发生，则这两个事件是不相交的。如果
<em>A</em> 和 <em>B</em> 是两个不相交事件，则 <em>P</em>(<em>A</em> 或
<em>B</em>) = <em>P(A)</em> +
<em>P(B)</em>。这称为<strong>不相交事件的加法法则</strong>(addition rule
for disjoint events)。</p>
<p>如果两个事件没有共同结果，则其中一个或另一个发生的概率是它们各自概率的总和。</p>
<p><strong>排列</strong>(Permutation)是对象的一种排列方式，其中顺序很重要且不重复。例如，可以用
[<em>n</em>]<em>P</em>[<em>r</em>] 种方式从总共 <em>n</em>
个对象中按特定顺序选择 <em>r</em> 个对象，其中
[<em>n</em>]<em>P</em>[<em>r</em>] = <em>n</em>! / (<em>n</em> −
<em>r</em>)!。各种符号，如 [<em>n</em>]<em>P</em>[<em>r</em>] 和
<em>P</em>(<em>n</em>, <em>r</em>)，用于表示从 <em>n</em>
个对象的集合中取 <em>r</em> 个对象的排列数。</p>
<p><strong>组合</strong>(Combination)是对象的选择方式，其中顺序不重要且不重复。这与排列不同。</p>
<p>样本空间定义了所有可能结果的集合，而事件是样本空间的子集，表示一个可能的结果或一组结果。</p>
<p><strong>随机变量</strong>(random
variable)是为每个结果分配一个数字的函数或规则。基本上，它是表示实验结果的符号。例如，<em>X</em>
可以是将硬币抛 <em>n</em> 次时正面朝上的次数。类似地，<em>S</em>
可以是雷达探测器测量的过往汽车的速度。</p>
<p>随机变量的值可以是离散的或连续的，具体取决于实验。<strong>离散随机变量</strong>(discrete
random
variable)可以持有所有可能的值(即可以表示所有可能的结果)而不遗漏任何值，尽管可能需要无限长的时间。<strong>连续随机变量</strong>(continuous
random variable)用于测量不可数的值，即使给定无限长的时间。</p>
<p>例如，如果随机变量 <em>X</em> 表示一个结果，该结果是 1 到 100
之间的实数，则 <em>X</em>
可能有无限多个值。因此，即使允许无限长的时间，也永远无法列出 <em>X</em>
的所有可能结果。这里，<em>X</em>
是一个连续随机变量。另一方面，对于同样的 1 到 100
区间，可以使用另一个随机变量 <em>Y</em> 来列出</p>
<p>因为顺序不重要。如果只是改变了顺序（而不是成员），则不会形成新的组合。可以用
[<em>n</em>]<em>C</em>[<em>r</em>] 种方式以任意顺序从总共 <em>n</em>
个对象中选择 <em>r</em> 个对象，其中 [<em>n</em>]<em>C</em>[<em>r</em>]
= <em>n</em>! / [<em>r</em>! * (<em>n</em> − <em>r</em>)!]。</p>
<h2 id="9-离散概率-1-c7">9. 离散概率 <strong>[1*, c7]</strong></h2>
<p><em>概率</em>是对随机性的数学描述。概率和随机性的基本定义在前面的部分已经提供。这里，我们从概率分布和离散概率背后的概念开始。</p>
<p><em>概率模型</em>是对随机现象的数学描述，由两部分组成：样本空间
<em>S</em> 和为事件分配概率的方法。</p>
<p>这里，<em>Y</em> 是一个离散随机变量。</p>
<p>大写字母，比如
<em>X</em>，将表示随机变量的<em>名称</em>。其小写对应字母，<em>x</em>，将表示随机变量的<em>值</em>。</p>
<p>随机变量 <em>X</em> 等于 <em>x</em> 的概率是：</p>
<p><em>P</em>(<em>X</em> = <em>x</em>) 或者更简单地写作
<em>P(x)</em>。</p>
<p><em>概率分布（密度）函数（PDF）</em>是描述随机变量的值以及与这些值相关的概率的表格、公式或图形。与离散随机变量相关的概率具有以下属性：</p>
<figure>
<img alt="图17.23. 掷骰子的离散概率函数" src="Figure%2017.23"/>
<figcaption aria-hidden="true">图17.23.
掷骰子的离散概率函数</figcaption>
</figure>
<table>
<thead>
<tr>
<th><strong><em>X</em></strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>P(x)</em></td>
<td>1/6</td>
<td>1/6</td>
<td>1/6</td>
<td>1/6</td>
<td>1/6</td>
<td>1/6</td>
</tr>
</tbody>
</table>
<p>• 0 ≤ <em>P(x)</em> ≤ 1 对所有 <em>x</em> 成立 • Σ<em>P(x)</em> =
1</p>
<p><em>离散概率分布</em>可以表示为一个离散随机变量。</p>
<p><em>概率分布模型的均值</em> μ
是各个事件及其结果概率的乘积项之和。换句话说，对于样本空间 <em>S</em>
中可能的结果 <em>x</em>[<em>1</em>], <em>x</em>[<em>2</em>], …,
<em>x</em>[<em>n</em>]，如果 <em>p</em>[<em>k</em>] 是结果
<em>x</em>[<em>k</em>] 的概率，则该概率的均值为 <em>μ</em> =
<em>x</em>[<em>1</em>]<em>p</em>[<em>1</em>] +
<em>x</em>[<em>2</em>]<em>p</em>[<em>2</em>] + … +
<em>x</em>[<em>n</em>]<em>p</em>[<em>n</em>]。图17.23中分布的概率密度均值如下：</p>
<p>1 * (1/6) + 2 * (1/6) + 3 * (1/6) + 4 * (1/6) + 5 (1/6) + 6 * (1/6) =
21 * (1/6) = 3.5</p>
<p>这里，样本空间指的是所有可能结果的集合。</p>
<p><em>离散概率模型的方差</em> σ[2] 为 σ[<em>2</em>] =
(<em>x</em>[<em>1</em>] – <em>μ</em>)[2]<em>p</em>[<em>1</em>] +
(<em>x</em>[<em>2</em>] – <em>μ</em>)[2]<em>p</em>[<em>2</em>] + … +
(<em>x</em>[<em>k</em>] – <em>μ</em>)[2]<em>p</em>[<em>k</em>]。</p>
<p><em>标准差</em> σ 是方差的平方根。对于图17.23中的概率分布，方差
σ[<em>2</em>] 如下：</p>
<p>σ[<em>2</em>] = [(1 – 3.5)[2] * (1/6) + (2 – 3.5)[2] * (1/6) + (3 –
3.5)[2] * (1/6) + (4 - 3.5)[2] * (1/6) + (5 – 3.5)[2] * (1/6) + (6 –
3.5)[2] * (1/6)] = (6.25 + 2.25 + 0.25 + 0.5 + 2.25 + 6.25) * (1/6) =
17.5 * (1/6) = 2.90 ∴ 标准差 s = 1.70</p>
<p>这些数字旨在从重复实验中得出平均值。这基于概率中最重要的原理，即重复实验的平均值可能接近一次实验的期望值。而且，随着实验次数的增加，平均值更可能更接近任何一次实验的期望值。</p>
<h2 id="10-数值精度准确度和误差-2-c1">10. 数值精度、准确度和误差
<strong>[2*, c1]</strong></h2>
<p>数值分析的主要目标是开发高效的算法来计算函数的精确数值，以及找到代数方程和微分方程、优化问题等的解。</p>
<p>数字计算机只能存储有限的数字。数字计算机无法表示任何无限大的数字，无论是整数、有理数，还是任何实数或复数[见第7节，数论]。近似的数学对于在计算机可以处理的有限范围内处理数字至关重要。</p>
<p>计算机中的每个数字都被分配一个位置（例如，一个地址或寄存器），并由一定数量的二进制位或比特组成。一个
<em>k</em> 位的位置可以存储 <em>N</em> = 2[<em>k</em>]
个不同的数字。一个32位的位置可以存储 <em>N</em> = 2[32] ≈ 4.3 × 10[9]
个不同的数字，而一个64位的位置可以存储 <em>N</em> = 2[64] ≈ 1.84 ×
10[19]
个不同的数字。问题是如何分配这些数字以在实际计算中实现最大效率和准确度。</p>
<p>一种选择是均匀分布这些数字，从而产生定点算术。在这个系统中，第一位表示符号，其余位表示大小。小数点，更准确地说是二进制点（整数值和小数值之间的过渡），可以在任何地方。整数通过将二进制点放在最低有效位的右侧来表示，可以存储
−2[<em>k</em>−1]−1 和 2[<em>k</em>−1]
之间的整数。将二进制点放在最低有效位的左侧可以表示非整数值。</p>
<p>另一种选择是将数字紧密地排列在一起，比如以 2[<em>−n</em>]
的均匀间隙，从而将总共 <em>N</em> 个数字均匀分布在区间
−2[<em>−n</em>−1]<em>N</em> &lt; <em>x</em> ≤ 2[<em>−n</em>−1]<em>N</em>
上。位于间隙之间的实数通过<em>舍入</em>（表示最接近的精确代表）或<em>截断</em>（表示紧邻的精确代表）来表示。</p>
<p><em>有效数字</em>是一个数字中已知正确的数字。在测量中，包含一个不确定的数字。例如，用尺子测量长度为15.5毫米，最大允许误差为±0.5毫米，有两个有效数字，而使用卡尺测量相同长度并记录为15.47毫米，最大允许误差为±0.01毫米</p>
<p>下方（如果是负数则在上方）的最大允许误差有三位有效数字。</p>
<p>超出范围的数字必须用可表示的最大数字（或最大负数）来表示。这成为溢出的符号，当计算产生超出范围的值时就会发生溢出。</p>
<p>当处理速度是一个重要瓶颈时，定点表示法可以成为一种有吸引力且更快的替代方案，相比实践中最常用的更繁琐的浮点运算。</p>
<p>精度和准确度是数值分析中的重要术语。</p>
<p><strong>准确度(Accuracy)</strong>
是指测量值或计算值与真实值的接近程度。</p>
<p>另一方面，<strong>精度(Precision)</strong>
是指针对同一事物的两个或多个测量值或计算值之间的接近程度。换句话说，精度是指一个数字表示精确值的接近程度。</p>
<p>设 <em>x</em> 为实数，<em>x*</em> 为近似值。近似值 <em>x*</em> ≈
<em>x</em> 的<strong>绝对误差(absolute error)</strong> 定义为 |
<em>x*</em> − <em>x</em> |。<strong>相对误差(relative error)</strong>
定义为绝对误差与 <em>x</em> 大小的比值，即 |<em>x*</em> − <em>x</em>| /
| <em>x</em> |，这里假设 <em>x</em> ≠
0；否则相对误差未定义。例如，1,000,000 是 1,000,001 的近似值，绝对误差为
1，相对误差为 10[−6]，而 10 是 11 的近似值，绝对误差为 1，相对误差为
0.1。通常，相对误差更直观，是确定误差大小的首选方法。当前的惯例是误差总是
≥ 0，并且当且仅当近似值是精确值时误差 = 0。</p>
<p>如果近似值 <em>x*</em> 的相对误差 &lt; 5 ×
10[<em>−k</em>−1]，则该近似值有 <em>k</em>
位<strong>有效十进制数字(significant decimal digits)</strong>。这意味着
<em>x*</em> 的第一个非零数字后的前 <em>k</em> 位数字与 <em>x</em>
的相同。</p>
<h2 id="11-代数结构algebraic-structures">11. 代数结构(Algebraic
Structures)</h2>
<p>本节介绍高等代数中使用的几种表示方法。代数结构由一个或两个在某些运算下封闭的集合组成，并满足若干公理（包括没有公理的情况）。群、幺半群、环和格是代数结构的例子。本节定义群、幺半群和环。</p>
<h3 id="111-群group">11.1. 群(Group)</h3>
<p>在二元运算 • 下封闭的集合 <em>S</em>
构成群，如果该二元运算满足以下四个条件：</p>
<p>• <strong>结合律(Associative)</strong>：∀ <em>a</em>, <em>b</em>,
<em>c</em> ∈ <em>S</em>，等式 (<em>a</em> • <em>b</em>) • <em>c</em> =
<em>a</em> • (<em>b</em> • <em>c</em>) 成立。 •
<strong>单位元(Identity)</strong>：存在单位元 <em>I</em> ∈
<em>S</em>，使得对所有 <em>a</em> ∈ <em>S</em>，<em>I</em> • <em>a</em>
= <em>a</em> • <em>I</em> = <em>a</em>。 •
<strong>逆元(Inverse)</strong>：每个元素 <em>a</em> ∈ S
都有一个关于二元运算的逆元 <em>a</em>′ ∈ <em>S</em>，即 <em>a</em> •
<em>a</em>′ = <em>I</em>；例如，整数集 Z
关于加法运算是一个群。该集合的单位元对于加法运算是 0。对于 ∀ <em>x</em>
∈ Z，<em>x</em> 的逆元是 −<em>x</em>，它也包含在 Z 中。 •
<strong>封闭性(Closure property)</strong>：∀ <em>a</em>, <em>b</em> ∈
<em>S</em>，运算 <em>a</em> • <em>b</em> 的结果 ∈ <em>S</em>。</p>
<p>满足交换律（即 <em>a</em> • <em>b</em> = <em>b</em> •
<em>a</em>）的群称为<strong>交换群(commutative group)</strong>
或<strong>阿贝尔群(Abelian group)</strong>。</p>
<p>自然数集 N（关于加法运算）不是群，因为在自然数集中任何 x &gt; 0
都没有逆元。（第三个条件，即逆元条件被违反。）然而，自然数集具有一些结构。</p>
<p>具有结合运算（第一个条件）的集合称为<strong>半群(semigroups)</strong>；如果它们还有单位元（第二个条件），则称为<strong>幺半群(monoids)</strong>。自然数集在加法下是幺半群的一个例子，这种结构不完全是群，因为它缺少每个元素在运算下都有逆元的要求。</p>
<p>幺半群是在单个结合二元运算 • 下封闭的集合 <em>S</em>，并且有单位元
<em>I</em> ∈ <em>S</em>，使得对所有 <em>a</em> ∈ <em>S</em>，<em>I</em>
• <em>a</em> = <em>a</em> • <em>I</em> =
<em>a</em>。幺半群必须至少包含一个元素。自然数集 N
在加法下构成交换幺半群，单位元为 0。同一个自然数集 N
在乘法下也构成幺半群，单位元为 1。正整数集 P
在乘法下构成交换幺半群，单位元为 1。</p>
<p>可以注意到，与群不同，幺半群中的元素不需要有逆元。幺半群也可以看作是具有单位元的半群。</p>
<p><strong>子群(subgroup)</strong> 是包含在更大的群 <em>G</em> 中的群
<em>H</em>，使得 <em>H</em> 的单位元与 <em>G</em> 的单位元相同。</p>
<p>群 <em>G</em> 是<strong>循环群(cyclic)</strong> 如果 <em>G</em> =
{<em>a</em>[<em>n</em>]，对于任意整数 <em>n</em>}。</p>
<p>由于群中某个元素生成的任何群都是该群的子群，因此证明包含 <em>a</em>
的群 <em>G</em> 的唯一子群就是 <em>G</em> 本身就足以证明 <em>G</em>
是循环群。例如，群 <em>G</em> = {0, 2, 4, 6, 1, 3, 5, 7}，关于模 8
加法运算，是循环群。子群 <em>J</em> = {0, 4} 和 <em>H</em> = {0, 2, 4,
6} 也是循环群。</p>
<h3 id="112-环ring">11.2. 环(Ring)</h3>
<p>如果我们取一个阿贝尔群并在其上定义第二个运算，就会发现一个不同于单纯群的新结构。如果这第二个运算是结合的，并且对第一个运算满足分配律，那么我们就有了一个环。</p>
<p><strong>环(ring)</strong> 是形如 (<em>S</em>, +, •) 的三元组，其中
(<em>S</em>, +) 是阿贝尔群，(<em>S</em>, •) 是半群，并且 • 对 +
满足分配律；即 ∀ <em>a</em>, <em>b</em>, <em>c</em> ∈ <em>S</em>，等式
<em>a</em> • (<em>b</em> + <em>c</em>) = (<em>a</em> • <em>b</em>) +
(<em>a</em> • <em>c</em>) 成立。此外，如果 •
是交换的，则称该环是交换环。如果 • 运算有单位元，则称该环有单位元。</p>
<p>作为例子，(Z, +, *)，即整数集 Z
及其通常的加法和乘法运算，是一个环。</p>
<p><em>h</em>[1] 和 <em>h</em>[2] 包含在 <em>H</em> 中，因此
<em>h</em>[1] • <em>h</em>[2]
也是如此。由于这个环是交换环或阿贝尔环，<em>G</em> 的每个元素都包含在
<em>H</em> 中，并且当乘法运算满足交换律时，这就是一个环。由于 (Z, *)
是交换的，所以这是一个交换环。该环以 1 作为其单位元。</p>
<p>因此，<em>H</em> 的元素配备上 <em>G</em> 中的群运算限制到 <em>H</em>
上，形成一个群。需要注意的是，第二个运算可能没有单位元，我们也不需要为每个元素找到关于第二个运算的逆元。</p>
<p>给定群 <em>G</em> 的任意子集 <em>S</em>，由 <em>S</em> 生成的子群由
<em>S</em> 的元素及其逆元的乘积组成。它是包含 <em>S</em> 的 <em>G</em>
的最小子群。至于分配律的含义，直观地说，就是我们在初等数学中执行以下运算时所做的：<em>a</em>
* (<em>b</em> + <em>c</em>) = (<em>a</em> * <em>b</em>) + (<em>a</em> *
<em>c</em>)。</p>
<p>例如，设 <em>G</em> 是一个阿贝尔群，其元素为 <em>G</em> = {0, 2, 4,
6, 1, 3, 5, 7}，群运算是模 8 加法。这个群有一对非平凡子群：<em>J</em> =
{0, 4} 和 <em>H</em> = {0, 2, 4, 6}，其中 <em>J</em> 也是 <em>H</em>
的子群。</p>
<p>在群论中，<strong>循环群</strong>(cyclic
group)是可以由单个元素生成的群，即该群有一个元素
<em>a</em>（称为群的<strong>生成元</strong>(generator)），使得当以乘法形式表示时，群的每个元素都是
<em>a</em> 的幂。</p>
<p><strong>域</strong>(field)是一个环，其中集合的元素（除 0
外）在第二个运算下形成阿贝尔群。域的一个简单例子是有理数域 (Q, +,
*)，具有通常的加法和乘法运算。这些数的形式为 <em>a</em>/<em>b</em> ∈
R，其中 <em>a, b</em> 是整数且 <em>b</em> ≠ 0。这种分数的加法逆元就是
−<em>a</em>/<em>b</em>，乘法逆元是 <em>b/a</em>（前提是 <em>a</em> ≠
0）。</p>
<p><strong>数学基础</strong> 17-21</p>
<h2 id="12-工程微积分">12. 工程微积分</h2>
<p>微积分是数学的一个分支，研究连续变化、函数的导数和积分，使用最初基于无穷小差分求和的方法。工程微积分专注于学习工程应用中的解析几何和向量。</p>
<p>向量微积分处理三维欧几里得空间中向量场的微分和积分。</p>
<p>工程微积分包括以下内容：</p>
<p>• 极限 • 连续性 • 微分 • 积分 • 超越函数 • 向量微积分</p>
<p>极限是微积分的基础。对于函数 f(x)，函数在点 a
处的极限是函数在该点达到的值。</p>
<p>L = lim f(x) x→a</p>
<p>如果函数在区间 [a, b] 中的每个点都连续，则称该函数在区间 [a, b]
上<strong>连续</strong>。</p>
<p>lim f(x) = f(a) x→a</p>
<p>微积分的两个主要元素是微分学和积分学。</p>
<p>•
<strong>微分学</strong>分析一个量相对于另一个量的变化率。从几何角度看，它是函数图像切线的斜率。<em>y</em>
相对于 <em>x</em> 的变化率表示为 <em>dy/dx</em>。</p>
<p>• <strong>积分学</strong>分析诸如函数所围成的面积或体积等概念。</p>
<p><strong>超越函数</strong>(transcendental
function)与代数函数相对，是一个不满足多项式方程的解析函数。</p>
<p>软件工程师应该通过案例研究来学习工程微积分。这些概念是分析和推断数据所必需的。</p>
<h2 id="13-新进展">13. 新进展</h2>
<h3 id="131-计算神经科学">13.1. 计算神经科学</h3>
<p><strong>计算神经科学</strong>(Computational
Neurosciences)是神经科学的一个分支，使用数学模型、计算机模拟和大脑抽象来理解和分析神经系统的认知能力。这使得人们能够学习控制论、信息论、定量心理学、机器学习、人工智能、创造力、想象力以及连接主义等内容。</p>
<p>计算神经科学的核心假设是大脑在进行计算。一般来说，计算机是一个动态系统，其状态变量编码了关于外部世界的信息。简而言之，计算等于编码加上动力学。一些神经科学家研究信息如何在神经活动和大脑的其他动态变量中编码。其他人则试图描述这些动态变量如何随时间演化。</p>
<p>神经动力学的研究可以进一步细分为两个独立的方向。一个传统以 Hodgkin 和
Huxley
的工作为代表，专注于单个神经元的生物物理学。另一个专注于网络的动力学，关注神经元之间相互作用产生的现象。因此，计算神经科学可以分为三个子专业：神经编码、神经元生物物理学和神经网络。</p>
<h3 id="132-基因组学">13.2. 基因组学</h3>
<p>对来自给定生物体的染色体核苷酸序列的计算机分析称为”基因组”(genome)。基因组研究旨在了解基因和遗传信息如何在基因组内组织，以及这种组织如何决定其功能。基因组是生物体的遗传物质，包含遗传特征，由
DNA 构成。</p>
<p>基因组学处理基因组的结构、功能、定位、进化和编辑，包括基因组的测序和分析。</p>
<p>17-22 <em>SWEBOK® GUIDE V4.0a</em></p>
<p><strong>主题与参考资料对照矩阵</strong></p>
<p><strong>1. 基本逻辑</strong> [c1]</p>
<p><strong>2. 证明技术</strong> [c1]</p>
<p>正在以下领域进行大量研究工作：</p>
<p><strong>3. 集合、关系、函数</strong> [c2]</p>
<p><strong>4. 图和树</strong> [c10, c11]</p>
<p><strong>5. 有限状态机</strong> [c13]</p>
<p><strong>6. 文法</strong> [c13]</p>
<p><strong>7. 数论</strong> [c4]</p>
<p><strong>8. 计数基础</strong> [c6]</p>
<p><strong>9. 离散概率</strong> [c7]</p>
<p><strong>10. 数值精度、准确度和误差</strong> [c1]</p>
<p><strong>11. 代数结构</strong></p>
<p><strong>12. 微积分</strong></p>
<p>预防和治疗性医疗保健，特别是在基因疾病的检测、分析和修复领域。这些包括基因组数据安全、基因组数据共享、基因组数据分析效率等。</p>
<p>基因组学涵盖多种技术和方法，包括DNA测序、生物信息分析、遗传变异研究、计算建模等。</p>
<p>DNA测序技术和生物信息分析的进步显著推动了基因组学的发展，使得能够对各种生物体的基因组进行详细研究。</p>
<p>由于基因组测序获得的核苷酸序列代表大量数据，需要信息学来处理这些数据。该领域特定软件的开发在很大程度上依赖于软件工程。</p>
<p><strong>参考文献</strong></p>
<p>[1*] K. Rosen, <em>Discrete Mathematics and Its Applications</em>,
8th ed., McGraw-Hill, 2018.</p>
<p>[2*] E.W. Cheney and D.R. Kincaid, <em>Numerical Mathematics and
Computing</em>, 7th ed., Addison Wesley, 2020.</p>
<h2 id="第18章-1"><strong>第18章</strong></h2>
<p>工程基础</p>
<p><strong>缩略语</strong></p>
<p>CAD 计算机辅助设计</p>
<p>CMMI 能力成熟度模型集成</p>
<p>PMF 概率质量函数</p>
<p>PDF 概率密度函数</p>
<p>RCA 根因分析</p>
<p>SDLC 软件开发生命周期</p>
<p><strong>引言</strong></p>
<p>电气和电子工程师协会(IEEE)将工程定义为”将系统化、规范化、可量化的方法应用于结构、机器、产品、系统或过程”[1]。随着软件工程理论和实践的成熟，越来越明显的是，软件工程作为一门学科是基于所有工程学科共有的技能和知识。</p>
<p>本知识领域(KA)探讨与其他工程学科相关且同样适用于软件工程的工程基础。重点是涵盖支持其他知识领域的主题，同时尽量减少与本<em>指南</em>其他部分内容的重复。</p>
<p><strong>工程基础知识领域的主题分解</strong></p>
<p>工程基础知识领域的主题分解如图18.1所示。</p>
<p><strong>1. 工程过程</strong> <strong>[2*, c4]</strong></p>
<p>所有工程学科通用的工程过程在软件工程经济学知识领域中有更充分的讨论。这里包含一个简要的高层次总结。图18.2显示了过程流程。</p>
<p>工程过程必然是迭代的；在任何时点获得的知识都可能与早期步骤相关，从而触发迭代。这些步骤简要定义如下：</p>
<p>• <strong>理解真正的问题</strong> —
当识别出一个需求且现有解决方案无法满足该需求时，工程就开始了。然而，需要解决的问题并不总是工程师被要求解决的问题。使用根因分析技术(本知识领域后面讨论)来发现需要解决的根本问题。</p>
<p>• <strong>定义选择标准</strong> —
工程决策必须考虑各种因素；例如，必须考虑财务标准，如软件工程经济学知识领域中所讨论的。务必识别所有相关的选择标准。</p>
<p>• <strong>识别所有合理的、技术上可行的解决方案</strong> —
最佳解决方案很少是第一个想到的解决方案。因此，要考虑多个技术上可行的解决方案，以确保最优解决方案在考虑的集合中。</p>
<p>• <strong>根据选择标准评估每个解决方案</strong> —
确定每个技术上可行的解决方案在满足各种标准(例如财务标准)的同时，如何很好地满足需求。</p>
<p>• <strong>选择首选方案</strong> —
识别哪个技术上可行的解决方案最能满足选择标准。</p>
<p>• <strong>监控所选解决方案的性能</strong> —
工程过程必然依赖于估计，而这些估计可能是错误的。因此，</p>
<p><strong>工程基础</strong></p>
<figure>
<img alt="图18.1. 工程基础知识领域的主题分解" src="media/figure-18-1.png"/>
<figcaption aria-hidden="true">图18.1.
工程基础知识领域的主题分解</figcaption>
</figure>
<p><strong>工程过程</strong> | <strong>经验方法和技术</strong> |
<strong>统计分析</strong> | <strong>建模、仿真和原型</strong> |
<strong>根因分析</strong> | <strong>抽象和封装</strong> |
<strong>工业4.0和软件工程</strong> | <strong>测量</strong> |
<strong>工程标准</strong></p>
<p>工程设计中的层次 | 抽象层次 | 设计实验 | 分析单元 | 建模 |
测量的层次(尺度) | 根因分析技术 | 仿真</p>
<p>工程教育 | 封装 | 观察性研究 | 测量的影响 | 基于根因的改进 |
(抽样单元)、总体和样本 | 原型</p>
<p>设计作为问题解决活动 | 编程语言理论上的替代抽象 | 回顾性研究 |
直接和派生测量 | 相关和回归</p>
<p>可靠性和有效性</p>
<p>评估可靠性</p>
<p>目标-问题-度量范式：为什么要测量？</p>
<p>必然依赖于估计，而这些估计可能是错误的。因此，在众多备选方案中最能满足所提出需求的解决方案，在经济上是可行的。</p>
<p>在商业中，目标可能是促进</p>
<p>对于评估所选替代方案在实际环境中的表现至关重要，如有必要（且可能），决定其他替代方案是否可能更好。</p>
<p>本知识领域的其余大部分内容详细阐述了这一高层工程过程的细节。</p>
<p><strong>2. 工程设计</strong> <strong>[3*, c1s2-s4]</strong></p>
<p>产品的设计会影响甚至决定其生命周期成本。这对制造产品和软件都适用。软件设计受到要实现的功能特性和要达到的质量属性的指导。在软件工程的语境中，“设计”具有特定的含义；虽然本节讨论的工程设计与软件架构知识领域和软件设计知识领域中讨论的软件工程设计之间存在共性，但也有许多差异。例如，工程设计的范围通常被认为比软件设计的范围更广。</p>
<p>许多学科涉及解决只有一个正确答案的问题。在工程中，大多数问题有许多解决方案，重点是找到一个可行的解决方案。</p>
<p>市场中的创新，产品定义可能源于商业案例。无论起源如何，可能的解决方案通常受到明确施加的限制的约束，例如成本、可用资源以及学科或领域知识的状态。在工程问题中，隐含约束（例如材料的物理属性或物理定律）有时会限制给定问题的可行解决方案集合。</p>
<p><em>2.1. 工程教育中的工程设计</em></p>
<p>设计被指导用于实现的功能特性和要达到的质量属性。</p>
<p>各种工程教育认证机构，包括加拿大工程认证委员会和工程技术认证委员会(ABET)，都高度重视工程设计，这从他们在该领域的高期望中可以明显看出。设计知识领域，但也存在许多差异。例如，工程设计的范围通常被认为比软件设计的范围更广得多。</p>
<p>加拿大工程认证委员会要求工程专业学生具有特定水平的工程设计经验和课程学习，并对教授此类课程或指导设计项目的教师成员提出特定资格要求。该组织的认证标准指出：</p>
<p><a href="#工程基础">工程基础</a> 18-3</p>
<figure>
<img alt="图18.2. 工程过程" src="media/image-placeholder.png"/>
<figcaption aria-hidden="true">图18.2. 工程过程</figcaption>
</figure>
<p><em>设计：为复杂、开放式工程问题设计解决方案的能力，以及设计满足特定需求的系统、组件或流程的能力，适当关注健康和安全风险、适用标准以及经济、环境、文化和社会考量
[4, p7]。</em></p>
<p>同样，ABET对工程设计的定义如下：</p>
<p><em>…一个设计系统、组件或流程以满足期望需求和规范的过程，需在约束条件内完成。这是一个迭代的、创造性的决策过程，其中应用基础科学、数学和工程科学将资源转化为解决方案
[5, p7]。</em></p>
<p>因此，工程设计对所有工程师的培训和教育至关重要。本节的其余部分重点关注工程设计的各个方面。</p>
<p><em>2.2. 作为问题解决活动的设计</em> [3*, c1s4, c2s1, c3s3] [6*,
c5s1]</p>
<p>工程设计主要是一种问题解决活动。找到解决方案特别具有挑战性，因为设计问题往往是开放式的、定义模糊的，并且通常有几种方法可以解决同一问题。设计通常被认为是一个<em>棘手问题(wicked
problem)</em> —— 这一术语由Horst
Rittel在20世纪60年代创造，当时设计方法是一个备受关注的主题。Rittel寻求一种替代许多设计师和设计理论家正在探索的线性、逐步过程的方法，并认为设计师解决的大多数问题都是棘手问题。正如McConnell所解释的，棘手问题呈现出一个悖论：只有通过解决它或解决其中一部分才能定义它。然而，该解决方案并不是最终解决方案；必须解决一次棘手问题以明确定义它，然后再次解决以创建有效的解决方案。几十年来，这对软件设计师来说一直是一个重要的见解
[6*, c5s1]。</p>
<p><strong>3. 抽象与封装</strong> <strong>[6*, c5s2-4]</strong></p>
<p>抽象是与问题解决相关的一项不可或缺的技术。它既指概括化的过程，也指概括化的结果，即通过减少关于概念、问题或可观察现象的信息来专注于”大局”。在任何工程工作中，最重要的技能之一是能够适当地框定抽象层次。</p>
<p>根据Voland的说法，“通过抽象，我们从更高的概念理解层次来看待问题及其可能的解决路径。因此，我们可能会更好地准备识别问题不同方面之间可能的关系，从而产生更具创造性的设计解决方案”
[2*]。这在计算机科学中普遍适用（例如硬件与软件），在软件工程中尤其如此（例如，数据结构与数据流）。</p>
<p>18-4 [<em>SWEBOK</em>] [<em>®</em>][ 指南 V4.0a]]</p>
<p>根据情况需要进行抽象。通常，这些不同的抽象层次被组织在一个层次结构中。有许多方法可以构建特定的层次结构，用于确定具体内容的标准</p>
<p>Dijkstra指出，“抽象的目的不是为了模糊，而是创建一个新的语义层次，在这个层次上可以做到绝对精确”[7]。</p>
<p><strong>3.1. 抽象层次</strong></p>
<p>在进行抽象时，我们一次只专注于全局图景的一个”层次”，确信我们可以有效地连接上层和下层。虽然我们专注于一个层次，但抽象并不意味着对相邻层次一无所知。抽象层次不一定对应于现实或问题域中的离散组件，而是对应于定义明确的标准接口，例如应用程序编程接口(API)。标准接口提供了诸多优势，如可移植性、更容易的软硬件集成和更广泛的使用。</p>
<p>每个层次的特定标准接口可能因执行工作的个人而异。有时，抽象层次结构是顺序的，这意味着每个层次只有一个前驱(下层)层次和一个后继(上层)层次——除了最上层(没有后继)和最底层(没有前驱)。然而有时，层次结构以树形结构组织，这意味着每个层次可以有多个前驱层次但只有一个后继层次。偶尔，层次结构可以具有多对多结构，其中每个层次具有多个前驱和后继。层次结构永远不包含循环。</p>
<p><strong>3.2. 封装</strong></p>
<p><em>封装(Encapsulation)</em>
是用于实现抽象的一种机制。当我们在一个抽象层次上工作时，关于该层次上下层次的信息被封装起来。这可以是关于概念、问题或可观察现象的信息，或者是对这些实体的允许操作的信息。封装通常意味着隐藏抽象所提供接口之上层次的底层细节。例如，隐藏关于对象的信息是有用的，因为我们不需要知道对象如何表示或对象上的操作如何实现的细节。</p>
<p><strong>3.3. 层次结构</strong></p>
<p>当我们在问题表述和解决方案中使用抽象时，我们可能在不同时间使用不同的抽象——换句话说，我们在不同的层次上工作。层次结构在任务分解中经常自然形成。通常，任务分析可以分层分解，从组织的较大任务和目标开始，将每个任务分解为可以再次细分的较小子任务。这种将任务持续划分为更小任务的过程产生了任务和子任务的层次结构。</p>
<p><strong>3.4. 替代抽象</strong></p>
<p>有时，对同一问题保持多个替代抽象有助于记住不同的视角。例如，我们可以在同一抽象层次上为同一软件拥有类图(class
diagram)、状态图(state chart)和序列图(sequence
diagram)。这些替代抽象不形成层次结构，而是相互补充，有助于阐明问题及其解决方案。尽管有益，但保持替代抽象同步有时很困难。</p>
<p><strong>4. 实证方法和实验技术 [8*, c1]</strong></p>
<p>工程过程涉及提出解决方案或解决方案模型，并进行实验或测试以研究这些提出的解决方案或模型。因此，工程师必须了解如何创建实验并分析结果以评估提出的解决方案。实证方法和实验技术帮助工程师描述和理解其观察中的变异性(variability)，识别该变异性的来源，并做出决策。</p>
<p>工程工作中常用的三种实证研究类型是设计实验、观察研究和回顾性研究。以下简要描述了常用方法。</p>
<p><strong>4.1. 设计实验</strong></p>
<p><em>设计实验</em>或<em>受控实验</em>通过操纵一个或多个自变量来测量它们对一个或多个因变量的影响，从而检验假设。进行此实验的先决条件是存在明确的假设。因此，工程师需要了解如何制定明确的假设。</p>
<p>设计实验允许工程师精确地确定变量之间的关系，特别是它们之间是否存在因果关系。自变量值的每个组合是一个<em>处理(treatment)</em>。最简单的实验只有两个处理，代表单个自变量的两个水平(例如：</p>
<p>[工程基础] 18-5</p>
<p>相关且现象与上下文之间的边界不清晰的情况)。</p>
<p><strong>4.3. 回顾性研究</strong></p>
<p><em>回顾性研究</em>涉及对历史数据的分析，因此也称为历史研究。这种类型的研究使用随时间归档的数据(关于某种现象)。然后分析这些归档数据以找到变量之间的关系，预测未来事件或识别趋势。一个局限性是分析的质量取决于归档数据的质量，而历史数据可能不完整、测量不一致或不正确。</p>
<p><strong>5. 统计分析 [8*, c9s1, c2s1] [9*, c11s3]</strong></p>
<p>工程师必须了解产品和过程特征如何变化。工程师经常遇到必须研究不同变量之间关系的情况。大多数研究使用样本，但结果需要针对整个总体来理解。因此，工程师必须了解用于收集和解释可靠数据(抽样和分析)的统计技术，以得出可以推广的结果。下面讨论这些技术。</p>
<p><strong>5.1. 分析单元(抽样单元)</strong></p>
<p>使用工具与不使用工具）。当使用超过两个水平、超过一个自变量或任何因变量时，会出现更复杂的实验设计。</p>
<p><strong>总体、样本</strong></p>
<p><strong>分析单位</strong>。在任何实证研究中，研究人员必须基于选定的单位进行观察，这些单位称为分析单位或抽样单位。这些单位必须明确识别并适合分析。例如，在软件产品可用性感知的研究中，用户或软件功能可能是分析单位。</p>
<h3 id="42-观察性研究">4.2. 观察性研究</h3>
<p><strong>观察性</strong>或<strong>案例研究</strong>是一种在现实世界背景下对过程或现象进行观察的实证调查。虽然实验故意忽略背景，但观察性研究或案例研究包含背景。案例研究在关注”如何”和”为什么”的问题时最有用，当涉及人员的行为无法被操纵时，以及当情境条件相关时。</p>
<p><strong>总体</strong>。所有受访者或项目（可能的抽样单位）的集合构成总体。例如，对于软件产品可用性感知的研究，所有可能的用户构成总体。18-6
[<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]]</p>
<p>在定义总体时，必须注意区分研究总体和目标总体。如果研究涉及样本，则正在研究的总体与结果推广的总体会有所不同。例如，当研究总体仅包含过去的观察但需要对未来进行推广时，研究总体和目标总体不同。</p>
<p><strong>样本</strong>。样本是总体的子集。选择样本时最关键的问题是其代表性，包括大小。样本必须以确保抽取独立的方式抽取，并且抽取样本的规则必须预先定义，以便事先知道选择特定抽样单位的概率。这种选择样本的方法称为<strong>概率抽样</strong>(probability
sampling)。</p>
<p><strong>随机变量</strong>(random
variable)。在统计术语中，对抽样单位进行观察或测量的过程称为进行实验。例如，如果实验是抛硬币10次并计算硬币正面朝上的次数，那么每10次抛硬币是一个抽样单位，给定样本的正面次数是实验的观察或结果。实验的结果以实数形式获得，并定义了正在研究的随机变量。在实验结果中测量的项目属性代表正在研究的随机变量；从特定抽样单位获得的观察是随机变量的特定实现。在抛硬币的例子中,随机变量是每次实验观察到的正面次数。</p>
<p>随机变量的可能值集合可能是有限的或无限但可数的（例如，所有整数的集合或所有奇数的集合）。在这种情况下，随机变量称为<strong>离散随机变量</strong>(discrete
random
variable)。在其他情况下，正在考虑的随机变量可能在连续尺度上取值，称为<strong>连续随机变量</strong>(continuous
random variable)。</p>
<p><strong>事件</strong>(event)。随机变量的可能值的子集称为事件。假设X表示某个随机变量；那么，例如，我们可以定义不同的事件，如<em>X</em>
≥ x或X &lt; x等等。</p>
<p><strong>随机变量的分布</strong>(distribution of a random
variable)。随机变量的范围和变化模式由其分布给出。当随机变量的分布已知时，可以计算任何事件的概率。一些分布经常出现，并用于建模工程背景下实践中出现的许多随机变量。下面描述一些更常见的分布：</p>
<p><strong>• 二项分布</strong>(binomial
distribution)用于建模在独立进行的<em>n</em>次试验中计数成功次数的随机变量，其中每次试验都导致成功或失败。我们假设成功试验的机会保持不变[8*,
c3s5]。</p>
<p><strong>• 泊松分布</strong>(Poisson
distribution)用于建模在时间或空间上某个事件的发生次数[8*, c3s8]。</p>
<p><strong>• 正态分布</strong>(normal
distribution)用于通过取非常大量的值来建模连续或离散随机变量[8*,
c4s5]。</p>
<p><strong>参数的概念</strong>(concept of
parameters)。参数表征统计分布。例如，任何给定试验中成功的比例是表征二项分布的唯一参数。类似地，泊松分布由发生率表征。正态分布由两个参数表征：其均值和标准差。</p>
<p>一旦参数的值已知，随机变量的分布就会显现，任何事件的机会（概率）都可以计算出来。离散随机变量的概率可以通过概率质量函数(probability
mass function,
PMF)计算。PMF在离散点上定义，并给出点质量——即随机变量取该特定值的概率。同样，对于连续随机变量，我们有概率密度函数(probability
density function,
PDF)。PDF需要在一个范围内积分以获得连续随机变量位于某些值之间的概率。因此，如果PMF或</p>
<p>[ENGINEERING FOUNDATIONS] 18-7</p>
<p>PDF已知，并且参数的值已知，则可以计算任何事件的概率。</p>
<p><strong>估计的概念</strong>。在实践中，参数的值通常是未知的，必须从数据中估计。<strong>点估计</strong>(point
estimate)是参数的单个数值估计。</p>
<p>或者，我们可能使用区间估计(interval
estimate)。区间估计是一个随机区间，其下限和上限是函数</p>
<p>PDF是已知的，随机变量取某组特定值的可能性可以通过样本观测值和样本大小来计算。</p>
<p>理论上可以计算得出。[限值是基于关于抽样分布的假设计算的]</p>
<p><strong>估计的概念(Concept of estimation)</strong> [8*, c7s1,
c7s3]。作为限值基础的点估计。</p>
<p>分布参数的真实值通常是未知的，需要从样本观测值中估计。[<strong>估计量的性质(Properties
of
estimators)</strong>。估计量的各种统计性质用于确定估计量在特定情况下的适用性。最重要的性质是效率(efficiency)、相对于总体的一致性(consistency)以及无偏性(lack
of bias)。]</p>
<p>这些估计值是样本值的函数，被称为<strong>统计量(statistics)</strong>。例如，样本均值是一个统计量，可用于估计总体均值。类似地，从样本估计的缺陷发生率(每行代码的缺陷率)是一个统计量，可作为总体每行代码缺陷率的估计值。</p>
<p>用于估计总体参数的统计量通常被称为<strong>该参数的估计量(estimator of
the parameter)</strong>。</p>
<p><strong>假设检验(Tests of hypotheses)</strong> [8*,
c9s1]。<strong>假设(hypothesis)</strong>
是关于参数可能取值的陈述。例如，假设有人声称一种新的软件开发方法减少了缺陷的发生。假设是缺陷发生率已经降低。当我们检验这个假设时，我们根据样本观测值来决定是否应该接受或拒绝它。</p>
<p>估计量本身的结果是随机的。如果我们取不同的样本，我们可能会得到不同的总体参数估计值。在估计理论中，我们需要理解估计量的不同性质——特别是估计值在不同样本间的变化程度，以及如何在不同的估计方法之间进行选择。例如，如果我们想估计总体均值，我们可以使用样本均值、样本中位数、样本众数或样本的中距作为估计量。</p>
<p>要检验假设，需要形成原假设和备择假设。<strong>原假设(null
hypothesis)</strong>
是无变化的假设，记为H₀。<strong>备择假设(alternative
hypothesis)</strong>
记为H₁。备择假设可以是单侧或双侧的。例如，如果我们的原假设是总体均值不小于某个给定值，那么备择假设就是它小于该值，这就是单侧检验。然而，如果我们的原假设是总体均值等于某个给定值，那么备择假设就是它不等于该值，这就是双侧检验(因为真实值可能小于或大于给定值)。</p>
<p>这些估计量中的每一个都具有不同的统计性质，可能会影响估计的标准误差。</p>
<p><strong>估计的类型(Types of estimates)</strong> [8*, c7s3,
c8s1]。估计有两种类型：<strong>点估计(point estimates)</strong>
和<strong>区间估计(interval
estimates)</strong>。当我们使用统计量的值来估计总体参数时，我们得到的是点估计。顾名思义，点估计给出被估计参数的一个点值。</p>
<p>检验假设的第一步是计算一个统计量。此外，定义一个区域，如果计算出的统计量值落在该区域内，则拒绝原假设。该区域称为<strong>临界区域(critical
region)</strong>(也称为<strong>置信区间(confidence
interval)</strong>)。在假设检验中，我们需要根据获得的证据接受或拒绝原假设。一般来说，备择假设是我们感兴趣的假设。</p>
<p>尽管点估计经常被使用，但它们留下了许多问题。例如，它们不能告诉我们任何关于可能的误差大小或估计的统计性质的信息。因此，我们可能需要用样本大小和估计方差的信息来补充点估计。</p>
<p>如果计算出的统计量值不在临界区域内，则我们不能拒绝原假设。这表明没有足够的证据相信备择假设是真的。</p>
<p>由于决策是基于样本观测值做出的，因此可能存在错误；此类错误的类型总结在下表中。</p>
<table>
<thead>
<tr>
<th></th>
<th>统计决策</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>自然状况</td>
<td>接受H₀</td>
<td>拒绝H₀</td>
</tr>
<tr>
<td>H₀为真</td>
<td>OK</td>
<td>第一类错误(Type I error)(概率 = α)</td>
</tr>
<tr>
<td>H₀为假</td>
<td>第二类错误(Type II error)(概率 = β)</td>
<td>OK</td>
</tr>
</tbody>
</table>
<p>在检验假设时，我们的目标是最大化检验的功效(power)(值为1 −
β)，同时确保第一类错误的概率</p>
<p><strong>相关性(Correlation)</strong>。相关分析只衡量两个变量之间的关系程度。如果计算出的统计量值落在临界区域内，则我们拒绝原假设。这表明有足够的证据相信备择假设是真的。</p>
<p>取-1到+1之间的值。值-1和+1表示变量之间的关联是完美的(即给定一个变量的值，另一个可以无误地估计出来)。正相关系数表示正关系(即如果一个变量增加，另一个也增加)。另一方面，当变量负相关时，一个变量的增加会导致另一个变量的减少。</p>
<p>始终记住，相关性并不意味着因果关系。因此，如果两个变量相关，我们不能得出一个导致另一个的结论。</p>
<p><strong>回归(Regression)</strong>。相关分析只衡量两个变量之间的关系程度。找出两个变量之间关系强度的分析称为<strong>回归分析(regression
analysis)</strong>。该分析使用决定系数(coefficient of
determination)——一个介于</p>
<p>(α的值)保持在一个特定的 [0和1之间。系数越接近1，]</p>
<p>范围内——通常是5%。 [变量之间的关系就越强。]</p>
<p>还需注意，假设检验的构建包括 [值为1表示完美关系。]</p>
<p>识别用于估计参数的统计量，以及定义一个临</p>
<p>界区域，使得当统计量的计算值 [<strong>6.
建模、仿真和原型开发</strong> ]</p>
<p>落入临界区域时，零假设被拒绝。 [<strong>[3*, c6] [10*, c10s3] [11*,
c5]</strong>]</p>
<p><em>5.2. 相关性和回归</em>
[<em>建模(Modeling)</em>是抽象过程的一部分，用于]</p>
<p>[8*, c11s2, c11s8]
[表示系统的各个方面。<em>仿真(Simulation)</em>]</p>
<p>[使用系统模型进行设计实验，以更好地理解系统、]</p>
<p>许多统计调查的一个主要<em>目标</em>是
[其行为以及子系统之间的关系，并分析设计的各个方面。]</p>
<p>建立能够根据其他变量预测一个或多个 [建模和仿真可用于构建]</p>
<p>变量的关系。虽然最理想的是
[关于系统行为的理论或假设。工程师然后使用这些理论]</p>
<p>能够根据另一个量精确预测某个量，
[对系统进行预测。<em>原型开发(Prototyping)</em>]</p>
<p>但这很少可能实现，在许多
[是另一个抽象过程，其中构建了产品或系统的]</p>
<p>情况下，我们必须满足于估计 [部分表示（捕获感兴趣的方面）。原型]</p>
<p>平均值或期望值。 [可能是系统的初始版本，]</p>
<p>两个变量之间的关系 [缺少最终版本的完整功能。]</p>
<p>使用相关性和回归来研究。这两个</p>
<p>概念简要解释如下。 <em>6.1. 建模</em></p>
<p><em>相关性(Correlation)</em>。两个变量之间线性关</p>
<p>系的程度使用<em>相关系数(correlation coefficient)</em>来衡量。计算
[<em>模型(Model)</em>始终是对某个真实]</p>
<p>相关系数适用于测量同一实体的 [或想象工件的抽象。工程师在]</p>
<p>两个不同属性的两个变量。相关系数
[问题解决活动中以多种方式使用模型。]</p>
<p><a href="#工程基础">工程基础</a> 18-9</p>
<p>[一些模型是物理的，例如]</p>
<p>按比例缩小的桥梁或建筑物 [模拟时钟和随机]</p>
<p>微型结构。其他模型是非 [数字生成器。仿真生成]</p>
<p>物理表示，例如齿轮的计算机辅助 [必须分析的输出。]</p>
<p>设计(CAD)图纸或过程的数学模型。 [离散仿真开发中的一个重要问题]</p>
<p>模型帮助工程师理解 [是<em>初始化</em>。在运行仿真之前，必须]</p>
<p>问题的各个方面。 [提供所有状态变量的初始值。由于仿真设计者可能不]</p>
<p>它们还可以帮助工程师确定
[知道状态变量的适当初始值，这些值可能被选择]</p>
<p>他们对问题的了解和不了解。 [得有些随意。例如，可能]</p>
<p>模型有三种类型：图标式、类比式和符号式。<em>图标式模型(iconic
model)</em>是视觉上 [决定队列应初始化为]</p>
<p>等效但不完整的二维或 [空和空闲状态。对初始条件的这种选择]</p>
<p>三维表示（例如，地图、 [可能对仿真结果产生重大但未被识别的]</p>
<p>地球仪或按比例建造的结构模型， [影响。]</p>
<p>如桥梁或高速公路）。图标式模型</p>
<p>与建模的工件相似。 <em>6.3. 原型开发</em></p>
<p>相反，<em>类比模型(analogic model)</em>是功能</p>
<p>上等效但不完整的表示。 [构建系统的原型是]</p>
<p>模型的行为类似于物理工件， [另一个抽象过程。在这种情况下，]</p>
<p>即使它在物理上可能不像它。 [构建系统的初始版本，]</p>
<p>类比模型的示例包括用于 [通常是在设计系统时，这]</p>
<p>风洞测试的微型飞机或制造 [帮助设计者确定其]</p>
<p>过程的计算机仿真。 [设计的可行性。]</p>
<p>最后，<em>符号模型(symbolic model)</em>使用更高级别的
[原型有许多用途，包括]</p>
<p>抽象，使用符号（如方程）对过程或系统 [收集需求、设计和改进]</p>
<p>进行建模。工程师 [用户界面，以及验证功能]</p>
<p>可以使用这些符号来理解、描述 [需求。构建原型的目标和目的]</p>
<p>和预测最终系统或产品的 [将指导其构建]</p>
<p>属性或行为。一个例子是 [并确定所使用的抽象级别。]</p>
<p>方程F = ma。</p>
<p>[原型开发对于物理系统和软件的]</p>
<p><em>6.2. 仿真</em> [作用有所不同。对于]</p>
<p>物理系统，原型可能是</p>
<p>所有仿真模型都是 [系统的第一个完全功能版本，或]</p>
<p>现实的描述。仿真中的一个核心问题是如何 [它可能是系统的模型。在软]</p>
<p>抽象数据并创建现实的适当简化。 [件工程中，原型也是]</p>
<p>开发这种抽象 [部分软件的抽象模型。然而，它们]</p>
<p>至关重要，因为抽象的错误规范 [通常不是用所有架构]</p>
<p>会使仿真的结果无效。 [、性能和其他质量特性]</p>
<p>练习。仿真可用于各种 [构建的，这些特性是成品所期望的。]</p>
<p>测试目的。 [无论哪种情况，原型构建都必须]</p>
<p>仿真根据类型分类</p>
<p>所研究的系统；仿真可以是连续的或离散的。在软件工程中，主要侧重于离散仿真。离散仿真可以模拟事件调度或过程交互。这种模型中的主要组件包括实体、活动和事件、资源、系统状态。</p>
<p>总之，建模、仿真和原型设计是从特定角度研究系统行为的强大技术。所有这些都可以用于执行设计的实验，以研究系统的各个方面。然而，这些都是抽象的，因此可能无法对所有感兴趣的属性进行建模。</p>
<p>在某些情况下——特别是在物理世界中——我们希望测量的属性很容易理解；然而，在像软件工程这样的人工世界中，定义属性可能并不那么简单。例如，高度、重量、距离等属性很容易被统一理解(尽管在所有情况下可能不太容易测量)。相比之下，软件规模和复杂度等属性需要明确的定义。</p>
<p><strong>7. 测量</strong> <strong>[2*, pp442-447] [3*, c4s4]</strong>
<strong>[12*, c7s5] [13*, c3s1-2]</strong></p>
<p>知道测量什么、如何测量、可以用测量做什么，甚至为什么要测量，这在工程工作中至关重要。参与工程项目的每个人都必须理解测量方法、测量结果以及如何使用这些结果。</p>
<p>测量可以是物理的、环境的、经济的、操作的或对项目有意义的其他类型的测量。本节探讨测量理论及其如何成为工程的基础。测量从抽象概念开始，发展到测量方法的定义，然后到该方法的实际应用以获得测量结果。每个步骤都必须被理解、传达和正确执行才能产生可用的数据。在传统工程中，通常使用直接测量。在软件工程中，需要结合使用直接测量和派生测量(定义见7.3)[13*,
p273]。</p>
<p>测量理论指出，测量是对底层经验系统进行描述的尝试。测量方法规定了为实体的属性分配值或符号的活动。然后必须根据用于识别和测量属性的操作(测量方法)来定义属性。</p>
<p>在某些情况下——特别是在物理世界中——我们希望测量的属性很容易理解；然而，在像软件工程这样的人工世界中，定义属性可能并不那么简单。例如，高度、重量、距离等属性很容易被统一理解(尽管在所有情况下可能不太容易测量)。相比之下，软件规模和复杂度等属性需要明确的定义。</p>
<p><strong>操作定义</strong>。首先，属性的定义通常是相当抽象的。这样的定义不便于测量。例如，我们可以将圆定义为形成闭合环的线，使得该线上任何点与称为中心的固定内部点之间的距离是恒定的。我们可以进一步说，从中心到闭合环上任何点的固定距离是圆的半径。虽然概念已经被定义，但没有提出测量半径的方法。操作定义指定了用于执行特定测量的确切步骤或方法。这也可以称为测量方法；有时，可能需要更精确的测量程序。</p>
<p>操作定义的重要性怎么强调都不过分。以看似简单的测量一个人的身高为例。除非我们指定各种因素——例如，测量身高的时间(因为个人的身高在一天中会变化)、如何处理头发造成的变化、测量时是否穿鞋、预期的精度(精确到最近的英寸、1/2英寸、厘米等)——否则即使是这个简单的测量也会产生很大的变化。因此，工程师必须理解从操作角度定义测量的必要性。</p>
<p><strong>7.1. 测量的层次(尺度)</strong> <strong>[2*, pp442-447] [12*,
c7s5] [13*, c3s2]</strong></p>
<p>一旦确定了操作定义，就可以进行实际测量。测量可以在四种不同的尺度类型中进行：名义尺度(nominal)、序数尺度(ordinal)、区间尺度(interval)和比率尺度(ratio)。以下是每种尺度的简要说明：</p>
<p><strong>名义尺度</strong>：这是最低级别的测量，代表最不受限制的符号分配，这些符号只是标签。名义尺度涉及分类，其中被测量的实体被放入互斥且完全穷尽的类别(类)之一。名义尺度的示例如下：</p>
<p>• 组织中的职位名称 •
汽车款式(轿车、双门轿跑车、掀背车、小型货车等)</p>
<p>•
使用术语表达的同意程度(非常同意、有些同意、中立、有些不同意、非常不同意)
• 能力成熟度模型集成(CMMI)的阶段成熟度级别</p>
<p>名义尺度上值的所有操作在序数尺度上都是有效的，而序数尺度还支持大于和小于的比较。例如：</p>
<p>• 你在那场比赛中是在我之前、与我同时还是在我之后完成的？ •
事件X是否与事件Y相同、更可能或更不可能？</p>
<p>• 软件开发生命周期（SDLC）模型（瀑布、迭代、敏捷等） •
事件X是否与事件Y相同、更严重或更轻微？ •
组织A的CMMI阶段成熟度级别是否与组织B相同、更高或更低？</p>
<p>在名义尺度中，符号之间不能推断任何关系。名义尺度中度量的唯一有效操作类型如下：</p>
<p>•
确定两个实体是否具有相同或不同的符号（例如，“你的职位是否与我的职位相同或不同？”）
•
计算具有相同符号的实体数量（例如，“该组织中有多少员工的职位是软件工程师二级？”）</p>
<p>可以进行统计分析，以了解属于不同类别的实体在某些其他变量方面的表现。</p>
<p><strong>序数尺度(Ordinal
scale)</strong>：序数尺度通过要求符号之间存在严格的顺序关系来扩展名义尺度。序数尺度必然是传递性的（如果A
&gt; B且B &gt; C，则A &gt; C）。以下是序数尺度的示例：</p>
<p>• 比赛中的完成顺序（第1名、第2名、第3名） •
使用术语表示的概率（极少、不太可能、均等、可能、几乎确定） •
使用术语表示的严重程度（可忽略、边缘、严重、关键、灾难性）</p>
<p>当序数尺度使用数字作为符号时——如CMMI阶段成熟度级别1、2、3、4和5——这些数字不能进行算术运算。我们不能说CMMI阶段成熟度级别5和级别4之间的差异（5
− 4）与级别3和级别2之间的差异（3 −
2）在任何有意义的方式上具有可比性。我们也不能说CMMI阶段成熟度级别4是级别2的两倍好。使用数字作为符号的序数尺度通常以这种方式被误用——例如，呈现平均值和标准差（例如，“全球软件组织的平均CMMI阶段成熟度级别为1.763”）。这种误用很容易导致错误的结论[13*,
p274]。（我们可以在序数尺度上计算中位数，因为这只涉及计数。）使用非数字符号，如初始的、可重复的、已定义的、已管理的和优化的（用于CMMI阶段成熟度级别），是首选的，因为它有助于防止这种误用。正确选择的标签也能更好地传达每个标签的含义。</p>
<p><strong>区间尺度(Interval
scale)</strong>：区间尺度通过要求任何一对相邻值之间的差异是恒定的来扩展序数尺度。以下是区间尺度的示例：</p>
<p>•
以摄氏度和华氏度表示的温度：−9°C和−8°C之间的差异与26°C和27°C之间的差异相同。−9°F和−8°F之间的差异与26°F和27°F之间的差异相同。
• 日历日期：任何两个连续日期之间的差异总是一天：24小时。 •
北美的鞋码：3码和4码之间的差异与10码和11码之间的差异相同——三分之一英寸，或8.467毫米（通常用于运动鞋、滑雪靴、溜冰鞋和芭蕾舞鞋）；270/105码的鞋适合长270毫米、宽105毫米的脚。
• 决策构造的计数（例如，在给定源代码文件中的if()、for()、while()） •
金钱</p>
<p>序数尺度上的所有值操作在区间尺度上都是有效的，而区间尺度还支持加法和减法。例如：</p>
<p>•
−9°C和0°C之间的差异与0°C和9°C之间的差异相同。−50°F和0°F之间的差异与25°F和75°F之间的差异相同。
•
5月6日和5月9日之间的时间长度与11月8日和11月11日之间的时间长度相同。</p>
<p>区间尺度支持大多数统计分析，如平均值、标准差、相关性和回归。另一方面，涉及值的乘法或除法的任何操作都是无意义的，因为区间尺度上的0（如果它存在的话）并不代表测量量的缺失。区间尺度上的0点相对于被测量的属性是任意的。考虑到0°（摄氏度和华氏度）并不代表热量的缺失（绝对零度），北美0码的鞋子具有非零长度。因此，30°C不能被解释为15°C的两倍热，北美9码的鞋子也不是3码鞋子长度的三倍。</p>
<p><strong>比率尺度(Ratio
scale)</strong>：比率尺度通过要求0点代表被测量属性的缺失来扩展序数尺度。以下是比率尺度的示例：</p>
<p>比率尺度支持所有算术和统计操作。一个比率尺度中的值通常可以通过使用乘法因子轻松转换为测量相同属性的另一个比率尺度中的相应值。英寸中的距离可以轻松转换为厘米，千克中的重量可以轻松转换为磅，节中的速度可以轻松转换为每小时公里数，等等。</p>
<p>另一个测量尺度，<strong>绝对尺度(absolute
scale)</strong>，是具有测量唯一性的比率尺度（不可能进行转换）。在项目中工作的软件工程师数量是一个绝对尺度，因为没有其他有意义的人数度量。</p>
<h2 id="72-测量理论对编程语言的影响">7.2. 测量理论对编程语言的影响</h2>
<p>常见的编程语言支持一组内置数据类型，通常包括以下内容：</p>
<p>• 不同范围的整数类型：int、integer、byte、short、long等。 •
不同范围和不同精度的浮点数：real、float、double等。 • 单字符：char •
有序字符序列：string</p>
<p>许多语言（尽管不是全部）也支持类型安全的枚举（例如，</p>
<p>在缺少被测量属性时。Java的”枚举”）。以下是比率量表的例子：[遗憾的是，这些语言不提供对测量理论的支持。它们不会]</p>
<p>• 开尔文温度（K）[阻止，甚至不会警告程序员关于]</p>
<p>• Mondopoint系统中的鞋码[不当的操作。整数和]</p>
<p><a href="#工程基础">工程基础</a> 18-13</p>
<p>浮点数数据类型在编程语言中作为比率量表运行[通用编程语言对]</p>
<p>并支持全部范围的操作：[图18.3示例G中显示的代码没有问题。]</p>
<p>比较、加法、减法、乘法、除法等。但考虑一下[另一方面，一个支持测量]</p>
<p>CMMI阶段成熟度级别表示为一个数字。用测量理论术语来说，如[理论的编程语言应该]</p>
<p>上所示，它是一个序数量表，所以加法、减法、乘法和除法是不合适的。如果程序员使用整数数据类型表示CMMI阶段成熟度级别，没有任何东西可以阻止程序员不当地对该数字进行加法、减法、乘法或除法运算。[未来的编程语言应该]</p>
<p>字符、字符串和枚举也是如此。编程语言将它们实现为序数量表；然而，它们可能只用于表示标称量表值。即使在不合适的情况下，也允许进行大于和小于比较。字符串”minivan”在字母表中出现在字符串”sedan”之前，但除了任意文本字符串的纯字母排序之外，得出任何其他结论都是不合适的。[未来的编程语言应该]</p>
<p>通用编程语言允许程序员轻松编写根据测量理论不合适的代码。只要编程语言允许，程序员就可以而且会——有意或无意地——误用测量量表类型。一个更合理的解决方案是显式强制执行测量理论的数据类型语义。例如，一种语言可以显式支持标称量表，如图18.3示例A所示。然后该语言可以阻止或至少警告程序员不要进行大于或小于比较，如图18.3示例B所示。</p>
<p>如果需要大于或小于比较，该语言支持序数类型的声明，如图18.3示例C所示。图18.3示例D不会触发任何错误或警告。类似地，可以支持区间量表，如图18.3示例E所示。可以支持比率量表，如图18.3示例F所示。[强制执行测量理论，不允许]</p>
<p>[开发人员不当地操作测量。]</p>
<p>[但在语言支持测量理论之前，软件工程师需要]</p>
<p>至少理解它，并在例如代码审查中注意不当的操作。</p>
<p><strong>7.3. 直接测量和派生测量</strong></p>
<p>[[13*, c7s5]]</p>
<p>[测量可以是直接的或派生的]</p>
<p>[（有时称为<em>间接测量</em>）。<em>直接测量</em>的例子是对事件发生次数的计数，例如在软件产品中发现的缺陷数量。]</p>
<p>[派生测量以与这些测量所用的测量方法一致的方式组合直接测量。]</p>
<p>例如，计算每个缺陷的平均修复小时数就是派生测量。在两种情况下，测量方法都决定了如何执行测量。</p>
<p>[这些测量的量表类型限制了它们如何被操作。当涉及不同的]</p>
<p>量表类型时：</p>
<p>[•
操作结果的量表类型不能高于所涉及的最原始测量量表的量表类型（例如，涉及区间量表和比率量表的操作只能当作两者都是区间量表来执行，并且产生的结果不能好于区间量表结果）。]</p>
<p>[• 需要投入来使更原始的量表类型与任何更高的量表类型兼容]</p>
<p>[（例如，需要努力将区间量表提升到比率量表，这样结果也可以是比率量表）。]</p>
<p>18-14 [<em>SWEBOK</em>] [<em>®</em>][ GUIDE V4.0a]</p>
<p>[nominal enum automobile_style = sedan, coupe, hatchback, ]</p>
<p>[minivan, suv, sports_car;]</p>
<p><strong>示例A</strong></p>
<p>[if( thisCarStyle &gt;= sedan ) then … // 这是不允许的]</p>
<p><strong>示例B</strong></p>
<p>[ordinal enum CMMI_staged_level = initial, repeatable, defined, ]</p>
<p>[managed, optimizing;]</p>
<p><strong>示例C</strong></p>
<p>[if( anOrgsCMMILevel &gt; repeatable ) then …]</p>
<p><strong>示例D</strong></p>
<p>[interval AirTemperatureCelsius from -120.0 to +180.0;]
[AirTemperatureCelsius yesterdaysHighTemp;]</p>
<p>[AirTemperatureCelsius todaysHighTemp;]</p>
<p>[if( todaysHighTemp &gt; yesterdaysHighTemp ) { … } // 允许] [if(
todaysHighTemp &gt; yesterdaysHighTemp * 2.0 ) { … } // 不允许]</p>
<p><strong>示例E</strong></p>
<p>[ratio TemperatureKelvin from 0.00 to 1000.00;] [TemperatureKelvin
previousReading;]</p>
<p>[TemperatureKelvin thisReading;]</p>
<p>[if( thisReading &gt; previousReading * 2. ) { … } // 允许]</p>
<p><strong>示例F</strong></p>
<p>[double priceOfBook;]</p>
<p>[double highTemperature;]</p>
<p>[highTemperature = priceOfBook; // 没有意义但是允许]</p>
<p><strong>示例G</strong></p>
<p>[ratio Money from -10000.00 to +10000.00;]</p>
<p>[ratio TemperatureKelvin from 0.00 to 1000.00;] [Money
priceOfBook;]</p>
<p>[TemperatureKelvin highTemperature;]</p>
<p>[double highTemperature;]</p>
<p>[highTemperature = priceOfBook; // 不允许]</p>
<p><strong>示例H</strong></p>
<p>[<strong>图18.3.</strong> ][测量理论代码示例]</p>
<p><strong>7.4. 可靠性和有效性</strong> [13*, c3s4-5]</p>
<p>在考虑任何测量时要问的一个基本问题取决于操作定义。它可以通过使用变异指数来量化，变异指数计算为标准差之间的比率</p>
<p>测量方法是否真正测量了具有良好质量的概念。可靠性(Reliability)和效度(Validity)是解决这个问题最有用的两个标准。</p>
<p><em>测量方法的可靠性</em>是指应用该方法产生一致结果的程度。可靠性指的是当同一项目被多次测量时获得的值的一致性。当结果彼此一致时,该测量方法就被认为是可靠的。可靠性通常使用提议的偏差和均值之间的关系来衡量。该指标越小,测量结果就越可靠。</p>
<p><em>效度</em>指的是测量方法是否测量了我们打算测量的内容。测量方法的效度可以从三个不同的角度来考虑:构念效度(construct
validity)、准则效度(criteria validity)和内容效度(content validity)。</p>
<h2 id="75-评估可靠性">7.5. 评估可靠性</h2>
<p>评估可靠性的方法包括重测法(test-retest
method)、替代形式法(alternative form method)、分半法(split-halves
method)和内部一致性法(internal consistency
method)。其中最简单的是重测法。在这种方法中,我们对同一对象应用测量方法两次。第一次和第二次测量结果之间的相关系数给出了测量方法的可靠性。</p>
<h2 id="76-目标-问题-度量范式为什么要测量">7.6.
目标-问题-度量范式:为什么要测量?</h2>
<p>关于测量最后要讨论的问题是理解我们为什么要测量。目标-问题-度量范式(Goal-Question-Metric
paradigm)可以用一个简单的观察来概括:进行测量应该是为了支持决策。一些测量支持代码中的决策。其他测量支持代码之外的人做出的决策(例如,过程改进度量)。关键点是应该根据测量结果做出某些决策。许多现实世界的软件组织陷入了”仅为好奇而测量”的综合症,即收集指标仅仅是因为它们易于测量,在图表中呈现时很有趣。这些测量并不用于支持任何决策,是对时间和精力的浪费。应该避免这种情况。</p>
<h2 id="8-标准">8. 标准</h2>
<p>Moore指出,标准可以是以下内容:</p>
<ol type="a">
<li><p>定义或表示单位量级的比较对象或度量</p></li>
<li><p>为项目类别建立可允许容差的特征描述</p></li>
<li><p>所需卓越程度或达到的水平</p></li>
</ol>
<p>标准在本质上是定义性的,其建立要么是为了促进理解和交互,要么是为了承认观察到的(或期望的)所展示特征或行为的规范。</p>
<p>标准提供了工程师必须遵守的要求、规格或指南,以便产品、过程和材料具有可接受的质量。各种标准规定的质量涉及安全性、可靠性或其他产品特征。标准对工程师来说被认为是至关重要的,工程师应该熟悉并使用适合其特定学科的适当标准。</p>
<p>符合或遵守标准使组织能够向公众保证该组织的产品满足该标准中包含的要求。因此,标准将组织或其产品分为符合标准的和不符合标准的。要使标准有用,符合性必须为产品、过程或工作增加真实的或可感知的价值。</p>
<p>除了支持组织目标外,标准还服务于其他几个目的,例如保护买家、保护企业,以及更好地定义软件工程中使用的方法和程序。标准还为用户提供了通用的术语和期望。</p>
<p>有许多国际公认的标准制定组织,包括国际电信联盟(ITU)、国际电工委员会(IEC)、IEEE和国际标准化组织(ISO)。此外,区域性和政府认可的组织为其区域或国家制定标准。例如,在美国,有300多个组织制定标准。这些组织包括美国国家标准协会(ANSI)、ASTM国际(前身为美国材料试验学会)、SAE国际(前身为汽车工程师协会)和美国保险商实验室(UL),以及美国政府。(有关软件工程中使用的标准的更多信息,请参见附录B。)</p>
<p>标准背后有一套常用的原则。标准制定者试图就其决策达成共识。这种方法培养了相关社区内的开放性,以便一旦设定标准,它就很有可能被广泛接受。大多数标准组织对其工作都有明确定义的流程,并认真遵守这些流程。工程师必须了解现有标准,并随时掌握这些标准的任何变化。</p>
<p>在许多工程工作中,理解和遵守标准至关重要。符合或遵守标准使组织能够向公众保证该组织的产品满足该标准中包含的要求。</p>
<h2 id="91-根因分析技术">9.1. 根因分析技术</h2>
<p>存在几种根因分析(RCA)技术,包括以下内容:</p>
<ul>
<li><em>变更分析(Change
analysis)</em>比较导致不良结果的情况与进展顺利的类似情况。假设是根本原因将在差异领域中找到。</li>
<li><em>5-why技术</em>从不良结果开始,使用重复的”为什么?“问题来追溯问题的根源。</li>
</ul>
<p>理解适用标准至关重要，法律甚至可能要求遵循特定的标准。在这些情况下，标准通常代表必须满足的最低要求，因此是设计工作约束的一个要素。因此，工程师必须审查与特定工作相关的所有现行标准，并确定必须满足哪些标准。然后，设计必须纳入适用标准施加的所有约束。</p>
<h2 id="9-根本原因分析">9. 根本原因分析</h2>
<p><strong>[3*, c9s3-5] [13*, c5, c3s7, c9s8]</strong></p>
<p>根本原因分析(Root Cause Analysis,
RCA)是一类问题解决方法，用于识别不良结果的根本原因。RCA方法识别不良结果发生的原因和方式，使组织能够采取有效行动防止再次发生。组织可以通过消除根本原因来解决问题，而不仅仅是解决表面上明显的症状。RCA在软件项目中可以发挥几个重要作用，包括：</p>
<ol type="1">
<li>识别工程工作要解决的真正问题</li>
<li>暴露风险的潜在驱动因素，从而支持项目风险评估</li>
<li>揭示软件过程改进的机会和行动</li>
<li>发现反复出现的缺陷的来源(缺陷因果分析)</li>
</ol>
<h3 id="91-根本原因分析技术">9.1. 根本原因分析技术</h3>
<p>通过提问-回答循环来隔离根本原因。</p>
<ul>
<li><p><strong>因果图</strong>(Cause-and-effect
diagrams)，有时称为石川图[15]或鱼骨图，以逐级细化的方式分解可能导致不良结果的原因。原因通常分为主要类别，如人员、流程、工具、材料、测量和环境。该图采用潜在原因树的形式，所有原因都可能导致该不良结果。</p></li>
<li><p><strong>故障树分析</strong>(Fault Tree Analysis,
FTA)是一种更正式的因果图方法，侧重于原因和结果之间的与/或关系。在某些情况下，多个原因中的任何一个都可以驱动结果(“或”关系)；在其他情况下，需要多个原因的组合来驱动结果(“与”关系)。因果图不区分”与”关系和”或”关系；故障树分析可以。</p></li>
<li><p><strong>失效模式与影响分析</strong>(Failure Modes and Effects
Analysis,
FMEA)采用正向推导，从可能失效的元素开始，级联到不良影响。这种方法与上述反向推导技术形成对比，后者从不良结果开始向后追溯原因。</p></li>
<li><p><strong>原因图</strong>(Cause
map)[16]是因果关系的结构化图，包括不良结果以及(1)反向推导到驱动原因和(2)正向推导到对组织目标的影响。原因图需要原因发生和效果因果关系的证据，因此比因果图、FTA和FMEA更严谨。</p></li>
<li><p><strong>当前现实树</strong>(Current Reality
Tree)[17]是一种受逻辑规则(合理保留类别)约束的因果树。</p></li>
<li><p><strong>人员绩效评估</strong>(Human Performance
Evaluation)认为人员绩效取决于(1)输入检测、(2)输入理解、(3)行动选择和(4)行动执行。由人员绩效导致的不良结果可以从全面的潜在驱动因素列表中识别，包括认知超负荷、认知负荷不足(无聊)、记忆失误、隧道视野或缺乏全局观、自满和疲劳。</p></li>
</ul>
<p>其他技术可以在DOE-NE-STD-1004-92根本原因分析指导文件中找到。</p>
<h3 id="92-基于根本原因的改进">9.2. 基于根本原因的改进</h3>
<p>RCA通常是更大过程改进工作中的一个要素。如果不采取任何行动，为什么要识别根本原因？为什么要花费精力识别低重要性问题的根本原因？下面给出了一个包含RCA的大型改进工作系统化过程的示例：</p>
<ol type="1">
<li><p><strong>选择要解决的问题</strong>：使用帕累托分析(“80/20法则”)、频率-严重性优先级排序(最频繁发生且消耗最多资源需要纠正的问题)等技术，根据规格说明、报告、历史趋势、实验或测试。</p></li>
<li><p><strong>使用9.1节中介绍的一种或多种RCA技术识别根本原因</strong>。</p></li>
<li><p><strong>选择纠正措施</strong>，该措施应(1)防止再次发生，(2)在组织的控制能力范围内，(3)符合组织目标和宗旨，(4)不会引起其他问题。应考虑多个候选纠正措施，潜在措施应消除原因、降低原因发生的概率或断开原因与结果的联系。选定的纠正措施应以最低成本产生最大程度的控制。</p></li>
<li><p><strong>实施选定的纠正措施</strong>。</p></li>
<li><p><strong>观察选定的纠正措施</strong>，以确保效率和有效性。</p></li>
</ol>
<h2 id="10-工业40与软件工程">10. 工业4.0与软件工程</h2>
<p>制造业一直在持续变化。工业4.0(Industry
4.0)将显著改变制造业，主要侧重于人工智能(AI)支持的定制化制造。这为成本、质量和效率带来潜在收益。工业4.0对数字化和AI的重视要求构建定制化的硬件和软件，并将其与其他标准系统集成。这得到了持续软件工程(Continuous
Software Engineering,
CSE)的支持，后者一直在解决持续制造实践，如持续规划、持续架构/设计、持续开发等问题。</p>
<p>识别最佳候选项)，并且统计过程控制用于识别需要解决的高优先级、不良结果。这一步需要清晰地定义问题及其重要性。</p>
<h2 id="2-收集有关该问题及其原因的证据">2.
收集有关该问题及其原因的证据</h2>
<p>考虑围绕所选不良结果的信息，包括陈述或证词、相关流程或标准、开发、持续集成(continuous
integration)、持续部署(continuous deployments)和持续审查/修订(continuous
review/revision)。</p>
<p>软件是工业4.0革命中的关键组成部分，工程化的软件对于构建健壮和智能的系统至关重要。一个产品的工程会影响其他产品，因为越来越多的设备与其他设备连接，主要是无线连接，以提供数据并接收命令和数据以实现进一步功能。</p>
<p>工业4.0中使用了许多技术，包括物联网(IoT)、大数据分析、人工智能和机器学习、网络安全、云计算和多平台应用等。软件在所有这些技术的实现中都发挥着关键作用。</p>
<h2 id="工业40的持续系统和软件工程">工业4.0的持续系统和软件工程</h2>
<p>持续系统和软件工程(CSSE
I4.0)提出了如何在工业4.0中应用软件工程。量子计算使复杂计算能够更快、更经济地执行。承载软件的设备的尺寸和成本正在显著下降，从而简化了工业4.0的采用。软件将越来越具有自学习和主动性，发展出预测用户需求的能力。</p>
<h2 id="主题与参考资料矩阵-2">主题与参考资料矩阵</h2>
<h3 id="1-工程过程">1. 工程过程</h3>
<h3 id="2-工程设计">2. 工程设计</h3>
<p><em>2.1. 工程教育中的工程设计</em></p>
<p><em>2.2. 作为问题解决活动的设计</em></p>
<h3 id="3-抽象和封装">3. 抽象和封装</h3>
<p><em>3.1. 抽象级别</em></p>
<p><em>3.2. 封装(Encapsulation)</em></p>
<p><em>3.3. 层次结构(Hierarchy)</em></p>
<p><em>3.4. 替代抽象</em></p>
<h3 id="4-经验方法和实验技术">4. 经验方法和实验技术</h3>
<p><em>4.1. 设计实验</em></p>
<p><em>4.2. 观察性研究</em></p>
<p><em>4.3. 回顾性研究</em></p>
<h3 id="5-统计分析">5. 统计分析</h3>
<p><em>5.1. 分析单元(抽样单元)、总体和样本</em></p>
<p><em>5.2. 相关性和回归</em></p>
<h3 id="6-建模仿真和原型设计">6. 建模、仿真和原型设计</h3>
<p><em>6.1. 建模</em></p>
<p><em>6.2. 仿真(Simulation)</em></p>
<p><em>6.3. 原型设计(Prototyping)</em></p>
<h3 id="7-测量">7. 测量</h3>
<p><em>7.1. 测量的级别(量表)</em></p>
<p><em>7.2. 测量理论对编程语言的影响</em></p>
<p><em>7.3. 直接测量和派生测量</em></p>
<p><em>7.4. 可靠性和有效性</em></p>
<p><em>7.5. 评估可靠性</em></p>
<p><em>7.6. 目标-问题-度量范式：为什么要测量?</em></p>
<h3 id="8-标准-1">8. 标准</h3>
<h3 id="9-根本原因分析技术">9. 根本原因分析技术</h3>
<p><em>9.1. 根本原因分析</em></p>
<p><em>9.2. 基于根本原因的改进</em></p>
<h3 id="10-工业40与软件工程-1">10. 工业4.0与软件工程</h3>
<h2 id="延伸阅读-4">延伸阅读</h2>
<p>A. Abran, <em>Software Metrics and Software Metrology</em>. [18]</p>
<p>本书提供了关于正确使用术语<em>测量</em>、<em>测量方法</em>和<em>测量结果</em>的非常好的信息。它为测量部分提供了强有力的支持材料。</p>
<p>W.G. Vincenti, <em>What Engineers Know and How They Know It</em>.
[19]</p>
<p>本书通过案例研究介绍工程基础，展示了许多在实际工程应用中的基础概念。</p>
<h2 id="参考文献-13">参考文献</h2>
<p>[1] ISO/IEC/IEEE 24765:2017, IEEE Systems and Software Engineering —
Vocabulary.</p>
<p>[2*] S. Tockey, <em>Return on Software: Maximizing the Return on Your
Software Investment</em>, 1st ed., Addison-Wesley, 2004.</p>
<p>[3*] G. Voland, <em>Engineering by Design</em>, 2nd ed., Prentice
Hall, 2003.</p>
<p>[4] “2021 Accreditation Criteria and Procedures,” Canadian
Engineering Accreditation Board, Engineers Canada, 2021.</p>
<p>[5] E.A. Commission, “Criteria for</p>
<p>[10*] E.W. Cheney and D.R. Kincaid, <em>Numerical Mathematics and
Computing</em>, 7th ed. Belmont, CA: Brooks/Cole, 2020.</p>
<p>[11*] I. Sommerville, <em>Software Engineering</em>, 10th ed. New
York: Addison-Wesley, 2016.</p>
<p>[12*] R.E. Fairley, <em>Managing and Leading Software Projects</em>.
Hoboken, NJ: Wiley-IEEE Computer Society Press, 2009.</p>
<p>[13*] S.H. Kan, <em>Metrics and Models in Software Quality
Engineering</em>, 2nd ed. Boston: Addison-Wesley, 2002.</p>
<p>[14] J.W. Moore, <em>The Road Map to Software Engineering: A
Standards-Based Guide</em>, 1st ed. Hoboken, NJ: Wiley-IEEE Computer
Society Press, 2006.</p>
<p>[15] K. Ishikawa, <em>Introduction to Quality Control</em>,
Productivity Press, 1990.</p>
<p>[16] D. Gano, <em>Apollo Root Cause Analysis</em>, 3rd ed.,
Apollonian Publications, 2007.</p>
<p>[17] E. Goldratt, <em>It’s Not Luck</em>, North</p>
<p>工程项目认证，River Press，1994。2022-2023年，“ABET，2021。</p>
<p>[18] A. Abran，《软件度量与</p>
<p>[6*] S. McConnell，《代码大全》，第二版，软件计量学》：Wiley-IEEE</p>
<p>微软出版社，2004。计算机协会出版社，2010。</p>
<p>[7] Edsger W. Dijkstra，“谦卑的 [19] W.G. Vincenti，《工程师</p>
<p>程序员”，《ACM通讯》，第15卷，第10期，1972年10月。所知及其认知方式》。约翰斯·霍普金斯大学出版社，1993。</p>
<p>[8*] D.C. Montgomery 和 G.C. Runger， [20] Elisa Yumi Nakagawa, Pablo
Oliveira</p>
<p>《工程师应用统计学与概率论》，第七版。新泽西州霍博肯：Antonio, Frank
Schnicke, Thomas</p>
<p>Wiley，2018。Kuhn, Peter Liggesmeyer，《工业4.0的持续</p>
<p>系统与软件工程：一个颠覆性视角》，Elsevier，</p>
<p>[9*] L. Null 和 J. Lobur，《计算机组织与 第135卷，2021年7月，106562
(https://www.sciencedirect.com/science/article/abs/pii/S0950584921000458)</p>
<p>体系结构要义》，第五版。马萨诸塞州萨德伯里：</p>
<p>Jones 和 Bartlett 出版社，2018。</p>
<h2 id="知识领域描述规范">知识领域描述规范</h2>
<p>附录 A</p>
<p><strong>引言</strong> 认可2004版和2014版</p>
<p>分别作为ISO/IEC技术报告19759:2005</p>
<p>本附录介绍了提供给知识领域(KA)编辑的规范
和19759:2015。知识领域列表</p>
<p>关于《软件工程知识体系指南 以及每个领域内的主题细分</p>
<p>第四版(SWEBOK指南V4)》的知识领域描述。这使得 在本《SWEBOK指南》的</p>
<p>读者、审阅者和用户能够清楚地理解
引言中进行了描述和详细说明。因此，《SWEBOK</p>
<p>在开发本版《SWEBOK指南》时使用了哪些规范。
指南》是IEEE计算机协会内其他举措的</p>
<p>本附录首先将《SWEBOK指南》定位为 基础性文档，具体如下：</p>
<p>IEEE计算机协会软件工程产品套件的基础性文档</p>
<p>以及在软件工程社区中的更广泛地位。 •
知识领域列表以及每个领域内的主题细分</p>
<p>附录随后描述了基线和变更控制的作用。定义了
也被IEEE计算机协会提供的软件</p>
<p>主题细分、这些 工程认证和相关专业发展产品</p>
<p>细分背后的基本原理和主题的简明描述 所采用。</p>
<p>以及参考资料的标准和要求。还确定了重要的 (参见
www.computer.org/certification)</p>
<p>输入文档，并 • 知识领域列表和主题细分</p>
<p>解释了它们在项目中的作用。最后，
也是IEEE计算机协会开发或认可的软件</p>
<p>讨论了非内容问题，如提交格式 工程课程指南的基础。(参见
https://www.computer.org/volunteering/boards-and-committees/professional-educational-activities/curriculum-accreditation-committee)</p>
<p>和样式指南。 • 综合参考文献列表(见</p>
<p>附录C)——即伴随每个知识领域内</p>
<p>主题细分的推荐参考文献列表</p>
<p><strong>SWEBOK指南是</strong> (详细到章节编号级别)</p>
<p><strong>IEEE计算机协会软件工程</strong>
——也被IEEE计算机协会提供的软件工程</p>
<p><strong>产品套件的</strong> 认证和相关专业</p>
<p><strong>基础性文档</strong> 发展产品所采用。</p>
<p>《SWEBOK指南》是IEEE计算机协会</p>
<p>软件工程产品套件的旗舰性和结构性文档。《SWEBOK指南》也
<strong>基线和变更控制</strong></p>
<p>在整个软件工程社区中被更广泛地认可为基础性</p>
<p>文档，特别是通过官方 由于《SWEBOK</p>
<p>认可2004版和2014版
指南》的结构性质及其被其他产品采用，SWEBOK指导小组</p>
<p>分别作为ISO/IEC技术报告19759:2005 在项目开始时制定了基线。</p>
<p>和19759:2015。知识领域列表</p>
<p>A-1</p>
<p>A-2 《SWEBOK® 指南 V4.0a》</p>
<p>基线包括知识领域列表(包括 • 主题细分应尽可能全面。</p>
<p>新的知识领域)以及每个知识领域 每个知识领域从上一版本的主题细分。 •
《SWEBOK指南》采取的立场是</p>
<p>此外，已经建立了一个SWEBOK知识领域编辑团队 尽管以下”主题”</p>
<p>来开发 在所有知识领域中是通用的，但它们也是</p>
<p>本版本，以处理来自知识领域 所有知识领域的组成部分，因此</p>
<p>编辑、审查过程中或 必须纳入每个知识领域提出的</p>
<p>其他方式提出的对该基线的所有重大变更 主题细分中。</p>
<p>请求。变更请求必须经过批准 这些共同主题包括度量(measurement)、</p>
<p><em>SWEBOK</em>
<em>指南</em>编辑团队和质量（通用）及安全团队在实施前都会对主题分解进行审查。该团队由上述倡议的成员组成，并在IEEE计算机学会专业与教育活动委员会（PEAB）的工程学科委员会授权下开展工作。</p>
<h2 id="知识领域内主题分解的标准和要求">知识领域内主题分解的标准和要求</h2>
<ul>
<li>知识领域编辑需要优化主题的基线分解，以反映延续自前一版本的知识领域在目标领域的最新发展。</li>
<li>主题分解应该”合理”，而非”完美”。</li>
<li>知识领域内的主题分解必须分解<em>SWEBOK</em>中”普遍认可”的子集。（有关这一点的更详细讨论，请参见下文。）</li>
<li>知识领域内的主题分解不得预设特定的应用领域、业务需求、组织规模、组织结构、管理理念、软件生命周期模型、软件技术或软件开发方法。</li>
<li>主题分解必须尽可能与软件工程中的各种学派兼容。</li>
<li>知识领域内的主题分解必须与行业和软件工程文献及标准中通常发现的软件工程分解兼容。</li>
<li>主题分解最多应为两到三个层级。尽管对每个知识领域内的主题数量没有设定上限或下限，但预期每个知识领域中应包含合理且可管理数量的主题。</li>
</ul>
<p>还应强调主题本身的选择，而不是将它们组织在适当的层次结构中。</p>
<ul>
<li>主题名称必须足够有意义，即使在<em>SWEBOK指南</em>之外引用时也能理解。</li>
<li>知识领域的描述将包括一个图表（树形形式），描述知识分解。该图表通常是相应知识领域的第一个图。</li>
</ul>
<h2 id="主题描述的标准和要求">主题描述的标准和要求</h2>
<p>主题只需充分描述，以便读者可以根据需要选择适当的参考资料。主题描述不得具有规定性。</p>
<h2 id="参考资料的标准和要求">参考资料的标准和要求</h2>
<ul>
<li>知识领域编辑需要使用合并参考资料列表为其知识领域分配的参考资料（精确到章节编号级别）作为推荐参考资料。</li>
<li>参考资料有三类：
<ul>
<li>推荐参考资料。推荐参考资料集（精确到章节编号级别）统称为合并参考资料列表。</li>
<li>延伸阅读。</li>
<li>知识领域描述中引用的其他参考资料（例如，引文的来源或支持特定论点理由的参考资料）。</li>
</ul></li>
<li>根据定义，<em>SWEBOK指南</em>在选择主题和相关参考资料时是有选择性的。参考资料列表应明确视为”经过充分考虑的合理选择”，而非权威列表。</li>
<li>参考资料可以是书籍章节、同行评审期刊论文、同行评审会议论文、同行评审技术或工业报告，或任何其他类型的公认制品。也允许引用另一个知识领域、子领域或主题。</li>
<li>参考资料必须公开可获取，不得具有机密性质。</li>
<li>参考资料必须为英文。</li>
<li>推荐参考资料或合并参考资料列表的标准和要求：
<ul>
<li>总体而言，推荐参考资料列表应该：
<ul>
<li>完整——涵盖<em>SWEBOK指南</em>的全部范围</li>
<li>充分——提供足够的信息来描述”普遍接受”的知识</li>
<li>一致——不提供矛盾的知识或冲突的实践</li>
<li>可信——被认可为提供专家处理</li>
<li>最新——以与当前普遍接受的知识相称的方式处理主题</li>
<li>简洁——尽可能简短（包括</li>
</ul></li>
</ul></li>
</ul>
<p>[附录A] A-3</p>
<p>在引用的页数和所引用的不同参考资料的数量方面） -
每个主题都应该能够从推荐参考资料中找到至少一个相关项（精确到章节编号级别）来支持。当然，参考资料项可以涵盖多个主题。在极少数情况下，主题可能具有自我描述性，不引用参考资料项（例如，主题是定义，或者主题描述本身无需引用参考资料即可满足<em>SWEBOK指南</em>的目标）。
- 对推荐参考资料的每个引用应尽可能精确，明确指出哪个特定章节或部分相关。
- 必须提供参考资料（精确到章节编号级别）与主题的对照矩阵。 -
如果存在多个版本或版次，应使用最新版本或版次作为推荐参考资料。 -
必须为每个知识领域确定合理数量的推荐参考资料。在确定多少是合理时，应使用以下准则：
-
如果推荐参考资料以连贯的方式编写，遵循建议的主题分解，并使用一致的风格（例如，列出基于建议的知识领域描述的新书），所有知识领域的平均页数目标为750页。但是，由于风格差异以及所选参考资料之间的重叠和冗余，在选择现有参考资料时可能无法达到此目标。
-
换句话说，<em>SWEBOK指南</em>中整个推荐参考资料集的页数目标范围为10,000到15,000页。
- 另一种看待这个问题的方式是，推荐参考资料的数量</p>
<p>在参考项目数量和参考材料方面是合理的，如果</p>
<p>总页数中没有失败，它包含了这个知识领域(KA)的学习材料，用于软件工程</p>
<p>其他目标的许可考试，毕业生</p>
<p>必须为每个主题确定推荐的参考材料，在完成四年工作经验后将通过该考试。A-4
[<em>SWEBOK</em>] [<em>®</em>][ 指南 V4.0a]</p>
<h2 id="通用结构"><strong>通用结构</strong></h2>
<p><strong>普遍认可的</strong></p>
<p>由许多组织推荐的既定传统实践</p>
<p>KA描述应使用以下结构：</p>
<p><strong>高级和研究</strong></p>
<p>• 缩略语</p>
<p>仅在一些组织中测试和使用的创新实践，以及仍在研究组织中开发和测试的概念</p>
<p>• 引言</p>
<p>• KA主题分解（包括描述分解的图表）</p>
<p>• 主题与参考材料对照矩阵</p>
<p>• 延伸阅读</p>
<p>• 参考文献</p>
<figure>
<img alt="图A.1. 知识类别" src="media/image-001.png"/>
<figcaption aria-hidden="true">图A.1. 知识类别</figcaption>
</figure>
<h2 id="我们所说的普遍认可的知识是什么意思"><strong>我们所说的”普遍认可的知识”是什么意思？</strong></h2>
<p>• KA编辑者可以在”延伸阅读”列表中包含其他参考材料：</p>
<p>软件工程知识体系是一个包罗万象的术语，描述了软件工程专业内的知识总和。然而，<em>SWEBOK指南</em>旨在识别和描述普遍认可的知识体系子集，换句话说，核心知识体系。</p>
<p>» 这些材料必须与分解中的主题相关，而不是例如更高级的主题。</p>
<p>为了更好地说明”普遍认可”的知识相对于其他类型知识的含义，图A.1提出了一个用于知识分类的三类模式。</p>
<p>»
列表必须加注释（每个参考一段），解释包含每个参考的原因。延伸阅读可以包括对KA的替代观点或KA的开创性论述。</p>
<p>项目管理协会在其《项目管理知识体系指南》中将项目管理的”普遍认可”知识定义为：</p>
<p>» 遵循的一般准则是每个KA不超过10篇延伸阅读。</p>
<p>» 延伸阅读中列出的参考材料与主题分解之间没有对照矩阵。</p>
<p><em>项目管理知识体系中普遍被认可为良好实践的子集。“普遍认可”意味着所描述的知识和实践在大多数时候适用于大多数项目，并且对其价值和有用性存在共识。“良好实践”意味着普遍同意应用这些技能、工具和技术可以在广泛的项目中提高成功的机会。“良好实践”并不意味着所描述的知识应始终统一应用于所有项目；组织和/或项目管理团队负责确定什么适合任何给定项目
[1]。</em></p>
<p>• KA描述中引用的其他参考文献的标准和要求：</p>
<p>»
<em>SWEBOK指南</em>不是研究文档，其读者群将是多样化的。因此，必须在确保文档内具有高水平的可读性和保持其技术卓越性之间保持微妙的平衡。因此，只有在讨论中必要时，KA编辑者才应引入其他参考材料。例如，参考材料可能会标识引文的来源或为重要论点背后的理由提供支持。</p>
<p>[附录A] A-5</p>
<p>“普遍接受”的知识也可以被视为包含在软件工程许可考试（在美国）学习材料中的知识，毕业生在完成四年工作经验后将参加该考试。这两个定义应被视为互补的。</p>
<p>该标准被视为关于生命周期过程定义的关键标准，并已被软件工程的两个主要标准化机构采用：ISO/IEC
JTC1/SC7和IEEE计算机协会软件和系统工程标准委员会。它还被IEEE软件和系统工程标准委员会(S2ESC)指定为关键标准。</p>
<p>KA编辑者还应在解释中具有一定的前瞻性，不仅要考虑今天”普遍认可”的内容，还要考虑他们预期在三到五年时间范围内将”普遍认可”的内容。</p>
<p>尽管我们不打算让<em>SWEBOK指南</em>完全符合12207标准，但该标准仍然是<em>SWEBOK指南</em>的关键输入，并且在整个<em>指南</em>中将特别注意<em>指南</em>与12207标准的兼容性。</p>
<h2 id="ka描述的长度"><strong>KA描述的长度</strong></h2>
<p>“软件工程2014：软件工程本科学位课程指南”，IEEE计算机协会和计算机协会，2015年<a href="https://www.acm.org/binaries/content/assets/education/se2014.pdf">;
https://www.acm.org/binaries/content/assets/education/se2014.pdf</a></p>
<p>KA描述使用IEEE计算机协会会议论文集发表的论文格式模板，大约为10到20页。这包括正文、参考文献、附录、表格等。</p>
<p>当然，这不包括参考资料本身。</p>
<p>本文档描述了软件工程本科学位的课程指南。《SWEBOK指南》被确定为制定这些指南所依据的知识体系的”主要来源之一”。</p>
<p><strong>重要相关文档</strong></p>
<p><em>软件工程研究生2009</em> <em>(GSwE2009):
软件工程研究生学位课程指南</em>, 2009 [2]。</p>
<p>本文档”为定义软件工程专业硕士级别课程提供指南和建议”。《SWEBOK指南》被确定为制定这些指南所依据的知识体系的”主要参考”。本文档已获得IEEE计算机协会的正式认可，并由美国计算机协会赞助。</p>
<p>ISO/IEC/IEEE 12207:2017 系统和软件工程标准 — 软件生命周期过程
[3]。</p>
<p><a href="https://www.acm.org/binaries/content/assets/education/se2014.pdf">se2014.pdf
[4]</a></p>
<p>ISO/IEC/IEEE 24765:2017 软件和系统工程 — 词汇表; <a href="https://www.computer.org/sevocab">https://www.computer.org/sevocab</a>
[5]。</p>
<p>术语参考的层次结构是《韦氏大学词典》（第11版）[6]、ISO/IEC/IEEE 24765
[5] 和新提出的定义（如需要）。</p>
<p>“软件专业认证计划”，IEEE计算机协会; <a href="https://www.computer.org/education/certifications">https://www.computer.org/education/certifications</a>
[7]。</p>
<p>IEEE计算机协会为软件工程领域专业人士开发和提供的认证及相关专业发展产品的信息可在本网站上找到。《SWEBOK指南》是这些产品的基础。</p>
<h2 id="其他详细指南">其他详细指南</h2>
<p>引用《软件工程知识体系指南》时，请使用标题<em>SWEBOK指南</em>。</p>
<p>为简单起见，避免使用脚注，并尝试将其内容包含在正文中。</p>
<p>使用对标准的明确引用，而不是简单地插入参考书目中的项目编号。我们认为这种方法能让读者更好地了解标准的来源和范围。</p>
<p>图表的配套文字应该是自解释的或有足够的相关文本。这确保读者知道图表的含义。</p>
<p>为确保《SWEBOK指南》中的某些信息不会很快过时，并反映其通用性质，请避免直接命名工具和产品。相反，尝试命名它们的功能。</p>
<h2 id="编辑">编辑</h2>
<p>《SWEBOK指南》的编辑以及专业文字编辑将编辑KA描述。编辑包括文字编辑（语法、标点和大写）、风格编辑（符合计算机协会风格指南）和内容编辑（流畅性、含义、清晰度、直接性和组织）。最终编辑将是一个协作过程，《SWEBOK指南》的编辑和KA编辑将共同努力，以实现简洁、措辞良好且有用的KA描述。</p>
<h2 id="版权发布">版权发布</h2>
<p>与《SWEBOK指南》相关的所有知识产权将归IEEE所有。KA编辑必须签署版权发布表格。</p>
<p>还需要理解的是，《SWEBOK指南》将继续免费在公共领域以至少一种格式提供，由IEEE计算机协会通过网络技术或其他方式提供。</p>
<p>（更多信息，请参见 <a href="http://www.computer.org/copyright.htm">www.computer.org/copyright.htm</a>。）</p>
<h2 id="ieee和isoiec标准">IEEE和ISO/IEC标准</h2>
<p>附录B</p>
<p><strong>缩略词</strong></p>
<p>并组织系统化的知识</p>
<h2 id="参考文献-14">参考文献</h2>
<p>[1]
项目管理协会，《项目管理知识体系指南（PMBOK®指南）》，第7版，项目管理协会，2021年。</p>
<p>[2] 综合软件和系统工程课程(iSSEc)项目，软件工程研究生2009 (GSwE2009):
软件工程研究生学位课程指南，史蒂文斯理工学院，2009年; <a href="https://dl.acm.org/doi/book/10.1145/2593248">https://dl.acm.org/doi/book/10.1145/2593248</a>。</p>
<p>[3] ISO/IEC/IEEE 12207:2017 系统和软件工程 — 软件生命周期过程。</p>
<p>[4]
计算课程联合工作组，IEEE计算机协会和美国计算机协会，“软件工程2014：软件工程本科学位课程指南”，2015年;
<a href="https://www.acm.org/binaries/content/assets/education/se2014.pdf">https://www.acm.org/binaries/content/assets/education/se2014.pdf</a>。</p>
<p>[5] ISO/IEC/IEEE 24765:2017 系统和软件工程 — 词汇表，第2版。</p>
<p>[6] 《韦氏大学词典》，第11版，2003年。</p>
<p>[7] IEEE计算机协会，“软件专业人员的认证和培训”，2013年; <a href="https://www.computer.org/education/certifications">https://www.computer.org/education/certifications</a>。</p>
<h1 id="标准">标准</h1>
<h2 id="缩略语-3">缩略语</h2>
<p>ISO 国际标准化组织</p>
<p>JTC 联合技术委员会</p>
<p>MSS 管理体系标准</p>
<p>S2ESC 系统与软件工程标准委员会</p>
<p>IEC 国际电工委员会</p>
<p>SC 标准委员会</p>
<p>SbC 分技术委员会</p>
<h2 id="支持软件工程知识体系swebok">支持软件工程知识体系(SWEBOK)</h2>
<h3 id="1-概述">1. 概述</h3>
<p>本附录的目的是描述IEEE软件工程标准与SWEBOK之间的关系，并介绍与SWEBOK知识领域(KA)最直接相关的主要国际软件工程标准。B.9节列出了一些对软件工程有用的标准汇总清单，包括本文档中引用的所有标准。</p>
<h4 id="11-swebok与标准">1.1 SWEBOK与标准</h4>
<p>SWEBOK和其他知识体系与软件工程标准密切相关，标准在SWEBOK的知识领域(KA)中被作为资源引用。软件工程标准扩展和应用了SWEBOK中收集的公认知识体系。相反，标准也定义了雇主或认证机构确定一个人是否具备从事软件工程或获得认证所需的知识并接受道德价值观的标准。</p>
<p>相比之下，标准是”由公认机构通过共识建立并批准的文件，为活动或其结果提供共同和重复使用的规则、指南或特性，旨在在特定环境中实现最优程度的秩序”(ISO/IEC
29110-1-1:2024)。在标准中，“规则、指南或特性”以不同方式表述：</p>
<ul>
<li>规范性标准中的要求(使用<em>应当</em>或祈使语气表述)</li>
<li>推荐实践(使用<em>应该</em>表述)</li>
<li>关于可能方法的其他指导(使用<em>可以</em>表述)</li>
</ul>
<p>标准使公认的概念、过程、人员和产品能够实现全球互操作性。标准的存在将一个非常大的(可能是无限的)备选方案空间进行规范化，支持采购方和供应方之间的相互理解。在这方面，软件工程标准抵制了竞争组织开发独特的、专有的、不能在其自身套件之外互操作的产品的趋势。当标准开放，使各种规模的组织都能满足其要求时，对可信产品和服务的需求就会增加，使许多供应商和采购方受益。</p>
<p>标准是自愿的；个人或组织可以选择遵守其要求并遵循其建议。当标准被纳入合同或其他协议、法律和法规时，遵守标准就成为强制性的。</p>
<h4 id="12-标准类型">1.2 标准类型</h4>
<p>标准可以根据它们标准化软件工程的哪个部分来分类：概念和术语、过程、产品、人员或能力评估。</p>
<p>一些软件工程标准仅仅呈现概念(特性)并定义术语，甚至可能建立关于软件工程主题的知识架构。这类标准的一个例子是ISO/IEC/IEEE
24765《系统与软件工程：词汇表》，可在www.computer.org/sevocab免费在线获取。然而，大多数软件工程标准描述一个或多个软件工程过程，并给出关于如何执行该过程的要求和建议。软件工程中的主要过程标准是ISO/IEC/IEEE
12207《系统与软件工程：软件生命周期过程》。甚至有一个关于如何描述过程的标准。</p>
<p>少数软件工程标准对软件工程的产品进行了标准化描述，例如模型或信息产品，如项目管理计划(ISO/IEC/IEEE
16326)。另一个值得注意的信息产品标准是ISO/IEC/IEEE
15289《系统与软件工程——生命周期信息项(文档)的内容》。最初，大多数软件工程标准都是针对一个重要信息产品——计划的标准。这些标准使客户(软件的采购方)能够理解和比较供应商将生产什么(产品)。计划标准描述了将生产或交付什么、将使用什么方法和技术，以及将执行什么活动。近年来，大多数计划标准已被修订为软件工程过程标准。</p>
<p>除了概念、过程和产品标准外，还有针对人员技能、知识或能力的标准，以及软件工程中认证方案和知识体系的标准。一个例子是ISO/IEC
24773-1:2019《软件与系统工程——软件与系统工程专业人员认证——第1部分：通用要求》。可以对软件工程师、组织、过程和工作产品进行标准化的审查和评估。</p>
<h4 id="13-软件工程标准的来源">1.3 软件工程标准的来源</h4>
<p>尽管数百个系统和软件工程标准中有数千页内容，但SWEBOK总结了关于软件工程实践的公认概念和基于经验的信息。这些知识总结可以以各种方式应用：定义软件工程师教育课程，或供雇主或认证机构使用，然后反映在收集的知识体系中。</p>
<p>然而，SWEBOK与大多数软件工程标准的目的不同。</p>
<h1 id="附录-b-软件工程标准">附录 B - 软件工程标准</h1>
<h2 id="流程标准">流程标准</h2>
<p>一个流程：ISO/IEC/IEEE
24774，《系统和软件工程——生命周期管理——流程描述规范》。标准、指南、教科书和手册中，只有两个国际组织获得认可来制定系统和软件工程标准：ISO/IEC
JTC 1/SC 7 和
IEEE。两者都已制定软件工程标准超过三十五年。两者都致力于使用文档化的、基于共识的流程进行标准制定，并开放参与。ISO/IEC
JTC 1（国际标准化组织/国际电工委员会联合技术委员会）/SC
7（分委员会），软件和系统工程，通过其国家标准机构成员制定标准。JTC 1/SC
7 拥有超过两百个标准的组合。IEEE
计算机协会系统和软件标准委员会（S2ESC）在个人专家工作组中制定标准。它维护约五十个标准，其中约
80% 已被批准为 ISO/IEC/IEEE 联合标准。这些是被 ISO/IEC JTC 1/SC 7 采纳的
IEEE 标准，或与 ISO/IEC JTC 1 联合开发和维护并指定为 ISO/IEC/IEEE
的标准。这些联合开发标准的目标是拥有一套协调一致的标准供国际使用。对于本附录中描述的
ISO/IEC/IEEE 标准，IEEE 版本和 ISO/IEC
版本在实质上是相同的。各自的版本可能具有不同的前言和后记，但技术内容完全相同。</p>
<p>它描述了流程的目的、结果、活动、任务，以及可能的输入、输出和其他特征。流程标准不应与程序或指令混淆；它们不提供详细的配方或进行软件工程的逐步说明。</p>
<p>标准可以从 IEEE、ISO 和 IEC
网站、国家标准组织以及商业转销商处购买。学术机构和软件工程组织可以购买或订阅标准集合供其员工使用。少数标准是免费提供的，通常是那些提供概念或术语介绍的标准。</p>
<p>在 IEEE 和 ISO/IEC JTC 1
中，系统工程标准由与软件工程标准相同的委员会维护。大多数标准适用于两者，特别是当软件被视为系统或关注系统的主要组成部分时。因此，本附录不做细微区分，而是涵盖适用于软件工程的两者。它不提及处理计算基础或计算语言和基本编程、数学或工程概念的较旧的、现已稳定的标准。</p>
<p>ISO 和 IEEE 有各自的标准编号系统。当 IEEE 标准被 ISO/IEC JTC 1
采纳时，它通常被重新编号为 5 位数字，例如，IEEE 1062 变成 ISO/IEC/IEEE
41062。ISO
标准具有长的、分类学的标题，包含三级和四级分类。第一级显示一般领域（例如系统和软件工程）；第二级是标准的主标题，第三级提供更多细节，特别是对于多部分标准。为避免繁琐的重复，本附录通常使用标准的简化标题或仅按编号引用。完整标题在
B.9 的列表中给出。所有这些软件工程标准都受版权保护，IEEE
标准编号是商标。</p>
<h2 id="2-软件工程标准全景">2. 软件工程标准全景</h2>
<p>图 B.1
展示了最突出的软件工程标准的概览，主要从其他标准如何与主要软件工程生命周期流程标准
ISO/IEC/12207（软件工程流程）相关联的角度来看。</p>
<p>它与 SWEBOK
密切相关，因为两者都提供与许多相同的软件生命周期流程相关的信息。图 B.1
的上部还包括基础标准，例如系统和软件工程的专业词汇（SEVOCAB，ISO/IEC/IEEE
24765）以及如何描述流程的规范（ISO/IEC/IEEE
24774）。有关于如何规划和管理软件工程（ISO/IEC/IEEE
24748-5）以及如何进行严格审查和审计的标准，适用于关键软件，如航空航天和国防系统（ISO/IEC/IEEE
24748-8）。</p>
<p>使用下一节中描述的 12207
生命周期流程模型，还有许多更专业的标准涵盖了各个流程和流程的现代方法，例如
ISO/IEC/IEEE 32675（DevOps），以及 IEEE 1012（验证和确认）和
ISO/IEC/IEEE 29119（软件测试，多个部分）。12207
中的生命周期流程通常关注于</p>
<figure>
<img alt="知识体系" src="images/000001.png"/>
<figcaption aria-hidden="true">知识体系</figcaption>
</figure>
<figure>
<img alt="图表：软件工程标准全景，显示了各种ISO/IEC/IEEE标准之间的关系，包括生命周期流程、管理系统、产品线和各个流程等" src="images/000012.png"/>
<figcaption aria-hidden="true">图表：软件工程标准全景，显示了各种ISO/IEC/IEEE标准之间的关系，包括生命周期流程、管理系统、产品线和各个流程等</figcaption>
</figure>
<ul>
<li><p><strong>核心标准：</strong></p>
<ul>
<li>ISO/IEC/IEEE 24765 词汇表（SEVOCAB）</li>
<li>ISO/IEC/IEEE 24774 流程描述</li>
<li>SWEBOK 软件工程知识体系</li>
<li>IEEE 指南</li>
</ul></li>
<li><p><strong>生命周期流程：</strong></p>
<ul>
<li>ISO/IEC/IEEE 12207（中心标准）</li>
<li>ISO/IEC/IEEE 24748-4 系统工程计划</li>
<li>ISO/IEC/IEEE 24748-8 审查和审计</li>
</ul></li>
<li><p><strong>管理系统：</strong></p>
<ul>
<li>ISO 9001 质量</li>
<li>ISO/IEC 27000 安全</li>
<li>ISO/IEC 20000 服务</li>
<li>ISO/IEC 19770 IT 资产管理</li>
</ul></li>
<li><p><strong>流程视图：</strong></p>
<ul>
<li>ISO/IEC/IEEE 32675 DevOps 流程视图</li>
<li>各个流程</li>
</ul></li>
<li><p><strong>产品线</strong></p></li>
<li><p><strong>信息管理：</strong></p>
<ul>
<li>ISO/IEC/IEEE 15289</li>
</ul></li>
</ul>
<h1 id="系统之系统sos软件测试验证确认isoiecieee-标准体系">系统之系统(SoS)、软件测试、验证/确认、ISO/IEC/IEEE
标准体系</h1>
<p><img src="images/000023.png"/></p>
<p><strong>图 B.1.</strong> 软件工程标准全景图</p>
<p><img src="images/000034.png"/></p>
<p>单一关注系统(SOI)但更专业化的系列专注于产品线工程和系统之系统(SoS)的过程和工具。系统之系统标准
ISO/IEC/IEEE 21839、21840 和 21841
解释了当关注系统(SOI)是系统之系统的组成部分时如何使用系统工程过程。</p>
<p>生命周期过程标准旨在与其他知名的管理系统标准兼容。根据 ISO
的定义，“管理系统是组织管理其业务相互关联部分以实现其目标的方式。”管理系统标准(MSS)具有一致的结构和需求框架，但每个
MSS 涵盖管理和交付工程产品和服务的特定方面。MSS
通常包含多个部分，为其系统的不同方面提供各种指南。与软件工程相关的知名
MSS 包括：ISO 9000 质量管理、ISO/IEC 20000 服务管理、ISO/IEC 27000
系列信息安全管理、ISO/IEC 19770 系列 IT 资产管理(如硬件和软件)，以及
ISO/IEC 30105 系列业务流程外包运营。</p>
<h2 id="生命周期过程标准">生命周期过程标准</h2>
<p>ISO/IEC/IEEE 12207《软件生命周期过程》和 ISO/IEC/IEEE
15288《系统生命周期过程》经过有意协调以便共同使用。如 ISO/IEC/IEEE
15288:2023
所述，“人造系统存在一个连续体，从几乎不使用软件的系统到软件是主要关注点的系统。当软件是主要的系统或关注要素时，应使用
ISO/IEC/IEEE
12207。”两个标准具有相同的生命周期模型(相同的四个过程组，如图 B.2
所示)和相同的过程。这些过程在两个标准中具有相同的名称、目的和过程结果(在几个过程名称上存在细微差异)。这两个基础标准之间的过程活动和任务有所不同，因为软件系统工程的某些方面与一般系统不同。</p>
<p>符合 ISO/IEC/IEEE 12207 或 15288
可以通过证明过程的所有结果已经实现，或者过程的所有必需活动和任务已经执行来显示。</p>
<p>生命周期过程在其项目使用的背景下呈现，由提供跨多个项目持续服务的组织支持。但是，这些过程可以应用于本质上组织为单个团队的非常小的实体，也可以应用于大型项目和没有明确终点的持续工作。</p>
<p><img src="images/000052.png"/></p>
<p><strong>图 B.2.</strong> ISO/IEC/IEEE 12207 的过程组</p>
<ul>
<li>技术过程组</li>
<li>管理过程组<br/>
</li>
<li>协议过程组</li>
<li>组织项目使能过程组</li>
</ul>
<p>ISO/IEC/IEEE 12207
为软件生命周期过程建立了一个通用框架，具有明确定义的术语，可供软件行业参考。ISO/IEC
12207
适用于系统和软件产品及服务的获取，以及软件系统和系统的软件部分的供应、开发、运营、维护和处置，无论是在组织内部还是外部执行。包括提供软件产品和服务背景所需的系统定义和使能系统(基础设施)方面。可以在整个生命周期中应用这些过程的选定集合，以管理和执行系统生命周期的各个阶段。这是通过在组织中更高层级或更一般层级上处理的功能来实现的。</p>
<p>本版 SWEBOK
增加了软件安全知识领域(KA)，由于历史原因，该领域与系统和软件工程标准委员会分开标准化。安全在
ISO/IEC/IEEE 12207 中未被识别为技术过程。基于 ISO/IEC 27001 MSS
的广泛安全标准套件在 ISO/IEC JTC 1 SC 27
信息安全、网络安全和隐私保护中开发。</p>
<p>表 B.1 还识别了旨在确定应使用软件工具和方法的过程相关功能的标准。</p>
<p><img src="images/000002.png"/> <img src="images/000003.png"/> <img src="images/000004.png"/> <img src="images/000005.png"/> <img src="images/000006.png"/> <img src="images/000007.png"/> <img src="images/000008.png"/> <img src="images/000009.png"/> <img src="images/000010.png"/> <img src="images/000011.png"/> <img src="images/000013.png"/> <img src="images/000014.png"/> <img src="images/000015.png"/> <img src="images/000016.png"/> <img src="images/000017.png"/> <img src="images/000018.png"/> <img src="images/000019.png"/> <img src="images/000020.png"/> <img src="images/000021.png"/> <img src="images/000022.png"/> <img src="images/000024.png"/> <img src="images/000025.png"/> <img src="images/000026.png"/> <img src="images/000027.png"/> <img src="images/000028.png"/> <img src="images/000029.png"/> <img src="images/000030.png"/> <img src="images/000031.png"/> <img src="images/000032.png"/> <img src="images/000033.png"/> <img src="images/000035.png"/> <img src="images/000036.png"/> <img src="images/000037.png"/> <img src="images/000038.png"/> <img src="images/000039.png"/> <img src="images/000040.png"/> <img src="images/000041.png"/> <img src="images/000042.png"/> <img src="images/000043.png"/> <img src="images/000044.png"/> <img src="images/000045.png"/> <img src="images/000046.png"/> <img src="images/000047.png"/> <img src="images/000048.png"/> <img src="images/000049.png"/> <img src="images/000050.png"/> <img src="images/000051.png"/> <img src="images/000053.png"/> <img src="images/000054.png"/></p>
<p>通过所有相关方的参与，以实现客户满意为目标，将这些过程应用到产品线工程（见
B.6）。</p>
<p>表 B.1 将 ISO/IEC/IEEE 12207 的软件生命周期过程与 SWEBOK
知识领域(KA)对齐，并识别了为各个过程提供更详细要求和指导的相关标准。SWEBOK
知识领域并未直接涵盖 ISO/IEC/IEEE 12207
中的所有过程组和过程。协议过程（获取和供应）未包含在内，组织项目支持过程组中的许多过程也未包含，并且并非所有技术管理或技术过程组的过程都包含在内。选择
SWEBOK
知识领域是为了涵盖在项目或持续工作中工作的软件工程师所应用的基本知识领域，而不是所有过程。</p>
<h2 id="4-isoiecieee-12207-的扩展和专业化应用">4. ISO/IEC/IEEE 12207
的扩展和专业化应用</h2>
<p>许多有用的标准补充了 ISO/IEC/IEEE 12207
的要求，以处理更严格或专业化的情况，或者为其概念和过程提供更详细的指导。这些标准中的许多是
ISO/IEC/IEEE 24748 系列的组成部分。</p>
<h3 id="41-概念和若干过程的说明">4.1 概念和若干过程的说明</h3>
<p>ISO/IEC/IEEE 24748-1、-2 和 -3
是生命周期过程的总体指南，对于理解和应用这些过程非常宝贵。</p>
<p><strong>表 B.1. 按 ISO/IEC/IEEE 12207
过程组和过程列出的相关软件工程标准和知识领域</strong></p>
<table>
<colgroup>
<col style="width: 20%"/>
<col style="width: 20%"/>
<col style="width: 20%"/>
<col style="width: 20%"/>
<col style="width: 20%"/>
</colgroup>
<thead>
<tr>
<th><strong>12207 条款号</strong></th>
<th><strong>简称</strong></th>
<th><strong>SWEBOK 知识领域</strong></th>
<th><strong>相关标准 (ISO/IEC/IEEE 除非另有说明)</strong></th>
<th><strong>产品线或工具标准 (ISO/IEC)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>协议</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.1.1</em></td>
<td>获取</td>
<td></td>
<td>41062, 26512</td>
<td></td>
</tr>
<tr>
<td><em>6.1.2</em></td>
<td>供应</td>
<td></td>
<td>41062</td>
<td></td>
</tr>
<tr>
<td><strong>组织过程支持</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.2.1</em></td>
<td>生命周期模型管理</td>
<td>是</td>
<td>24748-1, 24748-2, 24748-3, 33020</td>
<td></td>
</tr>
<tr>
<td><em>6.2.2</em></td>
<td>基础设施管理</td>
<td></td>
<td>26550</td>
<td></td>
</tr>
<tr>
<td><em>6.2.3</em></td>
<td>组合管理</td>
<td></td>
<td>33001</td>
<td>26556</td>
</tr>
<tr>
<td><em>6.2.4</em></td>
<td>人力资源管理</td>
<td>是，专业实践</td>
<td>24773</td>
<td></td>
</tr>
<tr>
<td><em>6.2.5</em></td>
<td>质量管理</td>
<td>是，软件质量</td>
<td>IEEE 730, 25000, 90003</td>
<td></td>
</tr>
<tr>
<td><em>6.2.6</em></td>
<td>知识管理</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>技术管理</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.3.1</em></td>
<td>项目规划</td>
<td>是</td>
<td>16326, 24748-4, 24748-5</td>
<td>26555</td>
</tr>
<tr>
<td><em>6.3.2</em></td>
<td>项目评估、控制</td>
<td>是</td>
<td>16326, 24748-4, 24748-5, 24748-7, 26511, 20246</td>
<td>23396, 23531, 26555, 33001, 33002</td>
</tr>
<tr>
<td><em>6.3.3</em></td>
<td>决策管理</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.3.4</em></td>
<td>风险管理</td>
<td></td>
<td>16085, 15026 (所有部分)</td>
<td></td>
</tr>
<tr>
<td><em>6.3.5</em></td>
<td>配置管理</td>
<td>是</td>
<td>IEEE 828, 16350, 19770 (所有部分)</td>
<td>26559, 26560, 26561</td>
</tr>
<tr>
<td><em>6.3.6</em></td>
<td>信息管理</td>
<td></td>
<td>15289, 26511, 26531, 23026, 82079-1</td>
<td></td>
</tr>
<tr>
<td><em>6.3.7</em></td>
<td>度量</td>
<td>是</td>
<td>15939, 14143, 32430, 19761, 20926, 25020, 25021, 25022, 25023,
25024, 29881, 33003</td>
<td></td>
</tr>
<tr>
<td><em>6.3.8</em></td>
<td>质量保证</td>
<td>是</td>
<td>IEEE 730, IEEE 982.1, 25010, 25012</td>
<td></td>
</tr>
<tr>
<td><strong>技术</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>6.4.1</em></td>
<td>业务或任务分析</td>
<td></td>
<td></td>
<td>26561</td>
</tr>
<tr>
<td><em>6.4.2</em></td>
<td>利益相关者需求和要求</td>
<td>是</td>
<td>25030</td>
<td></td>
</tr>
<tr>
<td><em>6.4.3</em></td>
<td>系统需求定义</td>
<td>是</td>
<td>29148</td>
<td>26551</td>
</tr>
<tr>
<td><em>6.4.4</em></td>
<td>架构定义</td>
<td>是</td>
<td>42010, 42020</td>
<td>26442, 26552</td>
</tr>
<tr>
<td><em>6.4.5</em></td>
<td>设计定义</td>
<td>是</td>
<td>24748-7000, 26514</td>
<td>26557, 26580</td>
</tr>
<tr>
<td><em>6.4.6</em></td>
<td>系统分析</td>
<td>是，模型和方法</td>
<td>ISO/IEC 24641</td>
<td>20246, 26558</td>
</tr>
<tr>
<td><em>6.4.7</em></td>
<td>实现</td>
<td>是，构建</td>
<td></td>
<td>26553</td>
</tr>
<tr>
<td><em>6.4.8</em></td>
<td>集成</td>
<td>是，构建</td>
<td>24748-6</td>
<td></td>
</tr>
<tr>
<td><em>6.4.9</em></td>
<td>验证</td>
<td>是，测试</td>
<td>IEEE 1012, 25021, 25040, 25041, 25045, 25062, 26513, 29119-1,
29119-2, 29119-3, 33063, 42030</td>
<td>23643, 26554, 30130</td>
</tr>
<tr>
<td><em>6.4.10</em></td>
<td>过渡</td>
<td></td>
<td></td>
<td>26562</td>
</tr>
<tr>
<td><em>6.4.11</em></td>
<td>确认</td>
<td>是，测试</td>
<td>IEEE 1012</td>
<td></td>
</tr>
<tr>
<td><em>6.4.12</em></td>
<td>运行</td>
<td>是</td>
<td>32675</td>
<td>23531</td>
</tr>
<tr>
<td><em>6.4.13</em></td>
<td>维护</td>
<td>是</td>
<td>14764</td>
<td></td>
</tr>
<tr>
<td><em>6.4.14</em></td>
<td>废弃</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>软件安全</td>
<td>是</td>
<td>ISO/IEC 27000 系列, 15026 (第 1 至 4 部分)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>软件工程计算基础</td>
<td>是</td>
<td>众多历史标准</td>
<td></td>
<td></td>
</tr>
<tr>
<td>软件工程数学基础</td>
<td>是</td>
<td>众多历史标准</td>
<td></td>
<td></td>
</tr>
<tr>
<td>软件工程基础</td>
<td>是</td>
<td>众多历史标准</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>系统和软件工程概念。通常在整个生命周期中反复应用这些过程，它包括对生命周期阶段的详细描述，涵盖其目的和成果。生命周期阶段有几种模型，在
ISO/IEC/IEEE 24748-1
中详细分析的模型包括以下阶段：概念、开发、生产、使用、支持和退役。</p>
<p>ISO/IEC/IEEE
24748-1《生命周期管理指南》不仅仅是执行生命周期管理过程的指南。它适用于软件和系统工程过程，进一步解释了系统和过程概念。该标准不是描述过程，而是解释生命周期阶段，涵盖其目的和成果。由于软件工程师很少将生产作为关注的阶段，因此软件生命周期阶段的替代模型更有用：概念、开发、运行和维护以及退役。生命周期模型按其开发方法分类：顺序、增量或演化。这些生命周期模型通过基于风险的方法进行比较。</p>
<p>ISO/IEC/IEEE 24748-2
是总体指南，涉及相关利益相关者在生命周期早期应用质量活动、安全、隐私、性能、验证和确认。IEEE
2675 强调成功应用 DevOps 所需的领导承诺。它回顾了 ISO/IEC/IEEE 12207
中的许多生命周期过程，分析它们如何通过 DevOps 进行转换，并讨论 DevOps
与敏捷方法的结合使用。</p>
<p>ISO/IEC/IEEE 15288
系统工程流程应用指南。然而，它并不提供每个流程、活动和任务的逐行详细说明，而是提出了一个过渡到使用标准化生命周期流程的整体策略。其中还包含更多关于系统概念的解释、组织概念的介绍、关于标准流程的符合性或裁剪(tailoring)的讨论，以及基于模型的系统和软件工程(MBSSE)的介绍。</p>
<p>ISO/IEC/IEEE
24748-3，软件生命周期流程应用指南，也对软件系统、组织和项目、流程、生命周期状态以及软件系统生命周期流程模型等概念提供了注释。它包含了
ISO/IEC/IEEE 12207
中每个流程的指导，包括对流程目的、成果和输出、活动、任务和方法、密切相关流程以及相关标准的进一步分析。</p>
<p>ISO/IEC/IEEE 32675 DevOps(IEEE
2675)的副标题是”构建可靠和安全的系统，包括应用构建、打包和部署”。它将
DevOps
定义为”一组原则和实践，能够在相关利益相关者之间实现更好的沟通和协作，用于规范、开发和运营软件和系统产品及服务，以及生命周期各方面的持续改进”。它阐述了
DevOps 的原则，包括业务或使命优先、以客户为中心、左移(left
shift)和持续一切，以及系统思维。(左移被定义为”优先考虑参与”。)</p>
<p>[在早期版本中，ISO/IEC/IEEE 24748-4 和 24748-5
分别涵盖了管理计划(系统工程管理计划或软件工程管理计划)应包含的内容。这些内容仍然存在，但现在它们还分别为系统工程师和软件工程师提供了管理规划和控制流程的指导，并简要介绍了相关流程。]</p>
<h2 id="42-更专业的扩展">4.2 更专业的扩展</h2>
<p>虽然健康与安全、安全性和环境问题的专业领域已经建立了完善的标准，但将伦理价值观与软件系统联系起来的标准相对较新。软件系统可能通过有偏见的决策、侵犯隐私或缺乏社会责任而造成伤害，这促使了
ISO/IEC/IEEE 24748-7000(IEEE 7000)的开发。IEEE 7000
提出了一个将伦理价值观纳入系统设计的模型流程。</p>
<p>工程师、他们的管理者和其他利益相关者受益于明确定义的流程，这些流程在系统生命周期早期就考虑伦理问题以及系统性能和功能的常规关注点。该标准要求考虑与系统部署文化相关的价值观。它适用于任何生命周期模型或开发方法。本标准中的流程旨在与
ISO/IEC/IEEE 12207 中的流程同时执行(表 B.3)。</p>
<p>早期版本的 ISO/IEC/IEEE 12207
被一些人认为在所需文档、评审和任务序列方面过于规范性。当前版本旨在供任何规模或类型的组织使用，对流程采用更具战略性、敏捷的方法，减少了文档和评审要求。</p>
<p>然而，对于高度复杂和关键的系统，与美国国防部协调开发了一套更加严格和结构化的流程、评审和审计，并在
ISO/IEC/IEEE 24748-7:2019《系统和软件工程 — 生命周期管理 —
第7部分：系统工程在国防计划中的应用》和 ISO/IEC/IEEE
24748-8:2019《系统和软件工程 — 生命周期管理 —
第8部分：国防计划的技术评审和审计》中进行了规定。对于更通用的用途，ISO/IEC
20246
概述了整个生命周期中工作产品评审的流程和特征，涵盖软件和信息产品。</p>
<p>ISO/IEC/IEEE 24748-9
是系统和软件生命周期流程在流行病预防和控制系统中的应用。更普遍地说，它展示了在基础设施和人员支持有限的情况下进行系统和软件工程的方法，例如”基础设施保护不足、交付周期短、频繁迭代升级，以及准确性等特殊要求”。</p>
<h2 id="5-单一流程标准">5. 单一流程标准</h2>
<p>ISO/IEC/IEEE 12207
适用于所有类型的软件工程，具有多种生命周期模型、技术和方法。其流程描述不详细说明应如何执行流程或哪些技术被认为是最佳实践。为此，有许多更专业的标准，其中包含适用于大多数软件工程流程的额外要求和指南。表
B.1 将 ISO/IEC/IEEE 12207 中的每个流程与相关的 SWEBOK
知识领域、更专业的标准和指南以及将流程应用于产品线、工具和方法的相关标准相关联。表
B.2 显示了每个知识领域中引用的标准。</p>
<h2 id="6-产品线方法和工具的标准">6. 产品线、方法和工具的标准</h2>
<p>产品线是”一组产品或服务，共享明确定义和管理的共同和可变特性，并依赖于相同的领域架构来满足特定市场的共同和可变需求”(ISO/IEC
26550:2015)。产品线工程提出了不同的考虑因素，特别是对于持续的配置</p>
<p>灾难容错、降级能力、发布管理、维护和安全性、用户容量和压力测试，以及快速需求捕获的基本方法，来自ISO/IEC/IEEE
12207，该标准从组织内项目的角度应用软件工程。</p>
<p><strong>4.3 SoS标准</strong></p>
<p>三个标准探讨了系统和软件工程概念及过程如何应用于系统之系统（SoS）。ISO/IEC/IEEE
21839描述了作为SoS组成部分的系统在其生命周期各阶段如何受到影响。ISO/IEC/IEEE
21940采取相反的视角，探讨SoS的概念以及ISO/IEC/IEEE
15288如何应用于SoS。ISO/IEC/IEEE
21841是一个简要的分类法，识别了四种类型的SoS：定向型、公认型、协作型和虚拟型。</p>
<p>ISO/IEC
26550至26569系列标准还涵盖了与各种软件工程过程和管理任务相关的工具能力。由于软件开发和运维工具能力不断扩展并更紧密地集成以支持DevOps流水线，该系列中的各个标准并未与当前商业产品套件或开源库紧密对齐。然而，这些工具标准确实建议了在支持软件生命周期时应寻求的有用功能。</p>
<p>B-10 <em>SWEBOK® GUIDE V4.0a</em></p>
<p><strong>表B.2. 按知识领域引用的标准</strong></p>
<table>
<colgroup>
<col style="width: 18%"/>
<col style="width: 27%"/>
<col style="width: 32%"/>
<col style="width: 20%"/>
</colgroup>
<thead>
<tr>
<th><strong>KA</strong></th>
<th><strong>知识领域</strong></th>
<th><strong>引用的标准</strong></th>
<th><strong>编号</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>引言</td>
<td>24765, 12207</td>
<td>（ISO/IEC/IEEE除非另有说明）</td>
</tr>
<tr>
<td>1</td>
<td>软件需求</td>
<td>24765, 12207, ISO/IEC 25010, 29148</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>软件架构</td>
<td>24765, 12207, 42010</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>软件设计</td>
<td>12207, 24748-7000, 24765</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>软件构造</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>软件测试</td>
<td>IEEE 1012, ISO/IEC 20246, 24765, ISO/IEC 25010, 29119（多个部分）,
32675</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>软件工程运维</td>
<td>12207, ISO/IEC 20000, 24765, 32675</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>软件维护</td>
<td>12207, 14764, 15288, 32675</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>软件配置管理</td>
<td>IEEE 828, 24765, 12207</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>软件工程管理</td>
<td>12207, 32675</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>软件工程过程</td>
<td>12207, 24748-1, 24748-3, 24765, 24774, ISO/IEC 25000, 29110, 33001,
32675</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>软件工程模型和方法</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>软件质量</td>
<td>IEEE 730, IEEE 982.1, IEEE 1012, IEEE 1228, IEEE 1633, ISO 9001,
12207, 15026-1, 15288, 20000, 20246, 24765, 25010, 27001, 33061, 90003,
IEC 60300</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>软件安全</td>
<td>ISO/IEC 15408-1, ISO/IEC 18045, ISO/IEC 19770-1, ISO/IEC 21827,
25010, ISO/IEC 27000, ISO/IEC 27001, ISO/IEC 27032</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>软件工程专业实践</td>
<td>ISO/IEC 24773-1, ISO/IEC 24773-4</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>软件工程经济学</td>
<td>12207, 15288</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>计算基础</td>
<td>12207, 24765</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>数学基础</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>工程基础</td>
<td>24765</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>7. 过程评估标准</strong></p>
<p>过程评估是一种长期存在的方法，用于确认软件工程过程的能力、质量和成熟度，并鼓励过程改进。过程审计寻找活动执行和成果达成的证据（如工作产品和信息项等工件）。假设是，由有能力的从业者执行的、具有组织支持的可重复过程更有可能产生可接受的软件产品和服务。ISO/IEC
33000标准系列</p>
<p>APPENDIX B B-11</p>
<p><strong>表B.3. ISO/IEC/IEEE 24748-7000（IEEE
7000）中的伦理价值过程与ISO/IEC/IEEE
12207中的软件工程过程的对齐</strong></p>
<table>
<colgroup>
<col style="width: 30%"/>
<col style="width: 69%"/>
</colgroup>
<thead>
<tr>
<th><strong>IEEE Std 7000过程条款</strong></th>
<th><strong>ISO/IEC/IEEE 12207:2017和ISO/IEC/IEEE
15288:2023过程条款</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>7. 运营概念（ConOps）和上下文探索</td>
<td><em>6.4.1 业务或任务分析</em></td>
</tr>
<tr>
<td>8. 伦理价值获取和优先级排序</td>
<td><em>6.4.1 业务或任务分析，6.4.2 利益相关者需求和需求定义</em></td>
</tr>
<tr>
<td>9. 伦理需求定义</td>
<td><em>6.4.2 利益相关者需求和需求定义，6.4.3 系统需求定义</em></td>
</tr>
<tr>
<td>10. 基于伦理风险的设计</td>
<td><em>6.4.4 架构定义，6.4.5 设计定义</em></td>
</tr>
<tr>
<td>11. 透明度管理</td>
<td><em>6.3.6 信息管理</em></td>
</tr>
</tbody>
</table>
<p>目前包括二十多个与过程评估相关的活跃标准，适用于软件和系统工程。ISO/IEC
33001描述了ISO/IEC
330xx系列的整体架构和内容。过程评估根据文档化的评估过程进行，该过程确定过程属性的评级方法以及如何确定过程评级。ISO/IEC
33061是与ISO/IEC/IEEE
12207软件工程过程对齐的过程评估标准，将其作为过程参考模型。</p>
<p><strong>8. 专业技能和知识标准</strong></p>
<p>ISO/IEC
24773系列包含专门与软件和系统工程专业人员认证相关的要求。它对行业组织很有用，ISO/IEC
24773-4为软件工程认证机构提供了具体要求。它指定IEEE
SWEBOK作为软件工程知识体系的参考。</p>
<p><strong>9. 精选软件工程标准</strong></p>
<p>这不是与软件工程相关或由IEEE系统和软件工程标准委员会（S2ESC）或ISO/IEC
JTC
1/SC7（软件和系统工程）赞助的标准的详尽列表。列出的标准被认为对SWEBOK用户更具权威性、相关性和帮助性。</p>
<p>本附录中描述的标准正在不断修订或被替换。</p>
<p>寻求比较各种新标准的认证。标准用户应</p>
<p>系统和/或软件工程专业人员；寻求获取认证的个人专业人员；以及可能选择认可此类认证的雇主。这些标准面向国际使用，不取代国家或地区对工程师的许可或注册要求。ISO/IEC
24773-1是认证概念的概述，以及认证过程和认证的要求</p>
<p>查找最新版本以及与软件工程新兴主题相关的新标题，如数字工程或与人工智能(AI)相关的标准。</p>
<p>• IEEE 730-2014 IEEE软件质量保证过程标准 • IEEE 828-2012
IEEE系统和软件工程配置管理标准 B-12
<em>SWEBOK</em>®<em>指南V4.0a</em></p>
<p>• IEEE 982.1-2005 IEEE软件测量标准词典</p>
<p>• IEEE 1012-2016 IEEE系统、软件和硬件验证与确认标准</p>
<p>• IEEE 1228-1994 (R2002) IEEE软件安全计划标准</p>
<p>• IEEE 1633-2016 IEEE软件可靠性推荐实践</p>
<p>• ISO 9000:2015 质量管理体系——基础和术语</p>
<p>• ISO 9001:2015 质量管理体系——要求</p>
<p>• ISO/IEC/IEEE 12207:2017 系统和软件工程：软件工程过程</p>
<p>• ISO/IEC 14143 信息技术——软件测量——功能规模测量(多个部分)</p>
<p>• ISO/IEC/IEEE 14764:2021 软件工程——软件生命周期过程——维护</p>
<p>• ISO/IEC/IEEE 15026-1:2019
系统和软件工程——系统和软件保证——第1部分：概念和术语</p>
<p>• ISO/IEC/IEEE 15026-2:2021
系统和软件工程——系统和软件保证——第2部分：保证案例</p>
<p>• ISO/IEC 15026-3:2023
系统和软件工程——系统和软件保证——第3部分：系统完整性等级</p>
<p>• ISO/IEC/IEEE 15026-4:2021
系统和软件工程——系统和软件保证——第4部分：生命周期中的保证</p>
<p>• ISO/IEC/IEEE 15288:2023 系统和软件工程标准——系统生命周期过程</p>
<p>• ISO/IEC/IEEE 15289:2019
系统和软件工程——生命周期信息产品内容(文档)</p>
<p>• ISO/IEC 15408-1:2022
信息安全、网络安全和隐私保护——IT安全评估标准</p>
<p>安全——第1部分：介绍和通用模型可信赖性方面</p>
<p>• ISO/IEC/IEEE 15939:2017 系统和软件工程——测量过程</p>
<p>• ISO/IEC/IEEE 16085:2021
系统和软件工程——软件生命周期过程——风险管理</p>
<p>• ISO/IEC/IEEE 16326:2019 系统和软件工程——生命周期过程——项目管理</p>
<p>• ISO/IEC 16350:2015 信息技术——系统和软件工程——应用管理</p>
<p>• ISO/IEC 18045:2022
信息安全、网络安全和隐私保护——IT安全评估标准——IT安全评估方法论</p>
<p>• ISO/IEC 19761:2011 软件工程——COSMIC：功能规模测量方法</p>
<p>• ISO/IEC 19770-1:2017
信息技术——IT资产管理——第1部分：IT资产管理系统——要求</p>
<p>• ISO/IEC 19770-2:2015
信息技术——IT资产管理——第2部分：软件标识标签</p>
<p>• ISO/IEC 19770-3:2016 信息技术——IT资产管理——第3部分：授权模式</p>
<p>• ISO/IEC 19770-4:2017
信息技术——IT资产管理——第4部分：资源利用率测量</p>
<p>• ISO/IEC 19770-5:2015 信息技术——IT资产管理——第5部分：概述和术语</p>
<p>• ISO/IEC 19770-8:2020
信息技术——IT资产管理——第8部分：行业实践与ISO/IEC
19770系列标准之间映射指南</p>
<p>• ISO/IEC 19770-11:2021
信息技术——IT资产管理——第11部分：提供IT资产管理系统审计和认证的机构要求</p>
<p>• ISO/IEC 20000-1:2018 信息技术——服务管理</p>
<p>[附录B] B-13</p>
<p>——第1部分：服务管理系统软件工程要求</p>
<p>• ISO/IEC 20246:2017 软件和系统工程——工作产品评审</p>
<p>• ISO/IEC 20741:2017 系统和软件工程——软件工程工具评估和选择指南</p>
<p>• ISO/IEC 20926:2009
软件和系统工程——软件测量——IFPUG功能规模测量方法</p>
<p>• ISO/IEC 20968:2002 软件工程——Mk II功能点分析——计数实践手册</p>
<p>• ISO/IEC 21827:2008
信息技术——安全技术——系统安全工程——能力成熟度模型®(SSE-CMM®)</p>
<p>• ISO/IEC/IEEE 21839:2019 系统和软件工程——系统的</p>
<p>• ISO/IEC/IEEE 24748-1:2024
系统和软件工程——生命周期管理——第1部分：生命周期管理指南</p>
<p>• ISO/IEC/IEEE 24748-2:2024
系统和软件工程——生命周期管理——第2部分：ISO/IEC/IEEE
15288(系统生命周期过程)应用指南</p>
<p>• ISO/IEC/IEEE 24748-3:2020
系统和软件工程——生命周期管理——第3部分：ISO/IEC/IEEE
12207(软件生命周期过程)应用指南</p>
<p>• ISO/IEC/IEEE 24748-4:2016
系统和软件工程——生命周期管理——第4部分：系统工程规划</p>
<p>• ISO/IEC/IEEE 24748-5:2017 系统和软件工程——生命周期</p>
<p>systems (SoS) considerations in life cycle [management —
第5部分：软件开发]</p>
<p>stages of a system opment planning</p>
<p>• ISO/IEC/IEEE 21840:2019 系统 [• ISO/IEC/IEEE
24748-6:2023，系统]</p>
<p>和软件工程 — 在系统之系统 [和软件工程 — 生命周期]</p>
<p>(SoS) 环境中使用 ISO/IEC/IEEE [管理 — 第6部分：系统和]</p>
<p>15288 的指南 [软件集成]</p>
<p>• ISO/IEC/IEEE 21841:2019 系统 [• ISO/IEC/IEEE 24748-7:2019 系统]</p>
<p>和软件工程 — 系统之系统 [和软件工程 — 生命周期]</p>
<p>的分类法 [管理 — 第7部分：系统工程]</p>
<p>• ISO/IEC/IEEE 23026:2023 系统 [在国防项目中的应用]</p>
<p>和软件工程 — 针对系统、 [• ISO/IEC/IEEE 24748-8:2019 系统]</p>
<p>软件和服务信息的网站 [和软件工程 — 生命周期]</p>
<p>工程和管理 [管理 — 第8部分：国防项目的]</p>
<p>• ISO/IEC 23396:2020 系统和软件 [技术评审和审计]</p>
<p>工程 — 评审工具的能力 [• ISO/IEC/IEEE 24748-9:2023 系统]</p>
<p>• ISO/IEC 23531:2020 系统和软件 [和软件工程，预防和]</p>
<p>工程 — 问题管理工具的能力 [控制系统]</p>
<p>• ISO/IEC 24570:2018 软件工程 [• ISO/IEC/IEEE 24748-7000:2022]</p>
<p>— NESMA 功能规模 [系统设计期间处理伦理]</p>
<p>测量方法 — 功能点分析 [关切的模型过程]</p>
<p>应用的定义和计数指南 [• ISO/IEC/IEEE 24765:2017 系统]</p>
<p>• ISO/IEC/IEEE 24641:2023 系统 [和软件工程 — 词汇表，]</p>
<p>和软件工程 — 基于模型的系统和 [可在 <a href="http://www.computer.org/sevocab">www.computer.org/sevocab</a>
获取]</p>
<p>软件的方法和工具 [• ISO/IEC 24773-1:2019 软件和]</p>
<p>[系统工程 — 软件和系统工程专业人员]</p>
<p>[的认证 — 第1部分：一般要求]</p>
<p>• ISO/IEC 24773-4:2023 软件和 B-14 [<em>SWEBOK</em>] [<em>®</em>][
指南 V4.0a]]</p>
<p>系统工程 — 软件和系统工程专业人员 [• ISO/IEC 25030:2019 系统和]</p>
<p>的认证 — 第4部分：软件工程 [软件工程 — 系统和]</p>
<p>• ISO/IEC/IEEE 24774:2021 系统 [软件质量要求和评估]</p>
<p>和软件工程 — 生命周期 [(SQuaRE) — 质量要求]</p>
<p>管理 — 过程描述规范 [框架]</p>
<p>• ISO/IEC 25000:2014 系统和软件 [• ISO/IEC 25040:2011 系统和软件]</p>
<p>工程 — 系统和软件 [工程 — 系统和软件]</p>
<p>质量要求和评估 [质量要求和评估]</p>
<p>(SQuaRE) — SQuaRE 指南 [(SQuaRE) — 评估过程]</p>
<p>• ISO/IEC 25001:2014 系统和软件 [• ISO/IEC 25041:2012 系统和]</p>
<p>工程 — 系统和软件 [软件工程 — 系统和]</p>
<p>质量要求和评估 [软件质量要求和]</p>
<p>(SQuaRE) — 规划和管理 [评估 (SQuaRE) — 开发者、]</p>
<p>• ISO/IEC 25010:2023 系统和 [采购方和独立评估者的]</p>
<p>软件工程 — 系统和 [评估指南]</p>
<p>软件质量要求和 [• ISO/IEC 25045:2010 系统和]</p>
<p>评估 (SQuaRE) — 系统和 [软件工程 — 系统和]</p>
<p>软件质量模型 [软件质量要求和]</p>
<p>• ISO/IEC 25012:2008 软件工程 [评估 (SQuaRE) — 可恢复性]</p>
<p>— 软件产品质量 [评估模块]</p>
<p>要求和评估 (SQuaRE) [• ISO/IEC 25051:2014 软件工程]</p>
<p>— 数据质量模型 [— 系统和软件质量]</p>
<p>• ISO/IEC 25020:2019 系统和 [要求和评估 (SQuaRE)]</p>
<p>软件工程 — 系统和 [— 即用软件产品 (RUSP)]</p>
<p>软件质量要求和 [的质量要求和]</p>
<p>评估 (SQuaRE) — 质量测量 [测试指南]</p>
<p>框架 [• ISO/IEC 25062 软件产品]</p>
<p>• ISO/IEC 25021:2012 系统和 [质量要求和评估]</p>
<p>软件工程 — 系统和 [(SQuaRE) — 可用性的]</p>
<p>软件质量要求和 [通用行业格式 (CIF)]</p>
<p>评估 (SQuaRE) — 质量测量 [• ISO/IEC 26442:2019 软件和系统]</p>
<p>要素 [工程 — 产品线架构设计的]</p>
<p>• ISO/IEC 25022:2016 系统和 [工具和方法]</p>
<p>软件工程 — 系统和 [• ISO/IEC/IEEE 26511:2018 系统和]</p>
<p>软件质量要求和评估 [软件工程 — 系统、软件和服务]</p>
<p>(SQuaRE) — 使用质量的测量 [用户信息管理者的要求]</p>
<p>• ISO/IEC 25023:2016 系统和 [• ISO/IEC/IEEE 26512:2018 系统和]</p>
<p>软件工程 — 系统和 [软件工程 — 用户信息的]</p>
<p>软件质量要求和 [采购方和供应商的要求]</p>
<p>评估 (SQuaRE) — 系统和 [• ISO/IEC/IEEE 26513:2017 系统和]</p>
<p>软件产品质量的测量 [软件工程 — 用户信息的]</p>
<p>• ISO/IEC 25024:2015 系统和 [测试人员和评审人员的要求]</p>
<p>软件工程 — 系统和 [• ISO/IEC 26514:2021 系统和]</p>
<p>软件质量要求和 [软件工程 — 用户信息的]</p>
<p>评估 (SQuaRE) — 数据质量 [设计和开发]</p>
<p>的测量 [• ISO/IEC/IEEE 26515:2018 系统和]</p>
<p>[附录B] B-15</p>
<p>软件工程 — 在敏捷环境中 [系统工程 — 产品线过渡]</p>
<p>为用户开发信息 [管理的方法和工具]</p>
<p>• ISO/IEC/IEEE 26531:2023 系统 [• ISO/IEC 26580:2021 软件和系统]</p>
<p>和软件工程 — 产品生命周期、用户 [工程 — 方法和工具]</p>
<p>的内容管理</p>
<p>和基于特性方法的软件服务管理文档</p>
<p>• ISO/IEC 26550:2015 软件和系统工程 — 产品线工程和管理的参考模型</p>
<p>• ISO/IEC 26551:2016 软件和系统工程 — 产品线需求工程的工具和方法</p>
<p>• ISO/IEC 26552:2019 软件和系统工程 — 产品线架构设计的工具和方法</p>
<p>• ISO/IEC 26553:2018 信息技术 — 软件和系统工程 —
产品线实现的工具和方法</p>
<p>• ISO/IEC 26554:2018 信息技术 — 软件和系统工程 —
产品线测试的工具和方法</p>
<p>• ISO/IEC 26555:2015 软件和系统工程 — 产品线技术管理的工具和方法</p>
<p>• ISO/IEC 26556:2018 信息技术 — 软件和系统工程 —
产品线组织管理的工具和方法</p>
<p>• ISO/IEC 26557:2016 软件和系统工程 —
软件和系统产品线中可变性机制的方法和工具</p>
<p>• ISO/IEC 26558:2017 软件和系统工程 —
软件和系统产品线中可变性建模的方法和工具</p>
<p>• ISO/IEC 26559:2017 软件和系统工程 —
软件和系统产品线中可变性追溯的方法和工具</p>
<p>• ISO/IEC 26560:2019 软件和系统工程 — 产品线产品管理的工具和方法</p>
<p>• ISO/IEC 26561:2019 软件和系统工程 — 产品线技术探查的方法和工具</p>
<p>• ISO/IEC 26562:2019 软件和系统工程</p>
<p>• ISO/IEC 27000:2018 信息技术 — 安全技术 — 信息安全管理系统 —
概述和词汇</p>
<p>• ISO/IEC 27001:2022 信息安全、网络安全和隐私保护 — 信息安全管理系统
— 要求</p>
<p>• ISO/IEC 27032:2012 信息技术 — 安全技术 — 网络安全指南</p>
<p>• ISO/IEC 29110-1-1:2024 系统和软件工程 —
极小型实体(VSEs)的生命周期概要文件 第1-1部分：概述</p>
<p>• ISO/IEC 29110-2-1:2015 软件工程 —
极小型实体(VSEs)的生命周期概要文件 — 第2-1部分：框架和分类</p>
<p>• ISO/IEC TR 29110-5-3:2018 系统和软件工程 —
极小型实体(VSEs)的生命周期概要文件 — 第5-3部分：服务交付指南</p>
<p>• ISO/IEC/IEEE 29119-1: 2022 软件和系统工程 — 软件测试 —
第1部分：概念和定义</p>
<p>• ISO/IEC/IEEE 29119-2: 2021 软件和系统工程 — 软件测试 —
第2部分：测试过程</p>
<p>• ISO/IEC/IEEE 29119-3: 2021 软件和系统工程 — 软件测试 —
第3部分：测试文档</p>
<p>• ISO/IEC/IEEE 29119-4 软件和系统工程 — 软件测试 —
第4部分：测试技术</p>
<p>• ISO/IEC/IEEE 29119-5: 2016 软件和系统工程 — 软件测试 —
第5部分：关键字驱动测试</p>
<p>• ISO/IEC TR 29119-6:2021 软件和系统工程 — 软件测试 —
第6部分：在敏捷项目中使用ISO/IEC/IEEE 29119(所有部分)的指南</p>
<p>• ISO/IEC TR 29119-11:2020 软件和系统工程 — 软件测试 —
第11部分：基于AI系统的测试指南</p>
<p>• ISO/IEC/IEEE 29148:2018 系统和软件工程 — 生命周期过程 —
需求工程</p>
<p>• ISO/IEC 30130:2016 软件工程 — 软件测试工具的能力</p>
<p>• ISO/IEC 33001:2015 信息技术 — 过程评估 — 概念和术语</p>
<p>• ISO/IEC 33002:2015 信息技术 — 过程评估 — 执行过程评估的要求</p>
<p>• ISO/IEC 33003:2015 信息技术 — 过程评估 — 过程测量框架的要求</p>
<p>• ISO/IEC 33004:2015 信息技术 — 过程评估 —
过程参考、过程评估和成熟度模型的要求</p>
<p>• ISO/IEC TR 33014:2013 信息技术 — 过程评估 — 过程改进指南</p>
<p>• ISO/IEC 33020:2019 信息技术 — 过程评估 —
过程能力评估的过程测量框架</p>
<p>• ISO/IEC TS 33061:2021 信息技术 — 过程评估 —
软件生命周期过程的过程评估模型</p>
<p>• ISO/IEC 33063:2015 信息技术 — 过程评估 — 软件测试的过程评估模型</p>
<p>• ISO/IEC/IEEE 32430 软件工程 — 软件非功能性规模测量标准</p>
<p>• ISO/IEC/IEEE 32675:2021
DevOps：构建可靠和安全的系统，包括应用程序构建、打包和部署</p>
<p>• ISO/IEC 38500:2008 信息技术的公司治理</p>
<p>• ISO/IEC/IEEE 41062:2023 软件工程 — 软件获取的推荐实践</p>
<p>• ISO/IEC/IEEE 42010:2022 软件、系统和企业 — 架构描述</p>
<p>• ISO/IEC/IEEE 42020:2019 软件、系统和企业 — 架构过程</p>
<p>• ISO/IEC/IEEE 42030: 2019 软件、系统和企业 — 架构评估框架</p>
<p>• IEC 60300-1:2014 可靠性管理 - 第1部分：管理和应用指南</p>
<p>• IEC/IEEE 82079-1 2019 产品使用信息(产品使用说明)的准备 -
第1部分：原则和通用要求</p>
<p>• ISO/IEC/IEEE 90003:2018 软件工程 — 将ISO
9001:2015应用于计算机软件的指南</p>
<h2 id="合并参考文献列表">合并参考文献列表</h2>
<p>附录C</p>
<h1 id="综合参考文献列表">综合参考文献列表</h1>
<p>综合参考文献列表确定了所有推荐的参考资料（精确到章节编号级别），这些资料与每个知识领域（KA）内的主题分解相对应。此综合参考文献列表已被IEEE计算机协会提供的软件工程认证及相关专业发展产品所采用。知识领域编辑使用综合参考文献列表分配给其知识领域的参考资料作为推荐参考文献。</p>
<p>总体而言，此综合参考文献列表具有以下特点：</p>
<ul>
<li><strong>完整性</strong>：涵盖SWEBOK指南的全部范围</li>
<li><strong>充分性</strong>：提供足够的信息来描述”普遍接受的”知识</li>
<li><strong>一致性</strong>：不提供矛盾的知识或冲突的实践</li>
<li><strong>可信性</strong>：被认可为提供专家级处理</li>
<li><strong>时效性</strong>：以与当前普遍接受的知识相称的方式处理主题</li>
<li><strong>简洁性</strong>：在不影响其他目标的前提下尽可能简短（无论是参考文献项目数量还是总页数）</li>
</ul>
<p>总共有40份参考资料如下：</p>
<ul>
<li>J.H. Allen et al., Software Security Engineering: A Guide for
Project Managers, Addison-Wesley, 2008.</li>
<li>L. Bass, P. Clements, and R. Kazman, Software Architecture in
Practice, 4th edition, 2021.</li>
<li>M. Bishop, Computer Security: Art and Science, 2nd Edition,
Addison-Wesley, 2018.</li>
<li>B. Boehm and R. Turner, Balancing Agility and Discipline: A Guide
for the Perplexed, Addison-Wesley, 2003.</li>
<li>G. Booch, J. Rumbaugh and I. Jacobson, The Unified Modeling Language
User Guide, 2nd edition, Addison-Wesley, 2005.</li>
<li>F. Bott et al., Professional Issues in Software Engineering, 3rd
ed., Taylor &amp; Francis, 2000.</li>
<li>F. Brooks, The Design of Design, Addison-Wesley, 2010</li>
<li>J.G. Brookshear, Computer Science: An Overview, 12th ed.,
Addison-Wesley, 2017.</li>
<li>D. Budgen, Software Design, 3rd ed., CRC Press, 2021.</li>
<li>E.W. Cheney and D.R. Kincaid, Numerical Mathematics and Computing,
7th ed., Addison Wesley, 2020.</li>
<li>P. Clements et al., Documenting Software Architectures: Views and
Beyond, 2nd ed., Pearson Education, 2010.</li>
<li>C. Dotson, Practical Cloud Security, O’Reilly, 2019.</li>
<li>D. Farley, Modern Software Engineering: Doing What Works to Build
Better Software Faster. Addison-Wesley Professional, 2022.</li>
<li>R.E. Fairley, Managing and Leading Software Projects, Wiley-IEEE
Computer Society Press, 2009.</li>
<li>C.Y Laporte, A. April, Software Quality Assurance, IEEE Computer
Society Press, 1st ed., 2018.</li>
<li>E. Gamma et al., Design Patterns: Elements of Reusable
Object-Oriented Software, 1st ed., Addison-Wesley Professional,
1994.</li>
<li>P. Grubb and A.A. Takang, Software Maintenance: Concepts and
Practice, 2nd ed., World Scientific Publishing, 2003.</li>
<li>A.M.J. Hass, Configuration Management Principles and Practices, 1st
ed., Addison-Wesley, 2003.</li>
<li>S.H. Kan, Metrics and Models in Software Quality Engineering, 2nd
ed., Addison-Wesley, 2002.</li>
<li>G. Kim, J. Humble, P. Debois, J. Willis and J. Allspaw, The DevOps
handbook: How to create world-class agility, reliability, &amp; security
in technology organizations, 2nd ed., IT Revolution, 2021.</li>
<li>M.W. Maier and E. Rechtin, The Art of Systems Architecting, 3rd
edition, CRC Press, 2009.</li>
<li>S. McConnell, Code Complete, 2nd ed., Microsoft Press, 2004.</li>
<li>J. McGarry et al., Practical Software Measurement: Objective
Information for Decision Makers, Addison-Wesley Professional, 2001.</li>
<li>S.J. Mellor and M.J. Balcer, Executable UML: A Foundation for
Model-Driven Architecture, 1st ed., Addison-Wesley, 2002.</li>
<li>D. C. Montgomery and G. C. Runger, Applied Statistics and
Probability for Engineers, 7th ed., Wiley, 2018.</li>
<li>S. Naik and P. Tripathy, Software Testing and Quality Assurance:
Theory and Practice, Wiley-Spektrum, 2008.</li>
<li>J. Nielsen, Usability Engineering, 1st ed., Morgan Kaufmann,
1993.</li>
<li>L. Null and J. Lobur, The Essentials of Computer Organization and
Architecture, 5th ed. Jones and Bartlett Publishers, 2018.</li>
<li>M. Page-Jones, Fundamentals of Object-Oriented Design in UML, 1st
ed., Addison-Wesley, 1999.</li>
<li>Project Management Institute and Agile Alliance, Agile Practice
Guide, Project Management Institute, 2017.</li>
<li>K. Rosen, Discrete Mathematics and its Applications, 8th ed.,
McGraw-Hill, 2018.</li>
<li>N. Rozanski and E. Woods, Software Systems Architecture: Working
with Stakeholders Using Viewpoints and Perspectives, 2nd edition,
Addison-Wesley, 2011.</li>
<li>J. Shore and S. Warden, The Art of Agile Development, O’Reilly
Media, 2nd Edition, 2021.</li>
<li>A. Silberschatz, P.B. Galvin, and G. Gagne, Operating System
Concepts, 8th ed., Wiley, 2008.</li>
<li>I. Sommerville, Software Engineering, 10th ed., Addison-Wesley,
2016.</li>
<li>R.N. Taylor, N. Medvidović, E. Dashofy, Software Architecture:
Foundations, Theory, and Practice, Wiley, 2009</li>
<li>S. Tockey, Return on Software: Maximizing the Return on Your
Software Investment, 1st ed., Addison-Wesley, 2004.</li>
<li>G. Voland, Engineering by Design, 2nd ed., Prentice Hall, 2003.</li>
<li>K.E. Wiegers, Software Requirements, 3rd ed., Microsoft Press,
2013.</li>
<li>J.M. Wing, “A Specifier’s Introduction to Formal Methods,” Computer,
vol. 23, no. 9, 1990, pp. 8, 10–23.</li>
</ul>
<p>《软件工程知识体系指南》（SWEBOK指南）由IEEE计算机协会出版，代表了当前普遍接受的知识状态，并在全球范围内推广软件工程的一致性观点。指南第4版反映了自2014年第3版发布以来的变化，包括现代开发实践、新技术和标准的进步，例如与敏捷和DevOps、架构、运维(Operations)、安全性和人工智能相关的领域和描述。</p>
<p>IEEE计算机协会是最大的计算机专业组织。</p>
<p>[致力于科学技术社区]</p>
<p>[吸引全球各地的工程师、科学家、学术界和行业][专业人士，][推动持续][进步。]</p>
<script>
        function toggleToc() {
            const sidebar = document.getElementById('tocSidebar');
            const overlay = document.getElementById('tocOverlay');
            
            if (sidebar.classList.contains('active')) {
                closeToc();
            } else {
                openToc();
            }
        }

        function openToc() {
            const sidebar = document.getElementById('tocSidebar');
            const overlay = document.getElementById('tocOverlay');
            
            sidebar.classList.add('active');
            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeToc() {
            const sidebar = document.getElementById('tocSidebar');
            const overlay = document.getElementById('tocOverlay');
            
            sidebar.classList.remove('active');
            overlay.classList.remove('active');
            document.body.style.overflow = 'auto';
        }

        // ESC键关闭目录
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeToc();
            }
        });

        // 点击目录链接后自动关闭目录（移动端）
        document.addEventListener('click', function(e) {
            if (e.target.matches('.simple-toc a') && window.innerWidth <= 768) {
                setTimeout(closeToc, 300);
            }
        });
    </script>
</body>
</html>