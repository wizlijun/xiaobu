<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>建立 AI 原生工程团队</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6;
            color: #111827;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
        }
        h1 {
            font-size: 2.25rem;
            line-height: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        h2 {
            font-size: 1.5rem;
            line-height: 2rem;
            font-weight: 600;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #e5e7eb;
        }
        h3 {
            font-size: 1.25rem;
            line-height: 1.75rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }
        p {
            margin-bottom: 1.25rem;
            color: #374151;
        }
        .subtitle {
            font-size: 1.125rem;
            color: #6b7280;
            margin-bottom: 2rem;
        }
        img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            margin: 2rem 0;
            display: block;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            font-size: 0.95rem;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 0.75rem;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #f9fafb;
            font-weight: 600;
        }
        ul {
            list-style-type: disc;
            padding-left: 1.5rem;
            margin-bottom: 1.25rem;
        }
        li {
            margin-bottom: 0.5rem;
        }
        strong {
            font-weight: 600;
            color: #111827;
        }
        /* Style for the 'Checklist' sections specifically */
        .checklist-section {
            background-color: #f3f4f6;
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>

    <header>
        <h1>建立 AI 原生工程团队</h1>
        <p class="subtitle">编码 Agent 如何加速软件开发生命周期</p>
    </header>

    <main>
        <h2>简介</h2>
        <p>AI 模型正在迅速扩展其能够执行的任务范围，这对工程领域有着深远的影响。前沿系统现在可以维持数小时的推理：截至 2025 年 8 月，METR 发现领先的模型可以连续工作 <strong>2 小时 17 分钟</strong>，并以大约 <strong>50% 的置信度</strong>生成正确答案。</p>
        <p>这种能力正在快速提升，任务长度大约每七个月翻一番。仅在几年前，模型只能处理约 30 秒的推理——仅足以提供简短的代码建议。今天，随着模型能够维持更长的推理链，整个软件开发生命周期都在 AI 协助的范围内，使得编码 Agent（Coding Agents）能够有效地为规划、设计、开发、测试、代码审查和部署做出贡献。</p>

        <img src="https://developers.openai.com/images/codex/guides/build-ai-native-engineering-team.png" alt="AI 原生工程团队示意图">

        <p>在本指南中，我们将分享真实的案例，概述 AI Agent 如何为软件开发生命周期做出贡献，并为工程领导者提供切实可行的指导，说明今天该如何开始建立 AI 原生团队和流程。</p>

        <h2>AI 编程：从自动补全到 Agent</h2>
        <p>AI 编程工具已经远远超出了其作为自动补全助手的起源。早期的工具主要处理快速任务，例如建议下一行代码或填充函数模板。随着模型获得更强的推理能力，开发人员开始在 IDE 中通过聊天界面与 Agent 互动，进行结对编程和代码探索。</p>
        <p>今天的编码 Agent 可以生成整个文件，搭建新项目，并将设计转化为代码。它们可以推理多步骤的问题，如调试或重构，Agent 的执行也从单个开发人员的机器转移到了基于云的多 Agent 环境。这正在改变开发人员的工作方式，使他们花在 IDE 内部生成代码的时间变少，而花在委派整个工作流上的时间变多。</p>

        <table>
            <thead>
                <tr>
                    <th>能力</th>
                    <th>带来的作用</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>跨系统的统一上下文</strong></td>
                    <td>单个模型可以读取代码、配置和遥测数据，提供跨层级的连贯推理，而以前这需要分离的工具。</td>
                </tr>
                <tr>
                    <td><strong>结构化工具执行</strong></td>
                    <td>模型现在可以直接调用编译器、测试运行器和扫描器，生成可验证的结果，而不是静态建议。</td>
                </tr>
                <tr>
                    <td><strong>持久的项目记忆</strong></td>
                    <td>长上下文窗口和压缩（compaction）技术允许模型从提案到部署全程跟踪一个功能，记住以前的设计选择和约束。</td>
                </tr>
                <tr>
                    <td><strong>评估循环</strong></td>
                    <td>模型输出可以根据基准（单元测试、延迟目标或风格指南）自动测试，确保持续改进基于可衡量的质量。</td>
                </tr>
            </tbody>
        </table>

        <p>在 OpenAI，我们亲眼目睹了这一点。开发周期已经缩短，以前需要数周的工作现在几天就能交付。团队在不同领域间移动更加轻松，能够更快地熟悉不熟悉的项目，并在整个组织中以更高的敏捷性和自主性运作。许多常规且耗时的任务，从为新代码编写文档、查找相关测试、维护依赖关系到清理功能标志（feature flags），现在完全委托给了 Codex。</p>
        <p>然而，工程学的某些方面保持不变。代码的真正所有权——尤其是对于新颖或模糊的问题——仍然属于工程师，某些挑战超出了当前模型的能力。但是，有了像 Codex 这样的编码 Agent，工程师现在可以将更多时间花在复杂和新颖的挑战上，专注于设计、架构和系统级推理，而不是调试或机械式的实现。</p>
        <p>在接下来的部分中，我们将分解 SDLC（软件开发生命周期）的每个阶段随编码 Agent 发生的变化，并概述您的团队可以采取的具体步骤，以开始像 AI 原生工程组织一样运作。</p>

        <h2>1. 规划 (Plan)</h2>
        <p>整个组织的团队通常依赖工程师来确定功能是否可行、构建需要多长时间以及涉及哪些系统或团队。虽然任何人都可以起草规范，但形成准确的计划通常需要对代码库有深刻的了解，并与工程部门进行多轮迭代，以发现需求、澄清边缘情况并就技术现实达成一致。</p>

        <h3>编码 Agent 如何提供帮助</h3>
        <p>AI 编码 Agent 在规划和定界过程中为团队提供即时的、感知代码的洞察。例如，团队可以构建工作流，将编码 Agent 连接到其问题跟踪系统，以读取功能规范，将其与代码库进行交叉引用，然后标记模糊之处，将工作分解为子组件，或估算难度。</p>
        <p>编码 Agent 还可以即时追踪代码路径，显示某个功能涉及哪些服务——这项工作以前需要数小时或数天的人工挖掘。</p>

        <h3>工程师转而做什么</h3>
        <p>团队可以将更多时间花在核心功能工作上，因为 Agent 提供了以前需要开会进行产品对齐和定界所需的上下文。关键的实现细节、依赖关系和边缘情况在前期就被识别出来，从而以更少的会议实现更快的决策。</p>

        <table>
            <thead>
                <tr>
                    <th>委派 (Delegate)</th>
                    <th>审查 (Review)</th>
                    <th>拥有 (Own)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>AI Agent 可以进行第一轮可行性和架构分析。它们读取规范，将其映射到代码库，识别依赖关系，并提出需要澄清的模糊点或边缘情况。</td>
                    <td>团队审查 Agent 的发现，以验证准确性，评估完整性，并确保估算反映了真实的技术限制。故事点分配、工作量大小评估和识别非显而易见的风险仍然需要人类判断。</td>
                    <td>战略决策——例如优先级排序、长期方向、排序和权衡——仍然由人类主导。团队可能会向 Agent 询问选项或后续步骤，但规划和产品方向的最终责任在于组织。</td>
                </tr>
            </tbody>
        </table>

        <div class="checklist-section">
            <h3>入门清单</h3>
            <ul>
                <li>识别那些通常需要特性与源代码之间进行对齐的流程。常见领域包括功能定界和工单创建。</li>
                <li>从实施基本工作流开始，例如对问题或功能请求进行标记和去重。</li>
                <li>考虑更高级的工作流，例如根据初始功能描述向工单添加子任务。或者在工单达到特定阶段时启动 Agent 运行，以补充更多细节描述。</li>
            </ul>
        </div>

        <h2>2. 设计 (Design)</h2>
        <p>设计阶段通常因基础设置工作而放缓。团队花费大量时间编写样板代码、集成设计系统以及完善 UI 组件或流程。模型图与实现之间的错位会造成返工和漫长的反馈周期，而探索替代方案或适应不断变化的需求的带宽有限，推迟了设计验证。</p>

        <h3>编码 Agent 如何提供帮助</h3>
        <p>AI 编程工具通过搭建样板代码、构建项目结构以及即时实施设计令牌（design tokens）或风格指南，极大地加速了原型设计。工程师可以用自然语言描述所需的功能或 UI 布局，并获得符合团队惯例的原型代码或组件桩（stubs）。</p>
        <p>它们可以直接将设计转换为代码，建议可访问性改进，甚至分析代码库中的用户流程或边缘情况。这使得在数小时而不是数天内迭代多个原型成为可能，并且可以在流程早期进行高保真原型设计，为决策提供更清晰的基础，并更早地进行客户测试。</p>

        <h3>工程师转而做什么</h3>
        <p>随着常规设置和转换任务由 Agent 处理，团队可以将注意力转移到高杠杆工作上。工程师专注于完善核心逻辑，建立可扩展的架构模式，并确保组件符合质量和可靠性标准。设计师可以花更多时间评估用户流程和探索替代概念。协作的重心从实施开销转移到改进底层产品体验上。</p>

        <table>
            <thead>
                <tr>
                    <th>委派 (Delegate)</th>
                    <th>审查 (Review)</th>
                    <th>拥有 (Own)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Agent 处理初始实现工作，包括搭建项目脚手架、生成样板代码、将模型图转换为组件以及应用设计令牌或风格指南。</td>
                    <td>团队审查 Agent 的输出，确保组件遵循设计惯例，符合质量和可访问性标准，并与现有系统正确集成。</td>
                    <td>团队拥有总体设计系统、UX 模式、架构决策以及用户体验的最终方向。</td>
                </tr>
            </tbody>
        </table>

        <div class="checklist-section">
            <h3>入门清单</h3>
            <ul>
                <li>使用同时接受文本和图像输入的多模态编码 Agent。</li>
                <li>通过 MCP（模型上下文协议）将设计工具与编码 Agent 集成。</li>
                <li>通过 MCP 编程方式公开组件库，并将它们与您的编码模型集成。</li>
                <li>构建映射工作流：设计 → 组件 → 组件的实现。</li>
                <li>利用强类型语言（如 Typescript）为 Agent 定义有效的 props 和子组件。</li>
            </ul>
        </div>

        <h2>3. 构建 (Build)</h2>
        <p>构建阶段是团队感到摩擦最大的地方，也是编码 Agent 影响最明显的地方。工程师花费大量时间将规范转换为代码结构，连接服务，在代码库中复制模式，并填充样板代码，即使是小功能也需要数小时的忙碌工作。</p>
        <p>随着系统的增长，这种摩擦会加剧。大型单体仓库积累了模式、惯例和历史遗留问题，拖慢了贡献者的速度。工程师花费在重新发现“正确做法”上的时间可能与实现功能本身的时间一样多。在规范、代码搜索、构建错误、测试失败和依赖项管理之间不断的上下文切换增加了认知负荷——长时间运行任务中的打断进一步破坏了心流并延迟了交付。</p>

        <h3>编码 Agent 如何提供帮助</h3>
        <p>在 IDE 和 CLI（命令行界面）中运行的编码 Agent 通过处理更大的、多步骤的实施任务来加速构建阶段。它们不仅是生成下一个函数或文件，而是在一次协调运行中生成完整的端到端功能——数据模型、API、UI 组件、测试和文档。凭借对整个代码库的持续推理，它们处理以前需要工程师手动追踪代码路径的决策。</p>
        <p>对于长时间运行的任务，Agent 可以：</p>
        <ul>
            <li>根据书面规范起草整个功能的实现。</li>
            <li>在数十个文件中搜索和修改代码，同时保持一致性。</li>
            <li>生成符合惯例的样板代码：错误处理、遥测、安全包装器或风格模式。</li>
            <li>在构建错误出现时立即修复，而不是停下来等待人工干预。</li>
            <li>作为单一工作流的一部分，在编写实现的同时编写测试。</li>
            <li>生成符合内部准则并包含 PR 消息的、可直接进行 diff 的变更集。</li>
        </ul>
        <p>在实践中，这将许多机械的“构建工作”从工程师转移到了 Agent 身上。Agent 成为第一轮实施者；工程师成为审查者、编辑和方向的来源。</p>

        <h3>工程师转而做什么</h3>
        <p>当 Agent 能够可靠地执行多步骤构建任务时，工程师会将注意力转移到更高阶的工作上：</p>
        <ul>
            <li>在实施之前澄清产品行为、边缘情况和规范。</li>
            <li>审查 AI 生成代码的架构影响，而不是进行机械的连接工作。</li>
            <li>完善需要深刻领域推理的业务逻辑和性能关键路径。</li>
            <li>设计指导 Agent 生成代码的模式、护栏和惯例。</li>
            <li>与产品经理和设计合作迭代功能意图，而不是样板代码。</li>
        </ul>
        <p>工程师不再是将功能规范“翻译”成代码，而是专注于正确性、连贯性、可维护性和长期质量，这些是人类背景知识仍然最重要的地方。</p>

        <table>
            <thead>
                <tr>
                    <th>委派 (Delegate)</th>
                    <th>审查 (Review)</th>
                    <th>拥有 (Own)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Agent 为明确指定的功能起草第一版实现——脚手架、CRUD 逻辑、连接、重构和测试。随着长时间推理能力的提高，这越来越多地涵盖完整的端到端构建，而不仅是孤立的片段。</td>
                    <td>工程师评估设计选择、性能、安全性、迁移风险和领域一致性，同时纠正 Agent 可能错过的细微问题。他们塑造和完善 AI 生成的代码，而不是执行机械工作。</td>
                    <td>工程师保留对需要深刻系统直觉的工作的所有权：新的抽象、跨领域的架构变更、模糊的产品需求和长期的可维护性权衡。随着 Agent 承担更长的任务，工程工作从逐行实施转变为迭代监督。</td>
                </tr>
            </tbody>
        </table>

        <p><strong>案例：</strong><br>
        Cloudwalk 的工程师、产品经理、设计师和运营人员每天都在使用 Codex 将规范转化为可工作的代码，无论是需要一个脚本、一个新的欺诈规则，还是几分钟内交付的完整微服务。它消除了构建阶段的繁忙工作，赋予每位员工以惊人速度实现想法的能力。</p>

        <div class="checklist-section">
            <h3>入门清单</h3>
            <ul>
                <li>从明确指定的任务开始。</li>
                <li>让 Agent 通过 MCP 使用规划工具，或者通过编写并提交到代码库的 PLAN.md 文件进行规划。</li>
                <li>检查 Agent 尝试执行的命令是否成功。</li>
                <li>迭代 AGENTS.md 文件，解锁 Agent 循环（如运行测试和 linter）以接收反馈。</li>
            </ul>
        </div>

        <h2>4. 测试 (Test)</h2>
        <p>开发人员经常难以确保足够的测试覆盖率，因为编写和维护全面的测试需要时间，需要切换上下文，并且需要深入了解边缘情况。团队经常面临在快速行动和编写彻底测试之间的权衡。当截止日期临近时，测试覆盖率往往首先受到影响。</p>
        <p>即使编写了测试，随着代码的演变保持其更新也会带来持续的摩擦。测试可能变得脆弱，因不明原因失败，并且可能需要随着底层产品的变化进行重大的重构。高质量的测试能让团队更有信心地更快发布。</p>

        <h3>编码 Agent 如何提供帮助</h3>
        <p>AI 编程工具可以通过几种强大的方式帮助开发人员编写更好的测试。首先，它们可以根据阅读需求文档和功能代码逻辑建议测试用例。模型在建议开发人员可能容易忽视的边缘情况和故障模式方面出奇地好，尤其是当开发人员一直专注于功能本身而需要第二种意见时。</p>
        <p>此外，模型可以帮助随着代码演变保持测试更新，减少重构的摩擦，避免陈旧的测试变得不稳定。通过处理测试编写的基本实现细节并发现边缘情况，编码 Agent 加速了开发测试的过程。</p>

        <h3>工程师转而做什么</h3>
        <p>使用 AI 工具编写测试并不能免除开发人员思考测试的需要。事实上，随着 Agent 消除了生成代码的障碍，测试作为应用程序功能真理来源的作用变得越来越重要。由于 Agent 可以运行测试套件并根据输出进行迭代，定义高质量的测试通常是允许 Agent 构建功能的第一步。</p>
        <p>相反，开发人员更多地关注测试覆盖率的高级模式，在模型识别的测试用例基础上进行构建和挑战。让测试编写更快，允许开发人员更快地发布功能，也能承担更雄心勃勃的功能开发。</p>

        <table>
            <thead>
                <tr>
                    <th>委派 (Delegate)</th>
                    <th>审查 (Review)</th>
                    <th>拥有 (Own)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>工程师将根据功能规范生成测试用例的初稿委托给 Agent。他们还会使用模型进行第一轮测试生成。让模型在与功能实现分开的会话中生成测试通常很有帮助。</td>
                    <td>工程师必须彻底审查模型生成的测试，以确保模型没有走捷径或实施桩（stubbed）测试。工程师还需确保测试可以由 Agent 运行；确保 Agent 具有适当的运行权限，并且 Agent 具有对其可以运行的不同测试套件的上下文感知。</td>
                    <td>工程师拥有将测试覆盖率与功能规范和用户体验期望对齐的责任。对抗性思维、映射边缘情况的创造力以及对测试意图的关注仍然是关键技能。</td>
                </tr>
            </tbody>
        </table>

        <div class="checklist-section">
            <h3>入门清单</h3>
            <ul>
                <li>引导模型将实施测试作为一个单独的步骤，并在进入功能实施之前验证新测试是否失败。</li>
                <li>在您的 AGENTS.md 文件中设置测试覆盖率指南。</li>
                <li>给 Agent 提供它可以调用的代码覆盖率工具的具体示例，以了解测试覆盖率。</li>
            </ul>
        </div>

        <h2>5. 审查 (Review)</h2>
        <p>平均而言，开发人员每周花费 2-5 小时进行代码审查。团队经常面临选择：是投入大量时间进行深度审查，还是对看似微小的更改进行快速的“差不多就行”的通过。当这种优先级排序出现偏差时，错误就会溜进生产环境，给用户带来问题并造成大量返工。</p>

        <h3>编码 Agent 如何提供帮助</h3>
        <p>编码 Agent 允许代码审查流程扩展，使每个 PR 都能获得一致的基础关注。与传统的静态分析工具（依赖于模式匹配和基于规则的检查）不同，AI 审查者实际上可以执行部分代码，解释运行时行为，并跨文件和服务追踪逻辑。然而，为了有效，模型必须经过专门训练以识别 P0 和 P1 级别的错误，并调整为提供简洁、高信号的反馈；过于冗长的回复就像嘈杂的 lint 警告一样容易被忽略。</p>

        <h3>工程师转而做什么</h3>
        <p>在 OpenAI，我们发现 AI 代码审查让工程师更有信心，相信他们不会将重大错误发布到生产环境。通常，代码审查会捕捉到贡献者可以在引入其他工程师之前纠正的问题。代码审查不一定能让拉取请求过程更快，尤其是当它发现有意义的错误时——但它确实能预防缺陷和中断。</p>

        <h3>委派 vs 审查 vs 拥有</h3>
        <p>即使有 AI 代码审查，工程师仍负责确保代码准备好发布。实际上，这意味着阅读并理解变更的含义。工程师将初始代码审查委托给 Agent，但拥有最终审查和合并流程。</p>

        <table>
            <thead>
                <tr>
                    <th>委派 (Delegate)</th>
                    <th>审查 (Review)</th>
                    <th>拥有 (Own)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>工程师将初始编码审查委托给 Agent。在队友标记 PR 为准备好审查之前，这种情况可能会发生多次。</td>
                    <td>工程师仍然审查拉取请求，但更侧重于架构对齐；是否实施了可组合的模式，是否使用了正确的惯例，功能是否符合需求。</td>
                    <td>工程师最终拥有部署到生产环境的代码；他们必须确保其运行可靠并满足预期要求。</td>
                </tr>
            </tbody>
        </table>

        <p><strong>案例：</strong><br>
        Sansan 使用 Codex 审查竞争条件（race conditions）和数据库关系，这些通常是人类容易忽视的问题。Codex 还能捕捉到不当的硬编码，甚至预见到未来的可扩展性问题。</p>

        <div class="checklist-section">
            <h3>入门清单</h3>
            <ul>
                <li>策划由工程师进行的黄金标准 PR 案例，包括代码更改和留下的评论。将其保存为评估集，以衡量不同工具的效果。</li>
                <li>选择一个专门在代码审查上训练过的产品模型。我们发现通用模型通常会吹毛求疵，提供的信噪比低。</li>
                <li>定义您的团队将如何衡量审查是否高质量。我们建议跟踪 PR 评论的反应（reactions），作为标记好坏审查的低摩擦方式。</li>
                <li>从小规模开始，但一旦对审查结果有了信心，就迅速推广。</li>
            </ul>
        </div>

        <h2>6. 文档 (Document)</h2>
        <p>大多数工程团队都知道他们的文档滞后，但发现追赶成本很高。关键知识通常由个人掌握，而不是记录在可搜索的知识库中，现有的文档很快就会过时，因为更新文档会分散工程师的产品工作。即使团队进行文档冲刺，结果通常也是一次性的努力，一旦系统演变就会失效。</p>

        <h3>编码 Agent 如何提供帮助</h3>
        <p>编码 Agent 非常擅长基于阅读代码库来总结功能。它们不仅可以撰写关于代码库部分如何工作的文章，还可以生成诸如 mermaid 语法的系统图表。随着开发人员使用 Agent 构建功能，他们也可以通过简单地提示模型来更新文档。通过 AGENTS.md，可以自动在每个提示中包含按需更新文档的指令，以保持一致性。</p>
        <p>由于编码 Agent 可以通过 SDK 以编程方式运行，它们也可以整合到发布工作流中。例如，我们可以要求编码 Agent 审查包含在发布中的提交并总结关键变更。结果是，文档成为交付管道的一个内置部分：生成更快，更容易保持最新，不再依赖于某人“找时间”来做。</p>

        <h3>工程师转而做什么</h3>
        <p>工程师从手动编写每份文档转变为塑造和监督系统。他们决定文档如何组织，添加决策背后的重要“原因”，设定 Agent 遵循的清晰标准和模板，并审查关键或面向客户的部分。他们的工作变成了确保文档结构化、准确并融入交付过程，而不是自己完成所有的打字工作。</p>

        <table>
            <thead>
                <tr>
                    <th>委派 (Delegate)</th>
                    <th>审查 (Review)</th>
                    <th>拥有 (Own)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>将低风险、重复性的工作完全移交给 Codex，如文件和模块的初稿摘要、输入输出的基本描述、依赖列表和拉取请求变更的简短摘要。</td>
                    <td>在发布任何内容之前，工程师审查和编辑由 Codex 起草的重要文档，如核心服务概述、公共 API 和 SDK 文档、运行手册（runbooks）和架构页面。</td>
                    <td>工程师仍负责整体文档策略和结构、Agent 遵循的标准和模板，以及所有涉及法律、监管或品牌风险的面向外部或安全关键的文档。</td>
                </tr>
            </tbody>
        </table>

        <div class="checklist-section">
            <h3>入门清单</h3>
            <ul>
                <li>尝试通过提示编码 Agent 来生成文档。</li>
                <li>将文档指南纳入您的 AGENTS.md。</li>
                <li>识别可以自动生成文档的工作流（例如发布周期）。</li>
                <li>审查生成内容的质量、正确性和重点。</li>
            </ul>
        </div>

        <h2>7. 部署和维护 (Deploy and Maintain)</h2>
        <p>理解应用日志对软件可靠性至关重要。在事件（Incident）期间，软件工程师会参考日志工具、代码部署和基础设施变更来确定根本原因。这个过程通常令人惊讶地手动化，需要开发人员在不同系统之间来回切换，在事件等高压情况下浪费了关键的几分钟。</p>

        <h3>编码 Agent 如何提供帮助</h3>
        <p>有了 AI 编程工具，除了代码库的上下文之外，您还可以通过 MCP 服务器提供对日志工具的访问。这允许开发人员拥有单一的工作流，他们可以提示模型查看特定端点的错误，然后模型可以使用该上下文遍历代码库并找到相关的错误或性能问题。由于编码 Agent 还可以使用命令行工具，它们可以查看 git 历史记录，以识别可能导致日志跟踪中捕获的问题的具体更改。</p>

        <h3>工程师转而做什么</h3>
        <p>通过自动化日志分析和事件分类中繁琐的部分，AI 使工程师能够专注于更高级别的故障排除和系统改进。与其手动关联日志、提交和基础设施变更，工程师可以专注于验证 AI 生成的根本原因，设计弹性的修复方案，并开发预防措施。这种转变减少了花在被动“救火”上的时间，使团队能够将更多精力投入到主动的可靠性工程和架构改进中。</p>

        <table>
            <thead>
                <tr>
                    <th>委派 (Delegate)</th>
                    <th>审查 (Review)</th>
                    <th>拥有 (Own)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>许多运营任务可以委托给 Agent——解析日志、发现异常指标、识别可疑代码更改，甚至提出热修复建议。</td>
                    <td>工程师审查并完善 AI 生成的诊断，确认准确性，并批准补救步骤。他们确保修复符合可靠性、安全性和合规性标准。</td>
                    <td>关键决策权在于工程师，尤其是对于新颖的事件、敏感的生产变更或模型置信度较低的情况。人类仍然负责判断和最终签署。</td>
                </tr>
            </tbody>
        </table>

        <p><strong>案例：</strong><br>
        Virgin Atlantic（维珍大西洋航空）使用 Codex 加强团队部署和维护系统的方式。Codex VS Code 扩展为工程师提供了一个单一的地方来调查日志，跨代码和数据追踪问题，并通过 Azure DevOps MCP 和 Databricks Managed MCP 审查变更。通过在 IDE 内统一这种操作上下文，Codex 加速了根本原因的发现，减少了手动分类，并帮助团队专注于验证修复和提高系统可靠性。</p>

        <div class="checklist-section">
            <h3>入门清单</h3>
            <ul>
                <li>将 AI 工具连接到日志记录和部署系统：将 Codex CLI 或类似工具与您的 MCP 服务器和日志聚合器集成。</li>
                <li>定义访问范围和权限：确保 Agent 可以访问相关的日志、代码存储库和部署历史记录，同时保持安全最佳实践。</li>
                <li>配置提示模板：为常见的操作查询创建可重用的提示，例如“调查端点 X 的错误”或“分析部署后的日志峰值”。</li>
                <li>测试工作流：运行模拟事件场景，以确保 AI 呈现正确的上下文，准确追踪代码，并提出可操作的诊断。</li>
                <li>迭代和改进：从真实事件中收集反馈，调整提示策略，并随着系统和流程的发展扩展 Agent 的能力。</li>
            </ul>
        </div>

        <h2>结论</h2>
        <p>编码 Agent 正在通过承担传统上拖慢工程团队速度的机械性、多步骤工作，以此变革软件开发生命周期。凭借持续的推理、统一的代码库上下文以及执行真实工具的能力，这些 Agent 现在处理从定界和原型设计到实施、测试、审查甚至运营分类的任务。工程师牢牢控制着架构、产品意图和质量——但编码 Agent 正日益成为 SDLC 每个阶段的第一轮实施者和持续合作者。</p>
        <p>这种转变不需要彻底的推翻重来；随着编码 Agent 变得更加能干和可靠，小的、有针对性的工作流会迅速复利。从范围明确的任务开始，投资于护栏，并迭代扩展 Agent 责任的团队，将在速度、一致性和开发人员专注度方面看到显著收益。</p>
        <p>如果您正在探索编码 Agent 如何加速您的组织，或正在准备您的首次部署，请联系 OpenAI。我们要帮助您将编码 Agent 转化为真正的杠杆——在规划、设计、构建、测试、审查和运营中设计端到端的工作流，并帮助您的团队采用生产就绪的模式，使 AI 原生工程成为现实。</p>
    </main>


<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="https://developers.openai.com/codex/guides/build-ai-native-engineering-team/" target="_blank">源链接</a>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>