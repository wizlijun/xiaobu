<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 AI 工程师路线图：从 Prompt 工程师到系统架构师</title>
    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fff;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        h3 {
            color: #555;
            margin-top: 20px;
        }
        .author-info {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #3498db;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .project-card {
            background-color: #f1f8ff;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 4px solid #0366d6;
        }
        .level-tag {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
        }
        .level-beginner { background-color: #d4edda; color: #155724; }
        .level-intermediate { background-color: #fff3cd; color: #856404; }
        .level-advanced { background-color: #cce5ff; color: #004085; }
        .level-expert { background-color: #e2d5f1; color: #5a3d8a; }
        .level-master { background-color: #f8d7da; color: #721c24; }
        blockquote {
            background-color: #f6f8fa;
            padding: 12px 20px;
            margin: 15px 0;
            border-radius: 6px;
            border-left: 4px solid #6f42c1;
            font-style: italic;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin: 8px 0;
        }
        strong {
            color: #2c3e50;
        }
        .truth-box {
            background-color: #fff5f5;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e53e3e;
            margin: 20px 0;
        }
        ol {
            padding-left: 20px;
        }
        ol li {
            margin: 12px 0;
        }
    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>
    <h1>2026 AI 工程师路线图：从 Prompt 工程师到系统架构师</h1>

    <p>大多数开发者还在造玩具，而市场需要的是系统。教程地狱是职业生涯的舒适坟墓。2026 年，prompt 工程师和系统架构师之间的薪资差距是 15 万美元。这篇文章给出跨越这道鸿沟的具体蓝图。</p>

    <p>别再做 GPT 的薄壳封装了。市场上到处都是这种东西，它们不是产品，只是等着被大厂收编的功能。想要不可替代，就必须往深处走——理解编排、记忆和本地推理。以下 5 个项目按复杂度递增排列，用来证明你能驾驭生产级复杂度。</p>

    <h2>项目 1：基于 SLM 的 AI 移动应用（入门级）</h2>
    <div class="project-card">
        <span class="level-tag level-beginner">入门级</span>
        <strong>证明能力：</strong>边缘 AI + 资源优化
    </div>

    <h3>挑战</h3>
    <p>构建一个离线优先的移动应用，使用小语言模型（SLM）。零 API 成本，完全隐私。这会教你如何在受限硬件上优化模型。</p>

    <h3>关键架构决策</h3>
    <ul>
        <li><strong>模型管理</strong>：按需懒加载模型以节省内存；检测到内存压力时卸载不活跃的模型；空闲时预加载常用模型</li>
        <li><strong>上下文窗口</strong>：实现带语义分块的滑动窗口；保留最相关的上下文，丢弃最旧的；用 embedding 相似度决定哪些留在窗口、哪些归档</li>
        <li><strong>量化策略</strong>：根据设备能力动态量化；2020 年前的旧设备用 4-bit 量化，新设备用 8-bit；检测可用 RAM 并相应调整</li>
        <li><strong>电池优化</strong>：批量推理请求以减少唤醒周期；低电量模式下节流模型调用；非关键处理延迟到充电时执行</li>
        <li><strong>离线优先同步</strong>：本地加密存储用户数据；仅在联网且用户许可时同步到云端；冲突解决优先本地更改</li>
    </ul>

    <h3>为什么是入门级</h3>
    <p>它证明你理解资源约束和边缘 AI。你不只是调用 API，而是在管理量化和内存压力。</p>

    <h2>项目 2：自我改进的编码 Agent（中级）</h2>
    <div class="project-card">
        <span class="level-tag level-intermediate">中级</span>
        <strong>证明能力：</strong>Agent 循环 + 生产调试
    </div>

    <h3>挑战</h3>
    <p>聊天机器人等待 prompt，Agent 等待目标——区别在于循环。构建一个自主 Agent，能写代码、跑测试、从失败中学习，直到代码能用为止。</p>

    <h3>关键架构决策</h3>
    <ul>
        <li><strong>执行循环设计</strong>：计划 → 执行 → 测试 → 反思循环，设置最大迭代限制；每次循环存储状态以便中断后恢复；熔断器模式阻止无限循环</li>
        <li><strong>沙箱策略</strong>：每个任务隔离执行环境；CPU、内存、执行时间设资源限制；文件系统访问仅限项目目录</li>
        <li><strong>记忆层级</strong>：短期记忆保存当前任务上下文（最近 5 次迭代）；长期记忆按问题类型索引成功模式；失败记忆存储错误签名及解决方案</li>
        <li><strong>反思机制</strong>：每次失败后提取错误模式和根因；用向量相似度与历史失败比对；生成失败原因和修复方法的假设</li>
        <li><strong>从错误中学习</strong>：存储失败尝试的完整上下文——尝试了什么、为什么失败、什么修复了它；遇到类似任务时先检索相关失败；避免重复同样的错误</li>
        <li><strong>代码安全</strong>：执行前静态分析；检测潜在危险操作；文件系统或网络操作需显式批准</li>
    </ul>

    <h3>为什么是中级</h3>
    <p>它引入了 Agent 循环（计划 → 编码 → 测试 → 反思），展示你理解生产调试和迭代改进。</p>

    <h2>项目 3：视频编辑器的 Cursor（高级）</h2>
    <div class="project-card">
        <span class="level-tag level-advanced">高级</span>
        <strong>证明能力：</strong>多模态 AI + 复杂工具集成
    </div>

    <h3>挑战</h3>
    <p>多模态前沿——文本是过去，视觉和视频是现在。公司需要能看懂复杂媒体并采取行动的 Agent。Fork 一个开源编辑器，构建一个理解编辑意图的 AI Agent。用户说"让它更有电影感"，Agent 就处理剪辑、转场和调色。</p>

    <blockquote>提示：可以 fork 开源编辑器如 Shotcut。</blockquote>

    <h3>关键架构决策</h3>
    <ul>
        <li><strong>多模态理解</strong>：视觉模型分析每帧的构图、光线和主体；音频模型分析对话、音乐和环境音；结合两个流来理解叙事流程</li>
        <li><strong>意图翻译</strong>：用户说"电影感"——翻译成具体参数：慢节奏（80% 速度）、去饱和色彩（应用 LUT）、浅景深模拟（背景高斯模糊）、戏剧性音乐提示</li>
        <li><strong>场景检测</strong>：分析帧差异检测硬切；用 embedding 相似度检测场景边界；基于视觉和音频变化识别故事节拍</li>
        <li><strong>剪辑决策列表生成</strong>：执行前规划整个剪辑；生成剪切、转场、特效的时间戳；应用前验证计划的叙事合理性</li>
        <li><strong>增量预览</strong>：每次更改后不重新渲染整个视频；只生成受影响部分的预览；缓存未更改片段以加快迭代</li>
        <li><strong>反馈整合</strong>：用户说"太暗了"——分析亮度直方图，识别问题区域，应用针对性校正；跨会话跟踪用户偏好以改进未来建议</li>
        <li><strong>带理由的撤销/重做</strong>：每次编辑不仅存储改了什么，还存储为什么改；用户可以问"你为什么在这里剪"并得到基于检测到的故事节拍的解释</li>
    </ul>

    <h3>为什么是高级</h3>
    <p>它需要多模态 AI 和与视频处理的复杂工具集成，让你从 99% 的通用聊天机器人构建者中脱颖而出。</p>

    <h2>项目 4：个人生活操作系统 Agent（专家级）</h2>
    <div class="project-card">
        <span class="level-tag level-expert">专家级</span>
        <strong>证明能力：</strong>深度上下文 + 隐私优先架构
    </div>

    <h3>挑战</h3>
    <p>深度上下文时代——AI 最大的障碍是记忆。会遗忘的 Agent 没用；了解你生活的 Agent 才是伙伴。构建一个深度个人化的 Agent，管理你的日历、财务和健康。它能提前数月规划，通过分析睡眠模式和会议密度检测倦怠。</p>

    <h3>关键架构决策</h3>
    <ul>
        <li><strong>持续上下文构建</strong>：实时摄取日历、财务、健康和通讯事件；提取实体（人、地点、项目）并构建个人知识图谱；随时间映射实体间关系</li>
        <li><strong>主动监控</strong>：后台线程每 6 小时运行一次分析模式；检测异常如会议密度增加而睡眠质量下降；在问题发生前标记风险</li>
        <li><strong>价值对齐</strong>：用户明确声明优先级（家庭 > 工作，健康 > 收入）；每个建议都根据这些价值观验证；暴露行动与声明优先级之间的冲突</li>
        <li><strong>隐私架构</strong>：所有数据用用户控制的密钥静态加密；未经明确许可数据不离开设备；敏感操作可完全离线运行</li>
        <li><strong>预测性规划</strong>：分析历史模式预测未来瓶颈；"根据你 Q4 的模式，你在三月会过度承诺"；现在就建议预防性日程调整</li>
        <li><strong>决策支持</strong>：用户面临选择时，Agent 呈现多维分析：财务影响、时间成本、与价值观的对齐、潜在冲突；建议包含推理过程，不只是结论</li>
        <li><strong>记忆整合</strong>：每晚将日常事件总结到长期记忆；压缩细节但保留含义；旧记忆除非被重复访问强化否则会衰减</li>
        <li><strong>透明推理</strong>：每个建议都包含"我为什么推荐这个"并引用具体数据点；用户可以深入推理链</li>
    </ul>

    <h3>为什么是专家级</h3>
    <p>需要复杂的上下文管理和伦理 AI 设计，证明你能构建安全的、隐私优先的生产架构。</p>

    <h2>项目 5：自主企业工作流 Agent（大师级）</h2>
    <div class="project-card">
        <span class="level-tag level-master">大师级</span>
        <strong>证明能力：</strong>生产级编排
    </div>

    <h3>挑战</h3>
    <p>这是 AI 工程的最终 Boss，作品集的收官之作——一个运营业务的 Agent。构建一个端到端运行业务工作流的 Agent：监控 Slack/Jira，规划执行，委派任务，并用完整审计日志报告结果。</p>

    <h3>关键架构决策</h3>
    <ul>
        <li><strong>事件驱动架构</strong>：监听来自 Slack、Jira、邮件、监控系统的事件；模式识别确定工作流触发器；每种事件类型映射到工作流模板</li>
        <li><strong>工作流编排</strong>：将复杂工作流拆分为有依赖关系的步骤；尽可能并行执行步骤；用持久状态处理长时间运行的操作</li>
        <li><strong>多 Agent 委派</strong>：编排 Agent 为子任务生成专家 Agent；通信 Agent 处理所有外部消息；数据 Agent 查询日志和数据库；分析 Agent 执行根因分析；文档 Agent 撰写报告</li>
        <li><strong>自愈机制</strong>：监控每个步骤的成功/失败；失败时判断是重试还是升级；对瞬态故障实现指数退避；熔断器阻止重复失败</li>
        <li><strong>审计追踪</strong>：每个操作的不可变日志；存储决定了什么、为什么、谁授权的、结果是什么；可查询用于合规和调试</li>
        <li><strong>基于角色的访问控制</strong>：Agent 操作受限于调用用户的权限；敏感操作需要明确的人工批准；Agent 不能访问其范围外的数据</li>
        <li><strong>可观测性</strong>：追踪每次 LLM 调用的输入、输出和延迟；工作流成功率、执行时间、每工作流成本的指标；工作流重复失败时告警</li>
        <li><strong>人在回路</strong>：关键工作流执行前 Agent 提出计划；高亮高风险操作供人工审查；置信度低时升级</li>
        <li><strong>工作流学习</strong>：工作流完成后评估什么有效什么无效；为类似未来情况存储成功模式；根据结果更新工作流模板</li>
        <li><strong>成本管理</strong>：跟踪每个工作流的 token 使用量；实现预算限制；优化 prompt 以在不牺牲质量的情况下降低成本</li>
    </ul>

    <h3>为什么是大师级</h3>
    <p>它将编排、安全和可观测性结合到一个可扩展的系统中，证明你已准备好进入 15 万美元以上的薪资层级。</p>

    <h2>前进之路</h2>
    <p>大多数人会读完这篇文章然后什么都不做。他们会收藏它，说"好文章"，然后继续等待许可。别做大多数人。</p>

    <div class="truth-box">
        <strong>2026 年的残酷真相：</strong>
        <ul>
            <li><strong>可替代的人</strong>：在做封装</li>
            <li><strong>不可解雇的人</strong>：在交付自主系统</li>
        </ul>
        <p>两者之间的差距只有 5 个项目。</p>
    </div>

    <h3>接下来怎么做</h3>
    <ol>
        <li>选一个项目。新手从项目 1 开始，已经在写代码的从项目 5 开始。总之，开始</li>
        <li>这个周末就构建它。市场奖励交付，不奖励学习</li>
        <li>记录一切：
            <ul>
                <li>你的架构决策</li>
                <li>你的失败和恢复</li>
                <li>你的自我纠正循环</li>
                <li>你的生产部署</li>
            </ul>
        </li>
        <li>公开构建。交付时 tag 我，我会帮你传播</li>
    </ol>

    <p>下个月，90% 的人什么都不会做，还在构建同样的封装。另外 10% 会交付真正的东西，拿到面试、offer 和职业筹码。</p>

    <p>选择很简单：成为公司急需的架构师，或者被淘汰。</p>

    <p><strong>专业能力是唯一剩下的工作保障。生产系统是唯一重要的作品集。</strong></p>

    <p>现在，去构建能经受现实考验的东西。</p>

<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="(Rohit @rohit4verse Twitter)[]" target="_blank">(Rohit @rohit4verse Twitter)[]</a>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>
