<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>软件之死 2.0（一个更好的类比）</title>
    <style>
        /* 现代化CSS样式 */
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fff;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        h3 {
            color: #34495e;
            margin-top: 25px;
        }
        .author-info {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #3498db;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .process-phase {
            background-color: #f1f8ff;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 4px solid #0366d6;
        }
        .scenario {
            background-color: #f6f8fa;
            padding: 12px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 3px solid #6f42c1;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #ddd;
        }
        p {
            margin: 15px 0;
        }
    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>
    <h1>软件之死 2.0（一个更好的类比）</h1>

    <p>当我上次写关于软件的文章时，收到了很多反对意见。今天，我相信 Claude Code 正在证实我一直以来的观点。软件将成为硬件的输出，成为当前硬件设计的延伸。基于这一点，我想谈谈我对软件未来变化的看法。</p>

    <h2>Claude Code 是未来的一瞥</h2>

    <div class="highlight">
        <p>让我们从一个核心信念开始。Claude Code 是未来的预览。假设它能够持续改进、具备约束机制，并能继续扩展大型上下文窗口且只是略微增加成本，我相信这足以将我们带入 AI 的下一个阶段。我必须强调，Claude Code 是 ChatGPT 时刻的重演。你必须亲自尝试才能理解。</p>
    </div>

    <p>有一天，Claude Code 的继任者将为每个人提供超人类的界面。如果说 Token 是 TCP/IP，那么 Claude Code 就是 AI 时代构建的第一个真正的网站。这将对软件行业的很大一部分造成冲击。</p>

    <h2>软件（尤其是按席位收费的）将面临更艰难的时期</h2>

    <p>OpenAI 的环境可能很艰难，但在传统 SaaS 公司，可能没有比从 2012 年的"SaaS 正在吞噬世界"到今天的"SaaS 完蛋了"更大的反差了。股票反映了这一点；公司的估值倍数压缩一直很痛苦，并将持续下去。</p>

    <p>这是结构性的。我认为是时候重新思考软件的价值主张了，我有一个我认为最好的类比来说明未来会是什么样子。之后，我们将探讨软件作为计算的延伸会是什么样子，我相信 Claude Code 类似于计算中的内存层次结构。让我们来解释一下。</p>

    <h2>软件的新模型</h2>

    <p>Claude Code（以及后续创新）显然会改变很多关于软件的东西，但典型的（也是正确的）反对意见是，你不能将"非确定性软件"用于明确的业务实践。然而，硬件中有一个持久的设计模式可以解决这种差异：内存层次结构。没有人可以依赖计算机非持久性内存中的任何东西，但它却是整个堆栈中最有价值的组件之一。</p>

    <div class="process-phase">
        <p>对于不熟悉计算机科学的人来说，存在一个内存层次结构，它用容量和持久性换取速度，系统之所以有效是因为层级之间存在交接。在传统堆栈中，SRAM 位于顶部；溢出到 DRAM，它是非持久性的（如果关闭它，数据就会消失），然后是 NAND，它是持久性的（如果关闭它，数据仍然存在）。</p>
    </div>

    <p>我认为 Claude Code 和 Agent Next 将成为计算堆栈中的非持久性内存堆栈。Claude Code 就是 DRAM。</p>

    <h3>内存层次结构的映射</h3>

    <p>我相信 AI 和软件将成为这一结构的延伸，我们已经可以识别出哪些层对应哪些。层次结构中的"CPU"包含原始信息，层次结构中的快速内存对应于上下文窗口。这个上下文级别是非常快速的信息，不是持久性的，会被系统性地清除。在非持久性内存中执行的工作输出被传递到 NAND，用于长期存储。</p>

    <p>现在代码仅仅是硬件的输出，我相信这个类比是适用的。</p>

    <div class="scenario">
        <p>AI Agent 及其上下文窗口将成为新的"快速内存"，我相信基础设施软件将更接近持久性内存。它将具有高价值、结构化输出，并且转换速度要慢得多。我认为思考软件和"未来软件"的方式更像 NAND，它是持久的、准确的，是需要存储的信息。用软件术语来说，它将是 AI Agent 交互和操作信息的"单一真实来源"。</p>
    </div>

    <h3>上下文窗口作为计算周期</h3>

    <p>每次 AI Agent 的计算周期发生时，这都是一个草稿本。每个上下文窗口都是一个时钟周期：缓存状态累积直到缓存被刷新，之后信息被处理。之后，整个上下文被丢弃，只留下输出。计算是短暂的，更高层次的计算进行的信息处理在很大程度上抽象掉了推理过程。</p>

    <div class="highlight">
        <p>重要的是，我认为在一个软件不会消失的世界中，它的角色必须改变。在这个类比中，数据、状态和 API 将是持久性存储，类似于 NAND，而面向人类消费的软件可能会变得过时。所有面向人类消费的横向软件公司都将过时。整个模型将专注于快速信息处理器（AI Agent），使用 token 来转换它们并将答案存回内存。软件本身必须改变以支持这一核心机制，因为层次结构顶部的计算引擎主要是非人类的，即 AI Agent。</p>
    </div>

    <p>我相信下一代软件公司必须完全转变其商业模式，为 AI 驱动的消费未来做好准备，否则它们将被抛在后面。</p>

    <h2>未来的一瞥</h2>

    <p>那么这个未来是什么样子的？我相信所有软件都必须尽快离开信息工作。我相信软件的未来角色不会有太多"信息处理"，即分析。Claude Code 或 Agent-Next 将进行信息综合、GUI 和工作流程。这将是短暂的，并根据手头的用途生成。任何人都应该能够以他们想要的格式访问他们想要的信息，并引用底层数据。</p>

    <p>我想说的是，传统的差异化指标将会改变。更快的工作流程、更好的 UI 和更流畅的集成都将变得毫无价值，而持久性信息（比如 API）将变得极其有价值。软件和基础设施软件将成为内存层次结构的"NAND"部分。</p>

    <h3>面临灭绝级事件的公司</h3>

    <div class="process-phase">
        <p>由于我将大量依赖内存的历史，上次新的竞争技术出现时，对于 DRAM 取代的磁芯来说是一个灭绝事件，我认为这可能也会发生在 UI 公司或像 Tableau 这样的可视化软件公司身上。Zapier / Make 作为连接器、PA 公司等，这些都面临着灭绝级事件。</p>
    </div>

    <p>我认为可能受到重大影响的其他公司包括 Notion 和 Airtable。Monday、Asana 和 Smartsheet 只是任务的 UI；它们为什么应该存在？如果 UI 作为人类为其他人类创建的概念消失，Figma 可能会受到重大干扰。</p>

    <h3>需要转型的"真实来源"公司</h3>

    <p>有趣的公司是"真实来源"，但其中许多需要改变。一个例子甚至可能是 Salesforce，一家 SaaS 公司。我认为 UI 不是很好，大多数定制项目只是在 CRM 中强化工作流程。为了实现飞跃，Salesforce 需要将其产品重点放在被 AI Agent 消费、操作和维护上，同时成为这个堆栈中最好的 NAND。问题是 Salesforce 会想尝试向上游发展，这样做可能会完全错过这一转变。</p>

    <div class="scenario">
        <p>如今，大多数 SaaS 公司需要将其商业模式转变为更接近基于 API 的模型，以与未来软件的内存层次结构保持一致。数据的保管和长期存储现在在很大程度上是软件公司的角色，它们必须学会看起来更像基础设施软件，以便被 AI Agent 消费。我相信这就是接下来会发生的事情。</p>
    </div>

    <h2>结语</h2>

    <p>这引出了一个问题：在不久的将来，这对整个行业来说会是什么样子？我相信未来 3-5 年将是一场灾难性的巨变。</p>


<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="https://fabricatedknowledge.substack.com" target="_blank">Fabricated Knowledge - Doug OLaughlin</a>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>