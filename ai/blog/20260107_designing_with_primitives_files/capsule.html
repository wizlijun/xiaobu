<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>不变的核心：用 Primitives 做设计</title>
    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fff;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        h3 {
            color: #495057;
            margin-top: 25px;
        }
        .author-info {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #3498db;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .process-phase {
            background-color: #f1f8ff;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 4px solid #0366d6;
        }
        .scenario {
            background-color: #f6f8fa;
            padding: 12px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 3px solid #6f42c1;
        }
        blockquote {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            margin: 20px 0;
            padding: 15px 20px;
            font-style: italic;
            color: #555;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #ddd;
        }
        .product-example {
            background-color: #e8f4fd;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }
        .product-example h3 {
            margin-top: 0;
            color: #1565c0;
        }
    </style>
</head>
<body>
    <h1>不变的核心：用 Primitives 做设计</h1>

    <div class="author-info">
        <p>Ryo Lu 是一位产品设计师，曾在 Notion 和 Cursor 工作。他提出了一种设计哲学：找到产品的基本构建块（primitives），从这些核心元素出发进行设计。通过理解产品真正的本质——那些不变的东西——设计师可以创造出灵活的系统，在演进过程中不丢失自己的身份。</p>
    </div>

    <p>这篇文章整理了 Ryo 关于 primitives 设计的核心观点，从软件作为概念树的视角，到为 AI 时代构建可复用的"砖块"。</p>

    <h2>设计是对根本真相的探索</h2>

    <p>Ryo Lu 认为设计不只是关于美学，而是关于揭示产品的底层真相或本质。用他的话说：</p>

    <blockquote>
        Design is the practice of seeing through the surface of things to understand structure and then rearranging those elements into new forms that didn't exist.
    </blockquote>

    <p>这意味着设计师必须问一些哲学性的问题：这个东西到底是什么？它的核心属性是什么？我能移除什么，直到它不再是它自己？</p>

    <p>通过把概念剥离到本质，设计师不只是让东西变好看——而是让它忠于自己的核心目的。一旦理解了核心，"我能构建什么新东西"就变得更清晰了。</p>

    <p>这种方法把设计当作元素层面的问题解决，寻找一个（当前的）"终极解决方案"——在给定约束下满足所有需求的最简配置。这个方案可能随着条件演变而改变，但在任何时刻，目标都是基于那些不变的、永恒的基础来做设计。</p>

    <h2>软件是核心概念的树</h2>

    <p>在软件产品的语境下，Ryo 把每个产品描述为"打包在一起的概念树"。每个应用都有几个核心数据 primitives，决定了上层能构建什么。这些 primitives 的稳定性和灵活性，决定了产品能多容易地成长或适应变化。</p>

    <p>不同的工具有不同的"概念树"：</p>

    <div class="product-example">
        <h3>Notion</h3>
        <p>建立在少量抽象 primitives 之上——blocks、pages 和 databases（在 workspace 内）。每一段内容都是一个 block（本质上是一个 JSON 对象），pages 是 blocks 的集合，databases 是 pages 的集合。</p>
        <p>这个通用模型非常灵活，让 Notion 能扩展到文档、wiki、任务、项目管理等等。因为一切都由相同的基本构建块组成，Notion 的新功能只是这些 primitives 的新组合。</p>
    </div>

    <div class="product-example">
        <h3>Asana</h3>
        <p>围绕更刚性的 primitives 构建——projects 和 tasks。几乎所有功能都围绕这两个概念。这个狭窄的模型让 Asana 在任务管理上做得很好，但限制了灵活性。</p>
        <p>如 Ryo 所说，Asana 的数据模型是"锁定的"，很难扩展到完全不同类型的生产力工具。与 Notion 相比，Asana 的核心概念不够抽象，所以无法轻易地被复用到原有范围之外。</p>
    </div>

    <div class="product-example">
        <h3>Cursor</h3>
        <p>一个 AI 驱动的编码工具，Cursor 把软件还原到可能是最根本的 primitive——code。它的核心概念包括 agents、models、context 和 editors，都服务于操作代码。</p>
        <p>因为代码是软件的一切基础，Cursor 对代码作为核心构建块的聚焦让系统极其通用。本质上，Cursor 的"树"根植于原始代码，给了它广泛的触达范围（从编写和编辑代码到建立在代码之上的更高层抽象）。</p>
    </div>

    <p>通过比较这些例子可以看到 Ryo 的观点：像 Notion 这样的产品成功，部分原因是它们的核心抽象简单且可组合；而那些 primitives 过于具体的产品会感觉受限。选择正确的 primitives 给产品留出了成长空间。</p>

    <h2>找到永恒的 Primitives</h2>

    <p>这个哲学的关键一步是找到设计中永恒的元素——那些即使功能来来去去也保持不变的方面。Ryo 认为在任何系统中：</p>

    <blockquote>
        There are always a set of things that don't really change, and it is so important to figure out what those things are.
    </blockquote>

    <p>这些成为一切的基础构建块或想法。一旦识别出来，设计师的工作就是确保这些 primitives 尽可能健壮和简单，因为它们构成了产品"不变的核心"。</p>

    <h3>0、1、N 状态设计</h3>

    <p>Ryo 提到的一个实用技巧是为 zero state、one state 和 n state 设计产品。换句话说，考虑系统在没有内容、有少量内容、有大量或复杂内容时如何表现。</p>

    <p>一个设计良好的 primitive 应该能优雅地跨越这些状态。当数据库为空、有一条记录、有很多记录时，UI 应该是什么样子？通过为这些使用阶段（0、1、N）设计，你能确保核心概念在所有场景下都成立。这帮助揭示哪些想法是核心的、永恒的。</p>

    <p>在每一层，都要问核心概念如何相互关联和融合。Ryo 指出你必须理解"它们在每一层如何相互关联"才能实现一个有凝聚力的系统。</p>

    <h3>寻找"终极答案"</h3>

    <p>Ryo 相信，对于给定的用户需求和约束，往往存在一个"终极答案"——本质上是完成所需一切的最简单、最优雅的核心部件组合。设计师的工作是寻找那个配置。</p>

    <p>这不意味着设计永远不会改变；而是意味着在任何给定时刻，设计都努力做到局部最优，并深深植根于关于用户和问题的真相。通过在添加新功能时不断重访基础（并愿意重构或简化），产品保持用户感知为直观或"必然"的完整性和清晰度。</p>

    <p>找到经得起时间考验的 primitives，围绕它们设计一切，产品就会在演进中保持连贯。</p>

    <h2>代码是终极 Primitive</h2>

    <p>因为 Ryo 的专业领域在软件，他强调代码是我们媒介的原材料。在传统平面设计中，primitive 可能是形状或颜色；在建筑中，可能是物理材料。但在软件中：</p>

    <blockquote>
        The code is the material.
    </blockquote>

    <p>这对设计师有两个重要含义。</p>

    <h3>在代码层面构建</h3>

    <p>要真正拥抱软件 primitives，设计师有时应该在代码层面操作，而不只是高保真 mockups。Ryo 描述了他如何从"困在图片或文字中"转向用代码做原型来传达想法。</p>

    <p>如果我们的终极 primitives 在代码中，直接在那个媒介中工作能产出更真实的设计。在他看来：</p>

    <blockquote>
        Because we're software makers, the best tool is code.
    </blockquote>

    <p>这是界面背后真正的物质。通过紧密地与代码工作，设计师参与到产品真正的 primitives（函数、数据结构、组件），这导向的解决方案不只是视觉上令人愉悦，而且功能上健全。</p>

    <p>代码级原型成为想法的容器，你和其他人可以实际使用和改进它，而不是一张静态图片。</p>

    <blockquote>
        The true material isn't the pixels in a mock-up; it's the code that renders them, and because it existed, it could be improved.
    </blockquote>

    <p>换句话说，编码的原型可以有机演进，而静态设计可能隐藏未预见的问题。</p>

    <h3>代码作为统一抽象</h3>

    <p>Ryo 还指出，当你的核心概念像代码一样低层时，它统一了产品的很多层。这在 Cursor 的设计中很明显：从编写代码到与 AI agent 讨论代码，一切都发生在一个环境中，因为代码（和文本）是共同的分母。</p>

    <p>从最根本的 primitive（在这个案例中是文本编辑器环境）出发，Cursor 可以在上面添加层（AI 辅助、协作、规划工具）而不打破范式。每个新层只是与同一个以代码为中心的模型的另一种视图或交互。这让整体系统比你有单独的断开连接的工具更简单。</p>

    <p>一般来说，用 primitives 设计往往意味着选择一个合适的最低公分母（像代码或"block"），这样更高层的功能都能说同一种语言。这是确保产品设计一致性的方式。</p>

    <h2>设计系统（"容器"）而非像素</h2>

    <p>Ryo 哲学的另一个主要主题是：现代设计师应该以系统和模式而非孤立的屏幕或像素来思考。他认为设计师产出的东西正在"上升一个抽象层级"：</p>

    <blockquote>
        Instead of designing exactly how one piece of UI will look, you are actually designing a container.
    </blockquote>

    <p>这意味着一个可复用的模式或组件，可以容纳不同内容但仍然一致地工作。</p>

    <p>在实践中，这是 design systems 背后的思维方式：定义按钮、卡片、模态框、布局等作为灵活的容器，而不是从头开始制作每个新屏幕。通过设计这些容器和它们的行为规则，你确保整个产品的一致性。单个屏幕然后成为这些容器组件的组合。</p>

    <h3>模式间的转换</h3>

    <p>在这个系统层面设计需要一个底层架构，能够容纳各种配置和自定义。Ryo 强调要有"相互转换"的模式——换句话说，每个组件应该像拼图一样嵌入更大的系统，使用相同的设计语言和原则。</p>

    <p>例如，如果你定义了 Notion 中"block"如何工作，这个概念可以嵌套在页面中，转换为数据库条目，或在不同视图中显示，而不需要每次都有全新的 UI 范式。设计师的角色是设定那些模式规则，让系统灵活但也有凝聚力。</p>

    <h3>容器的持久性</h3>

    <p>聚焦于容器和模式的一个优势是持久性。一个精心设计的容器可以欢迎新内容甚至新功能类型，而不需要重新设计核心。这在 Cursor 如何利用 VS Code 的 primitives 中得到呼应——像通用编辑器面板（可以显示代码、文本或 diff 视图）和包含文件/文件夹的 workspaces 这样的概念。</p>

    <p>这些容器概念让同一个界面以一致的方式为不同用户角色（开发者、设计师、产品经理等）呈现不同信息。本质上，展示层保持简单，因为它建立在处理许多用例的少数容器之上。</p>

    <p>对设计师来说，这意味着花精力"设计容器"（带有所有状态的可复用模式），而不是在每个屏幕上画每个像素。这样做，你创建了一个系统，添加或更改内容不会破坏设计——容器会适应它。</p>

    <h2>为 AI 时代构建"砖块"</h2>

    <p>随着 AI 的兴起，Ryo 指出设计正在进入一个新时代，AI agents 可以生成和组装界面。在这个背景下，他认为为 AI（和人类）提供高质量的构建块——"砖块"——是至关重要的：</p>

    <blockquote>
        Because AI is really good at composing parts, we need to build bricks. Really good bricks.
    </blockquote>

    <p>这些砖块是可以反复复用的基础 UI 和代码组件。如果砖块设计良好且一致，AI（或开发者）可以用无数种方式把它们组合在一起，结果仍然感觉连贯。另一方面，如果你不提供好的砖块，AI 可能每次都以次优的方式"重新发明轮子"。</p>

    <h3>什么是好的"砖块"</h3>

    <p>Ryo 认为即使在视觉层面，设计师也应该建立扎实、可复用的模式：</p>

    <blockquote>
        All the foundational bricks, they need to fit perfectly even in the visual space.
    </blockquote>

    <p>他指出像调色板、间距规则、字体是视觉设计系统的基础砖块。随着时间推移，团队将这些基础提炼成一个直观的工具包——一套产品中一切都建立在其上的视觉和交互 primitives。</p>

    <p>当这些低层想法以最简单、最纯粹的形式构建时，它们可以组合在一起而不冲突。结果是一个和谐的界面，每个部分都似乎属于那里。</p>

    <h3>AI 时代的实践</h3>

    <p>在实践中，为 AI 时代构建砖块意味着严格定义你的设计语言和组件。AI 可能被要求即时生成一个新对话框或页面布局——如果它使用你预定义的"砖块"（按钮、文本框、容器等），新 UI 将看起来和感觉像产品的其他部分。</p>

    <p>Ryo 设想设计师提供"人类和 agents 都能使用"的模式库来创建新解决方案。这防止了无尽的重复发明并确保质量。这是 design systems 背后想法的延伸，但把 AI 作为协作者纳入考虑：砖块越好，AI（或任何人）能从中创建的组合就越好。</p>

    <p>简而言之，即使技术和 AI 能力可能快速变化，一些核心设计常量（"不变的核心"如间距、颜色、基础组件）应该保持稳定，作为动态的、AI 生成的界面可以建立在其上的基石。</p>

    <h2>小结</h2>

    <div class="highlight">
        <p>用 primitives 设计是关于缩小视野看森林（系统）而不只是树木（单个屏幕）。通过定义一个不变的基础概念核心——无论是数据层面（如 blocks、tasks、code）还是视觉层面（网格、字体比例、颜色）——像 Ryo Lu 这样的设计师创造出随时间推移依然灵活且连贯的产品。</p>
    </div>

    <p>这种方法需要哲学性的内省（来确定产品的核心到底是什么）和在基础层面构建原型和系统的技术意愿。回报是一个可以在能力上成长而在设计上不会变得混乱的产品。</p>

    <p>这不仅让产品更容易被用户理解，还让产品准备好利用新技术（如 AI），通过用新方式重组那些值得信赖的构建块。归根结底，"不变的核心"思维方式提醒我们：虽然功能和趋势可能改变，好的设计锚定在永恒的原则和 primitives 上——那些如此根本的元素，如果改变了，产品就不再是它自己。通过忠实地围绕这些核心 primitives 设计，我们确保无论什么变化到来，产品的本质和可用性都保持完整。</p>

</body>
</html>
