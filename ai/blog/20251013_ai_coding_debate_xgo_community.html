<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XGo 社区观察：AI Coding 实践中的两种路径</title>
    <style>
        /* 现代化CSS样式 */
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fff;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        h3 {
            color: #34495e;
            margin-top: 25px;
        }
        .author-info {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #3498db;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .process-phase {
            background-color: #f1f8ff;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 4px solid #0366d6;
        }
        .scenario {
            background-color: #f6f8fa;
            padding: 12px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 3px solid #6f42c1;
        }
        blockquote {
            background-color: #f9f9f9;
            border-left: 4px solid #3498db;
            margin: 20px 0;
            padding: 15px 20px;
            font-style: italic;
            color: #555;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #e83e8c;
        }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #ddd;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        ul, ol {
            padding-left: 30px;
        }
        li {
            margin: 8px 0;
        }
        strong {
            color: #2c3e50;
        }
        .intro {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #28a745;
        }
        .summary-box {
            background-color: #e7f3ff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #0366d6;
        }
    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>
    <h1>XGo 社区观察：AI Coding 实践中的两种路径</h1>

    <div class="intro">
        <p>最近在 XGo 用户群里，看到许士伟和马工围绕 AI Coding 展开了几轮有意思的讨论。从 10 月 9 日到 13 日，两人在 AI 的本质定位、工作流程、组织变革等话题上碰撞出不少火花。这些讨论不是纯理论的，背后都有真实的实践经验支撑。许士伟团队刚刚在 10 月 12 日发布了 XGo v1.5.2，这是第一个 AI 作为主力程序员参与开发的版本，AI 代号 XGopilot 已经成为项目的第 8 大贡献者。</p>

        <p>这篇文章整理了他们的核心观点和分歧，帮助大家了解当前 AI Coding 实践中的不同思路。</p>
    </div>

    <h2>AI 到底是不是软件</h2>

    <p>10 月 9 日晚，马工抛出一个问题："现在还认为 AI 是软件吗？"暗示 AI 可能已经超越传统软件的范畴。</p>

    <p>许士伟的回答很直接："当然啊"，并且批评这是"一个不太有营养的问题"。他给出了清晰的定义：</p>

    <blockquote>
        AI Coding 和 AI 是两码事。AI Coding 属于一类 AI 应用。而 AI 狭义上应该是提供智能的单元本身。
    </blockquote>

    <p>这个定义把讨论拉回到具体的工程实践层面，后续的争论也主要集中在 AI Coding 的应用方式上。</p>

    <h2>Issue 和 PR 里怎么跟 AI 对话</h2>

    <p>马工关心一个实际问题："你同时在 issue 和 pr 下和它对话，不会乱吗？"他在探索企业级的工程化方案，关注 system prompt 应该放在哪一层（repo 层、公司层还是 persona 层），以及如何管理多个 persona（dev、tester、security engineer）。</p>

    <p>许士伟的做法比较简单粗暴：</p>

    <ul>
        <li><strong>Issue 下面是分拆任务</strong></li>
        <li><strong>PR 下面是修正任务</strong></li>
    </ul>

    <p>他反对搞复杂的 spec 规范，主张"用 GitHub 传递上下文，其他都交给 AI"。实战中，他在 XGo 主 repo 里放了一个 <code>CLAUDE.md</code> 作为 AI 的工作指南。</p>

    <h3>AI 的设计能力怎么样</h3>

    <p>到了 10 月 11 日，马工分享了自己的经验：</p>

    <blockquote>
        设计这个环节，同步模式比较好，它出方案，你现场纠正，feedback loop 短。
    </blockquote>

    <p>许士伟的观察更谨慎：</p>

    <blockquote>
        复杂逻辑的 design，AI 还是想不出特别好的主意，给的方案整体上比较平庸。
    </blockquote>

    <p>他说自己已经纠正了 2 次，AI 表现仍然不理想。这说明 AI 在创造性设计方面还有明显局限。</p>

    <h2>要不要让销售直接用 AI 做 POC</h2>

    <p>马工提出一个大胆的想法：</p>

    <blockquote>
        我想挑战这个流程，去掉中间商，销售直接叫研发。
    </blockquote>

    <p>他的设想是，让 To B 公司的销售拥有独立环境和 POC 分支，配合 AI 快速完成客户定制化演示，"一个销售 + 一个工程师 + AI，两个小时就能完成"。</p>

    <p>许士伟的反应很强烈：</p>

    <blockquote>
        这个不会成功，公司会乱套了。
    </blockquote>

    <p>他的理由是：</p>

    <ul>
        <li>对销售要求太高，销售不可 scale</li>
        <li>产品经理的能力要求，原则上需要是研发的 10 倍，找不到合格的销售</li>
    </ul>

    <p>但他也认可 POC 场景："这样可以，只是 POC 没问题"——前提是不进主分支。</p>

    <div class="highlight">
        <p>两人最终在一个点上达成共识：售前用 AI Coding 快速出 POC 或方案是有价值的。马工说"销售可以带 live demo system 见客户，而不只是 PPT"，许士伟回应"这个和我们思路一样"。</p>
    </div>

    <h2>两种不同的 AI Coding 理念</h2>

    <h3>许士伟：工匠路线</h3>

    <p>许士伟对 AI 的定位很清楚：</p>

    <blockquote>
        AI 推理能力在人类平均线附近且偏下一点。AI 的优势是几乎没有知识盲区，所以很多看似很难的问题它都能够解答。AI 虽然不够聪明（推理能力），但是足够全能。
    </blockquote>

    <p>他的实践重点：</p>

    <ul>
        <li><strong>效率评估</strong>：单一任务时间略有变长，但通过并行开发多个功能，平均效率提升；质量提升，尤其在文档和测试覆盖度上（要求 85% 以上测试覆盖率）</li>
        <li><strong>工作方式</strong>："我只动嘴不动手"，"你只要有嘴就行，AI 能够帮你做任何事情"</li>
        <li><strong>质量要求</strong>：保持传统软件工程的严谨性，提升个人和小团队的研发效率</li>
    </ul>

    <p>他还提到一个教育话题：</p>

    <blockquote>
        对中国的教育挑战很大，我们的教育出来的人才和大模型能力重叠度太高。
    </blockquote>

    <h3>马工：变革路线</h3>

    <p>马工关注的是更大层面的组织变革：</p>

    <ul>
        <li><strong>工程化落地</strong>：探索企业级 AI Coding 流程，关注 system prompt 的分层管理，研究多 persona / sub agent 架构</li>
        <li><strong>实用主义</strong>："寻找到合适的 AI Coding 应用场景，可能比提高 AI Coding 质量更重要"</li>
        <li><strong>组织创新</strong>：尝试打破传统研发流程，让销售直接对接研发 + AI</li>
    </ul>

    <p>他用 Claude Code 生成 Mermaid 架构图和文档，解决代码文档漂移问题。</p>

    <h2>技术实践对比</h2>

    <table>
        <thead>
            <tr>
                <th>对比维度</th>
                <th>许士伟</th>
                <th>马工</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>目标</strong></td>
                <td>编译器开发 + POC</td>
                <td>企业级应用 + 销售赋能</td>
            </tr>
            <tr>
                <td><strong>质量标准</strong></td>
                <td>高（85%+ 测试覆盖）</td>
                <td>灵活（POC 不进主分支）</td>
            </tr>
            <tr>
                <td><strong>工具选择</strong></td>
                <td>主要用 Claude</td>
                <td>Claude Code + 多模型</td>
            </tr>
            <tr>
                <td><strong>流程理念</strong></td>
                <td>简化，反对复杂 spec</td>
                <td>探索分层 system prompt</td>
            </tr>
            <tr>
                <td><strong>组织变革</strong></td>
                <td>保守（产品经理必须会写代码）</td>
                <td>激进（销售直接用 AI 做 POC）</td>
            </tr>
        </tbody>
    </table>

    <h2>小结</h2>

    <div class="summary-box">
        <p>这场讨论本质上反映了 AI Coding 应用的两种路径：</p>

        <p><strong>许士伟的工匠路线</strong>：把 AI 当作高质量的编程助手，保持传统软件工程的严谨性，提升个人和小团队的研发效率。</p>

        <p><strong>马工的变革路线</strong>：把 AI 当作组织流程重构的催化剂，探索打破传统职能边界的可能性，通过 AI 赋能非技术角色参与技术工作。</p>

        <p>两人在 POC 场景上有共识，但在是否用 AI 重构组织流程上存在分歧。许士伟更注重工程质量和可持续性，马工更关注快速响应客户需求和组织敏捷性。</p>

        <p>XGo v1.5.2 的发布是一个重要的里程碑，XGopilot 作为第 8 大贡献者已经证明了 AI 可以成为真正的团队成员。接下来值得关注的是，这两种路径会在实践中产生怎样的效果，以及是否会出现更多混合模式。</p>
    </div>

<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="/write/20251013_ai_coding_debate_xgo_community.md" target="_blank">原文</a>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>
