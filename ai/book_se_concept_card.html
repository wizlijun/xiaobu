<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SWEBOK v4.0a 知识卡片</title>
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #50e3c2;
            --background-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #333;
            --card-shadow: 0 4px 8px rgba(0,0,0,0.1);
            --border-radius: 12px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            line-height: 1.6;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 2em;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 2em;
        }

        header h1 {
            color: var(--primary-color);
            font-weight: 600;
        }
        header p {
            color: #6c757d;
            font-size: 1.1em;
        }

        .ka-section {
            margin-bottom: 3em;
        }

        .ka-section h2 {
            color: var(--primary-color);
            border-bottom: 3px solid var(--secondary-color);
            padding-bottom: 0.5em;
            margin-bottom: 1.5em;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 25px;
        }

        .card-container {
            background-color: transparent;
            width: 100%;
            height: 220px;
            perspective: 1000px;
            cursor: pointer;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .card-container:hover .card-inner,
        .card-container.is-flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
        }

        .card-front {
            color: var(--text-color);
            font-size: 1.25em;
            font-weight: 600;
        }
        
        .card-front::after {
            content: '点击翻转';
            font-size: 0.7em;
            font-weight: 400;
            color: #adb5bd;
            position: absolute;
            bottom: 15px;
        }

        .card-back {
            background-color: var(--primary-color);
            color: white;
            transform: rotateY(180deg);
            font-size: 0.95em;
            text-align: left;
            overflow-y: auto;
        }
        
        .card-back h4 {
            margin: 0 0 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.5);
            padding-bottom: 5px;
        }
        
        .card-back ul {
            padding-left: 20px;
            margin: 0;
        }
        
        .card-back p {
            margin: 0;
        }

        footer {
            text-align: center;
            margin-top: 3em;
            padding-top: 1.5em;
            border-top: 1px solid #dee2e6;
            color: #6c757d;
        }
    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>SWEBOK v4.0a 知识卡片</h1>
            <p>点击卡片查看定义与解释</p>
        </header>

        <main>
            <!-- KA Sections will be generated here by JS -->
        </main>

        <footer>
            <p>由 Gemini 基于《SWEBOK Guide v4.0a》生成</p>
        </footer>
    </div>

    <script>
        const knowledgePoints = {
            "基础概念 (Fundamental Concepts)": [
                {q: "什么是SWEBOK指南?", a: "<h4>定义：</h4><p>由IEEE计算机学会发布的指南，总结了软件工程专业领域内“普遍认可的知识”。它为软件工程的教育、认证和专业实践提供了一个权威的基础框架。</p>"},
                {q: "什么是软件 (Software)?", a: "<h4>定义 (基于ISO/IEC/IEEE 24765):</h4><p>计算机程序、流程、以及可能相关的文档和数据，它们服务于一个计算机系统的运行。</p><strong>关键点:</strong> 软件不仅仅是代码。"},
                {q: "什么是软件工程 (Software Engineering)?", a: "<h4>定义 (基于IEEE):</h4><p>将系统化的、规范的、可量化的方法应用于软件的开发、运行和维护的过程；即将工程化方法应用于软件。</p><strong>本质:</strong> 它是一门工程学科。"},
                {q: "编程 vs. 软件工程", a: "<h4>区别：</h4><ul><li><strong>编程:</strong> 主要是指编写代码以实现特定算法或逻辑的活动。</li><li><strong>软件工程:</strong> 是一个更广泛的学科，它包含编程，但更涵盖了需求、设计、架构、测试、质量保证、项目管理和维护等整个软件生命周期。</li></ul><p>简单说：编程是建造活动的一部分，而软件工程是整个建筑项目的设计、管理和维护。</p>"},
                {q: "什么是知识域 (KA)?", a: "<h4>定义：</h4><p>SWEBOK指南中划分的一个特定的、被认可的软件工程专业知识领域。每个KA涵盖了一组相关的概念、实践、活动和技能。</p>"}
            ],
            "第1章: 软件需求": [
                {q: "软件需求的双重视角", a: "<h4>两种视角：</h4><ul><li>表达产品为解决现实世界问题所需的“需求与约束”。</li><li>为开发和维护这些需求所需的“活动”。</li></ul>"},
                {q: "功能性需求 (Functional Requirements)", a: "<h4>定义：</h4>指定软件应提供的可观察行为、要执行的策略和流程。它描述了系统“做什么”。<br><strong>示例:</strong> “用户应能登录系统”、“系统应能计算税费”。"},
                {q: "非功能性需求 (Nonfunctional Requirements)", a: "<h4>定义：</h4>对实现技术或系统质量属性的约束，描述了系统“如何做”或其特性。<br><strong>分类:</strong> 技术约束（如必须使用Java）、服务质量约束（如响应时间小于2秒）。"},
                {q: "需求获取 (Elicitation)", a: "<h4>定义：</h4>从各种来源（客户、用户、法规等）发现、理解并记录候选需求的过程。<br><strong>技术:</strong> 访谈、工作坊、原型、用户故事地图、问卷调查等。"},
                {q: "需求分析 (Analysis)", a: "<h4>定义：</h4>理解、协商、解决需求之间的冲突，并确保需求的完整性和一致性。<br><strong>关键活动:</strong> 需求分类、概念建模、冲突解决、优先级排序。"},
                {q: "需求规格说明 (Specification)", a: "<h4>定义：</h4>将已分析的需求清晰、准确、无歧义地记录下来的过程。<br><strong>形式:</strong> 自然语言文档、UML模型、数学规约、验收测试驱动开发（ATDD）、行为驱动开发（BDD）脚本。"},
                {q: "需求验证 (Validation)", a: "<h4>定义：</h4>确保规格说明中记录的需求是正确的、完整的，并真正反映了干系人的需求。<br><strong>方法:</strong> 需求评审、原型演示、仿真与执行。"},
                {q: "需求管理 (Management)", a: "<h4>定义：</h4>在整个软件生命周期中管理需求变更、维护需求可追溯性以及控制项目范围的活动。<br><strong>核心:</strong> 变更控制、范围匹配、需求跟踪。"}
            ],
            "第2章: 软件架构": [
                {q: "软件架构的定义", a: "<h4>核心思想：</h4>系统在其环境中的基本概念或属性，体现在其元素、关系以及设计和演化的原则中。<br>它是关于系统中那些“重要的、难以更改”的决策。"},
                {q: "视图与视点 (Views and Viewpoints)", a: "<h4>定义：</h4><ul><li><strong>视点:</strong> 描述如何构建和使用一个视图的规范，针对特定干系人的关注点（如4+1视点模型）。</li><li><strong>视图:</strong> 从特定视点出发对整个系统架构的表示（如逻辑视图、部署视图）。</li></ul>"},
                {q: "架构模式与风格 (Patterns and Styles)", a: "<h4>定义：</h4><ul><li><strong>风格:</strong> 对系统组织方式的宏观描述，定义了一系列组件和连接器类型以及它们的约束（如分层、客户端-服务器）。</li><li><strong>模式:</strong> 对在特定上下文中常见架构问题的可复用解决方案。</li></ul>"},
                {q: "架构重要需求 (ASRs)", a: "<h4>定义：</h4>对系统架构有重大影响的需求，通常是那些关键的质量属性（非功能性需求），如性能、可修改性、安全性、可用性等。"},
                {q: "架构评估方法 (ATAM)", a: "<h4>全称：</h4>Architecture Tradeoff Analysis Method (架构权衡分析方法)。<br><strong>目的:</strong> 一种系统性地评估软件架构以确定其是否能满足质量属性目标，并识别潜在风险和权衡点的方法。"},
                {q: "架构技术债务", a: "<h4>定义：</h4>在架构设计中有意或无意做出的非最优决策，虽然可能带来短期利益（如加快开发速度），但会在未来导致额外的维护、演化成本或风险。"}
            ],
            "第3章: 软件设计": [
                {q: "软件设计的目标", a: "<h4>定义：</h4>将软件需求转化为软件表示（蓝图）的过程，其详细程度足以用于后续的软件构建。它弥合了“做什么”（需求）和“如何做”（实现）之间的鸿沟。"},
                {q: "高内聚，低耦合", a: "<h4>原则：</h4><ul><li><strong>高内聚:</strong> 一个模块内部的各个元素（代码、数据）应该紧密相关，共同完成一个单一、明确的功能。</li><li><strong>低耦合:</strong> 模块与模块之间的依赖关系应该尽可能少和弱。</li></ul><strong>目的:</strong> 提高模块的独立性，便于理解、修改、测试和复用。"},
                {q: "设计原则: SOLID", a: "<h4>五个原则：</h4><ul><li><strong>S (单一职责):</strong> 一个类只应有一个引起变化的原因。</li><li><strong>O (开闭原则):</strong> 对扩展开放，对修改关闭。</li><li><strong>L (里氏替换):</strong> 子类必须能够替换其父类。</li><li><strong>I (接口隔离):</strong> 不应强迫客户端依赖于它们不使用的方法。</li><li><strong>D (依赖倒置):</strong> 高层模块不应依赖于低层模块，二者都应依赖于抽象。</li></ul>"},
                {q: "设计模式 (Design Patterns)", a: "<h4>定义：</h4>在特定情境下，对反复出现的设计问题的成熟、可复用的解决方案。<br><strong>分类:</strong> 创建型模式（如工厂、单例）、结构型模式（如适配器、代理）、行为型模式（如策略、观察者）。"},
                {q: "领域驱动设计 (DDD)", a: "<h4>核心思想：</h4>一种软件开发方法，强调将软件的核心复杂性放在领域模型上，并围绕该模型进行设计。使用通用语言（Ubiquitous Language）来连接领域专家和开发团队。"},
                {q: "设计质量属性", a: "<h4>定义：</h4>设计需要考虑的系统特性，通常与非功能性需求对应。<br><strong>示例:</strong> 并发性、错误处理与容错、可集成性与互操作性、安全性、可变性。"}
            ],
            "第4章: 软件构建": [
                {q: "软件构建 (Construction) 的核心活动", a: "<h4>主要活动包括：</h4><ul><li>详细设计（微观设计）</li><li>编码</li><li>验证（Code Review, Static Analysis）</li><li>单元测试</li><li>集成测试</li><li>调试</li></ul>"},
                {q: "构建的核心原则", a: "<h4>三大原则：</h4><ul><li><strong>最小化复杂性:</strong> 编写简单、清晰、可读的代码，避免“炫技”。</li><li><strong>为验证而构建:</strong> 编写的代码必须是可测试的。</li><li><strong>预期变更:</strong> 设计和编码时要考虑到未来的变化，使软件易于扩展和维护。</li></ul>"},
                {q: "测试驱动开发 (TDD)", a: "<h4>又称测试优先编程：</h4>一种开发实践，其工作流为“红-绿-重构”：<br><ol><li>编写一个失败的自动化测试（红灯）。</li><li>编写刚好能让测试通过的最简单的代码（绿灯）。</li><li>重构代码以消除重复和改进设计。</li></ol>"},
                {q: "防御式编程与契约式设计", a: "<h4>两种处理错误的方法：</h4><ul><li><strong>防御式编程:</strong> 在程序内部主动检查所有可能出错的条件（如无效输入），保护程序不受错误数据影响。</li><li><strong>契约式设计:</strong> 通过定义前置条件、后置条件和不变量来明确模块的责任“契约”，由调用方保证前置条件，被调用方保证后置条件。</li></ul>"},
                {q: "持续集成 (CI)", a: "<h4>定义：</h4>一种开发实践，团队成员频繁地（通常每天多次）将他们的工作集成到共享的主线仓库中。每次集成都会通过自动化的构建和测试来验证，以尽早发现集成错误。"}
            ],
            "第5章: 软件测试": [
                {q: "故障、错误与失效的区别", a: "<h4>因果链：</h4><ul><li><strong>错误(Error):</strong> 人类行为导致了不正确的结果。</li><li><strong>故障(Fault/Defect):</strong> 错误在软件中留下的静态缺陷，如错误的代码。</li><li><strong>失效(Failure):</strong> 故障在运行时被触发，导致软件表现出与预期不符的外部行为。</li></ul><strong>关系:</strong> 测试观察到的是失效，目的是为了找到并移除故障。"},
                {q: "黑盒测试与白盒测试", a: "<h4>两种基本测试方法：</h4><ul><li><strong>黑盒测试 (Black-box):</strong> 基于软件的规格说明和需求，不关心内部实现。也称为基于规格的测试或功能测试。</li><li><strong>白盒测试 (White-box):</strong> 基于软件的内部结构、逻辑和代码。也称为基于结构的测试。</li></ul>"},
                {q: "测试级别 (Test Levels)", a: "<h4>传统分层：</h4><ol><li><strong>单元测试:</strong> 验证单个组件（函数、类）的功能。</li><li><strong>集成测试:</strong> 验证多个组件组合在一起时能否协同工作。</li><li><strong>系统测试:</strong> 验证整个系统是否满足其规格说明。</li><li><strong>验收测试:</strong> 验证系统是否满足用户和业务的需求。</li></ol>"},
                {q: "回归测试 (Regression Testing)", a: "<h4>定义：</h4>在对软件进行修改（如修复缺陷、增加功能）后，重新运行之前的测试用例，以确保修改没有引入新的缺陷或导致原有功能失效。"},
                {q: "探索式测试 (Exploratory Testing)", a: "<h4>定义：</h4>一种非脚本化的测试方法，测试人员在执行测试的同时，动态地进行学习、设计和执行。它强调测试人员的自由度和创造力，常用于补充脚本化测试。"}
            ],
            "第6章: 软件工程运维": [
                {q: "DevOps 的核心理念", a: "<h4>文化与实践的集合：</h4>旨在打破开发(Dev)、质量(QA)和运维(Ops)之间的壁垒，通过自动化和协作，实现软件的快速、可靠、高质量的持续交付和价值流动。"},
                {q: "基础设施即代码 (IaC)", a: "<h4>定义：</h4>通过代码（而非手动流程）来管理和配置计算基础设施（如服务器、网络、数据库）。<br><strong>优点:</strong> 自动化、可重复性、版本控制、快速恢复、消除配置漂移。"},
                {q: "CI/CD 管道 (Pipeline)", a: "<h4>定义：</h4>一套自动化的流程，用于将代码从版本控制库可靠地交付到生产环境。典型的阶段包括：构建 -> 测试 -> 发布 -> 部署 -> 验证。"},
                {q: "监控与遥测 (Monitoring & Telemetry)", a: "<h4>目标：</h4>收集、处理、聚合和分析来自生产系统的数据，以了解系统健康状况、用户行为和业务性能。<br><strong>关键指标:</strong> 黄金四信号 (延迟、流量、错误、饱和度)、日志、追踪。"},
                {q: "站点可靠性工程 (SRE)", a: "<h4>定义：</h4>由Google开创，将软件工程的原则（特别是关于自动化和可扩展性）应用于基础设施和运维问题。<br><strong>核心概念:</strong> 服务水平目标(SLO)、错误预算(Error Budget)、消除琐事(Toil)。"}
            ]
        };
        
        const placeholders = {
            "第7章: 软件维护": [
                {q: "维护的四种类型", a: "<ul><li><strong>纠正性:</strong> 修复已发现的缺陷。</li><li><strong>适应性:</strong> 修改软件以适应变化的外部环境（如新操作系统）。</li><li><strong>完善性:</strong> 增加新功能或改进性能。</li><li><strong>预防性:</strong> 为防止未来问题而进行修改（如重构）。</li></ul>"},
                {q: "影响分析 (Impact Analysis)", a: "<h4>定义：</h4>在进行变更前，评估提议的变更对现有系统的各个部分（代码、文档、测试等）可能产生的影响的过程。"}
            ],
            "第8章: 软件配置管理": [
                {q: "SCM 的四大活动", a: "<ol><li><strong>配置识别:</strong> 确定哪些是配置项(CI)并为其建立基线。</li><li><strong>配置控制:</strong> 规范化地管理对CI的变更。</li><li><strong>配置状态审计:</strong> 记录和报告CI的状态和变更历史。</li><li><strong>配置审计:</strong> 验证CI的完整性和正确性。</li></ol>"},
                {q: "基线 (Baseline)", a: "<h4>定义：</h4>一个或多个配置项在生命周期中某个特定时间点上，经过正式审查和同意的版本，此后它将作为进一步开发的基础，并且只能通过正式的变更控制程序进行更改。"}
            ],
            "第9章: 软件工程管理": [
                {q: "软件项目规划的核心内容", a: "<h4>包括：</h4>过程规划、可交付成果定义、工作量/进度/成本估算、资源分配、风险管理、质量管理和计划管理。"},
                {q: "风险管理", a: "<h4>过程：</h4>风险识别 -> 风险分析（可能性与影响） -> 风险优先级排序 -> 风险应对策略制定（规避、转移、减轻、接受） -> 风险监控。"}
            ],
            "第10章: 软件工程过程": [
                {q: "生命周期模型 (Life Cycle Models)", a: "<h4>定义：</h4>为软件开发、维护和退役的整个生命周期提供一个框架。<br><strong>类型:</strong> 预测型（如瀑布）、迭代型、增量型、适应型（如敏捷）。"},
                {q: "过程评估与改进", a: "<h4>目的：</h4>系统性地评估现有软件过程的有效性，并识别改进机会。<br><strong>模型/方法:</strong> CMMI, SPICE (ISO/IEC 33000), PDCA循环。"}
            ],
            "第11章: 软件工程模型与方法": [
                {q: "形式化方法 (Formal Methods)", a: "<h4>定义：</h4>使用基于严格数学的语言和技术来对软件系统进行规格说明、设计和验证的方法。<br><strong>优点:</strong> 能够提供最高级别的正确性保证。"}
            ],
            "第12章: 软件质量": [
                {q: "软件质量保证 (SQA)", a: "<h4>定义：</h4>一套关注于“过程”的活动，旨在提供足够的信心，证明软件项目将满足相关的质量标准。它是一种预防性措施。"},
                {q: "验证与确认 (V&V)", a: "<h4>区别：</h4><ul><li><strong>验证(Verification):</strong> “我们是否正确地构建了产品？”（即产品是否符合其规格说明）</li><li><strong>确认(Validation):</strong> “我们是否构建了正确的产品？”（即产品是否满足用户和业务的真实需求）</li></ul>"}
            ],
            "第13章: 软件安全": [
                {q: "安全开发生命周期 (Secure SDLC)", a: "<h4>核心理念：</h4>将安全活动集成到软件开发的每个阶段，而不是在开发后期才考虑安全。也称为“安全左移”(Shift Left Security)。"},
                {q: "威胁建模 (Threat Modeling)", a: "<h4>定义：</h4>一种结构化的方法，用于识别、量化和应对系统中的潜在安全威胁和漏洞。常见的步骤包括：识别资产 -> 分解应用 -> 识别威胁 -> 缓解威胁。"}
            ],
            "第14章: 软件工程专业实践": [
                {q: "职业道德规范的核心原则", a: "<h4>通常包括：</h4>对公众、客户与雇主、产品、判断、管理、职业、同事和自我的责任。旨在指导工程师做出符合公共利益的、负责任的决策。"}
            ],
            "第15章: 软件工程经济学": [
                {q: "货币的时间价值", a: "<h4>基本概念：</h4>今天的钱比未来的同一笔钱更有价值，因为它可以被投资并产生收益。这是进行项目投资回报分析（如净现值NPV）的基础。"}
            ],
            "第16章: 计算基础": [
                {q: "算法复杂度", a: "<h4>定义：</h4>用于描述算法运行所需资源（通常是时间和空间）随输入数据规模增长而增长的速率。<br><strong>表示法:</strong> 大O表示法 (Big O Notation) 用于表示最坏情况下的上界。"}
            ],
            "第17章: 数学基础": [
                {q: "命题逻辑与谓词逻辑", a: "<h4>区别：</h4><ul><li><strong>命题逻辑:</strong> 处理可以被判断为真或假的完整命题。</li><li><strong>谓词逻辑:</strong> 引入变量、量词（所有∀, 存在∃），能够表达更复杂的陈述和对象之间的关系。</li></ul>"}
            ],
            "第18章: 工程基础": [
                {q: "根本原因分析 (RCA)", a: "<h4>定义：</h4>一种结构化的问题解决方法，旨在识别导致问题的深层次、根本性的原因，而不仅仅是处理表面症状。<br><strong>技术:</strong> 5 Whys, 鱼骨图 (Ishikawa Diagram)。"}
            ]
        };

        const allKnowledge = {...knowledgePoints, ...placeholders};
        
        const mainContent = document.querySelector('main');
        
        // This makes sure the "Fundamental Concepts" section appears first
        const sectionOrder = [
            "基础概念 (Fundamental Concepts)", 
            ...Object.keys(allKnowledge).filter(k => k !== "基础概念 (Fundamental Concepts)")
        ];

        sectionOrder.forEach(ka => {
            if (!allKnowledge[ka]) return;

            const section = document.createElement('section');
            section.className = 'ka-section';
            
            const title = document.createElement('h2');
            title.textContent = ka;
            section.appendChild(title);
            
            const grid = document.createElement('div');
            grid.className = 'card-grid';
            
            allKnowledge[ka].forEach(point => {
                const cardContainer = document.createElement('div');
                cardContainer.className = 'card-container';
                
                const cardInner = document.createElement('div');
                cardInner.className = 'card-inner';
                
                const cardFront = document.createElement('div');
                cardFront.className = 'card-front';
                cardFront.innerHTML = `<span>${point.q}</span>`;
                
                const cardBack = document.createElement('div');
                cardBack.className = 'card-back';
                cardBack.innerHTML = point.a;

                cardInner.appendChild(cardFront);
                cardInner.appendChild(cardBack);
                cardContainer.appendChild(cardInner);
                grid.appendChild(cardContainer);
            });
            
            section.appendChild(grid);
            mainContent.appendChild(section);
        });

        document.querySelectorAll('.card-container').forEach(card => {
            card.addEventListener('click', () => {
                card.classList.toggle('is-flipped');
            });
        });
    </script>


<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="book_se_swebok_4.html" target="_blank">源链接</a>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>