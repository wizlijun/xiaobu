<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>《敏捷软件开发》核心摘要</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --background-color: #ffffff;
            --text-color: #333;
            --light-gray: #f8f9fa;
            --border-color: #dee2e6;
            --highlight-bg: #e9ecef;
        }

        body {
            font-family: 'PingFang SC', 'Helvetica Neue', 'Microsoft YaHei', sans-serif;
            line-height: 1.7;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 2rem;
            display: flex;
            justify-content: center;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        header {
            text-align: center;
            margin-bottom: 2.5rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 1rem;
        }

        header h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            margin: 0;
        }

        header p {
            color: var(--secondary-color);
            font-size: 1.1rem;
        }

        .accordion-item {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: box-shadow 0.3s ease;
        }
        
        .accordion-item:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .accordion-header {
            background-color: var(--light-gray);
            padding: 1rem 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .accordion-header:hover {
            background-color: #e2e6ea;
        }

        .accordion-header::after {
            content: '＋';
            font-size: 1.5rem;
            color: var(--primary-color);
            transition: transform 0.3s ease;
        }
        
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s cubic-bezier(0, 1, 0, 1);
            background-color: #fff;
        }

        .accordion-content-inner {
             padding: 1.5rem;
             border-top: 1px solid var(--border-color);
        }
        
        .accordion-item input[type="checkbox"] {
            display: none;
        }
        
        .accordion-item input[type="checkbox"]:checked ~ .accordion-content {
            max-height: 5000px; /* Large enough value */
            transition: max-height 1s cubic-bezier(1, 0, 1, 0);
        }

        .accordion-item input[type="checkbox"]:checked ~ .accordion-header::after {
            transform: rotate(45deg);
        }
        
        h3 {
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            margin-top: 0;
        }

        ul, ol {
            padding-left: 20px;
        }
        
        li {
            margin-bottom: 0.75rem;
        }

        .keyword {
            background-color: #e0f3ff;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 0.9em;
        }
        
        .principle {
            font-style: italic;
            font-weight: bold;
            color: #28a745;
        }
        
        .quote {
            display: block;
            border-left: 4px solid var(--primary-color);
            padding: 10px 15px;
            margin: 1rem 0;
            background-color: var(--light-gray);
            font-style: italic;
            color: var(--secondary-color);
        }
        
        .dev-way {
            margin-top: 3rem;
            padding: 2rem;
            background-color: #f0f8ff;
            border: 2px solid #bde0fe;
            border-radius: 10px;
        }
        
        .dev-way h2 {
            text-align: center;
            color: var(--primary-color);
            margin-top: 0;
        }
        
        .dev-way p {
            font-size: 1.1rem;
            text-align: center;
            margin: 1rem 0;
            line-height: 1.8;
        }
        
        .dev-way p strong {
            display: block;
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 0.5rem;
        }

    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>《敏捷软件开发：原则、模式与实践》</h1>
            <p>Robert C. Martin (Uncle Bob) 著</p>
            <p>核心思想动态摘要</p>
        </header>

        <main>
            <!-- Section 1: Agile Development -->
            <div class="accordion-item">
                <input type="checkbox" id="section1">
                <label class="accordion-header" for="section1">第一部分：敏捷开发 (Agile Development)</label>
                <div class="accordion-content">
                    <div class="accordion-content-inner">
                        <h3>第1章：敏捷实践</h3>
                        <p>本章探讨了敏捷运动的起源和核心价值观，旨在解决传统重量级流程带来的问题。</p>
                        <strong>敏捷宣言的四大价值观:</strong>
                        <ol>
                            <li><span class="principle">个体和互动</span> 高于 流程和工具。</li>
                            <li><span class="principle">工作的软件</span> 高于 详尽的文档。</li>
                            <li><span class="principle">客户合作</span> 高于 合同谈判。</li>
                            <li><span class="principle">响应变化</span> 高于 遵循计划。</li>
                        </ol>
                        <strong>敏捷开发的十二条原则 (精选):</strong>
                        <ul>
                            <li>我们的最高目标是，通过<span class="keyword">尽早和持续地交付</span>有价值的软件来满足客户。</li>
                            <li>欢迎对需求提出更改，即使在开发后期。敏捷过程利用变化为客户创造竞争优势。</li>
                            <li>工作的软件是进度的首要度量标准。</li>
                            <li>敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一个<span class="keyword">长期的、稳定的</span>开发速度。</li>
                            <li><span class="principle">简洁</span>——最大化未完成工作的艺术——是根本。</li>
                            <li>最好的架构、需求和设计出自<span class="keyword">自组织</span>的团队。</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="accordion-item">
                <input type="checkbox" id="chapter2-6">
                <label class="accordion-header" for="chapter2-6">第2-6章：极限编程 (XP) 与核心实践</label>
                <div class="accordion-content">
                    <div class="accordion-content-inner">
                        <h3>第2章：极限编程概览 (XP)</h3>
                        <p>XP是敏捷方法中最著名的一种，由一系列相互依赖的实践组成。</p>
                        <ul>
                            <li><strong>客户作为团队成员:</strong> 客户全程参与，定义和排序<span class="keyword">用户故事</span>。</li>
                            <li><strong>短周期:</strong> 以一到两周为<span class="keyword">迭代</span>周期，频繁交付可工作的软件。</li>
                            <li><strong>测试驱动开发 (TDD):</strong> 先写失败的单元测试，再编写恰好能让测试通过的代码，最后重构。</li>
                            <li><strong>结对编程:</strong> 所有生产代码都由两人在同一台电脑上共同完成，以提高代码质量和知识共享。</li>
                            <li><strong>重构:</strong> 持续地改进代码内部结构，而不改变其外部行为，以对抗代码腐化。</li>
                            <li><strong>简单设计:</strong> 永远选择“能工作的最简单方案” (YAGNI - You Ain't Gonna Need It)。</li>
                            <li><strong>持续集成:</strong> 团队成员每天多次集成他们的工作。</li>
                        </ul>
                         <h3>第3-6章：规划、测试、重构与编程实例</h3>
                        <p>这几章通过一个保龄球计分程序的实例，生动展示了XP实践的威力。</p>
                        <blockquote class="quote">核心观点：设计的演化应由测试驱动，而不是预先过度设计。保龄球计分程序最初并不需要`Game`、`Frame`、`Throw`等复杂对象，一个简单的整数数组就足以开始。随着测试用例的增加（如处理全中和补中），设计才逐步演化得更加完善。这体现了<span class="principle">简单设计</span>和<span class="principle">演进式设计</span>的思想。</blockquote>
                    </div>
                </div>
            </div>

            <!-- Section 2: Agile Design -->
            <div class="accordion-item">
                <input type="checkbox" id="section2">
                <label class="accordion-header" for="section2">第二部分：敏捷设计 (Agile Design)</label>
                <div class="accordion-content">
                    <div class="accordion-content-inner">
                        <h3>第7章：什么是敏捷设计？</h3>
                        <p>敏捷设计是一个持续的过程，而非一个阶段。核心观点是：<span class="principle">源代码就是设计</span>。</p>
                        <strong>糟糕设计的“坏味道” (Smells of Rotting Software):</strong>
                        <ul>
                            <li><strong>僵化性 (Rigidity):</strong> 难以修改，一个改动会导致连锁反应。</li>
                            <li><strong>脆弱性 (Fragility):</strong> 修改代码时，容易在不相关的地方引入新错误。</li>
                            <li><strong>顽固性 (Immobility):</strong> 难以将代码复用到其他系统中。</li>
                            <li><strong>粘滞性 (Viscosity):</strong> 做正确的事比做错误的事更难。</li>
                            <li><strong>不必要的复杂性 (Needless Complexity):</strong> 过度设计。</li>
                            <li><strong>不必要的重复 (Needless Repetition):</strong> 复制粘贴代码。</li>
                            <li><strong>晦涩性 (Opacity):</strong> 代码难以理解。</li>
                        </ul>
                        <blockquote class="quote">敏捷团队通过持续的<span class="keyword">重构</span>来对抗这些“坏味道”，让设计始终保持整洁、简单和富有表现力。</blockquote>
                    </div>
                </div>
            </div>
            
            <div class="accordion-item">
                <input type="checkbox" id="chapter8-12">
                <label class="accordion-header" for="chapter8-12">第8-12章：SOLID 设计原则</label>
                <div class="accordion-content">
                    <div class="accordion-content-inner">
                        <p>SOLID原则是面向对象设计的基石，旨在创建易于维护和扩展的系统。</p>
                        <ol>
                            <li><strong><span class="principle">S</span> - 单一职责原则 (SRP):</strong>
                                <p>一个类应该只有一个引起它变化的原因。本章通过`Rectangle`类的例子（几何计算职责 vs. GUI绘制职责）说明了将不同变化轴向的职责分离开的重要性。</p>
                            </li>
                            <li><strong><span class="principle">O</span> - 开放-封闭原则 (OCP):</strong>
                                <p>软件实体（类、模块、函数等）应该对<span class="keyword">扩展</span>是开放的，但对<span class="keyword">修改</span>是封闭的。<strong style="color:var(--primary-color);">抽象</strong>是实现该原则的关键。当需求变化时，我们应该通过添加新代码（如实现一个新的子类）来应对，而不是修改已有的、工作的代码。</p>
                            </li>
                            <li><strong><span class="principle">L</span> - 里氏替换原则 (LSP):</strong>
                                <p>子类型必须能够替换掉它们的基类型。著名的“正方形是矩形吗？”问题揭示了LSP的精髓：继承关系必须基于<span class="keyword">行为</span>，而不仅仅是属性。如果子类的行为与客户端对基类的期望不符，那么继承就是不恰当的。</p>
                            </li>
                            <li><strong><span class="principle">I</span> - 接口隔离原则 (ISP):</strong>
                                <p>客户端不应该被强迫依赖于它们不使用的方法。该原则提倡使用多个小的、专一的接口（角色接口），而不是一个大的、臃肿的接口（胖接口），以避免不必要的耦合。</p>
                            </li>
                            <li><strong><span class="principle">D</span> - 依赖倒置原则 (DIP):</strong>
                                <p>A. 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。<br>B. 抽象不应该依赖于细节，细节应该依赖于抽象。<br>这是传统分层架构的“反转”，是框架设计的核心。通过依赖于接口而非具体实现，系统变得更加灵活和可复用。</p>
                            </li>
                        </ol>
                    </div>
                </div>
            </div>
            
            <!-- Sections 3 & 4: Payroll Case Study -->
            <div class="accordion-item">
                <input type="checkbox" id="section3-4">
                <label class="accordion-header" for="section3-4">第3 & 4部分：案例研究：薪资系统</label>
                <div class="accordion-content">
                    <div class="accordion-content-inner">
                        <h3>第13-22章：薪资系统设计与打包</h3>
                        <p>这个案例研究详细展示了如何将设计原则和模式应用于一个实际问题。从一个简单的需求开始，通过迭代逐步构建出一个健壮、灵活的薪资系统。</p>
                        <strong>核心设计决策与模式应用:</strong>
                        <ul>
                            <li><strong>事务处理:</strong> 使用<span class="keyword">命令模式 (COMMAND)</span> 将“添加员工”、“删除员工”等操作封装为事务对象。这实现了操作的请求者与执行者的解耦。</li>
                            <li><strong>支付分类/方式/时间表:</strong> 员工有不同的支付方式（小时工、月薪、提成），不同的支付方法（邮寄、直接存款），不同的支付周期（每周、每月）。这些易变的部分被<span class="keyword">策略模式 (STRATEGY)</span> 完美地分离开来，使得`Employee`类对这些变化封闭。</li>
                            <li><strong>添加员工事务:</strong> `AddEmployeeTransaction`的执行逻辑是固定的，但获取具体支付分类和时间表的逻辑是变化的。这正是<span class="keyword">模板方法模式 (TEMPLATE METHOD)</span> 的经典应用场景。</li>
                            <li><strong>数据库访问:</strong> 使用<span class="keyword">外观模式 (FACADE)</span> 创建一个`PayrollDatabase`类，将所有数据库操作的复杂性封装起来，为上层提供一个简单的接口。</li>
                            <li><strong>单一实例:</strong> 对于像数据库这样的全局访问点，可以使用<span class="keyword">单例模式 (SINGLETON)</span> 或<span class="keyword">MONOSTATE模式</span>来确保其唯一性。</li>
                            <li><strong>处理“空”情况:</strong> 员工可以没有工会会籍。与其在代码中到处检查`null`，不如使用一个`NoAffiliation`对象，这就是<span class="keyword">空对象模式 (NULL OBJECT)</span>。</li>
                            <li><strong>对象创建:</strong> 随着系统包的划分，为了避免高层包依赖于低层具体类，引入了<span class="keyword">工厂模式 (FACTORY)</span>，由工厂负责创建具体实例，从而遵循了依赖倒置原则。</li>
                        </ul>
                        <strong>包设计原则:</strong>
                        <ul>
                            <li><strong>包内聚性原则:</strong>
                                <ul>
                                   <li><span class="principle">复用-发布等价原则 (REP):</span> 复用的粒度就是发布的粒度。</li>
                                   <li><span class="principle">共同复用原则 (CRP):</span> 一个包中的类应该被一起复用。</li>
                                   <li><span class="principle">共同封闭原则 (CCP):</span> 一个包中的类应该对同一种变化共同封闭。</li>
                                </ul>
                            </li>
                             <li><strong>包耦合性原则:</strong>
                                <ul>
                                   <li><span class="principle">无环依赖原则 (ADP):</span> 包依赖关系图中不应该有环。</li>
                                   <li><span class="principle">稳定依赖原则 (SDP):</span> 依赖应该指向更稳定的方向。</li>
                                   <li><span class="principle">稳定抽象原则 (SAP):</span> 包的抽象程度应该和其稳定程度一致。</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- Sections 5 & 6: Other Case Studies -->
            <div class="accordion-item">
                <input type="checkbox" id="section5-6">
                <label class="accordion-header" for="section5-6">第5 & 6部分：案例研究：气象站 & ETS框架</label>
                <div class="accordion-content">
                    <div class="accordion-content-inner">
                        <h3>第23-27章：气象站案例</h3>
                        <p>这个案例展示了如何从一个紧密耦合的设计，通过重构，“退后”到一个经典的模式中。核心在于分离UI、业务逻辑和硬件API。</p>
                        <ul>
                            <li><strong>初始问题:</strong> `Scheduler`（调度器）了解所有的传感器和UI组件，导致任何组件的增删都会修改`Scheduler`，违反了OCP。</li>
                            <li><strong>演化过程:</strong>
                                <ol>
                                    <li>引入<span class="keyword">观察者模式 (OBSERVER)</span>，让UI观察传感器，从而将UI从调度器中解耦。</li>
                                    <li>随着需求增多（如多个UI、传感器间依赖），设计进一步演化，最终形成了标准的“主题(Subject)-观察者(Observer)”结构。</li>
                                    <li>使用<span class="keyword">桥接模式 (BRIDGE)</span> 和<span class="keyword">工厂模式 (FACTORY)</span> 将硬件抽象（API）与业务逻辑（传感器）彻底分离，实现了跨平台。</li>
                                </ol>
                            </li>
                        </ul>
                        <h3>第28-30章：ETS框架案例</h3>
                        <p>该案例聚焦于为一个考试系统构建一个可复用的框架，展示了如何处理对一个稳定类层次结构添加新功能的需求。</p>
                        <ul>
                            <li><span class="keyword">访问者模式 (VISITOR):</span> 当需要为一个稳定的类层次结构（如`Modem`及其子类）添加新操作（如为不同操作系统配置），但又不希望修改这些类时，可以使用访问者模式。它将操作逻辑从对象结构中分离出来。</li>
                            <li><strong>非循环访问者 (ACYCLIC VISITOR):</strong> 解决了传统访问者模式中，增加新`Modem`子类会导致`ModemVisitor`接口改变的循环依赖问题。</li>
                            <li><span class="keyword">状态模式 (STATE):</span> 用于实现复杂的有限状态机（FSM）。通过将每个状态封装成一个对象，状态转换变成了更换对象，而不是使用巨大的`switch-case`语句。这使得状态逻辑清晰且易于扩展。书中的地铁闸机和GUI任务控制器是绝佳示例。</li>
                        </ul>
                    </div>
                </div>
            </div>
        </main>
        
        <footer class="dev-way">
            <h2>开发者之道 (The Developer's Way)</h2>
            <p><strong>专业精神即是责任。</strong>
            我们的目标是为客户交付最高的价值。一个能工作但难以修改或理解的模块，就是个“坏掉”的模块。我们从不让腐坏开始。</p>
            <p><strong>代码即是设计，整洁是我们的准则。</strong>
            源代码是设计的最终体现，是唯一的真理之源。重构如同饭后清理厨房，不是一个阶段，而是一种持续的纪律，它让我们的代码库永远整洁，随时准备应对下一次挑战。</p>
            <p><strong>测试驱动一切。</strong>
            我们不为尚不存在的功能编写代码。我们先写一个失败的测试，再编写恰好能让它通过的代码。测试不是验证的终点，而是设计的起点，它迫使我们走向解耦和简洁。</p>
            <p><strong>拥抱变化，依赖抽象。</strong>
            需求变化是常态，而非例外。我们通过依赖稳定的抽象，而非易变的具体实现来构建强韧的系统。这正是SOLID原则的核心：将变化隔离开，让系统对扩展开放，对修改封闭。</p>
            <p><strong>以简驭繁，演进式前进。</strong>
            我们不为遥远的未来过度设计（YAGNI）。我们构建“能工作的最简单的东西”，并信任我们有能力在变化真正到来时进行调整。设计不是一次性的事件，而是在迭代中不断浮现和完善的过程。</p>
        </footer>
    </div>

<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="book_agile_development_files/book.html" target="_blank">源链接</a>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>