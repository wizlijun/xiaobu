# 软件工程工作流中的知识抽取与迁移

研发和工程团队越来越多地使用 AI 及程序化工具，从一手资料（源代码、版本历史、文档、会议记录、聊天日志等）中抽取知识，并将其迁移到其他工作流中。这些方法帮助打破信息孤岛，让知识在编码、新人入职、文档编写、问题跟踪、架构规划等场景中得以复用。本文按知识来源和目标用例，梳理知识如何被挖掘并应用到不同场景。

## 从源代码到新代码和解决方案

源代码本身蕴含大量可复用的知识——设计模式、算法、API 用法等。现代 AI 编码助手通过阅读和理解代码来辅助代码生成、调试和复用。例如 GitHub Copilot 在海量代码语料上训练，可以在上下文中建议代码补全甚至整个函数。然而，朴素的"自动补全"模型往往缺乏对项目整体上下文的感知，容易产生幻觉或不一致。

为解决这个问题，Sourcegraph Cody 等工具采用检索增强生成（RAG）：Cody 先在代码库中搜索相关代码片段和文档（使用代码图谱、关键词搜索和 embedding），然后才将上下文输入 LLM 生成答案或代码。这种"先搜索"的方式意味着 Cody 可以回答诸如"我们项目中如何处理认证？"这样的问题——它会自动检索相关文件（如 `auth.go`、`UserService.ts` 等）并将其纳入 prompt，从而给出有实际代码引用的知情答案。本质上，助手用最新的项目知识增强 prompt，而非仅依赖训练数据或单个文件的内容。

### 结构化代码分析

除了自由文本检索，一些技术还整合了结构化代码分析。研究原型如 HASTE 使用抽象语法树（AST）来引导上下文提取——将语义搜索与 AST 引导选择相结合，拉取既相关又语法完整的代码。通过保留完整函数或依赖关系，这些方法确保生成的解决方案或摘要不会遗漏关键部分（否则可能导致错误或幻觉标识符）。最终目标是给 AI 一个比典型上下文长度更大的代码库"窗口"，使其能像经验丰富的开发者浏览大型代码库一样进行推理。

### 实际工具示例

Atlassian 的 Rovo Dev agent（Atlassian Rovo AI 套件的一部分）连接源代码仓库（Bitbucket/GitHub）和其他项目数据，作为上下文感知的编码助手。它可以回答代码相关问题、建议修复，甚至通过结合代码、文档和工单知识来实现简单功能。因为它理解公司的代码历史、编码规范，甚至开放的 Jira issue 和 Confluence 文档，Rovo Dev 可以自动化常规开发任务——如修复 bug 或重构代码——并符合项目上下文。通过统一这些知识源，agent 不仅生成代码；它还利用"为什么"（来自工单的需求）和"如何"（当前代码和文档）来产出相关变更。实际中，这可能意味着自动为最近修复的 bug 编写单元测试，同时参考代码库和 issue 中的验收标准。

Embedding 和语义代码搜索是这些方案的核心。例如 Sourcegraph 为代码和文档构建 embedding，使语义相关的内容即使关键词不同也能被找到。这实现了诸如在迁移过程中发现一个仓库中的函数如何映射到另一个仓库中类似函数的"知识迁移"。AI 助手可以通过从旧代码库检索模式来帮助将功能移植到新代码库。

总之，通过 RAG、embedding 和 AST 分析从源代码中抽取知识，Cody、Copilot 和 Rovo Dev 等工具支持代码生成、跨项目复用、调试辅助和回答代码库特定问题等工作流。

## 从版本历史到文档和规划

Commit 历史和代码变更是另一个丰富的组织知识源。研发团队正在使用 AI 将这些历史记录转化为人类友好的文档、发布说明，甚至规划洞察。

### 自动生成 Commit Message

一个直接的例子是自动生成 commit message 和 pull request 描述。GitHub Copilot 可以分析代码 diff 并生成简洁的变更摘要——本质上用自然语言记录了什么被改变。这有助于确保 Git 历史"讲述项目故事"并附有有意义的描述，而无需完全依赖开发者手动编写。AI 查看文件变更，总结每个变更，并建议一个开发者可以修改或接受的 commit message。通过用文本捕获代码变更的意图，未来的贡献者可以更容易理解为什么做出某些变更，工具也可以更方便地搜索和推理 commit 日志。

### 聚合多个 Commit 生成文档

AI 可以聚合多个 commit 的知识来产出更高层级的文档。例如 DigestDiff 等服务使用 LLM 将项目的 commit 历史编织成代码库演进的叙事摘要。其理念是每个仓库的 commit 都讲述着一个关于新增功能、修复 bug 和设计决策的"未被讲述的故事"。DigestDiff 的 AI 生成详细概述，追溯代码随时间的演进——突出主要贡献者和变更——这可以加速新开发者的入职。新人无需阅读数千条 commit message，就能获得项目历史和关键转折点的概要。类似地，该工具可以回顾近期工作（如上周的 commit）来帮助团队准备状态更新或回顾会议。这本质上是将粒度化的 commit 数据迁移为面向人的报告。

### 自动化 Changelog 和 Release Notes

另一个常见用途是自动化 changelog 和发布说明。给定一个 commit 范围（比如自上次发布以来的所有 commit），AI 可以总结面向用户的变更。DigestDiff 可以在不直接访问代码的情况下从 commit 历史生成详细的发布说明。AI 被指示将 commit 日志转化为连贯的功能、改进和修复列表，以适合最终用户或利益相关者的方式表述。这种程序化知识迁移使工程师免于编写发布摘要的繁琐工作，并确保没有 commit 在 changelog 中被遗漏。

### 规划和质量洞察

Commit 历史还可以为规划和质量洞察提供输入。Commit 中的模式（如某个组件中大量 revert 或 bug 修复 commit）可能预示技术债务，工具可将其标记为 Jira issue 或重构任务。一些 agent 正被设计为监视 commit 流，并在某些情况下建议开通工单，比如 TODO 注释被移除但没有后续跟进。Atlassian 的 Rovo AI 暗示了这个方向：它有可以起草 bug 报告的 agent，以及开箱即用的发布说明 agent。

### 链接代码变更到文档

将代码变更链接到文档是知识迁移的另一个方面。一些 AI 文档生成器监视新 commit，然后相应更新帮助文档或开发者文档。一个理想的系统可以注意到新功能何时被合并、分析代码及其 commit message、交叉引用相关的 Jira 工单以获取上下文，然后为该功能起草帮助中心文章或文档章节。草稿会按照公司风格编写，不仅解释代码做了什么，还解释为什么（得益于从项目管理工单中提取目的）。这种管道说明知识从代码和项目元数据流入精炼文档。它确保面向用户的指南或内部 wiki 与产品保持同步——减少工程和文档之间的漂移。

## 从会议和聊天到摘要和行动项

团队讨论——无论在会议还是聊天线程中——通常包含需要捕获和执行的决策、想法和任务。手动筛选这些内容以获取洞察是繁琐的，因此组织正在使用 AI 来转录、总结和提炼对话中的行动项。

### 会议 AI 工具

Zoom 的 AI Companion 及类似的"会议 AI"工具是典型例子。在实时会议中（或会后），Zoom 的 AI 可以生成简洁的会议摘要，突出关键点和决策，甚至列出带有责任人的行动项。这通过分析会议记录实现：AI 识别重要话题、谁就承诺或提议说了什么，以及任何明确提到的任务或截止日期。输出是自然语言的有组织回顾，通常包含参会者、做出的决策和下一步等部分，可以自动分享给团队。这将一小时的讨论转化为快速参考的工件——确保即使错过会议的人也能在几分钟内了解情况。

### 工作流集成

关键的是，这些系统不仅仅停留在静态摘要。它们旨在通过将讨论结果转化为可跟踪的工作来驱动工作流集成。Zoom 的 AI 与 Zoom Tasks 功能绑定，可以自动从会议或聊天中创建任务项，用提到的任务填充待办列表，甚至建议负责人或截止日期。

Atlassian 通过 Confluence-Loom 集成采用类似方法：Loom（会议录制工具）转录和总结会议，然后 Confluence 存储笔记，点击一下就可以将每个分配的行动项转换为 Jira 工单。这样，口头协议就变成项目跟踪器中的具体 issue，无需手动输入。例如，如果在设计评审中有人说"Alice 将在下周前重构登录模块"，AI 会议笔记会捕获这一点，并允许一键创建 Jira issue "重构登录模块 – 责任人：Alice"。这种无缝的知识迁移确保会议后没有事情"掉链子"，并将讨论上下文与执行联系起来。

### 聊天日志挖掘

Slack 或 MS Teams 等工具中的聊天日志是另一个被挖掘的非正式知识源。Slack 的首席产品官指出，Slack 已成为"事实上的机构知识库"——对话、决策、问答——但传统搜索难以表面化这些知识。生成式 AI 的引入改变了这一点：Slack GPT（2023 年发布）引入了频道摘要和 AI 驱动的搜索，从聊天历史中提取含义。

Slack 的 AI 可以总结长项目频道，生成讨论话题的摘要（带有指向特定消息的指针），使休假归来的团队成员可以快速了解发生了什么。摘要不仅仅是一团文字——它包含回到消息的引用/链接，提供透明度并让用户可以深入了解细节。这对信任很重要：AI 引用对话中每个要点的来源，用户可以验证上下文。

此外，Slack 的 AI 允许用户对公司的聊天语料库提出自然语言问题。用户可以问"上周关于 Project Gizmo 做出了什么决定？"Slack 的 AI 检索相关消息并总结答案，如"团队决定继续采用 Project Gizmo 的方案 X 并推迟功能 Y"。与频道摘要一样，答案附带原始 Slack 消息的源链接。这实际上是对内部通信的 RAG——模型使用 Slack 的对话数据作为私有知识库来给用户提供对话式答案。

### 技术实现

为支持这些能力，使用了语音识别、NLP 和 LLM 摘要的组合。首先，会议音频被转录为文本（Zoom 和 Loom 实时执行此操作）。然后，NLP 启发式或模型 prompt 识别关键句子（如"我将做 X"）作为行动项或决策。最后，大型语言模型生成连贯的摘要或以标准格式重述任务。许多系统还使用 embedding 来比较对话片段，确保相似的点被分组或 AI 答案能从可能分散的聊天消息中找到语义相关的上下文。

这些努力的结果是，来自短暂对话的知识被捕获并迁移到持久形式：文档页面、跟踪器中的任务或直接的问答响应。这极大地帮助了知识复用和连续性。团队成员不再需要依赖记忆或翻阅聊天日志——AI 可以表面化谁说了什么、决定了什么、需要做什么。它还支持入职：新员工可以查询过去的讨论（在权限范围内）来了解为什么做出某些决定，有效地搜索机构记忆。

## 从设计讨论到架构知识记录

高层架构和设计讨论通常记录在长会议或提案文档中。将这些转化为具体的参考——如设计文档、决策日志或规划工件——是 AI 辅助知识迁移的另一个领域。

### 架构决策记录（ADR）

一个值得注意的例子是使用 LLM 从设计会议内容或提案撰写中生成架构决策记录（ADR）。ADR 是记录关键架构决策背后的上下文和推理的短文档（例如，为什么团队为新系统选择微服务而非单体），以及其后果。编写 ADR 被认为是最佳实践，但由于简洁阐述决策"为什么"所需的努力而经常被跳过。

AI 可以减少这种努力。在一个案例研究中，一位工程师构建了一个 ADR Writer Agent，它接受架构提案（如 PDF 幻灯片或设计文档）作为输入，并产出结构良好的 Markdown 格式 ADR。该 agent 使用检索增强生成：它从提案文档中提取文本，将其（连同 ADR 模板）输入 LLM，并要求 LLM 生成涵盖问题、决策、替代方案、优缺点和后果的 ADR。本质上，它将知识从设计讨论迁移到标准化的 ADR 格式，确保理由被保存。

ADR agent 甚至采用了多步骤方法：一个 LLM 起草 ADR，另一个 LLM agent 审查或验证它，然后最终 agent 格式化输出。这种类似人在回路的链式方法（AI agent 扮演不同角色）旨在提高记录决策的质量和一致性。

通过使用组织现有的设计文档作为上下文，ADR 生成器捕获通用摘要可能遗漏的细节——例如，考虑过的具体替代方案以及为什么被拒绝。好处是双重的：架构师节省时间，未来团队获得可搜索的记录来了解为什么做出某些架构选择（防止人员离开或项目演进时的知识流失）。

### 其他规划应用

这种方法与工程师使用 AI 从聊天讨论中起草技术设计文档或 RFC 类似。例如，如果架构讨论发生在 Slack 上，可以想象一个 AI agent 将对话编译成决策日志草稿（突出共识和不同意见）。Atlassian 的 Rovo 包含一个"Meeting Insights Reporter"agent，用户可以询问过去会议中的决策——实际上，它可以阅读会议笔记并告诉你在某个话题上决定了什么。

在功能规划领域，生成式 AI 也在取得进展。Atlassian 的 Rovo Agents 套件提供 OKR（目标和关键结果）生成器等工具。这样的 agent 可以接受项目文档（愿景声明、路线图草案）作为输入，并为下一季度建议 OKR 草案——本质上将非结构化的战略笔记转化为结构化目标。类似地，"规格助手"可以阅读用户故事或 Jira epic 集合，并产出概述如何实现它们的设计文档草稿，借鉴类似过往项目的文档作为指导。

总之，通过实时捕获架构和规划知识，AI 帮助组织维护关于为什么以及如何以某种方式构建事物的持续知识库。这支持复用（新项目可以从过去的决策中学习）、治理（确保决策被记录以供合规）和入职（新团队成员可以快速了解系统设计背后的理由）。

## 结语

在编码、协作和规划工作流中，研发和软件工程组织正在利用 RAG、基于 embedding 的搜索和智能摘要等 AI 技术，从一个上下文中抽取知识并应用到另一个上下文中。源代码和 commit 历史不再仅仅是给机器看的——它们正被翻译成自然语言文档、commit 叙事和新代码建议。来自会议和聊天的对话数据，曾经转瞬即逝，现在被挖掘用于决策和任务，直接输入项目积压和知识库。高层设计推理通过自动化记录和 agent 被保存，确保一手资料中的经验和意图在项目生命周期中持续存在。

这些方法，在 GitHub Copilot、Sourcegraph Cody、Zoom AI Companion、Atlassian Rovo AI、Slack GPT 和定制内部 agent 等工具中可见，都服务于一个共同目标：打破知识孤岛。通过程序化地将信息从其诞生之处（在代码中、在对话中、在文档中）迁移到需要采取行动之处（在新仓库、帮助指南、任务跟踪器中），团队可以更快更智能地工作。当新人可以查询过去的代码和聊天时，入职变得更快；当代码变更时文档保持最新；会议中做出的决定导向切实的结果。AI 与软件知识管理的融合仍在演进，但 2023-2025 年的早期成功表明，未来组织的大部分部落知识将被索引、可访问，并准备好支持从开发到部署的每个工作流。
