
# oldhu fly jun talk AI Coding 实践与洞察详细复盘大纲

## 👤 fly：本地化 RAG 与 MCP 的强制流控

### 1. 背景与现状 (Context / AND)
*   **原有模式效率低下：** 在推进 Lesson 平台和迁移工具开发时，发现单纯使用 Prompt 怼 AI 的方式效率遇到瓶颈。
*   **基础设施搭建：** 为了解决开源方案过重的问题，自建了一套 **轻量级本地 RAG 系统**。
    *   将 ONES 全套产品文档（PDF）、技术文档和代码仓进行切片、向量化。
    *   建立本地索引，支持通过向量检索和 SQL 查询。

### 2. 面临的挑战 (Conflict / BUT)
*   **上下文碎片化：** 对话式交互导致信息散落，AI 容易产生幻觉或偏离需求。
*   **缺乏控制：** 如果没有强制手段，AI 生成的内容无法有效记录，变成“一次性”的黑盒操作。

### 3. 核心实践与方案 (Solution / THEREFORE)
*   **搭建 Skill 体系：** 整合 ONES MCP、Chrome MCP 和 Figma MCP。
*   **强制性的流程控制机制：**
    *   **Wiki UUID 锁：** 在执行任何编码任务前，AI 被强制要求提供一个 Wiki 子页面的 UUID。
    *   **逻辑阻断：** 若不提供 UUID，AI 会被逻辑阻断，无法继续执行。
    *   **过程沉淀：** 所有的思考过程、技术方案、代码生成记录，必须实时写入该 Wiki 页面，而非停留在对话框。
*   **效果：** AI 先读懂文档再读代码，能精准反写项目架构，实现了“理解优于执行”。

---

## 👤 Jun：iOS 26 下的“四屏工作法”与架构师觉醒

### 1. 背景与现状 (Context / AND)
*   **项目背景：** 正在进行一个复杂移动端项目（iOS/WatchOS）的独立开发与重构。
*   **极高的工程要求：** 要求在所有手机上运行，处理 10 小时长视频，要求无感、自动执行。
*   **利用 AI 进行跨语言重构：** 将开源的 Flutter/Java 代码“翻译”为原生 Swift 代码，MVP 阶段效率极高。

### 2. 面临的挑战 (Conflict / BUT)
*   **知识边界的缺失 (**`iOS 26`**)：**
    *   特别提到 **`iOS 26`** 增加了很多新特性（如后台处理机制）。
    *   人如果不具备 **`iOS 26`** 的背景知识，无法向 AI 提出正确的要求。
    *   **后果：** AI 在缺乏明确指令时，会使用“野路子”实现，导致程序不稳定（例如录音运行两小时后突然中断，因为不符合 **`iOS 26`** 的规范）。
*   **配置文件的破坏：** AI（如 Cloud Code）在解决不了问题时，倾向于乱改 Config 配置文件，导致环境崩溃。
*   **审美的平庸化：** AI 生成的 UI 趋同于“苹果冷淡风”，缺乏创意。

### 3. 核心实践与方案 (Solution / THEREFORE)
*   **“四屏工作法” (The 4-Screen Workflow)：**
    *   **屏幕 1（主力）：** Coding (Cloud Code/Opus)。
    *   **屏幕 2（架构）：** 方案探讨 (CodeX) —— 专门用于确定 **`iOS 26`** 环境下的最优技术方案。
    *   **屏幕 3（找茬）：** Code Review Agent —— 专门负责对比需求文档与代码实现，进行反向评审。
    *   **屏幕 4（验证）：** 测试运行与日志监控。
*   **人的角色进化：**
    *   **架构师：** 必须快速学习 **`iOS 26`** 的新文档和边界，指导 AI。
    *   **决策者：** 进行“取舍”决策（例如：为了降低复杂度，果断砍掉旧版本兼容，只兼容 **`iOS 26`** 以上版本）。
*   **严格限制：** 禁止 AI 修改生产环境的配置文件。

---

## 👤 oldhu：软件工程的本质与代码洁癖

### 1. 背景与现状 (Context / AND)
*   基于多年的软件工程经验，审视 AI 在研发流程中的实际价值。

### 2. 面临的挑战 (Conflict / BUT)
*   **信息传递的本质难题：** 软件工程最大的瓶颈是信息在“用户 -> 产品 -> 开发”传递过程中的失真。
*   **AI 无法解决失真：** AI 基于自然语言，而自然语言天生模糊。AI 并不能解决“把需求说清楚”这个最难的问题。
*   **不可维护的风险：** 如果允许 AI 生成横跨 50 个文件、逻辑错综复杂且无人读得懂的代码，这将是项目的灾难（毒药）。

### 3. 核心实践与洞察 (Insight / THEREFORE)
*   **“代码即真理” (Code is Truth)：** 只有代码本身才是最清晰、完备、无歧义的逻辑表达。
*   **管理的红线：**
    *   **坚决清理：** 禁止 AI 生成大范围的“面条代码”。
    *   **仅允许：** AI 生成“原子化”的功能函数（Function Level）。
    *   **严格标准：** 输入输出必须极其清晰，且必须配套完备的测试用例。

---

## 👤 UI Tao：跳过 Figma 的极速 UI 开发

### 1. 背景与现状 (Context / AND)
*   传统的 UI 开发流程（Figma -> 标注 -> 代码）链条过长，尤其在快速验证想法时效率低。

### 2. 面临的挑战 (Conflict / BUT)
*   复杂的交互（如时间轴组件）难以通过单纯的 Prompt 描述清楚。
*   高保真设计图的制作成本高。

### 3. 核心实践与方案 (Solution / THEREFORE)
*   **“草图即代码”模式：**
    *   直接在纸上画粗糙的线框图/草图。
    *   将草图喂给 AI，直接生成 HTML/Preview 代码。
*   **交互式迭代：** 在生成的骨架基础上，通过对话调整颜色、布局。
*   **技术红利：** 利用新模型（如 Claude 3.5 Sonnet）的能力，以前很难实现的复杂前端交互现在可以一次性生成。



# sihao：AI Coding 深度实践与架构洞察报告

> **核心对话人**：
>
> *   🟦 **Jun (spk_05)**：项目负责人 / 实践者
> *   🟧 **Sihao (spk_04)**：技术专家 / 架构顾问

---

## 0. 当前困境：Jun 面临的“生产力归零”危机

**背景**：Jun 使用 AI Coding 开发的产品（MVP）已经跑通，但在试图将其产品化、长期维护的过程中，遇到了严峻的挑战。

*   **生产力倒退**：随着项目复杂度增加，代码混乱度（Entropy）急剧上升。Jun 坦言“生产力归零”，甚至感觉 1+1 < 2。
*   **“坏味道”感知缺失**：Jun 意识到自己缺乏资深架构师的“代码品味”（Code Sense/Smell）。他无法像人类专家那样预判现在的代码写法在三个月后会带来什么灾难，而 AI 也缺乏这种长期视角的预判。
*   **不可控的副作用**：修复一个 Bug 往往引发新的 Bug（例如在修复 V2 版本问题时，AI 错误地引用了 V1 的旧代码）。
*   **外包与新人的局限**：试图招人解决问题，但发现普通水平的新人如果不具备极高的代码规范意识，只会比 AI 制造更多的混乱。
*   **核心焦虑**：产品在个人设备（MVP环境）运行良好，但一旦涉及多设备同步、不同硬件环境、长时运行，稳定性急剧下降。

---

## 1. 方法论激辩：AI Coding 的边界与新范式

### 1.1 两派观点的冲突

> **🟦 Jun 分享的两种对立观点**

*   **“不可知论”派（oldhu）**：
    传统的极客架构师认为，自然语言天生模糊，无法描述清楚复杂的逻辑。因此，**AI 只能用来写原子函数**（纯逻辑、无副作用的代码）。一旦让 AI 介入架构设计或写“面条代码”（业务胶水层），项目必死无疑。

*   **“全能工具”派（spy - 天文App案例）**：
    另一位技术大牛通过 AI 完成了高难度的天文算法 App。他的观点是：**如果 AI 写不对，是因为你没描述清楚。** 只要 Spec（规格说明书）写得足够详尽，AI 可以完成 100% 的代码。

### 1.2 Sihao 的深度洞察：消除随机性

> **🟧 Sihao 的分析**

这两种观点其实殊途同归。核心问题在于 **“如何消除中间过程的随机性”**。

*   **熵减过程**：从自然语言到可运行代码，中间有巨大的模糊空间。AI 的 `Temperature` 属性决定了它会“瞎猜”。
*   **锚点理论**：我们必须提供足够的“锚点”来框死 AI 的发散空间。这些锚点包括：
    *   **UI/UX 设计图**：限制视觉和交互的随机性。
    *   **E2E 测试用例**：限制业务流程的随机性。
    *   **API 契约 (Swagger/OpenAPI)**：限制数据结构的随机性。
*   **文档即真理**：如果你的“文档”包含了依赖库的源码、框架文档和详细设计，那么文档确实就是真理。

### 1.3 解决方案：四屏工作法 (The 4-Screen Workflow)

Jun 总结并正在实践的一套高强度 AI 协作流程：

1.  **Design/Debate (设计/辩论屏)**：绝不直接让 AI 写代码。先在一个窗口与 LLM 深度探讨技术方案，像人类工程师辩论一样，直到方案无懈可击。
2.  **Spec Generation (文档生成)**：将辩论结果转化为详尽的 Spec 文档。
3.  **Execution (执行屏)**：将 Spec 喂给 IDE (Cursor/Cloud Code) 进行代码生成。
4.  **Review/Test (评审/测试屏)**：运行代码，并使用另一个 AI 角色进行 Code Review，检查是否符合设计初衷。

---

## 2. 架构诊断：从分层架构走向领域驱动 (DDD)

### 2.1 现状与痛点

当前项目采用传统的 MVC/分层架构（Router 层、Service 层、Data 层物理分离）。

> **🟦 Jun**：每次改一个功能（比如“下载”），AI 需要横跨多个目录去修改 Router、Service 和 Model。这导致 AI 的上下文窗口（Context Window）被大量无关代码填充，容易产生幻觉或改错文件。

### 2.2 架构处方：模块化与内聚

> **🟧 Sihao 的建议**

AI Coding 时代的架构应更倾向于 **领域驱动设计 (DDD)** 的目录结构，以减少 AI 的认知负载。

**关键变更建议：**

*   **按业务领域 (Domain) 切分目录**：不要把所有 API 放在一起。建立如 `/modules/calendar`、`/modules/transcription` 等目录。
*   **高内聚 (Cohesion)**：每个业务目录下，包含该业务独有的 API 定义、模型 (Model)、服务 (Service) 和测试用例。
*   **收益**：当你需要 AI 修改“日历”功能时，只需喂给它 `/modules/calendar` 目录。AI 的注意力被**物理隔离**在相关代码中，准确率将大幅提升。




# talk with Stellarlink about Vibe Coding 实战困境与深度洞察

## ⚠️ 核心聚焦：Jun 遭遇的“Vibe Coding 之墙”

**背景：**
**Jun** 是一位有十年空窗期的技术出身产品经理，目前负责内部创新项目。MVP 阶段利用 **Vibe Coding** 跑得很快，但转型做 iOS 原生 App 准备上架时，陷入了严重的生产力瓶颈。

**Jun 目前面临的具体障碍：**

1.  **知识结构的天花板效应**
    *   Jun 发现 AI 的能力上限被“使用者的知识上限”锁死。
    *   当涉及到 iOS 底层设计、复杂架构时，因为自己不懂，导致无法向 AI 提出精准的需求（Prompt），AI 输出的代码变得不可控。

2.  **从 Prototype 到 Production 的鸿沟**
    *   做 **Vibe** 小工具或 Web 脚本时，代码失败了无所谓。
    *   但做正式 App 时，需要处理中断恢复、任务队列、打点测试等“详细设计”。AI 可以生成看起来很酷的功能（如 Apple Watch 创意），但无法生成健壮、可维护的系统级代码。

3.  **信任危机与不可验证性**
    *   即使 AI 写出了代码，Jun 也没有能力去辨别对错（例如一个复杂的任务队列实现）。
    *   这种“不知道对错”的状态导致了极度的不自信，不敢随意合并代码。

4.  **熵增与混乱**
    *   目前的开发状态是：每增加一个新功能或新文件，整个项目的代码就变得更加混乱和不可控。
    *   缺乏资深架构师来“压阵”，导致项目从原本的“嗑药般兴奋”变成了“寸步难行”。

5.  **团队角色的缺失**
    *   团队只有产品（Jun）和 AI，缺乏一位能做长远架构思考、能做详细设计（Spec）、能驱动 AI 写出高质量代码的**资深工程师**。

---

## 💡 深度对话拆解与洞察

### 1. 隐性知识与“Redis”案例：为何小白无法驱动 AI？

> **Jun：** 我现在最大的痛点是，我已经描述不出来了。比如我要做一个**任务队列**，涉及中断自动恢复。我能描述到“要个队列”，但更细的、怎么测试、怎么确保它不丢任务，我没底。AI 写的代码我看不懂，就不确定它是对是错。

**Wenjie (技术合伙人) 的解析：**

这个问题揭示了 AI 编程的核心痛点——**隐性知识（Implicit Knowledge）**。

*   **小白/初级做法：**
    只告诉 AI “我要防多端登录”。AI 可能会写一个简单的逻辑，但在 PC 和手机同时操作时，容易出现 Bug，无法真正锁住。
*   **资深专家做法：**
    我一眼就知道这事儿得用 **Redis** 做队列挤占。我直接告诉 AI：“用 Redis 实现单点登录队列，后来的挤掉前面的。” AI 马上就写对了。

**核心洞察：**
如果你连 **Redis** 这个词都不知道，你就无法给 AI 提供正确的上下文（Context）。AI 的推理是基于 Transformer 的，你给的提示词没有技术深度，它就推理不出深度方案。

---

### 2. 破局之道：架构先行与“脚手架”理论

> **He (运营/战略)：** 你们是不是太焦虑了？如果是创业初期，**市场验证**（Feasibility）应该大于长期的架构规划。是不是可以用 Demo 倒推？找一个“靠谱的人”（技术大牛）进来，哪怕是兼职，快速把框架捋顺。AI 只是手脚，脑子还得是人。

**Wenjie 的最佳实践方案：**

目前阶段，**Vibe Coding** 必须采用混合模式：

1.  **脚手架（Structure/Scaffolding）：**
    在国外这叫 Structure。必须由人先搭建好项目的骨架、目录结构、基础规范。
2.  **AI 作为新员工：**
    把 AI 当成一个刚入职的初级员工。你不能扔给它一句话就走，你得给它文档、给它约束。
3.  **人工验收（Code Review）：**
    现阶段 **98%** 的代码还是需要人工去合并（Pull Request）的。AI 不知道自己写错了，人必须去验收。
4.  **拒绝 AI Yolo：**
    现阶段全自动的 **AI Yolo** (Solo) 模式并不成熟，无法处理复杂的工程问题。

> **Jun：** 确实，国外现在的说法也是要先定 Structure。如果能把“脚手架”和技术规范定清楚，AI 填充代码是很快的。我现在缺的就是那个定脚手架的人。

---

### 3. 未来预判：文档的消亡与“代码即事实”

> **Jun：** 我做了一辈子企业 Wiki，现在觉得这东西要被革命了。

**核心观点：**
*   **Code is Truth：** 只有代码和原始的会议录音是“事实”。人为编写的文档往往是滞后的、有偏差的。
*   **Cloud Code 模式：** 有了 AI（如 Cloud Code），我们可以直接对代码仓库提问，或者对会议录音提问。
*   **拒绝噪音：** 为什么要花时间去整理二手文档？很多人为了整理知识库而整理，塞进去一堆没人看的东西，最后变成了检索的噪音（垃圾进，垃圾出）。

**Wenjie：** 非常认同。让 AI 基于原始数据自我生成知识体系，比人去刻意整理效率高太多了。未来的文档就是 AI 对着代码库实时生成的解释。

---

### 4. 审美与人的不可替代性

> **He：** 我们在这个群里聊过，现在的 AI 代码虽然能跑，但**“没人味儿”**。设计出来的 UI 缺乏统一的审美调性。

**人的价值回归：**
*   **审美统一：** 人需要去控制产品的 VI、调性和用户体验的细腻程度。
*   **处理不确定性：** AI 擅长处理确定的任务（Fixed Tasks），而人擅长处理变化（Changes）、沟通和复杂的商业决策。
*   **Jun：** 对，之前那些 Apple Watch 的设计虽然 AI 生成得很快很有创意，但很难受控，一旦要修改或者统一风格，就很痛苦。这还是需要设计师介入。

---

## 🎯 结论：从“全自动幻想”回归“人机协作”

通过 **Jun** 的踩坑经历和 **Wenjie、He** 的分析，得出的共识是：

1.  **纯小白无法用 AI 做复杂产品：**
    没有编程经验或架构思维，做 Demo 可以，做生产级产品（Production Ready）几乎必死。
2.  **经验依然是护城河：**
    资深程序员的价值在于“知道该让 AI 用什么技术”（如 Redis），以及“如何设计稳健的架构”。
3.  **当前最优解：**
    **资深架构师搭台（Structure） + AI 填肉（Vibe Coding） + 人工验收（Review）。**
4.  **心态调整：**
    不要指望 **AI Yolo**（全自动），要把 AI 当作一个极高效率但需要指导的“超级实习生”。


# 2026年1月28日 cctg群内 讨论记录
xg 10:44:43
> 那个游戏公司通过扣费池随机扣费这事，我觉得正常人类应该做不出来，往这方面想都难。应该是ai干的。
Jun 11:30:25
> 生产力归零
> 随着代码混乱度的增加，团队生产力会逐渐趋近于零。增加人手只会制造更多混乱（因为新人不熟悉系统）。
> 唯一出路： 保持代码整洁。
Jun 11:31:31
> 现在是用方法保持ai写的东西可维护 可评审阅读
Jun 11:32:35
> 程序员的艺术
> 整洁代码不仅仅是原则，更是一种像画家一样的"代码感"。
> 它能让你看到代码的坏味道，并本能地知道如何通过一系列微小的重构将其转化为整洁的代码。
Jun 11:34:30
> 自己没写代码 还跟神一样
Jun 11:43:17
> 这些原则我相信Claude openai模型都训练过。 只是人不太行，就很容易失控
spy 11:43:58
> 我现在每天想的都是如何重构，如何在我的代码审查 skill 中添加新的规则，今天还准备对数万行代码进行整体的代码审查。有些地方写得稍微复杂错乱一些，目前 Opus 都已经有点 hold 不足了，我现在发现大模型最大的障碍就是上下文太短，记忆力不行，希望 ds 能给我惊喜。
Jun 11:44:13
> 我看生成的xcode代码很规整
sunsh 11:45:59
> 单个小任务的 ai轻松搞
Jun 11:48:53
> 只有经验丰富的老司机才能驾驭aicoding
spy 14:18:23
> 刚刚和一个朋友聊，他是做算法底层的，现在也在 AI Coding，但是没啥产品架构经验，现在也很痛苦，不断的返工试错。
xg 14:19:14
> 没有架构经验的人很难做好ai coding，除非是一次性代码。
sunsh 14:19:51
> 我昨天到今天搞个问题 最后发现是让AI网上抄的redis令牌桶脚本 然后算ttl 边界情况会=0 然后自己加了个<1就设置成1
spy 15:01:01
> skill 不能解决所有的问题，这玩意主要还是记录一些高频的重复动作，我举个例子，现在代码中有很多航天器数据，但是这些数据可能过几个月需要进行更新，以前可能会做一个表格记录一下，每几个月看看有哪些需要更新的，现在我就把这一条写到了 qz-review 里面，每次审查都会一起检查，比较方便，也不会遗漏。但是有很多具体的设计，靠 skill 是解决不了的，另外设计的一些东西，可以同步写在代码注释里面，但我在工程里面保留的文档，都是涉及到基础架构、协议、规则和约束，这非常重要，能确保代码的一致性。
spy 15:06:19
> 准确的说不是功能模块，就是你认为应该让 AI 在做某件事情前必须要知道的和该项目有关的约束。
spy 22:17:00
> 我一直都是既管技术，又管产品，所以现在感觉特别舒服，因为一个人古法编程在效率上就是最大的瓶颈。
spy 22:17:31
> 现在 AI 解决了我的痛点。

核心观点总结
AI Coding 需要老司机驾驭：没有架构经验的人很难做好 AI Coding，容易陷入不断返工试错
代码整洁是生命线：坚决清理 AI 生成的"面条代码"，只允许生成原子化的功能函数
大模型的瓶颈：上下文太短、记忆力不行，复杂代码 hold 不住
约束与规则很重要：让 AI 在做事前必须知道项目相关的约束，确保代码一致性



# aise群的反馈

**Jun** 
> **核心观点总结：**
> - **AI Coding 需要老司机驾驭**：没有架构经验的人很难做好 AI Coding，容易陷入不断返工试错
> - **代码整洁是生命线**：坚决清理 AI 生成的"面条代码"，只允许生成原子化的功能函数
> - **大模型的瓶颈**：上下文太短、记忆力不行，复杂代码 hold 不住
> - **约束与规则很重要**：让 AI 在做事前必须知道项目相关的约束，确保代码一致性

## 讨论展开

### 关于上下文和文档结构化

**胥克谦** 10:29:
> 上下文就是靠拆
> 还有文档本身的结构化也很重要

**leo** 10:34:
> 我觉得这个非常重要
> 文档结构化就像个建筑里面的框架，代码只是水泥，用来填充的

**胥克谦** 10:35:
> 对，文档结构化，便于LLM执行块操作，节省上下文

**陈明** 10:35:
> 我这两天bmad经常超上下文。估计文档还要拆

**胥克谦** 分享了他的解决方案：
> 我做了个可继续todo skill，对任何任务都自动拆分任务放到todo文件夹，然后里面一个一个子任务随着进展标注进展。偶尔超上下文断了，新开回话，直接让继续执行，都没问题

---

### 关于脚手架与架构

**Jun** 10:37-38:
> 脚手架
> 代码框架的脚手架也要人维护
> 或者写的架构文档能清晰约束，而且要可验收
> 这个脚手架层面直接影响后面ai开发的质量，英美语系应该是叫structure
> 指aiagent或普通码农 茁壮生长的 框架

---

### 关于 AI Coding 对老手友好

**陈浩** 10:38:
> 这是AI Coding对老登友好的原因

**Jun** 10:39:
> 是的
> 人的隐性知识是上限

**陈浩** 10:39:
> VibeCoding降低了Coding的门槛，但是要搞生产用的项目，不是小白能胜任的

---

### 关于工程师会不会被干掉

**Jun** 10:40:
> 哪个傻子再提干掉工程师 我就怼，估计还能怼一年
> 一年后不知道

**leo** 10:40:
> 不好说，我觉得半年

**胥克谦** 10:41:
> 我今天的朋友圈，是表达高级架构师也不安全了。。。。[捂脸]

**leo** 10:42-44 分析：
> 当每一个角色，都有一个专业AGENT去做这件事，它缺的只是你的私有知识，补全之后，那么干就干了
> 现在明显大模型能力还在上来，配套工具也在上来，记忆存储方式也在上来
> 那么效果就是个X*Y*Z
> 所以我觉得半年差不多了

---

### 陈浩的 AI Coding 三观点

**陈浩** 10:45:
> 我对AI Coding的几个观点：
> 1. VibeCoding的门槛很低，小白也可以搞，可以快速出原型、出demo，出玩具，对于要快速做业务验证的很有利
> 2. 生产用的项目，VibeCoding大部分时候不能用，要用SDD的方法，传统软件工程的方法，从需求-设计-计划-开发-测试 的流程去做
> 3. 开发阶段是提效最明显的阶段，在项目不变的情况下，生产项目不需要这么多程序员了，从N个缩减到1个，但并不能把这1个也砍掉

---

### 关于隐性知识的表达

**Jun** 10:45-46:
> 隐形知识都要表达出来，弄成skill或prompt之类的，但知识的诅咒导致很多有经验的人写不出来
> 只能用作品 code 来表达自己的能力

---

### 关于大型企业的规范化开发

**leo** 介绍了金融企业的经验 10:46-50:
> ^^ 组织靠的是组织的力量，有统一开发框架，有架构管理平台，不太存在隐性的架构知识 ^^
> 我现司的开发少一点，前司大概5000人，同一个开发框架
> AI就在现有的开发框架做就行了，贼快
> 像招商银行，就两个开发框架，很多前后端的逻辑和标准都是以代码形式写死的

**Jun** 10:48-49:
> 有可能，长期大规模协作确实都得干清晰
> 那理论上规则清晰的大工程 更应该ai能胜任

**leo** 10:49-50:
> 对的，因为框架在VIBE，所以才有不清晰的事情
> 像我们这种金融企业，三件套都是基本就绪的，业务架构、技术架构、数据架构，而且都是有标准的技术实现的，在过去的10几年都是在不断收敛和平台化
> 所以那个框，其实是比个人开发者在VIBE，严谨很多的

---

### 关于遗留框架的迁移问题

**Jun** 10:52-54:
> 另一个问题，这么多年 框架和依赖的三方 会不会陈旧，导致不适应现aicoding擅长的东西？
> 例如好像有群友做cobar移植的
> ai能帮助移植 但估计没法在原基础上加东西

**leo** 10:54-57:
> 这个不是直接换mycat就好了吗
> 像我们，以前用MAINFRAME，有银行就直接把COBOL直接转JAVA，没有大模型的时候，直接就已经有语言迁移工具了，有大模型，应该更简单吧
> 我都想说，让研发团队把JAVA的一些应用用RUST重写一遍，然后复用自动化测试和回归测试用例，让大模型自己LOOP
> 那就少了很多GC的这些烂问题


